import {
  AbiDecodingDataSizeTooSmallError,
  AbiDecodingZeroDataError,
  AbiEncodingLengthMismatchError,
  AbiEventNotFoundError,
  AbiEventSignatureEmptyTopicsError,
  AbiEventSignatureNotFoundError,
  AtomicReadyWalletRejectedUpgradeError,
  AtomicityNotSupportedError,
  BaseError,
  BaseError2,
  BlockOverrides_exports,
  BundleTooLargeError,
  BytesSizeMismatchError,
  Bytes_exports,
  CallExecutionError,
  ChainDisconnectedError,
  ChainMismatchError,
  ChainNotFoundError,
  ContractFunctionExecutionError,
  ContractFunctionRevertedError,
  ContractFunctionZeroDataError,
  DecodeLogDataMismatch,
  DecodeLogTopicsMismatch,
  DuplicateIdError,
  Errors_exports,
  FeeCapTooHighError,
  Hex_exports,
  HttpRequestError,
  IntegerOutOfRangeError,
  InternalRpcError,
  InvalidAddressError,
  InvalidChainIdError,
  InvalidInputRpcError,
  InvalidLegacyVError,
  InvalidLengthError,
  InvalidParamsRpcError,
  InvalidRequestRpcError,
  InvalidSerializableTransactionError,
  InvalidStorageKeySizeError,
  JsonRpcVersionUnsupportedError,
  Json_exports,
  LimitExceededRpcError,
  LruMap,
  MethodNotFoundRpcError,
  MethodNotSupportedRpcError,
  ParseRpcError,
  PositionOutOfBoundsError,
  ProviderDisconnectedError,
  RawContractError,
  ResourceNotFoundRpcError,
  ResourceUnavailableRpcError,
  RpcRequestError,
  SwitchChainError,
  TimeoutError,
  TipAboveFeeCapError,
  TransactionExecutionError,
  TransactionNotFoundError,
  TransactionReceiptNotFoundError,
  TransactionRejectedRpcError,
  UnauthorizedProviderError,
  UnknownBundleIdError,
  UnknownNodeError,
  UnknownRpcError,
  UnsupportedChainIdError,
  UnsupportedNonOptionalCapabilityError,
  UnsupportedPackedAbiType,
  UnsupportedProviderMethodError,
  UserRejectedRequestError,
  WaitForTransactionReceiptTimeoutError,
  Withdrawal_exports,
  addressResolverAbi,
  arrayRegex,
  assertRequest,
  boolToHex,
  bytesRegex,
  bytesToHex,
  call,
  checksumAddress,
  concat,
  concat2,
  concat3,
  concatHex,
  createBatchScheduler,
  createCursor,
  decodeAbiParameters,
  decodeErrorResult,
  decodeFunctionData,
  decodeFunctionResult,
  defineFormatter,
  deploylessCallViaBytecodeBytecode,
  encodeAbiParameters,
  encodeDeployData,
  encodeFunctionData,
  extract,
  formatAbi,
  formatAbiItem,
  formatAbiItem2,
  formatAbiParameters,
  formatEther,
  formatGwei,
  formatTransactionRequest,
  from,
  from2,
  fromArray,
  fromBoolean,
  fromBytes,
  fromHex2 as fromHex,
  fromNumber,
  fromNumber2,
  fromRpc,
  fromString,
  fromString2,
  getAbiItem,
  getAddress,
  getCallError,
  getChainContractAddress,
  getNodeError,
  getUrl,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  integerRegex,
  isAddress,
  isAddressEqual,
  isEqual,
  isHex,
  keccak256,
  keccak_256,
  localBatchGatewayUrl,
  maxUint256,
  multicall3Abi,
  numberToHex,
  pad,
  padLeft,
  padLeft2,
  padRight,
  panicReasons,
  parseAbi,
  parseAbiItem,
  parseAbiParameters,
  parseAccount,
  prettyPrint,
  prettyPrint2,
  random,
  serializeStateOverride,
  size,
  size2,
  size3,
  slice,
  slice2,
  slice3,
  sliceHex,
  stringToBytes,
  stringToHex,
  stringify,
  stringify2,
  textResolverAbi,
  toBigInt,
  toBoolean,
  toBytes,
  toBytes2 as toBytes3,
  toEventSelector,
  toHex,
  toHex2,
  toNumber,
  toNumber2,
  toRpc,
  toRpc2,
  toString,
  toString2,
  trim,
  trimLeft,
  trimLeft2,
  universalResolverResolveAbi,
  universalResolverReverseAbi,
  universalSignatureValidatorAbi,
  universalSignatureValidatorByteCode,
  validate,
  validate2,
  withResolvers
} from "./chunk-U34KSMZB.js";
import {
  Chi,
  Field,
  FpInvertBatch,
  FpLegendre,
  FpPow,
  HashMD,
  Maj,
  SHA256_IV,
  createCurve,
  createHasher as createHasher2,
  getMinHashLength,
  hmac,
  isogenyMap,
  mapHashToField,
  mapToCurveSimpleSWU,
  mod,
  normalizeZ,
  secp256k1,
  sha256,
  sha384,
  sha512,
  weierstrassPoints
} from "./chunk-3REMI6TK.js";
import {
  Hash,
  abytes,
  add,
  add3H,
  add3L,
  aexists,
  ahash,
  anumber,
  aoutput,
  asyncLoop,
  bitGet,
  bitLen,
  bitMask,
  bytesToHex as bytesToHex2,
  bytesToNumberBE,
  checkOpts,
  clean,
  concatBytes,
  createHasher,
  createOptHasher,
  createView,
  createXOFer,
  ensureBytes,
  fromBig,
  hexToBytes as hexToBytes2,
  kdfInputToBytes,
  memoized,
  notImplemented,
  numberToBytesBE,
  randomBytes,
  rotl,
  rotr,
  rotr32H,
  rotr32L,
  rotrBH,
  rotrBL,
  rotrSH,
  rotrSL,
  swap32IfBE,
  swap8IfBE,
  toBytes as toBytes2,
  u32,
  u8,
  utf8ToBytes
} from "./chunk-5NAQZVLA.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has19 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn2, context15, once5) {
      this.fn = fn2;
      this.context = context15;
      this.once = once5 || false;
    }
    function addListener(emitter, event, fn2, context15, once5) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context15 || emitter, once5), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has19.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
      if (!handlers2) return [];
      if (handlers2.fn) return [handlers2.fn];
      for (var i = 0, l = handlers2.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers2[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args2, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args2 = new Array(len - 1); i < len; i++) {
          args2[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args2);
      } else {
        var length6 = listeners.length, j;
        for (i = 0; i < length6; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args2) for (j = 1, args2 = new Array(len - 1); j < len; j++) {
                args2[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args2);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn2, context15) {
      return addListener(this, event, fn2, context15, false);
    };
    EventEmitter2.prototype.once = function once5(event, fn2, context15) {
      return addListener(this, event, fn2, context15, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context15, once5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once5 || listeners.once) && (!context15 || listeners.context === context15)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length6 = listeners.length; i < length6; i++) {
          if (listeners[i].fn !== fn2 || once5 && !listeners[i].once || context15 && listeners[i].context !== context15) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@graphprotocol/grc-20/dist/src/types.js
var VoteOption;
(function(VoteOption2) {
  VoteOption2[VoteOption2["None"] = 0] = "None";
  VoteOption2[VoteOption2["Abstain"] = 1] = "Abstain";
  VoteOption2[VoteOption2["Yes"] = 2] = "Yes";
  VoteOption2[VoteOption2["No"] = 3] = "No";
})(VoteOption || (VoteOption = {}));

// node_modules/@graphprotocol/grc-20/dist/src/id.js
var id_exports = {};
__export(id_exports, {
  Id: () => Id,
  IdBase64: () => IdBase64,
  assertValid: () => assertValid,
  fromBase64: () => fromBase64,
  fromBytes: () => fromBytes2,
  generate: () => generate,
  isValid: () => isValid2,
  isValidBase64: () => isValidBase64,
  toBase64: () => toBase64,
  toBytes: () => toBytes4
});

// node_modules/effect/dist/esm/Function.js
var Function_exports = {};
__export(Function_exports, {
  SK: () => SK,
  absurd: () => absurd,
  apply: () => apply,
  compose: () => compose,
  constFalse: () => constFalse,
  constNull: () => constNull,
  constTrue: () => constTrue,
  constUndefined: () => constUndefined,
  constVoid: () => constVoid,
  constant: () => constant,
  dual: () => dual,
  flip: () => flip,
  flow: () => flow,
  hole: () => hole,
  identity: () => identity,
  isFunction: () => isFunction,
  pipe: () => pipe,
  satisfies: () => satisfies,
  tupled: () => tupled,
  unsafeCoerce: () => unsafeCoerce,
  untupled: () => untupled
});
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var apply = (...a) => (self) => self(...a);
var identity = (a) => a;
var satisfies = () => (b) => b;
var unsafeCoerce = identity;
var constant = (value10) => () => value10;
var constTrue = constant(true);
var constFalse = constant(false);
var constNull = constant(null);
var constUndefined = constant(void 0);
var constVoid = constUndefined;
var flip = (f2) => (...b) => (...a) => f2(...a)(...b);
var compose = dual(2, (ab, bc) => (a) => bc(ab(a)));
var absurd = (_) => {
  throw new Error("Called `absurd` function which should be uncallable");
};
var tupled = (f2) => (a) => f2(...a);
var untupled = (f2) => (...a) => f2(a);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
var hole = unsafeCoerce(absurd);
var SK = (_, b) => b;

// node_modules/effect/dist/esm/Arbitrary.js
var Arbitrary_exports = {};
__export(Arbitrary_exports, {
  getDescription: () => getDescription,
  make: () => make5,
  makeArrayConstraints: () => makeArrayConstraints,
  makeBigIntConstraints: () => makeBigIntConstraints,
  makeDateConstraints: () => makeDateConstraints,
  makeLazy: () => makeLazy2,
  makeNumberConstraints: () => makeNumberConstraints,
  makeStringConstraints: () => makeStringConstraints
});

// node_modules/effect/dist/esm/Array.js
var Array_exports = {};
__export(Array_exports, {
  Do: () => Do3,
  allocate: () => allocate,
  append: () => append2,
  appendAll: () => appendAll2,
  bind: () => bind4,
  bindTo: () => bindTo4,
  cartesian: () => cartesian2,
  cartesianWith: () => cartesianWith2,
  chop: () => chop,
  chunksOf: () => chunksOf2,
  contains: () => contains3,
  containsWith: () => containsWith3,
  copy: () => copy,
  countBy: () => countBy2,
  dedupe: () => dedupe,
  dedupeAdjacent: () => dedupeAdjacent2,
  dedupeAdjacentWith: () => dedupeAdjacentWith2,
  dedupeWith: () => dedupeWith,
  difference: () => difference2,
  differenceWith: () => differenceWith,
  drop: () => drop2,
  dropRight: () => dropRight,
  dropWhile: () => dropWhile,
  empty: () => empty4,
  ensure: () => ensure,
  every: () => every3,
  extend: () => extend,
  filter: () => filter4,
  filterMap: () => filterMap4,
  filterMapWhile: () => filterMapWhile2,
  findFirst: () => findFirst3,
  findFirstIndex: () => findFirstIndex,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex,
  flatMap: () => flatMap4,
  flatMapNullable: () => flatMapNullable3,
  flatten: () => flatten3,
  forEach: () => forEach2,
  fromIterable: () => fromIterable2,
  fromNullable: () => fromNullable3,
  fromOption: () => fromOption3,
  fromRecord: () => fromRecord2,
  get: () => get2,
  getEquivalence: () => getEquivalence5,
  getLefts: () => getLefts3,
  getOrder: () => getOrder3,
  getRights: () => getRights3,
  getSomes: () => getSomes3,
  group: () => group2,
  groupBy: () => groupBy2,
  groupWith: () => groupWith2,
  head: () => head2,
  headNonEmpty: () => headNonEmpty,
  init: () => init,
  initNonEmpty: () => initNonEmpty,
  insertAt: () => insertAt,
  intersection: () => intersection2,
  intersectionWith: () => intersectionWith,
  intersperse: () => intersperse2,
  isArray: () => isArray,
  isEmptyArray: () => isEmptyArray,
  isEmptyReadonlyArray: () => isEmptyReadonlyArray,
  isNonEmptyArray: () => isNonEmptyArray2,
  isNonEmptyReadonlyArray: () => isNonEmptyReadonlyArray,
  join: () => join,
  last: () => last,
  lastNonEmpty: () => lastNonEmpty,
  length: () => length,
  let: () => let_4,
  liftEither: () => liftEither,
  liftNullable: () => liftNullable2,
  liftOption: () => liftOption,
  liftPredicate: () => liftPredicate3,
  make: () => make4,
  makeBy: () => makeBy2,
  map: () => map6,
  mapAccum: () => mapAccum,
  match: () => match3,
  matchLeft: () => matchLeft,
  matchRight: () => matchRight,
  max: () => max2,
  min: () => min2,
  modify: () => modify2,
  modifyNonEmptyHead: () => modifyNonEmptyHead,
  modifyNonEmptyLast: () => modifyNonEmptyLast,
  modifyOption: () => modifyOption2,
  of: () => of2,
  pad: () => pad2,
  partition: () => partition2,
  partitionMap: () => partitionMap3,
  prepend: () => prepend2,
  prependAll: () => prependAll2,
  range: () => range2,
  reduce: () => reduce3,
  reduceRight: () => reduceRight,
  remove: () => remove2,
  removeOption: () => removeOption,
  replace: () => replace2,
  replaceOption: () => replaceOption2,
  replicate: () => replicate2,
  reverse: () => reverse2,
  rotate: () => rotate,
  scan: () => scan2,
  scanRight: () => scanRight,
  separate: () => separate2,
  setNonEmptyHead: () => setNonEmptyHead,
  setNonEmptyLast: () => setNonEmptyLast,
  some: () => some6,
  sort: () => sort,
  sortBy: () => sortBy,
  sortWith: () => sortWith,
  span: () => span,
  split: () => split,
  splitAt: () => splitAt,
  splitNonEmptyAt: () => splitNonEmptyAt,
  splitWhere: () => splitWhere,
  tail: () => tail,
  tailNonEmpty: () => tailNonEmpty,
  take: () => take2,
  takeRight: () => takeRight,
  takeWhile: () => takeWhile2,
  unappend: () => unappend,
  unfold: () => unfold2,
  union: () => union2,
  unionWith: () => unionWith,
  unprepend: () => unprepend,
  unsafeGet: () => unsafeGet,
  unzip: () => unzip,
  window: () => window2,
  zip: () => zip2,
  zipWith: () => zipWith4
});

// node_modules/effect/dist/esm/Either.js
var Either_exports = {};
__export(Either_exports, {
  Do: () => Do,
  TypeId: () => TypeId3,
  all: () => all3,
  andThen: () => andThen,
  ap: () => ap,
  bind: () => bind2,
  bindTo: () => bindTo2,
  filterOrLeft: () => filterOrLeft,
  flatMap: () => flatMap,
  flip: () => flip2,
  fromNullable: () => fromNullable,
  fromOption: () => fromOption2,
  gen: () => gen,
  getEquivalence: () => getEquivalence,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse,
  getOrNull: () => getOrNull,
  getOrThrow: () => getOrThrow,
  getOrThrowWith: () => getOrThrowWith,
  getOrUndefined: () => getOrUndefined,
  getRight: () => getRight2,
  isEither: () => isEither2,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left2,
  let: () => let_2,
  liftPredicate: () => liftPredicate,
  map: () => map,
  mapBoth: () => mapBoth,
  mapLeft: () => mapLeft,
  match: () => match,
  merge: () => merge,
  orElse: () => orElse,
  right: () => right2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_,
  void: () => void_,
  zipWith: () => zipWith
});

// node_modules/effect/dist/esm/Equivalence.js
var Equivalence_exports = {};
__export(Equivalence_exports, {
  Date: () => Date2,
  all: () => all,
  array: () => array,
  bigint: () => bigint,
  boolean: () => boolean,
  combine: () => combine,
  combineAll: () => combineAll,
  combineMany: () => combineMany,
  make: () => make,
  mapInput: () => mapInput,
  number: () => number,
  product: () => product,
  productMany: () => productMany,
  strict: () => strict,
  string: () => string,
  struct: () => struct,
  symbol: () => symbol,
  tuple: () => tuple
});
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var string = strict();
var number = strict();
var boolean = strict();
var bigint = strict();
var symbol = strict();
var combine = dual(2, (self, that) => make((x, y) => self(x, y) && that(x, y)));
var combineMany = dual(2, (self, collection) => make((x, y) => {
  if (!self(x, y)) {
    return false;
  }
  for (const equivalence3 of collection) {
    if (!equivalence3(x, y)) {
      return false;
    }
  }
  return true;
}));
var isAlwaysEquivalent = (_x, _y) => true;
var combineAll = (collection) => combineMany(isAlwaysEquivalent, collection);
var mapInput = dual(2, (self, f2) => make((x, y) => self(f2(x), f2(y))));
var Date2 = mapInput(number, (date5) => date5.getTime());
var product = dual(2, (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)));
var all = (collection) => {
  return make((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const equivalence3 of collection) {
      if (collectionLength >= len) {
        break;
      }
      if (!equivalence3(x[collectionLength], y[collectionLength])) {
        return false;
      }
      collectionLength++;
    }
    return true;
  });
};
var productMany = (self, collection) => {
  const equivalence3 = all(collection);
  return make((x, y) => !self(x[0], y[0]) ? false : equivalence3(x.slice(1), y.slice(1)));
};
var tuple = (...elements) => all(elements);
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});
var struct = (fields) => {
  const keys15 = Object.keys(fields);
  return make((self, that) => {
    for (const key of keys15) {
      if (!fields[key](self[key], that[key])) {
        return false;
      }
    }
    return true;
  });
};

// node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map49) => dual(3, (self, name, f2) => map49(self, (a) => ({
  ...a,
  [name]: f2(a)
})));
var bindTo = (map49) => dual(2, (self, name) => map49(self, (a) => ({
  [name]: a
})));
var bind = (map49, flatMap29) => dual(3, (self, name, f2) => flatMap29(self, (a) => map49(f2(a), (b) => ({
  ...a,
  [name]: b
}))));

// node_modules/effect/dist/esm/Equal.js
var Equal_exports = {};
__export(Equal_exports, {
  equals: () => equals,
  equivalence: () => equivalence,
  isEqual: () => isEqual2,
  symbol: () => symbol3
});

// node_modules/effect/dist/esm/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  array: () => array2,
  cached: () => cached,
  combine: () => combine2,
  hash: () => hash,
  isHash: () => isHash,
  number: () => number2,
  optimize: () => optimize,
  random: () => random2,
  string: () => string2,
  structure: () => structure,
  structureKeys: () => structureKeys,
  symbol: () => symbol2
});

// node_modules/effect/dist/esm/GlobalValue.js
var GlobalValue_exports = {};
__export(GlobalValue_exports, {
  globalValue: () => globalValue
});

// node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.16.12";
var getCurrentVersion = () => moduleVersion;
var setCurrentVersion = (version) => {
  moduleVersion = version;
};

// node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue/globalStoreId/${getCurrentVersion()}`;
var globalStore;
var globalValue = (id3, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ?? (globalThis[globalStoreId] = /* @__PURE__ */ new Map());
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id3)) {
    globalStore.set(id3, compute());
  }
  return globalStore.get(id3);
};

// node_modules/effect/dist/esm/Predicate.js
var Predicate_exports = {};
__export(Predicate_exports, {
  all: () => all2,
  and: () => and,
  compose: () => compose2,
  eqv: () => eqv,
  every: () => every,
  hasProperty: () => hasProperty,
  implies: () => implies,
  isBigInt: () => isBigInt,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction2,
  isIterable: () => isIterable,
  isMap: () => isMap,
  isNever: () => isNever,
  isNotNull: () => isNotNull,
  isNotNullable: () => isNotNullable,
  isNotUndefined: () => isNotUndefined,
  isNull: () => isNull,
  isNullable: () => isNullable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPromise: () => isPromise,
  isPromiseLike: () => isPromiseLike,
  isPropertyKey: () => isPropertyKey,
  isReadonlyRecord: () => isReadonlyRecord,
  isRecord: () => isRecord,
  isRecordOrArray: () => isRecordOrArray,
  isRegExp: () => isRegExp,
  isSet: () => isSet,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTagged: () => isTagged,
  isTruthy: () => isTruthy,
  isTupleOf: () => isTupleOf,
  isTupleOfAtLeast: () => isTupleOfAtLeast,
  isUint8Array: () => isUint8Array,
  isUndefined: () => isUndefined,
  isUnknown: () => isUnknown,
  mapInput: () => mapInput2,
  nand: () => nand,
  nor: () => nor,
  not: () => not,
  or: () => or,
  product: () => product2,
  productMany: () => productMany2,
  some: () => some,
  struct: () => struct2,
  tuple: () => tuple2,
  xor: () => xor
});
var mapInput2 = dual(2, (self, f2) => (b) => self(f2(b)));
var isTupleOf = dual(2, (self, n) => self.length === n);
var isTupleOfAtLeast = dual(2, (self, n) => self.length >= n);
var isTruthy = (input) => !!input;
var isSet = (input) => input instanceof Set;
var isMap = (input) => input instanceof Map;
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isPropertyKey = (u) => isString(u) || isNumber(u) || isSymbol(u);
var isFunction2 = isFunction;
var isUndefined = (input) => input === void 0;
var isNotUndefined = (input) => input !== void 0;
var isNull = (input) => input === null;
var isNotNull = (input) => input !== null;
var isNever = (_) => false;
var isUnknown = (_) => true;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = dual(2, (self, property2) => isObject(self) && property2 in self);
var isTagged = dual(2, (self, tag5) => hasProperty(self, "_tag") && self["_tag"] === tag5);
var isNullable = (input) => input === null || input === void 0;
var isNotNullable = (input) => input !== null && input !== void 0;
var isError = (input) => input instanceof Error;
var isUint8Array = (input) => input instanceof Uint8Array;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isReadonlyRecord = isRecord;
var isPromise = (input) => hasProperty(input, "then") && "catch" in input && isFunction2(input.then) && isFunction2(input.catch);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);
var isRegExp = (input) => input instanceof RegExp;
var compose2 = dual(2, (ab, bc) => (a) => ab(a) && bc(a));
var product2 = (self, that) => ([a, b]) => self(a) && that(b);
var all2 = (collection) => {
  return (as18) => {
    let collectionIndex = 0;
    for (const p of collection) {
      if (collectionIndex >= as18.length) {
        break;
      }
      if (p(as18[collectionIndex]) === false) {
        return false;
      }
      collectionIndex++;
    }
    return true;
  };
};
var productMany2 = (self, collection) => {
  const rest = all2(collection);
  return ([head13, ...tail5]) => self(head13) === false ? false : rest(tail5);
};
var tuple2 = (...elements) => all2(elements);
var struct2 = (fields) => {
  const keys15 = Object.keys(fields);
  return (a) => {
    for (const key of keys15) {
      if (!fields[key](a[key])) {
        return false;
      }
    }
    return true;
  };
};
var not = (self) => (a) => !self(a);
var or = dual(2, (self, that) => (a) => self(a) || that(a));
var and = dual(2, (self, that) => (a) => self(a) && that(a));
var xor = dual(2, (self, that) => (a) => self(a) !== that(a));
var eqv = dual(2, (self, that) => (a) => self(a) === that(a));
var implies = dual(2, (antecedent, consequent) => (a) => antecedent(a) ? consequent(a) : true);
var nor = dual(2, (self, that) => (a) => !(self(a) || that(a)));
var nand = dual(2, (self, that) => (a) => !(self(a) && that(a)));
var every = (collection) => (a) => {
  for (const p of collection) {
    if (!p(a)) {
      return false;
    }
  }
  return true;
};
var some = (collection) => (a) => {
  for (const p of collection) {
    if (p(a)) {
      return true;
    }
  }
  return false;
};

// node_modules/effect/dist/esm/Utils.js
var Utils_exports = {};
__export(Utils_exports, {
  GenKindImpl: () => GenKindImpl,
  GenKindTypeId: () => GenKindTypeId,
  PCGRandom: () => PCGRandom,
  SingleShotGen: () => SingleShotGen,
  YieldWrap: () => YieldWrap,
  YieldWrapTypeId: () => YieldWrapTypeId,
  adapter: () => adapter,
  internalCall: () => internalCall,
  isGenKind: () => isGenKind,
  isGeneratorFunction: () => isGeneratorFunction,
  makeGenKind: () => makeGenKind,
  structuralRegion: () => structuralRegion,
  structuralRegionState: () => structuralRegionState,
  yieldWrapGet: () => yieldWrapGet
});

// node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = Symbol.for("effect/Gen/GenKind");
var isGenKind = (u) => isObject(u) && GenKindTypeId in u;
var _a;
var GenKindImpl = class {
  constructor(value10) {
    __publicField(this, "value");
    /**
     * @since 2.0.0
     */
    __publicField(this, _a, GenKindTypeId);
    this.value = value10;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [(_a = GenKindTypeId, Symbol.iterator)]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "called", false);
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var makeGenKind = (kind) => new GenKindImpl(kind);
var adapter = () => function() {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  constructor(seedHi, seedLo, incHi, incLo) {
    __publicField(this, "_state");
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max14) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max14;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = Symbol.for("effect/Utils/YieldWrap");
var _value;
var YieldWrap = class {
  constructor(value10) {
    /**
     * @since 3.0.6
     */
    __privateAdd(this, _value);
    __privateSet(this, _value, value10);
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return __privateGet(this, _value);
  }
};
_value = new WeakMap();
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var structuralRegion = (body, tester) => {
  const current2 = structuralRegionState.enabled;
  const currentTester = structuralRegionState.tester;
  structuralRegionState.enabled = true;
  if (tester) {
    structuralRegionState.tester = tester;
  }
  try {
    return body();
  } finally {
    structuralRegionState.enabled = current2;
    structuralRegionState.tester = currentTester;
  }
};
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var _a2;
var isNotOptimizedAway = ((_a2 = standard.effect_internal_function(() => new Error().stack)) == null ? void 0 : _a2.includes("effect_internal_function")) === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = (function* () {
}).constructor;
var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

// node_modules/effect/dist/esm/Hash.js
var randomHashCache = globalValue(Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol2 = Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number2(self);
    case "bigint":
      return string2(self.toString(10));
    case "boolean":
      return string2(String(self));
    case "symbol":
      return string2(String(self));
    case "string":
      return string2(self);
    case "undefined":
      return string2("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string2("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol2]();
      } else {
        return random2(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random2 = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine2 = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol2);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h2 = n | 0;
  if (h2 !== n) {
    h2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h2 ^= n /= 4294967295;
  }
  return optimize(h2);
};
var string2 = (str) => {
  let h2 = 5381, i = str.length;
  while (i) {
    h2 = h2 * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h2);
};
var structureKeys = (o, keys15) => {
  let h2 = 12289;
  for (let i = 0; i < keys15.length; i++) {
    h2 ^= pipe(string2(keys15[i]), combine2(hash(o[keys15[i]])));
  }
  return optimize(h2);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h2 = 6151;
  for (let i = 0; i < arr.length; i++) {
    h2 = pipe(h2, combine2(hash(arr[i])));
  }
  return optimize(h2);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash12) {
      Object.defineProperty(self2, symbol2, {
        value() {
          return hash12;
        },
        enumerable: false
      });
      return hash12;
    };
  }
  const self = arguments[0];
  const hash11 = arguments[1];
  Object.defineProperty(self, symbol2, {
    value() {
      return hash11;
    },
    enumerable: false
  });
  return hash11;
};

// node_modules/effect/dist/esm/Equal.js
var symbol3 = Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual2(self) && isEqual2(that)) {
        if (hash(self) === hash(that) && self[symbol3](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual2 = (u) => hasProperty(u, symbol3);
var equivalence = () => equals;

// node_modules/effect/dist/esm/Inspectable.js
var Inspectable_exports = {};
__export(Inspectable_exports, {
  BaseProto: () => BaseProto,
  Class: () => Class,
  NodeInspectSymbol: () => NodeInspectSymbol,
  format: () => format,
  isRedactable: () => isRedactable,
  redact: () => redact,
  stringifyCircular: () => stringifyCircular,
  symbolRedactable: () => symbolRedactable,
  toJSON: () => toJSON,
  toStringUnknown: () => toStringUnknown,
  withRedactableContext: () => withRedactableContext
});
var NodeInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value10) => typeof value10 === "object" && value10 !== null ? cache.includes(value10) ? void 0 : cache.push(value10) && (redactableState.fiberRefs !== void 0 && isRedactable(value10) ? value10[symbolRedactable](redactableState.fiberRefs) : value10) : value10, whitespace);
  cache = void 0;
  return retVal;
};
var symbolRedactable = Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = (context15, f2) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context15;
  try {
    return f2();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/effect/dist/esm/Pipeable.js
var Pipeable_exports = {};
__export(Pipeable_exports, {
  Class: () => Class2,
  Prototype: () => Prototype,
  pipeArguments: () => pipeArguments
});
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};
var Prototype = {
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var Base = function() {
  function PipeableBase() {
  }
  PipeableBase.prototype = Prototype;
  return PipeableBase;
}();
var Class2 = (klass) => klass ? class extends klass {
  pipe() {
    return pipeArguments(this, arguments);
  }
} : Base;

// node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = Symbol.for("effect/Effect");
var StreamTypeId = Symbol.for("effect/Stream");
var SinkTypeId = Symbol.for("effect/Sink");
var ChannelTypeId = Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol3](that) {
    return this === that;
  },
  [symbol2]() {
    return cached(this, random2(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol2]() {
    return cached(this, structure(this));
  },
  [symbol3](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base2 = function() {
  function Base4() {
  }
  Base4.prototype = CommitPrototype;
  return Base4;
}();
var StructuralBase = function() {
  function Base4() {
  }
  Base4.prototype = StructuralCommitPrototype;
  return Base4;
}();

// node_modules/effect/dist/esm/internal/option.js
var TypeId = Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = Object.assign(Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol3](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol2]() {
    return cached(this, combine2(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = hash("None");
var NoneProto = Object.assign(Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol3](that) {
    return isOption(that) && isNone(that);
  },
  [symbol2]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = Object.create(NoneProto);
var some2 = (value10) => {
  const a = Object.create(SomeProto);
  a.value = value10;
  return a;
};

// node_modules/effect/dist/esm/internal/either.js
var TypeId2 = Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = Object.assign(Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol3](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol2]() {
    return combine2(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = Object.assign(Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol3](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol2]() {
    return combine2(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};
var getLeft = (self) => isRight(self) ? none : some2(self.left);
var getRight = (self) => isLeft(self) ? none : some2(self.right);
var fromOption = dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));

// node_modules/effect/dist/esm/Either.js
var TypeId3 = TypeId2;
var right2 = right;
var void_ = right2(void 0);
var left2 = left;
var fromNullable = dual(2, (self, onNullable) => self == null ? left2(onNullable(self)) : right2(self));
var fromOption2 = fromOption;
var try_ = (evaluate4) => {
  if (isFunction2(evaluate4)) {
    try {
      return right2(evaluate4());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate4.try());
    } catch (e) {
      return left2(evaluate4.catch(e));
    }
  }
};
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getRight2 = getRight;
var getLeft2 = getLeft;
var getEquivalence = ({
  left: left3,
  right: right3
}) => make((x, y) => isLeft2(x) ? isLeft2(y) && left3(x.left, y.left) : isRight2(y) && right3(x.right, y.right));
var mapBoth = dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? left2(onLeft(self.left)) : right2(onRight(self.right)));
var mapLeft = dual(2, (self, f2) => isLeft2(self) ? left2(f2(self.left)) : right2(self.right));
var map = dual(2, (self, f2) => isRight2(self) ? right2(f2(self.right)) : left2(self.left));
var match = dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var liftPredicate = dual(3, (a, predicate, orLeftWith) => predicate(a) ? right2(a) : left2(orLeftWith(a)));
var filterOrLeft = dual(3, (self, predicate, orLeftWith) => flatMap(self, (r) => predicate(r) ? right2(r) : left2(orLeftWith(r))));
var merge = match({
  onLeft: identity,
  onRight: identity
});
var getOrElse = dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);
var getOrNull = getOrElse(constNull);
var getOrUndefined = getOrElse(constUndefined);
var getOrThrowWith = dual(2, (self, onLeft) => {
  if (isRight2(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
var getOrThrow = getOrThrowWith(() => new Error("getOrThrow called on a Left"));
var orElse = dual(2, (self, that) => isLeft2(self) ? that(self.left) : right2(self.right));
var flatMap = dual(2, (self, f2) => isLeft2(self) ? left2(self.left) : f2(self.right));
var andThen = dual(2, (self, f2) => flatMap(self, (a) => {
  const b = isFunction2(f2) ? f2(a) : f2;
  return isEither2(b) ? b : right2(b);
}));
var zipWith = dual(3, (self, that, f2) => flatMap(self, (r) => map(that, (r2) => f2(r, r2))));
var ap = dual(2, (self, that) => zipWith(self, that, (f2, a) => f2(a)));
var all3 = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const e of input) {
      if (isLeft2(e)) {
        return e;
      }
      out2.push(e.right);
    }
    return right2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const e = input[key];
    if (isLeft2(e)) {
      return e;
    }
    out[key] = e.right;
  }
  return right2(out);
};
var flip2 = (self) => isLeft2(self) ? right2(self.left) : left2(self.right);
var adapter2 = adapter();
var gen = (...args2) => {
  const f2 = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f2(adapter2);
  let state = iterator.next();
  while (!state.done) {
    const current2 = isGenKind(state.value) ? state.value.value : yieldWrapGet(state.value);
    if (isLeft2(current2)) {
      return current2;
    }
    state = iterator.next(current2.right);
  }
  return right2(state.value);
};
var Do = right2({});
var bind2 = bind(map, flatMap);
var bindTo2 = bindTo(map);
var let_2 = let_(map);
var transposeOption = (self) => {
  return isNone(self) ? right2(none) : map(self.value, some2);
};
var transposeMapOption = dual(2, (self, f2) => isNone(self) ? right2(none) : map(f2(self.value), some2));

// node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// node_modules/effect/dist/esm/Iterable.js
var Iterable_exports = {};
__export(Iterable_exports, {
  append: () => append,
  appendAll: () => appendAll,
  cartesian: () => cartesian,
  cartesianWith: () => cartesianWith,
  chunksOf: () => chunksOf,
  contains: () => contains2,
  containsWith: () => containsWith2,
  countBy: () => countBy,
  dedupeAdjacent: () => dedupeAdjacent,
  dedupeAdjacentWith: () => dedupeAdjacentWith,
  drop: () => drop,
  empty: () => empty2,
  filter: () => filter2,
  filterMap: () => filterMap2,
  filterMapWhile: () => filterMapWhile,
  findFirst: () => findFirst,
  findLast: () => findLast,
  flatMap: () => flatMap3,
  flatMapNullable: () => flatMapNullable2,
  flatten: () => flatten2,
  forEach: () => forEach,
  fromRecord: () => fromRecord,
  getLefts: () => getLefts,
  getRights: () => getRights,
  getSomes: () => getSomes,
  group: () => group,
  groupBy: () => groupBy,
  groupWith: () => groupWith,
  head: () => head,
  intersperse: () => intersperse,
  isEmpty: () => isEmpty,
  makeBy: () => makeBy,
  map: () => map4,
  of: () => of,
  prepend: () => prepend,
  prependAll: () => prependAll,
  range: () => range,
  reduce: () => reduce,
  replicate: () => replicate,
  scan: () => scan,
  size: () => size4,
  some: () => some4,
  take: () => take,
  takeWhile: () => takeWhile,
  unfold: () => unfold,
  unsafeHead: () => unsafeHead,
  zip: () => zip,
  zipWith: () => zipWith3
});

// node_modules/effect/dist/esm/Option.js
var Option_exports = {};
__export(Option_exports, {
  Do: () => Do2,
  TypeId: () => TypeId4,
  all: () => all5,
  andThen: () => andThen2,
  ap: () => ap2,
  as: () => as,
  asVoid: () => asVoid,
  bind: () => bind3,
  bindTo: () => bindTo3,
  composeK: () => composeK,
  contains: () => contains,
  containsWith: () => containsWith,
  exists: () => exists,
  filter: () => filter,
  filterMap: () => filterMap,
  firstSomeOf: () => firstSomeOf,
  flatMap: () => flatMap2,
  flatMapNullable: () => flatMapNullable,
  flatten: () => flatten,
  fromIterable: () => fromIterable,
  fromNullable: () => fromNullable2,
  gen: () => gen2,
  getEquivalence: () => getEquivalence2,
  getLeft: () => getLeft3,
  getOrElse: () => getOrElse2,
  getOrNull: () => getOrNull2,
  getOrThrow: () => getOrThrow2,
  getOrThrowWith: () => getOrThrowWith2,
  getOrUndefined: () => getOrUndefined2,
  getOrder: () => getOrder,
  getRight: () => getRight3,
  isNone: () => isNone2,
  isOption: () => isOption2,
  isSome: () => isSome2,
  let: () => let_3,
  lift2: () => lift2,
  liftNullable: () => liftNullable,
  liftPredicate: () => liftPredicate2,
  liftThrowable: () => liftThrowable,
  map: () => map2,
  match: () => match2,
  mergeWith: () => mergeWith,
  none: () => none2,
  orElse: () => orElse2,
  orElseEither: () => orElseEither,
  orElseSome: () => orElseSome,
  partitionMap: () => partitionMap,
  product: () => product4,
  productMany: () => productMany4,
  reduceCompact: () => reduceCompact,
  some: () => some3,
  tap: () => tap,
  toArray: () => toArray,
  toRefinement: () => toRefinement,
  void: () => void_2,
  zipLeft: () => zipLeft,
  zipRight: () => zipRight,
  zipWith: () => zipWith2
});

// node_modules/effect/dist/esm/Order.js
var Order_exports = {};
__export(Order_exports, {
  Date: () => Date3,
  all: () => all4,
  array: () => array3,
  between: () => between,
  bigint: () => bigint2,
  boolean: () => boolean2,
  clamp: () => clamp,
  combine: () => combine3,
  combineAll: () => combineAll2,
  combineMany: () => combineMany2,
  empty: () => empty,
  greaterThan: () => greaterThan,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo,
  lessThan: () => lessThan,
  lessThanOrEqualTo: () => lessThanOrEqualTo,
  make: () => make2,
  mapInput: () => mapInput3,
  max: () => max,
  min: () => min,
  number: () => number3,
  product: () => product3,
  productMany: () => productMany3,
  reverse: () => reverse,
  string: () => string3,
  struct: () => struct3,
  tuple: () => tuple3
});
var make2 = (compare3) => (self, that) => self === that ? 0 : compare3(self, that);
var string3 = make2((self, that) => self < that ? -1 : 1);
var number3 = make2((self, that) => self < that ? -1 : 1);
var boolean2 = make2((self, that) => self < that ? -1 : 1);
var bigint2 = make2((self, that) => self < that ? -1 : 1);
var reverse = (O) => make2((self, that) => O(that, self));
var combine3 = dual(2, (self, that) => make2((a1, a2) => {
  const out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  return that(a1, a2);
}));
var combineMany2 = dual(2, (self, collection) => make2((a1, a2) => {
  let out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  for (const O of collection) {
    out = O(a1, a2);
    if (out !== 0) {
      return out;
    }
  }
  return out;
}));
var empty = () => make2(() => 0);
var combineAll2 = (collection) => combineMany2(empty(), collection);
var mapInput3 = dual(2, (self, f2) => make2((b1, b22) => self(f2(b1), f2(b22))));
var Date3 = mapInput3(number3, (date5) => date5.getTime());
var product3 = dual(2, (self, that) => make2(([xa, xb], [ya, yb]) => {
  const o = self(xa, ya);
  return o !== 0 ? o : that(xb, yb);
}));
var all4 = (collection) => {
  return make2((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
};
var productMany3 = dual(2, (self, collection) => {
  const O = all4(collection);
  return make2((x, y) => {
    const o = self(x[0], y[0]);
    return o !== 0 ? o : O(x.slice(1), y.slice(1));
  });
});
var tuple3 = (...elements) => all4(elements);
var array3 = (O) => make2((self, that) => {
  const aLen = self.length;
  const bLen = that.length;
  const len = Math.min(aLen, bLen);
  for (let i = 0; i < len; i++) {
    const o = O(self[i], that[i]);
    if (o !== 0) {
      return o;
    }
  }
  return number3(aLen, bLen);
});
var struct3 = (fields) => {
  const keys15 = Object.keys(fields);
  return make2((self, that) => {
    for (const key of keys15) {
      const o = fields[key](self[key], that[key]);
      if (o !== 0) {
        return o;
      }
    }
    return 0;
  });
};
var lessThan = (O) => dual(2, (self, that) => O(self, that) === -1);
var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);
var lessThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== 1);
var greaterThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== -1);
var min = (O) => dual(2, (self, that) => self === that || O(self, that) < 1 ? self : that);
var max = (O) => dual(2, (self, that) => self === that || O(self, that) > -1 ? self : that);
var clamp = (O) => dual(2, (self, options) => min(O)(options.maximum, max(O)(options.minimum, self)));
var between = (O) => dual(2, (self, options) => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));

// node_modules/effect/dist/esm/Option.js
var TypeId4 = Symbol.for("effect/Option");
var none2 = () => none;
var some3 = some2;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var toRefinement = (f2) => (a) => isSome2(f2(a));
var fromIterable = (collection) => {
  for (const a of collection) {
    return some3(a);
  }
  return none2();
};
var getRight3 = getRight;
var getLeft3 = getLeft;
var getOrElse2 = dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse2 = dual(2, (self, that) => isNone2(self) ? that() : self);
var orElseSome = dual(2, (self, onNone) => isNone2(self) ? some3(onNone()) : self);
var orElseEither = dual(2, (self, that) => isNone2(self) ? map2(that(), right) : map2(self, left));
var firstSomeOf = (collection) => {
  let out = none2();
  for (out of collection) {
    if (isSome2(out)) {
      return out;
    }
  }
  return out;
};
var fromNullable2 = (nullableValue) => nullableValue == null ? none2() : some3(nullableValue);
var liftNullable = (f2) => (...a) => fromNullable2(f2(...a));
var getOrNull2 = getOrElse2(constNull);
var getOrUndefined2 = getOrElse2(constUndefined);
var liftThrowable = (f2) => (...a) => {
  try {
    return some3(f2(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow2 = getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = dual(2, (self, f2) => isNone2(self) ? none2() : some3(f2(self.value)));
var as = dual(2, (self, b) => map2(self, () => b));
var asVoid = as(void 0);
var void_2 = some3(void 0);
var flatMap2 = dual(2, (self, f2) => isNone2(self) ? none2() : f2(self.value));
var andThen2 = dual(2, (self, f2) => flatMap2(self, (a) => {
  const b = isFunction(f2) ? f2(a) : f2;
  return isOption2(b) ? b : some3(b);
}));
var flatMapNullable = dual(2, (self, f2) => isNone2(self) ? none2() : fromNullable2(f2(self.value)));
var flatten = flatMap2(identity);
var zipRight = dual(2, (self, that) => flatMap2(self, () => that));
var zipLeft = dual(2, (self, that) => tap(self, () => that));
var composeK = dual(2, (afb, bfc) => (a) => flatMap2(afb(a), bfc));
var tap = dual(2, (self, f2) => flatMap2(self, (a) => map2(f2(a), () => a)));
var product4 = (self, that) => isSome2(self) && isSome2(that) ? some3([self.value, that.value]) : none2();
var productMany4 = (self, collection) => {
  if (isNone2(self)) {
    return none2();
  }
  const out = [self.value];
  for (const o of collection) {
    if (isNone2(o)) {
      return none2();
    }
    out.push(o.value);
  }
  return some3(out);
};
var all5 = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const o of input) {
      if (isNone2(o)) {
        return none2();
      }
      out2.push(o.value);
    }
    return some3(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (isNone2(o)) {
      return none2();
    }
    out[key] = o.value;
  }
  return some3(out);
};
var zipWith2 = dual(3, (self, that, f2) => map2(product4(self, that), ([a, b]) => f2(a, b)));
var ap2 = dual(2, (self, that) => zipWith2(self, that, (f2, a) => f2(a)));
var reduceCompact = dual(3, (self, b, f2) => {
  let out = b;
  for (const oa of self) {
    if (isSome2(oa)) {
      out = f2(out, oa.value);
    }
  }
  return out;
});
var toArray = (self) => isNone2(self) ? [] : [self.value];
var partitionMap = dual(2, (self, f2) => {
  if (isNone2(self)) {
    return [none2(), none2()];
  }
  const e = f2(self.value);
  return isLeft(e) ? [some3(e.left), none2()] : [none2(), some3(e.right)];
});
var filterMap = flatMap2;
var filter = dual(2, (self, predicate) => filterMap(self, (b) => predicate(b) ? some2(b) : none));
var getEquivalence2 = (isEquivalent) => make((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value));
var getOrder = (O) => make2((self, that) => isSome2(self) ? isSome2(that) ? O(self.value, that.value) : 1 : -1);
var lift2 = (f2) => dual(2, (self, that) => zipWith2(self, that, f2));
var liftPredicate2 = dual(2, (b, predicate) => predicate(b) ? some3(b) : none2());
var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
var _equivalence = equivalence();
var contains = containsWith(_equivalence);
var exists = dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
var bindTo3 = bindTo(map2);
var let_3 = let_(map2);
var bind3 = bind(map2, flatMap2);
var Do2 = some3({});
var adapter3 = adapter();
var gen2 = (...args2) => {
  const f2 = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f2(adapter3);
  let state = iterator.next();
  while (!state.done) {
    const current2 = isGenKind(state.value) ? state.value.value : yieldWrapGet(state.value);
    if (isNone2(current2)) {
      return current2;
    }
    state = iterator.next(current2.value);
  }
  return some3(state.value);
};
var mergeWith = (f2) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some3(f2(o1.value, o2.value));
};

// node_modules/effect/dist/esm/Tuple.js
var Tuple_exports = {};
__export(Tuple_exports, {
  appendElement: () => appendElement,
  at: () => at,
  getEquivalence: () => getEquivalence3,
  getFirst: () => getFirst,
  getOrder: () => getOrder2,
  getSecond: () => getSecond,
  isTupleOf: () => isTupleOf,
  isTupleOfAtLeast: () => isTupleOfAtLeast,
  make: () => make3,
  map: () => map3,
  mapBoth: () => mapBoth2,
  mapFirst: () => mapFirst,
  mapSecond: () => mapSecond,
  swap: () => swap
});
var make3 = (...elements) => elements;
var getFirst = (self) => self[0];
var getSecond = (self) => self[1];
var map3 = dual(2, (self, fn2) => self.map((element2) => fn2(element2)));
var mapBoth2 = dual(2, (self, {
  onFirst,
  onSecond
}) => [onFirst(self[0]), onSecond(self[1])]);
var mapFirst = dual(2, (self, f2) => [f2(self[0]), self[1]]);
var mapSecond = dual(2, (self, f2) => [self[0], f2(self[1])]);
var swap = (self) => [self[1], self[0]];
var getEquivalence3 = tuple;
var getOrder2 = tuple3;
var appendElement = dual(2, (self, that) => [...self, that]);
var at = dual(2, (self, index3) => self[index3]);

// node_modules/effect/dist/esm/Iterable.js
var makeBy = (f2, options) => {
  const max14 = (options == null ? void 0 : options.length) !== void 0 ? Math.max(1, Math.floor(options.length)) : Infinity;
  return {
    [Symbol.iterator]() {
      let i = 0;
      return {
        next() {
          if (i < max14) {
            return {
              value: f2(i++),
              done: false
            };
          }
          return {
            done: true,
            value: void 0
          };
        }
      };
    }
  };
};
var range = (start5, end7) => {
  if (end7 === void 0) {
    return makeBy((i) => start5 + i);
  }
  return makeBy((i) => start5 + i, {
    length: start5 <= end7 ? end7 - start5 + 1 : 1
  });
};
var replicate = dual(2, (a, n) => makeBy(() => a, {
  length: n
}));
var fromRecord = (self) => ({
  *[Symbol.iterator]() {
    for (const key in self) {
      if (Object.prototype.hasOwnProperty.call(self, key)) {
        yield [key, self[key]];
      }
    }
  }
});
var prepend = dual(2, (self, head13) => prependAll(self, [head13]));
var prependAll = dual(2, (self, that) => appendAll(that, self));
var append = dual(2, (self, last8) => appendAll(self, [last8]));
var appendAll = dual(2, (self, that) => ({
  [Symbol.iterator]() {
    const iterA = self[Symbol.iterator]();
    let doneA = false;
    let iterB;
    return {
      next() {
        if (!doneA) {
          const r = iterA.next();
          if (r.done) {
            doneA = true;
            iterB = that[Symbol.iterator]();
            return iterB.next();
          }
          return r;
        }
        return iterB.next();
      }
    };
  }
}));
var scan = dual(3, (self, b, f2) => ({
  [Symbol.iterator]() {
    let acc = b;
    let iterator;
    function next6() {
      if (iterator === void 0) {
        iterator = self[Symbol.iterator]();
        return {
          done: false,
          value: acc
        };
      }
      const result = iterator.next();
      if (result.done) {
        return result;
      }
      acc = f2(acc, result.value);
      return {
        done: false,
        value: acc
      };
    }
    return {
      next: next6
    };
  }
}));
var isEmpty = (self) => {
  const iterator = self[Symbol.iterator]();
  return iterator.next().done === true;
};
var size4 = (self) => {
  const iterator = self[Symbol.iterator]();
  let count9 = 0;
  while (!iterator.next().done) {
    count9++;
  }
  return count9;
};
var head = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  return result.done ? none2() : some3(result.value);
};
var unsafeHead = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  if (result.done) throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var take = dual(2, (self, n) => ({
  [Symbol.iterator]() {
    let i = 0;
    const iterator = self[Symbol.iterator]();
    return {
      next() {
        if (i < n) {
          i++;
          return iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var takeWhile = dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done || !predicate(result.value, i++)) {
          return {
            done: true,
            value: void 0
          };
        }
        return result;
      }
    };
  }
}));
var drop = dual(2, (self, n) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        while (i < n) {
          const result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
          i++;
        }
        return iterator.next();
      }
    };
  }
}));
var findFirst = dual(2, (self, f2) => {
  let i = 0;
  for (const a of self) {
    const o = f2(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var findLast = dual(2, (self, f2) => {
  let i = 0;
  let last8 = none2();
  for (const a of self) {
    const o = f2(a, i);
    if (isBoolean(o)) {
      if (o) {
        last8 = some3(a);
      }
    } else {
      if (isSome2(o)) {
        last8 = o;
      }
    }
    i++;
  }
  return last8;
});
var zip = dual(2, (self, that) => zipWith3(self, that, make3));
var zipWith3 = dual(3, (self, that, f2) => ({
  [Symbol.iterator]() {
    const selfIterator = self[Symbol.iterator]();
    const thatIterator = that[Symbol.iterator]();
    return {
      next() {
        const selfResult = selfIterator.next();
        const thatResult = thatIterator.next();
        if (selfResult.done || thatResult.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f2(selfResult.value, thatResult.value)
        };
      }
    };
  }
}));
var intersperse = dual(2, (self, middle) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let next6 = iterator.next();
    let emitted = false;
    return {
      next() {
        if (next6.done) {
          return next6;
        } else if (emitted) {
          emitted = false;
          return {
            done: false,
            value: middle
          };
        }
        emitted = true;
        const result = next6;
        next6 = iterator.next();
        return result;
      }
    };
  }
}));
var containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = equivalence();
var contains2 = containsWith2(_equivalence2);
var chunksOf = dual(2, (self, n) => {
  const safeN = Math.max(1, Math.floor(n));
  return {
    [Symbol.iterator]() {
      let iterator = self[Symbol.iterator]();
      return {
        next() {
          if (iterator === void 0) {
            return {
              done: true,
              value: void 0
            };
          }
          const chunk7 = [];
          for (let i = 0; i < safeN; i++) {
            const result = iterator.next();
            if (result.done) {
              iterator = void 0;
              return chunk7.length === 0 ? {
                done: true,
                value: void 0
              } : {
                done: false,
                value: chunk7
              };
            }
            chunk7.push(result.value);
          }
          return {
            done: false,
            value: chunk7
          };
        }
      };
    }
  };
});
var groupWith = dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let nextResult;
    return {
      next() {
        let result;
        if (nextResult !== void 0) {
          if (nextResult.done) {
            return {
              done: true,
              value: void 0
            };
          }
          result = nextResult;
          nextResult = void 0;
        } else {
          result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
        }
        const chunk7 = [result.value];
        while (true) {
          const next6 = iterator.next();
          if (next6.done || !isEquivalent(result.value, next6.value)) {
            nextResult = next6;
            return {
              done: false,
              value: chunk7
            };
          }
          chunk7.push(next6.value);
        }
      }
    };
  }
}));
var group = groupWith(equivalence());
var groupBy = dual(2, (self, f2) => {
  const out = {};
  for (const a of self) {
    const k = f2(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: void 0
    };
  }
};
var empty2 = () => constEmpty;
var of = (a) => [a];
var map4 = dual(2, (self, f2) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f2(result.value, i++)
        };
      }
    };
  }
}));
var flatMap3 = dual(2, (self, f2) => flatten2(map4(self, f2)));
var flatten2 = (self) => ({
  [Symbol.iterator]() {
    const outerIterator = self[Symbol.iterator]();
    let innerIterator;
    function next6() {
      if (innerIterator === void 0) {
        const next7 = outerIterator.next();
        if (next7.done) {
          return next7;
        }
        innerIterator = next7.value[Symbol.iterator]();
      }
      const result = innerIterator.next();
      if (result.done) {
        innerIterator = void 0;
        return next6();
      }
      return result;
    }
    return {
      next: next6
    };
  }
});
var filterMap2 = dual(2, (self, f2) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          const b = f2(result.value, i++);
          if (isSome2(b)) {
            return {
              done: false,
              value: b.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var filterMapWhile = dual(2, (self, f2) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const b = f2(result.value, i++);
        if (isSome2(b)) {
          return {
            done: false,
            value: b.value
          };
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var getSomes = filterMap2(identity);
var getLefts = (self) => filterMap2(self, getLeft2);
var getRights = (self) => filterMap2(self, getRight2);
var filter2 = dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          if (predicate(result.value, i++)) {
            return {
              done: false,
              value: result.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var flatMapNullable2 = dual(2, (self, f2) => filterMap2(self, (a) => {
  const b = f2(a);
  return b == null ? none2() : some3(b);
}));
var some4 = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i++)) {
      return true;
    }
  }
  return false;
});
var unfold = (b, f2) => ({
  [Symbol.iterator]() {
    let next6 = b;
    return {
      next() {
        const o = f2(next6);
        if (isNone2(o)) {
          return {
            done: true,
            value: void 0
          };
        }
        const [a, b3] = o.value;
        next6 = b3;
        return {
          done: false,
          value: a
        };
      }
    };
  }
});
var forEach = dual(2, (self, f2) => {
  let i = 0;
  for (const a of self) {
    f2(a, i++);
  }
});
var reduce = dual(3, (self, b, f2) => {
  if (Array.isArray(self)) {
    return self.reduce(f2, b);
  }
  let i = 0;
  let result = b;
  for (const n of self) {
    result = f2(result, n, i++);
  }
  return result;
});
var dedupeAdjacentWith = dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let first5 = true;
    let last8;
    function next6() {
      const result = iterator.next();
      if (result.done) {
        return {
          done: true,
          value: void 0
        };
      }
      if (first5) {
        first5 = false;
        last8 = result.value;
        return result;
      }
      const current2 = result.value;
      if (isEquivalent(last8, current2)) {
        return next6();
      }
      last8 = current2;
      return result;
    }
    return {
      next: next6
    };
  }
}));
var dedupeAdjacent = dedupeAdjacentWith(equivalence());
var cartesianWith = dual(3, (self, that, f2) => flatMap3(self, (a) => map4(that, (b) => f2(a, b))));
var cartesian = dual(2, (self, that) => cartesianWith(self, that, (a, b) => [a, b]));
var countBy = dual(2, (self, f2) => {
  let count9 = 0;
  let i = 0;
  for (const a of self) {
    if (f2(a, i)) {
      count9++;
    }
    i++;
  }
  return count9;
});

// node_modules/effect/dist/esm/Record.js
var Record_exports = {};
__export(Record_exports, {
  collect: () => collect,
  difference: () => difference,
  empty: () => empty3,
  every: () => every2,
  filter: () => filter3,
  filterMap: () => filterMap3,
  findFirst: () => findFirst2,
  fromEntries: () => fromEntries,
  fromIterableBy: () => fromIterableBy,
  fromIterableWith: () => fromIterableWith,
  get: () => get,
  getEquivalence: () => getEquivalence4,
  getLefts: () => getLefts2,
  getRights: () => getRights2,
  getSomes: () => getSomes2,
  has: () => has,
  intersection: () => intersection,
  isEmptyReadonlyRecord: () => isEmptyReadonlyRecord,
  isEmptyRecord: () => isEmptyRecord,
  isSubrecord: () => isSubrecord,
  isSubrecordBy: () => isSubrecordBy,
  keys: () => keys,
  map: () => map5,
  mapEntries: () => mapEntries,
  mapKeys: () => mapKeys,
  modify: () => modify,
  modifyOption: () => modifyOption,
  partition: () => partition,
  partitionMap: () => partitionMap2,
  pop: () => pop,
  reduce: () => reduce2,
  remove: () => remove,
  replace: () => replace,
  replaceOption: () => replaceOption,
  separate: () => separate,
  set: () => set,
  singleton: () => singleton,
  size: () => size5,
  some: () => some5,
  toEntries: () => toEntries,
  union: () => union,
  values: () => values
});
var empty3 = () => ({});
var isEmptyRecord = (self) => keys(self).length === 0;
var isEmptyReadonlyRecord = isEmptyRecord;
var fromIterableWith = dual(2, (self, f2) => {
  const out = empty3();
  for (const a of self) {
    const [k, b] = f2(a);
    out[k] = b;
  }
  return out;
});
var fromIterableBy = (items, f2) => fromIterableWith(items, (a) => [f2(a), a]);
var fromEntries = Object.fromEntries;
var collect = dual(2, (self, f2) => {
  const out = [];
  for (const key of keys(self)) {
    out.push(f2(key, self[key]));
  }
  return out;
});
var toEntries = collect((key, value10) => [key, value10]);
var size5 = (self) => keys(self).length;
var has = dual(2, (self, key) => Object.prototype.hasOwnProperty.call(self, key));
var get = dual(2, (self, key) => has(self, key) ? some3(self[key]) : none2());
var modify = dual(3, (self, key, f2) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  return {
    ...self,
    [key]: f2(self[key])
  };
});
var modifyOption = dual(3, (self, key, f2) => {
  if (!has(self, key)) {
    return none2();
  }
  return some3({
    ...self,
    [key]: f2(self[key])
  });
});
var replaceOption = dual(3, (self, key, b) => modifyOption(self, key, () => b));
var remove = dual(2, (self, key) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  const out = {
    ...self
  };
  delete out[key];
  return out;
});
var pop = dual(2, (self, key) => has(self, key) ? some3([self[key], remove(self, key)]) : none2());
var map5 = dual(2, (self, f2) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f2(self[key], key);
  }
  return out;
});
var mapKeys = dual(2, (self, f2) => {
  const out = {};
  for (const key of keys(self)) {
    const a = self[key];
    out[f2(key, a)] = a;
  }
  return out;
});
var mapEntries = dual(2, (self, f2) => {
  const out = {};
  for (const key of keys(self)) {
    const [k, b] = f2(self[key], key);
    out[k] = b;
  }
  return out;
});
var filterMap3 = dual(2, (self, f2) => {
  const out = empty3();
  for (const key of keys(self)) {
    const o = f2(self[key], key);
    if (isSome2(o)) {
      out[key] = o.value;
    }
  }
  return out;
});
var filter3 = dual(2, (self, predicate) => {
  const out = empty3();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      out[key] = self[key];
    }
  }
  return out;
});
var getSomes2 = filterMap3(identity);
var getLefts2 = (self) => {
  const out = empty3();
  for (const key of keys(self)) {
    const value10 = self[key];
    if (isLeft2(value10)) {
      out[key] = value10.left;
    }
  }
  return out;
};
var getRights2 = (self) => {
  const out = empty3();
  for (const key of keys(self)) {
    const value10 = self[key];
    if (isRight2(value10)) {
      out[key] = value10.right;
    }
  }
  return out;
};
var partitionMap2 = dual(2, (self, f2) => {
  const left3 = empty3();
  const right3 = empty3();
  for (const key of keys(self)) {
    const e = f2(self[key], key);
    if (isLeft2(e)) {
      left3[key] = e.left;
    } else {
      right3[key] = e.right;
    }
  }
  return [left3, right3];
});
var separate = partitionMap2(identity);
var partition = dual(2, (self, predicate) => {
  const left3 = empty3();
  const right3 = empty3();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      right3[key] = self[key];
    } else {
      left3[key] = self[key];
    }
  }
  return [left3, right3];
});
var keys = (self) => Object.keys(self);
var values = (self) => collect(self, (_, a) => a);
var set = dual(3, (self, key, value10) => {
  return {
    ...self,
    [key]: value10
  };
});
var replace = dual(3, (self, key, value10) => {
  if (has(self, key)) {
    return {
      ...self,
      [key]: value10
    };
  }
  return {
    ...self
  };
});
var isSubrecordBy = (equivalence3) => dual(2, (self, that) => {
  for (const key of keys(self)) {
    if (!has(that, key) || !equivalence3(self[key], that[key])) {
      return false;
    }
  }
  return true;
});
var isSubrecord = isSubrecordBy(equivalence());
var reduce2 = dual(3, (self, zero3, f2) => {
  let out = zero3;
  for (const key of keys(self)) {
    out = f2(out, self[key], key);
  }
  return out;
});
var every2 = dual(2, (self, refinement) => {
  for (const key of keys(self)) {
    if (!refinement(self[key], key)) {
      return false;
    }
  }
  return true;
});
var some5 = dual(2, (self, predicate) => {
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      return true;
    }
  }
  return false;
});
var union = dual(3, (self, that, combine20) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = empty3();
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine20(self[key], that[key]);
    } else {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(out, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
var intersection = dual(3, (self, that, combine20) => {
  const out = empty3();
  if (isEmptyRecord(self) || isEmptyRecord(that)) {
    return out;
  }
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine20(self[key], that[key]);
    }
  }
  return out;
});
var difference = dual(2, (self, that) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = {};
  for (const key of keys(self)) {
    if (!has(that, key)) {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(self, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
var getEquivalence4 = (equivalence3) => {
  const is4 = isSubrecordBy(equivalence3);
  return (self, that) => is4(self, that) && is4(that, self);
};
var singleton = (key, value10) => ({
  [key]: value10
});
var findFirst2 = dual(2, (self, f2) => {
  const k = keys(self);
  for (let i = 0; i < k.length; i++) {
    const key = k[i];
    if (f2(self[key], key)) {
      return some3([key, self[key]]);
    }
  }
  return none2();
});

// node_modules/effect/dist/esm/Array.js
var make4 = (...elements) => elements;
var allocate = (n) => new Array(n);
var makeBy2 = dual(2, (n, f2) => {
  const max14 = Math.max(1, Math.floor(n));
  const out = new Array(max14);
  for (let i = 0; i < max14; i++) {
    out[i] = f2(i);
  }
  return out;
});
var range2 = (start5, end7) => start5 <= end7 ? makeBy2(end7 - start5 + 1, (i) => start5 + i) : [start5];
var replicate2 = dual(2, (a, n) => makeBy2(n, () => a));
var fromIterable2 = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self) => Array.isArray(self) ? self : [self];
var fromRecord2 = toEntries;
var fromOption3 = toArray;
var match3 = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
var matchLeft = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
var matchRight = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
var prepend2 = dual(2, (self, head13) => [head13, ...self]);
var prependAll2 = dual(2, (self, that) => fromIterable2(that).concat(fromIterable2(self)));
var append2 = dual(2, (self, last8) => [...self, last8]);
var appendAll2 = dual(2, (self, that) => fromIterable2(self).concat(fromIterable2(that)));
var scan2 = dual(3, (self, b, f2) => {
  const out = [b];
  let i = 0;
  for (const a of self) {
    out[i + 1] = f2(out[i], a);
    i++;
  }
  return out;
});
var scanRight = dual(3, (self, b, f2) => {
  const input = fromIterable2(self);
  const out = new Array(input.length + 1);
  out[input.length] = b;
  for (let i = input.length - 1; i >= 0; i--) {
    out[i] = f2(out[i + 1], input[i]);
  }
  return out;
});
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var length = (self) => self.length;
var isOutOfBounds = (i, as18) => i < 0 || i >= as18.length;
var clamp2 = (i, as18) => Math.floor(Math.min(Math.max(0, i), as18.length));
var get2 = dual(2, (self, index3) => {
  const i = Math.floor(index3);
  return isOutOfBounds(i, self) ? none2() : some3(self[i]);
});
var unsafeGet = dual(2, (self, index3) => {
  const i = Math.floor(index3);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var unprepend = (self) => [headNonEmpty(self), tailNonEmpty(self)];
var unappend = (self) => [initNonEmpty(self), lastNonEmpty(self)];
var head2 = get2(0);
var headNonEmpty = unsafeGet(0);
var last = (self) => isNonEmptyReadonlyArray(self) ? some3(lastNonEmpty(self)) : none2();
var lastNonEmpty = (self) => self[self.length - 1];
var tail = (self) => {
  const input = fromIterable2(self);
  return isNonEmptyReadonlyArray(input) ? some3(tailNonEmpty(input)) : none2();
};
var tailNonEmpty = (self) => self.slice(1);
var init = (self) => {
  const input = fromIterable2(self);
  return isNonEmptyReadonlyArray(input) ? some3(initNonEmpty(input)) : none2();
};
var initNonEmpty = (self) => self.slice(0, -1);
var take2 = dual(2, (self, n) => {
  const input = fromIterable2(self);
  return input.slice(0, clamp2(n, input));
});
var takeRight = dual(2, (self, n) => {
  const input = fromIterable2(self);
  const i = clamp2(n, input);
  return i === 0 ? [] : input.slice(-i);
});
var takeWhile2 = dual(2, (self, predicate) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    out.push(a);
    i++;
  }
  return out;
});
var spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop2 = dual(2, (self, n) => {
  const input = fromIterable2(self);
  return input.slice(clamp2(n, input), input.length);
});
var dropRight = dual(2, (self, n) => {
  const input = fromIterable2(self);
  return input.slice(0, input.length - clamp2(n, input));
});
var dropWhile = dual(2, (self, predicate) => fromIterable2(self).slice(spanIndex(self, predicate)));
var findFirstIndex = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return some3(i);
    }
    i++;
  }
  return none2();
});
var findLastIndex = dual(2, (self, predicate) => {
  const input = fromIterable2(self);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return some3(i);
    }
  }
  return none2();
});
var findFirst3 = findFirst;
var findLast2 = dual(2, (self, f2) => {
  const input = fromIterable2(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f2(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var countBy2 = dual(2, (self, f2) => {
  let count9 = 0;
  const as18 = fromIterable2(self);
  for (let i = 0; i < as18.length; i++) {
    const a = as18[i];
    if (f2(a, i)) {
      count9++;
    }
  }
  return count9;
});
var insertAt = dual(3, (self, i, b) => {
  const out = Array.from(self);
  if (i < 0 || i > out.length) {
    return none2();
  }
  out.splice(i, 0, b);
  return some3(out);
});
var replace2 = dual(3, (self, i, b) => modify2(self, i, () => b));
var replaceOption2 = dual(3, (self, i, b) => modifyOption2(self, i, () => b));
var modify2 = dual(3, (self, i, f2) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  const b = f2(out[i]);
  out[i] = b;
  return out;
});
var modifyOption2 = dual(3, (self, i, f2) => {
  const arr = fromIterable2(self);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self) ? self.slice() : arr;
  const b = f2(arr[i]);
  out[i] = b;
  return some3(out);
});
var remove2 = dual(2, (self, i) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
var removeOption = dual(2, (self, i) => {
  const arr = fromIterable2(self);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self) ? self.slice() : arr;
  out.splice(i, 1);
  return some3(out);
});
var reverse2 = (self) => Array.from(self).reverse();
var sort = dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var sortWith = dual(3, (self, f2, order) => Array.from(self).map((a) => [a, f2(a)]).sort(([, a], [, b]) => order(a, b)).map(([_]) => _));
var sortBy = (...orders) => {
  const sortByAll = sort(combineAll2(orders));
  return (self) => {
    const input = fromIterable2(self);
    if (isNonEmptyReadonlyArray(input)) {
      return sortByAll(input);
    }
    return [];
  };
};
var zip2 = dual(2, (self, that) => zipWith4(self, that, make3));
var zipWith4 = dual(3, (self, that, f2) => {
  const as18 = fromIterable2(self);
  const bs = fromIterable2(that);
  if (isNonEmptyReadonlyArray(as18) && isNonEmptyReadonlyArray(bs)) {
    const out = [f2(headNonEmpty(as18), headNonEmpty(bs))];
    const len = Math.min(as18.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f2(as18[i], bs[i]);
    }
    return out;
  }
  return [];
});
var unzip = (self) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1; i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
};
var intersperse2 = dual(2, (self, middle) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const tail5 = tailNonEmpty(input);
    for (let i = 0; i < tail5.length; i++) {
      if (i < tail5.length) {
        out.push(middle);
      }
      out.push(tail5[i]);
    }
    return out;
  }
  return [];
});
var modifyNonEmptyHead = dual(2, (self, f2) => [f2(headNonEmpty(self)), ...tailNonEmpty(self)]);
var setNonEmptyHead = dual(2, (self, b) => modifyNonEmptyHead(self, () => b));
var modifyNonEmptyLast = dual(2, (self, f2) => append2(initNonEmpty(self), f2(lastNonEmpty(self))));
var setNonEmptyLast = dual(2, (self, b) => modifyNonEmptyLast(self, () => b));
var rotate = dual(2, (self, n) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const len = input.length;
    const m = Math.round(n) % len;
    if (isOutOfBounds(Math.abs(m), input) || m === 0) {
      return copy(input);
    }
    if (m < 0) {
      const [f2, s] = splitNonEmptyAt(input, -m);
      return appendAll2(s, f2);
    } else {
      return rotate(self, m - len);
    }
  }
  return [];
});
var containsWith3 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence3 = equivalence();
var contains3 = containsWith3(_equivalence3);
var chop = dual(2, (self, f2) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const [b, rest] = f2(input);
    const out = [b];
    let next6 = rest;
    while (isNonEmptyArray(next6)) {
      const [b3, rest2] = f2(next6);
      out.push(b3);
      next6 = rest2;
    }
    return out;
  }
  return [];
});
var splitAt = dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend2(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var split = dual(2, (self, n) => {
  const input = fromIterable2(self);
  return chunksOf2(input, Math.ceil(input.length / Math.floor(n)));
});
var splitWhere = dual(2, (self, predicate) => span(self, (a, i) => !predicate(a, i)));
var copy = (self) => self.slice();
var pad2 = dual(3, (self, n, fill) => {
  if (self.length >= n) {
    return take2(self, n);
  }
  return appendAll2(self, makeBy2(n - self.length, () => fill));
});
var chunksOf2 = dual(2, (self, n) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
});
var window2 = dual(2, (self, n) => {
  const input = fromIterable2(self);
  if (n > 0 && isNonEmptyReadonlyArray(input)) {
    return Array.from({
      length: input.length - (n - 1)
    }, (_, index3) => input.slice(index3, index3 + n));
  }
  return [];
});
var groupWith2 = dual(2, (self, isEquivalent) => chop(self, (as18) => {
  const h2 = headNonEmpty(as18);
  const out = [h2];
  let i = 1;
  for (; i < as18.length; i++) {
    const a = as18[i];
    if (isEquivalent(a, h2)) {
      out.push(a);
    } else {
      break;
    }
  }
  return [out, as18.slice(i)];
}));
var group2 = groupWith2(equivalence());
var groupBy2 = dual(2, (self, f2) => {
  const out = {};
  for (const a of self) {
    const k = f2(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
var unionWith = dual(3, (self, that, isEquivalent) => {
  const a = fromIterable2(self);
  const b = fromIterable2(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe3 = dedupeWith(isEquivalent);
      return dedupe3(appendAll2(a, b));
    }
    return a;
  }
  return b;
});
var union2 = dual(2, (self, that) => unionWith(self, that, _equivalence3));
var intersectionWith = (isEquivalent) => {
  const has19 = containsWith3(isEquivalent);
  return dual(2, (self, that) => fromIterable2(self).filter((a) => has19(that, a)));
};
var intersection2 = intersectionWith(_equivalence3);
var differenceWith = (isEquivalent) => {
  const has19 = containsWith3(isEquivalent);
  return dual(2, (self, that) => fromIterable2(self).filter((a) => !has19(that, a)));
};
var difference2 = differenceWith(_equivalence3);
var empty4 = () => [];
var of2 = (a) => [a];
var map6 = dual(2, (self, f2) => self.map(f2));
var flatMap4 = dual(2, (self, f2) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f2(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten3 = flatMap4(identity);
var filterMap4 = dual(2, (self, f2) => {
  const as18 = fromIterable2(self);
  const out = [];
  for (let i = 0; i < as18.length; i++) {
    const o = f2(as18[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile2 = dual(2, (self, f2) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    const b = f2(a, i);
    if (isSome2(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap3 = dual(2, (self, f2) => {
  const left3 = [];
  const right3 = [];
  const as18 = fromIterable2(self);
  for (let i = 0; i < as18.length; i++) {
    const e = f2(as18[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes3 = filterMap4(identity);
var getLefts3 = (self) => {
  const out = [];
  for (const a of self) {
    if (isLeft2(a)) {
      out.push(a.left);
    }
  }
  return out;
};
var getRights3 = (self) => {
  const out = [];
  for (const a of self) {
    if (isRight2(a)) {
      out.push(a.right);
    }
  }
  return out;
};
var filter4 = dual(2, (self, predicate) => {
  const as18 = fromIterable2(self);
  const out = [];
  for (let i = 0; i < as18.length; i++) {
    if (predicate(as18[i], i)) {
      out.push(as18[i]);
    }
  }
  return out;
});
var partition2 = dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  const as18 = fromIterable2(self);
  for (let i = 0; i < as18.length; i++) {
    if (predicate(as18[i], i)) {
      right3.push(as18[i]);
    } else {
      left3.push(as18[i]);
    }
  }
  return [left3, right3];
});
var separate2 = partitionMap3(identity);
var reduce3 = dual(3, (self, b, f2) => fromIterable2(self).reduce((b3, a, i) => f2(b3, a, i), b));
var reduceRight = dual(3, (self, b, f2) => fromIterable2(self).reduceRight((b3, a, i) => f2(b3, a, i), b));
var liftPredicate3 = (predicate) => (b) => predicate(b) ? [b] : [];
var liftOption = (f2) => (...a) => fromOption3(f2(...a));
var fromNullable3 = (a) => a == null ? empty4() : [a];
var liftNullable2 = (f2) => (...a) => fromNullable3(f2(...a));
var flatMapNullable3 = dual(2, (self, f2) => flatMap4(self, (a) => fromNullable3(f2(a))));
var liftEither = (f2) => (...a) => {
  const e = f2(...a);
  return isLeft2(e) ? [] : [e.right];
};
var every3 = dual(2, (self, refinement) => self.every(refinement));
var some6 = dual(2, (self, predicate) => self.some(predicate));
var extend = dual(2, (self, f2) => self.map((_, i, as18) => f2(as18.slice(i))));
var min2 = dual(2, (self, O) => self.reduce(min(O)));
var max2 = dual(2, (self, O) => self.reduce(max(O)));
var unfold2 = (b, f2) => {
  const out = [];
  let next6 = b;
  let o;
  while (isSome2(o = f2(next6))) {
    const [a, b3] = o.value;
    out.push(a);
    next6 = b3;
  }
  return out;
};
var getOrder3 = array3;
var getEquivalence5 = array;
var forEach2 = dual(2, (self, f2) => fromIterable2(self).forEach((a, i) => f2(a, i)));
var dedupeWith = dual(2, (self, isEquivalent) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var dedupeAdjacentWith2 = dual(2, (self, isEquivalent) => {
  const out = [];
  let lastA = none2();
  for (const a of self) {
    if (isNone2(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = some3(a);
    }
  }
  return out;
});
var dedupeAdjacent2 = dedupeAdjacentWith2(equivalence());
var join = dual(2, (self, sep) => fromIterable2(self).join(sep));
var mapAccum = dual(3, (self, s, f2) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self) {
    const r = f2(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});
var cartesianWith2 = dual(3, (self, that, f2) => flatMap4(self, (a) => map6(that, (b) => f2(a, b))));
var cartesian2 = dual(2, (self, that) => cartesianWith2(self, that, (a, b) => [a, b]));
var Do3 = of2({});
var bind4 = bind(map6, flatMap4);
var bindTo4 = bindTo(map6);
var let_4 = let_(map6);

// node_modules/effect/dist/esm/FastCheck.js
var FastCheck_exports = {};
__export(FastCheck_exports, {
  Arbitrary: () => Arbitrary,
  ExecutionStatus: () => ExecutionStatus,
  PreconditionFailure: () => PreconditionFailure,
  Random: () => Random,
  Stream: () => Stream,
  Value: () => Value,
  VerbosityLevel: () => VerbosityLevel,
  __commitHash: () => __commitHash2,
  __type: () => __type2,
  __version: () => __version2,
  anything: () => anything,
  array: () => array4,
  ascii: () => ascii,
  asciiString: () => asciiString,
  assert: () => assert,
  asyncDefaultReportMessage: () => asyncDefaultReportMessage,
  asyncModelRun: () => asyncModelRun,
  asyncProperty: () => asyncProperty,
  asyncStringify: () => asyncStringify,
  asyncToStringMethod: () => asyncToStringMethod,
  base64: () => base64,
  base64String: () => base64String,
  bigInt: () => bigInt,
  bigInt64Array: () => bigInt64Array,
  bigIntN: () => bigIntN,
  bigUint: () => bigUint,
  bigUint64Array: () => bigUint64Array,
  bigUintN: () => bigUintN,
  boolean: () => boolean3,
  char: () => char,
  char16bits: () => char16bits,
  check: () => check,
  clone: () => clone,
  cloneIfNeeded: () => cloneIfNeeded,
  cloneMethod: () => cloneMethod,
  commands: () => commands,
  compareBooleanFunc: () => compareBooleanFunc,
  compareFunc: () => compareFunc,
  configureGlobal: () => configureGlobal,
  constant: () => constant2,
  constantFrom: () => constantFrom,
  context: () => context,
  createDepthIdentifier: () => createDepthIdentifier,
  date: () => date,
  defaultReportMessage: () => defaultReportMessage,
  dictionary: () => dictionary,
  domain: () => domain,
  double: () => double,
  emailAddress: () => emailAddress,
  falsy: () => falsy,
  float: () => float,
  float32Array: () => float32Array,
  float64Array: () => float64Array,
  fullUnicode: () => fullUnicode,
  fullUnicodeString: () => fullUnicodeString,
  func: () => func,
  gen: () => gen3,
  getDepthContextFor: () => getDepthContextFor,
  hasAsyncToStringMethod: () => hasAsyncToStringMethod,
  hasCloneMethod: () => hasCloneMethod,
  hasToStringMethod: () => hasToStringMethod,
  hash: () => hash2,
  hexa: () => hexa,
  hexaString: () => hexaString,
  infiniteStream: () => infiniteStream,
  int16Array: () => int16Array,
  int32Array: () => int32Array,
  int8Array: () => int8Array,
  integer: () => integer,
  ipV4: () => ipV4,
  ipV4Extended: () => ipV4Extended,
  ipV6: () => ipV6,
  json: () => json,
  jsonValue: () => jsonValue,
  letrec: () => letrec,
  limitShrink: () => limitShrink,
  lorem: () => lorem,
  mapToConstant: () => mapToConstant,
  maxSafeInteger: () => maxSafeInteger,
  maxSafeNat: () => maxSafeNat,
  memo: () => memo,
  mixedCase: () => mixedCase,
  modelRun: () => modelRun,
  nat: () => nat,
  noBias: () => noBias,
  noShrink: () => noShrink,
  object: () => object,
  oneof: () => oneof,
  option: () => option,
  pre: () => pre,
  property: () => property,
  readConfigureGlobal: () => readConfigureGlobal,
  record: () => record,
  resetConfigureGlobal: () => resetConfigureGlobal,
  sample: () => sample,
  scheduledModelRun: () => scheduledModelRun,
  scheduler: () => scheduler,
  schedulerFor: () => schedulerFor,
  shuffledSubarray: () => shuffledSubarray,
  sparseArray: () => sparseArray,
  statistics: () => statistics,
  stream: () => stream,
  string: () => string4,
  string16bits: () => string16bits,
  stringMatching: () => stringMatching,
  stringOf: () => stringOf,
  stringify: () => stringify3,
  subarray: () => subarray,
  toStringMethod: () => toStringMethod,
  tuple: () => tuple4,
  uint16Array: () => uint16Array,
  uint32Array: () => uint32Array,
  uint8Array: () => uint8Array,
  uint8ClampedArray: () => uint8ClampedArray,
  ulid: () => ulid,
  unicode: () => unicode,
  unicodeJson: () => unicodeJson,
  unicodeJsonValue: () => unicodeJsonValue,
  unicodeString: () => unicodeString,
  uniqueArray: () => uniqueArray,
  uuid: () => uuid,
  uuidV: () => uuidV,
  webAuthority: () => webAuthority,
  webFragments: () => webFragments,
  webPath: () => webPath,
  webQueryParameters: () => webQueryParameters,
  webSegment: () => webSegment,
  webUrl: () => webUrl
});

// node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js
var PreconditionFailure = class _PreconditionFailure extends Error {
  constructor(interruptExecution = false) {
    super();
    this.interruptExecution = interruptExecution;
    this.footprint = _PreconditionFailure.SharedFootPrint;
  }
  static isFailure(err2) {
    return err2 != null && err2.footprint === _PreconditionFailure.SharedFootPrint;
  }
};
PreconditionFailure.SharedFootPrint = Symbol.for("fast-check/PreconditionFailure");

// node_modules/fast-check/lib/esm/check/precondition/Pre.js
function pre(expectTruthy) {
  if (!expectTruthy) {
    throw new PreconditionFailure();
  }
}

// node_modules/fast-check/lib/esm/stream/StreamHelpers.js
var Nil = class {
  [Symbol.iterator]() {
    return this;
  }
  next(value10) {
    return { value: value10, done: true };
  }
};
Nil.nil = new Nil();
function nilHelper() {
  return Nil.nil;
}
function* mapHelper(g, f2) {
  for (const v of g) {
    yield f2(v);
  }
}
function* flatMapHelper(g, f2) {
  for (const v of g) {
    yield* f2(v);
  }
}
function* filterHelper(g, f2) {
  for (const v of g) {
    if (f2(v)) {
      yield v;
    }
  }
}
function* takeNHelper(g, n) {
  for (let i = 0; i < n; ++i) {
    const cur = g.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
function* takeWhileHelper(g, f2) {
  let cur = g.next();
  while (!cur.done && f2(cur.value)) {
    yield cur.value;
    cur = g.next();
  }
}
function* joinHelper(g, others) {
  for (let cur = g.next(); !cur.done; cur = g.next()) {
    yield cur.value;
  }
  for (const s of others) {
    for (let cur = s.next(); !cur.done; cur = s.next()) {
      yield cur.value;
    }
  }
}

// node_modules/fast-check/lib/esm/stream/Stream.js
var safeSymbolIterator = Symbol.iterator;
var Stream = class _Stream {
  static nil() {
    return new _Stream(nilHelper());
  }
  static of(...elements) {
    return new _Stream(elements[safeSymbolIterator]());
  }
  constructor(g) {
    this.g = g;
  }
  next() {
    return this.g.next();
  }
  [Symbol.iterator]() {
    return this.g;
  }
  map(f2) {
    return new _Stream(mapHelper(this.g, f2));
  }
  flatMap(f2) {
    return new _Stream(flatMapHelper(this.g, f2));
  }
  dropWhile(f2) {
    let foundEligible = false;
    function* helper(v) {
      if (foundEligible || !f2(v)) {
        foundEligible = true;
        yield v;
      }
    }
    return this.flatMap(helper);
  }
  drop(n) {
    if (n <= 0) {
      return this;
    }
    let idx = 0;
    function helper() {
      return idx++ < n;
    }
    return this.dropWhile(helper);
  }
  takeWhile(f2) {
    return new _Stream(takeWhileHelper(this.g, f2));
  }
  take(n) {
    return new _Stream(takeNHelper(this.g, n));
  }
  filter(f2) {
    return new _Stream(filterHelper(this.g, f2));
  }
  every(f2) {
    for (const v of this.g) {
      if (!f2(v)) {
        return false;
      }
    }
    return true;
  }
  has(f2) {
    for (const v of this.g) {
      if (f2(v)) {
        return [true, v];
      }
    }
    return [false, null];
  }
  join(...others) {
    return new _Stream(joinHelper(this.g, others));
  }
  getNthOrLast(nth) {
    let remaining = nth;
    let last8 = null;
    for (const v of this.g) {
      if (remaining-- === 0)
        return v;
      last8 = v;
    }
    return last8;
  }
};
function stream(g) {
  return new Stream(g);
}

// node_modules/fast-check/lib/esm/check/symbols.js
var cloneMethod = Symbol.for("fast-check/cloneMethod");
function hasCloneMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
function cloneIfNeeded(instance) {
  return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}

// node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
var safeObjectDefineProperty = Object.defineProperty;
var Value = class {
  constructor(value_, context15, customGetValue = void 0) {
    this.value_ = value_;
    this.context = context15;
    this.hasToBeCloned = customGetValue !== void 0 || hasCloneMethod(value_);
    this.readOnce = false;
    if (this.hasToBeCloned) {
      safeObjectDefineProperty(this, "value", { get: customGetValue !== void 0 ? customGetValue : this.getValue });
    } else {
      this.value = value_;
    }
  }
  getValue() {
    if (this.hasToBeCloned) {
      if (!this.readOnce) {
        this.readOnce = true;
        return this.value_;
      }
      return this.value_[cloneMethod]();
    }
    return this.value_;
  }
};

// node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign = Object.assign;
var Arbitrary = class {
  filter(refinement) {
    return new FilterArbitrary(this, refinement);
  }
  map(mapper, unmapper) {
    return new MapArbitrary(this, mapper, unmapper);
  }
  chain(chainer) {
    return new ChainArbitrary(this, chainer);
  }
  noShrink() {
    return new NoShrinkArbitrary(this);
  }
  noBias() {
    return new NoBiasArbitrary(this);
  }
};
var ChainArbitrary = class extends Arbitrary {
  constructor(arb, chainer) {
    super();
    this.arb = arb;
    this.chainer = chainer;
  }
  generate(mrng, biasFactor) {
    const clonedMrng = mrng.clone();
    const src = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  shrink(value10, context15) {
    if (this.isSafeContext(context15)) {
      return (!context15.stoppedForOriginal ? this.arb.shrink(context15.originalValue, context15.originalContext).map((v) => this.valueChainer(v, context15.clonedMrng.clone(), context15.clonedMrng, context15.originalBias)) : Stream.nil()).join(context15.chainedArbitrary.shrink(value10, context15.chainedContext).map((dst) => {
        const newContext = safeObjectAssign(safeObjectAssign({}, context15), {
          chainedContext: dst.context,
          stoppedForOriginal: true
        });
        return new Value(dst.value_, newContext);
      }));
    }
    return Stream.nil();
  }
  valueChainer(v, generateMrng, clonedMrng, biasFactor) {
    const chainedArbitrary = this.chainer(v.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context15 = {
      originalBias: biasFactor,
      originalValue: v.value_,
      originalContext: v.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng
    };
    return new Value(dst.value_, context15);
  }
  isSafeContext(context15) {
    return context15 != null && typeof context15 === "object" && "originalBias" in context15 && "originalValue" in context15 && "originalContext" in context15 && "stoppedForOriginal" in context15 && "chainedArbitrary" in context15 && "chainedContext" in context15 && "clonedMrng" in context15;
  }
};
var MapArbitrary = class extends Arbitrary {
  constructor(arb, mapper, unmapper) {
    super();
    this.arb = arb;
    this.mapper = mapper;
    this.unmapper = unmapper;
    this.bindValueMapper = (v) => this.valueMapper(v);
  }
  generate(mrng, biasFactor) {
    const g = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g);
  }
  canShrinkWithoutContext(value10) {
    if (this.unmapper !== void 0) {
      try {
        const unmapped = this.unmapper(value10);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value10, context15) {
    if (this.isSafeContext(context15)) {
      return this.arb.shrink(context15.originalValue, context15.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== void 0) {
      const unmapped = this.unmapper(value10);
      return this.arb.shrink(unmapped, void 0).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  mapperWithCloneIfNeeded(v) {
    const sourceValue = v.value;
    const mappedValue = this.mapper(sourceValue);
    if (v.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
      Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
    }
    return [mappedValue, sourceValue];
  }
  valueMapper(v) {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
    const context15 = { originalValue: sourceValue, originalContext: v.context };
    return new Value(mappedValue, context15);
  }
  isSafeContext(context15) {
    return context15 != null && typeof context15 === "object" && "originalValue" in context15 && "originalContext" in context15;
  }
};
var FilterArbitrary = class extends Arbitrary {
  constructor(arb, refinement) {
    super();
    this.arb = arb;
    this.refinement = refinement;
    this.bindRefinementOnValue = (v) => this.refinementOnValue(v);
  }
  generate(mrng, biasFactor) {
    while (true) {
      const g = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  canShrinkWithoutContext(value10) {
    return this.arb.canShrinkWithoutContext(value10) && this.refinement(value10);
  }
  shrink(value10, context15) {
    return this.arb.shrink(value10, context15).filter(this.bindRefinementOnValue);
  }
  refinementOnValue(v) {
    return this.refinement(v.value);
  }
};
var NoShrinkArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value10) {
    return this.arb.canShrinkWithoutContext(value10);
  }
  shrink(_value2, _context) {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
};
var NoBiasArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, _biasFactor) {
    return this.arb.generate(mrng, void 0);
  }
  canShrinkWithoutContext(value10) {
    return this.arb.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    return this.arb.shrink(value10, context15);
  }
  noBias() {
    return this;
  }
};
function isArbitrary(instance) {
  return typeof instance === "object" && instance !== null && "generate" in instance && "shrink" in instance && "canShrinkWithoutContext" in instance;
}
function assertIsArbitrary(instance) {
  if (!isArbitrary(instance)) {
    throw new Error("Unexpected value received: not an instance of Arbitrary");
  }
}

// node_modules/fast-check/lib/esm/utils/apply.js
var untouchedApply = Function.prototype.apply;
var ApplySymbol = Symbol("apply");
function safeExtractApply(f2) {
  try {
    return f2.apply;
  } catch (err2) {
    return void 0;
  }
}
function safeApplyHacky(f2, instance, args2) {
  const ff = f2;
  ff[ApplySymbol] = untouchedApply;
  const out = ff[ApplySymbol](instance, args2);
  delete ff[ApplySymbol];
  return out;
}
function safeApply(f2, instance, args2) {
  if (safeExtractApply(f2) === untouchedApply) {
    return f2.apply(instance, args2);
  }
  return safeApplyHacky(f2, instance, args2);
}

// node_modules/fast-check/lib/esm/utils/globals.js
var SArray = typeof Array !== "undefined" ? Array : void 0;
var SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
var SBigInt64Array = typeof BigInt64Array !== "undefined" ? BigInt64Array : void 0;
var SBigUint64Array = typeof BigUint64Array !== "undefined" ? BigUint64Array : void 0;
var SBoolean = typeof Boolean !== "undefined" ? Boolean : void 0;
var SDate = typeof Date !== "undefined" ? Date : void 0;
var SError = typeof Error !== "undefined" ? Error : void 0;
var SFloat32Array = typeof Float32Array !== "undefined" ? Float32Array : void 0;
var SFloat64Array = typeof Float64Array !== "undefined" ? Float64Array : void 0;
var SInt8Array = typeof Int8Array !== "undefined" ? Int8Array : void 0;
var SInt16Array = typeof Int16Array !== "undefined" ? Int16Array : void 0;
var SInt32Array = typeof Int32Array !== "undefined" ? Int32Array : void 0;
var SNumber = typeof Number !== "undefined" ? Number : void 0;
var SString = typeof String !== "undefined" ? String : void 0;
var SSet = typeof Set !== "undefined" ? Set : void 0;
var SUint8Array = typeof Uint8Array !== "undefined" ? Uint8Array : void 0;
var SUint8ClampedArray = typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : void 0;
var SUint16Array = typeof Uint16Array !== "undefined" ? Uint16Array : void 0;
var SUint32Array = typeof Uint32Array !== "undefined" ? Uint32Array : void 0;
var SencodeURIComponent = typeof encodeURIComponent !== "undefined" ? encodeURIComponent : void 0;
var SMap = Map;
var SSymbol = Symbol;
var untouchedForEach = Array.prototype.forEach;
var untouchedIndexOf = Array.prototype.indexOf;
var untouchedJoin = Array.prototype.join;
var untouchedMap = Array.prototype.map;
var untouchedFilter = Array.prototype.filter;
var untouchedPush = Array.prototype.push;
var untouchedPop = Array.prototype.pop;
var untouchedSplice = Array.prototype.splice;
var untouchedSlice = Array.prototype.slice;
var untouchedSort = Array.prototype.sort;
var untouchedEvery = Array.prototype.every;
function extractForEach(instance) {
  try {
    return instance.forEach;
  } catch (err2) {
    return void 0;
  }
}
function extractIndexOf(instance) {
  try {
    return instance.indexOf;
  } catch (err2) {
    return void 0;
  }
}
function extractJoin(instance) {
  try {
    return instance.join;
  } catch (err2) {
    return void 0;
  }
}
function extractMap(instance) {
  try {
    return instance.map;
  } catch (err2) {
    return void 0;
  }
}
function extractFilter(instance) {
  try {
    return instance.filter;
  } catch (err2) {
    return void 0;
  }
}
function extractPush(instance) {
  try {
    return instance.push;
  } catch (err2) {
    return void 0;
  }
}
function extractPop(instance) {
  try {
    return instance.pop;
  } catch (err2) {
    return void 0;
  }
}
function extractSplice(instance) {
  try {
    return instance.splice;
  } catch (err2) {
    return void 0;
  }
}
function extractSlice(instance) {
  try {
    return instance.slice;
  } catch (err2) {
    return void 0;
  }
}
function extractSort(instance) {
  try {
    return instance.sort;
  } catch (err2) {
    return void 0;
  }
}
function extractEvery(instance) {
  try {
    return instance.every;
  } catch (err2) {
    return void 0;
  }
}
function safeForEach(instance, fn2) {
  if (extractForEach(instance) === untouchedForEach) {
    return instance.forEach(fn2);
  }
  return safeApply(untouchedForEach, instance, [fn2]);
}
function safeIndexOf(instance, ...args2) {
  if (extractIndexOf(instance) === untouchedIndexOf) {
    return instance.indexOf(...args2);
  }
  return safeApply(untouchedIndexOf, instance, args2);
}
function safeJoin(instance, ...args2) {
  if (extractJoin(instance) === untouchedJoin) {
    return instance.join(...args2);
  }
  return safeApply(untouchedJoin, instance, args2);
}
function safeMap(instance, fn2) {
  if (extractMap(instance) === untouchedMap) {
    return instance.map(fn2);
  }
  return safeApply(untouchedMap, instance, [fn2]);
}
function safeFilter(instance, predicate) {
  if (extractFilter(instance) === untouchedFilter) {
    return instance.filter(predicate);
  }
  return safeApply(untouchedFilter, instance, [predicate]);
}
function safePush(instance, ...args2) {
  if (extractPush(instance) === untouchedPush) {
    return instance.push(...args2);
  }
  return safeApply(untouchedPush, instance, args2);
}
function safePop(instance) {
  if (extractPop(instance) === untouchedPop) {
    return instance.pop();
  }
  return safeApply(untouchedPop, instance, []);
}
function safeSplice(instance, ...args2) {
  if (extractSplice(instance) === untouchedSplice) {
    return instance.splice(...args2);
  }
  return safeApply(untouchedSplice, instance, args2);
}
function safeSlice(instance, ...args2) {
  if (extractSlice(instance) === untouchedSlice) {
    return instance.slice(...args2);
  }
  return safeApply(untouchedSlice, instance, args2);
}
function safeSort(instance, ...args2) {
  if (extractSort(instance) === untouchedSort) {
    return instance.sort(...args2);
  }
  return safeApply(untouchedSort, instance, args2);
}
function safeEvery(instance, ...args2) {
  if (extractEvery(instance) === untouchedEvery) {
    return instance.every(...args2);
  }
  return safeApply(untouchedEvery, instance, args2);
}
var untouchedGetTime = Date.prototype.getTime;
var untouchedToISOString = Date.prototype.toISOString;
function extractGetTime(instance) {
  try {
    return instance.getTime;
  } catch (err2) {
    return void 0;
  }
}
function extractToISOString(instance) {
  try {
    return instance.toISOString;
  } catch (err2) {
    return void 0;
  }
}
function safeGetTime(instance) {
  if (extractGetTime(instance) === untouchedGetTime) {
    return instance.getTime();
  }
  return safeApply(untouchedGetTime, instance, []);
}
function safeToISOString(instance) {
  if (extractToISOString(instance) === untouchedToISOString) {
    return instance.toISOString();
  }
  return safeApply(untouchedToISOString, instance, []);
}
var untouchedAdd = Set.prototype.add;
var untouchedHas = Set.prototype.has;
function extractAdd(instance) {
  try {
    return instance.add;
  } catch (err2) {
    return void 0;
  }
}
function extractHas(instance) {
  try {
    return instance.has;
  } catch (err2) {
    return void 0;
  }
}
function safeAdd(instance, value10) {
  if (extractAdd(instance) === untouchedAdd) {
    return instance.add(value10);
  }
  return safeApply(untouchedAdd, instance, [value10]);
}
function safeHas(instance, value10) {
  if (extractHas(instance) === untouchedHas) {
    return instance.has(value10);
  }
  return safeApply(untouchedHas, instance, [value10]);
}
var untouchedSet = WeakMap.prototype.set;
var untouchedGet = WeakMap.prototype.get;
function extractSet(instance) {
  try {
    return instance.set;
  } catch (err2) {
    return void 0;
  }
}
function extractGet(instance) {
  try {
    return instance.get;
  } catch (err2) {
    return void 0;
  }
}
function safeSet(instance, key, value10) {
  if (extractSet(instance) === untouchedSet) {
    return instance.set(key, value10);
  }
  return safeApply(untouchedSet, instance, [key, value10]);
}
function safeGet(instance, key) {
  if (extractGet(instance) === untouchedGet) {
    return instance.get(key);
  }
  return safeApply(untouchedGet, instance, [key]);
}
var untouchedMapSet = Map.prototype.set;
var untouchedMapGet = Map.prototype.get;
function extractMapSet(instance) {
  try {
    return instance.set;
  } catch (err2) {
    return void 0;
  }
}
function extractMapGet(instance) {
  try {
    return instance.get;
  } catch (err2) {
    return void 0;
  }
}
function safeMapSet(instance, key, value10) {
  if (extractMapSet(instance) === untouchedMapSet) {
    return instance.set(key, value10);
  }
  return safeApply(untouchedMapSet, instance, [key, value10]);
}
function safeMapGet(instance, key) {
  if (extractMapGet(instance) === untouchedMapGet) {
    return instance.get(key);
  }
  return safeApply(untouchedMapGet, instance, [key]);
}
var untouchedSplit = String.prototype.split;
var untouchedStartsWith = String.prototype.startsWith;
var untouchedEndsWith = String.prototype.endsWith;
var untouchedSubstring = String.prototype.substring;
var untouchedToLowerCase = String.prototype.toLowerCase;
var untouchedToUpperCase = String.prototype.toUpperCase;
var untouchedPadStart = String.prototype.padStart;
var untouchedCharCodeAt = String.prototype.charCodeAt;
var untouchedNormalize = String.prototype.normalize;
var untouchedReplace = String.prototype.replace;
function extractSplit(instance) {
  try {
    return instance.split;
  } catch (err2) {
    return void 0;
  }
}
function extractStartsWith(instance) {
  try {
    return instance.startsWith;
  } catch (err2) {
    return void 0;
  }
}
function extractEndsWith(instance) {
  try {
    return instance.endsWith;
  } catch (err2) {
    return void 0;
  }
}
function extractSubstring(instance) {
  try {
    return instance.substring;
  } catch (err2) {
    return void 0;
  }
}
function extractToLowerCase(instance) {
  try {
    return instance.toLowerCase;
  } catch (err2) {
    return void 0;
  }
}
function extractToUpperCase(instance) {
  try {
    return instance.toUpperCase;
  } catch (err2) {
    return void 0;
  }
}
function extractPadStart(instance) {
  try {
    return instance.padStart;
  } catch (err2) {
    return void 0;
  }
}
function extractCharCodeAt(instance) {
  try {
    return instance.charCodeAt;
  } catch (err2) {
    return void 0;
  }
}
function extractNormalize(instance) {
  try {
    return instance.normalize;
  } catch (err2) {
    return void 0;
  }
}
function extractReplace(instance) {
  try {
    return instance.replace;
  } catch (err2) {
    return void 0;
  }
}
function safeSplit(instance, ...args2) {
  if (extractSplit(instance) === untouchedSplit) {
    return instance.split(...args2);
  }
  return safeApply(untouchedSplit, instance, args2);
}
function safeStartsWith(instance, ...args2) {
  if (extractStartsWith(instance) === untouchedStartsWith) {
    return instance.startsWith(...args2);
  }
  return safeApply(untouchedStartsWith, instance, args2);
}
function safeEndsWith(instance, ...args2) {
  if (extractEndsWith(instance) === untouchedEndsWith) {
    return instance.endsWith(...args2);
  }
  return safeApply(untouchedEndsWith, instance, args2);
}
function safeSubstring(instance, ...args2) {
  if (extractSubstring(instance) === untouchedSubstring) {
    return instance.substring(...args2);
  }
  return safeApply(untouchedSubstring, instance, args2);
}
function safeToLowerCase(instance) {
  if (extractToLowerCase(instance) === untouchedToLowerCase) {
    return instance.toLowerCase();
  }
  return safeApply(untouchedToLowerCase, instance, []);
}
function safeToUpperCase(instance) {
  if (extractToUpperCase(instance) === untouchedToUpperCase) {
    return instance.toUpperCase();
  }
  return safeApply(untouchedToUpperCase, instance, []);
}
function safePadStart(instance, ...args2) {
  if (extractPadStart(instance) === untouchedPadStart) {
    return instance.padStart(...args2);
  }
  return safeApply(untouchedPadStart, instance, args2);
}
function safeCharCodeAt(instance, index3) {
  if (extractCharCodeAt(instance) === untouchedCharCodeAt) {
    return instance.charCodeAt(index3);
  }
  return safeApply(untouchedCharCodeAt, instance, [index3]);
}
function safeNormalize(instance, form) {
  if (extractNormalize(instance) === untouchedNormalize) {
    return instance.normalize(form);
  }
  return safeApply(untouchedNormalize, instance, [form]);
}
function safeReplace(instance, pattern2, replacement) {
  if (extractReplace(instance) === untouchedReplace) {
    return instance.replace(pattern2, replacement);
  }
  return safeApply(untouchedReplace, instance, [pattern2, replacement]);
}
var untouchedNumberToString = Number.prototype.toString;
function extractNumberToString(instance) {
  try {
    return instance.toString;
  } catch (err2) {
    return void 0;
  }
}
function safeNumberToString(instance, ...args2) {
  if (extractNumberToString(instance) === untouchedNumberToString) {
    return instance.toString(...args2);
  }
  return safeApply(untouchedNumberToString, instance, args2);
}
var untouchedHasOwnProperty = Object.prototype.hasOwnProperty;
var untouchedToString = Object.prototype.toString;
function safeHasOwnProperty(instance, v) {
  return safeApply(untouchedHasOwnProperty, instance, [v]);
}
function safeToString(instance) {
  return safeApply(untouchedToString, instance, []);
}

// node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
var LazyIterableIterator = class {
  constructor(producer) {
    this.producer = producer;
  }
  [Symbol.iterator]() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it;
  }
  next() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it.next();
  }
};
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
var safeArrayIsArray = Array.isArray;
var safeObjectDefineProperty2 = Object.defineProperty;
function tupleMakeItCloneable(vs, values15) {
  return safeObjectDefineProperty2(vs, cloneMethod, {
    value: () => {
      const cloned = [];
      for (let idx = 0; idx !== values15.length; ++idx) {
        safePush(cloned, values15[idx].value);
      }
      tupleMakeItCloneable(cloned, values15);
      return cloned;
    }
  });
}
function tupleWrapper(values15) {
  let cloneable = false;
  const vs = [];
  const ctxs = [];
  for (let idx = 0; idx !== values15.length; ++idx) {
    const v = values15[idx];
    cloneable = cloneable || v.hasToBeCloned;
    safePush(vs, v.value);
    safePush(ctxs, v.context);
  }
  if (cloneable) {
    tupleMakeItCloneable(vs, values15);
  }
  return new Value(vs, ctxs);
}
function tupleShrink(arbs, value10, context15) {
  const shrinks2 = [];
  const safeContext = safeArrayIsArray(context15) ? context15 : [];
  for (let idx = 0; idx !== arbs.length; ++idx) {
    safePush(shrinks2, makeLazy(() => arbs[idx].shrink(value10[idx], safeContext[idx]).map((v) => {
      const nextValues = safeMap(value10, (v2, idx2) => new Value(cloneIfNeeded(v2), safeContext[idx2]));
      return [...safeSlice(nextValues, 0, idx), v, ...safeSlice(nextValues, idx + 1)];
    }).map(tupleWrapper)));
  }
  return Stream.nil().join(...shrinks2);
}
var TupleArbitrary = class extends Arbitrary {
  constructor(arbs) {
    super();
    this.arbs = arbs;
    for (let idx = 0; idx !== arbs.length; ++idx) {
      const arb = arbs[idx];
      if (arb == null || arb.generate == null)
        throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);
    }
  }
  generate(mrng, biasFactor) {
    const mapped = [];
    for (let idx = 0; idx !== this.arbs.length; ++idx) {
      safePush(mapped, this.arbs[idx].generate(mrng, biasFactor));
    }
    return tupleWrapper(mapped);
  }
  canShrinkWithoutContext(value10) {
    if (!safeArrayIsArray(value10) || value10.length !== this.arbs.length) {
      return false;
    }
    for (let index3 = 0; index3 !== this.arbs.length; ++index3) {
      if (!this.arbs[index3].canShrinkWithoutContext(value10[index3])) {
        return false;
      }
    }
    return true;
  }
  shrink(value10, context15) {
    return tupleShrink(this.arbs, value10, context15);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/tuple.js
function tuple4(...arbs) {
  return new TupleArbitrary(arbs);
}

// node_modules/fast-check/lib/esm/check/property/IRawProperty.js
var safeMathLog = Math.log;
function runIdToFrequency(runId) {
  return 2 + ~~(safeMathLog(runId + 1) * 0.4342944819032518);
}

// node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
var globalParameters = {};
function configureGlobal(parameters) {
  globalParameters = parameters;
}
function readConfigureGlobal() {
  return globalParameters;
}
function resetConfigureGlobal() {
  globalParameters = {};
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js
var UndefinedContextPlaceholder = Symbol("UndefinedContextPlaceholder");
function noUndefinedAsContext(value10) {
  if (value10.context !== void 0) {
    return value10;
  }
  if (value10.hasToBeCloned) {
    return new Value(value10.value_, UndefinedContextPlaceholder, () => value10.value);
  }
  return new Value(value10.value_, UndefinedContextPlaceholder);
}

// node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
var AsyncProperty = class _AsyncProperty {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0 && beforeEach !== void 0) {
      throw SError(`Global "asyncBeforeEach" and "beforeEach" parameters can't be set at the same time when running async properties`);
    }
    if (asyncAfterEach !== void 0 && afterEach !== void 0) {
      throw SError(`Global "asyncAfterEach" and "afterEach" parameters can't be set at the same time when running async properties`);
    }
    this.beforeEachHook = asyncBeforeEach || beforeEach || _AsyncProperty.dummyHook;
    this.afterEachHook = asyncAfterEach || afterEach || _AsyncProperty.dummyHook;
  }
  isAsync() {
    return true;
  }
  generate(mrng, runId) {
    const value10 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value10);
  }
  shrink(value10) {
    if (value10.context === void 0 && !this.arb.canShrinkWithoutContext(value10.value_)) {
      return Stream.nil();
    }
    const safeContext = value10.context !== UndefinedContextPlaceholder ? value10.context : void 0;
    return this.arb.shrink(value10.value_, safeContext).map(noUndefinedAsContext);
  }
  async runBeforeEach() {
    await this.beforeEachHook();
  }
  async runAfterEach() {
    await this.afterEachHook();
  }
  async run(v, dontRunHook) {
    if (!dontRunHook) {
      await this.beforeEachHook();
    }
    try {
      const output = await this.predicate(v);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err2) {
      if (PreconditionFailure.isFailure(err2))
        return err2;
      if (err2 instanceof SError && err2.stack) {
        return { error: err2, errorMessage: err2.stack };
      }
      return { error: err2, errorMessage: SString(err2) };
    } finally {
      if (!dontRunHook) {
        await this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
AsyncProperty.dummyHook = () => {
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/AlwaysShrinkableArbitrary.js
var AlwaysShrinkableArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    const value10 = this.arb.generate(mrng, biasFactor);
    return noUndefinedAsContext(value10);
  }
  canShrinkWithoutContext(value10) {
    return true;
  }
  shrink(value10, context15) {
    if (context15 === void 0 && !this.arb.canShrinkWithoutContext(value10)) {
      return Stream.nil();
    }
    const safeContext = context15 !== UndefinedContextPlaceholder ? context15 : void 0;
    return this.arb.shrink(value10, safeContext).map(noUndefinedAsContext);
  }
};

// node_modules/fast-check/lib/esm/check/property/AsyncProperty.js
function asyncProperty(...args2) {
  if (args2.length < 2) {
    throw new Error("asyncProperty expects at least two parameters");
  }
  const arbs = safeSlice(args2, 0, args2.length - 1);
  const p = args2[args2.length - 1];
  safeForEach(arbs, assertIsArbitrary);
  const mappedArbs = safeMap(arbs, (arb) => new AlwaysShrinkableArbitrary(arb));
  return new AsyncProperty(tuple4(...mappedArbs), (t) => p(...t));
}

// node_modules/fast-check/lib/esm/check/property/Property.generic.js
var Property = class _Property2 {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { beforeEach = _Property2.dummyHook, afterEach = _Property2.dummyHook, asyncBeforeEach, asyncAfterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0) {
      throw SError(`"asyncBeforeEach" can't be set when running synchronous properties`);
    }
    if (asyncAfterEach !== void 0) {
      throw SError(`"asyncAfterEach" can't be set when running synchronous properties`);
    }
    this.beforeEachHook = beforeEach;
    this.afterEachHook = afterEach;
  }
  isAsync() {
    return false;
  }
  generate(mrng, runId) {
    const value10 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value10);
  }
  shrink(value10) {
    if (value10.context === void 0 && !this.arb.canShrinkWithoutContext(value10.value_)) {
      return Stream.nil();
    }
    const safeContext = value10.context !== UndefinedContextPlaceholder ? value10.context : void 0;
    return this.arb.shrink(value10.value_, safeContext).map(noUndefinedAsContext);
  }
  runBeforeEach() {
    this.beforeEachHook();
  }
  runAfterEach() {
    this.afterEachHook();
  }
  run(v, dontRunHook) {
    if (!dontRunHook) {
      this.beforeEachHook();
    }
    try {
      const output = this.predicate(v);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err2) {
      if (PreconditionFailure.isFailure(err2))
        return err2;
      if (err2 instanceof SError && err2.stack) {
        return { error: err2, errorMessage: err2.stack };
      }
      return { error: err2, errorMessage: SString(err2) };
    } finally {
      if (!dontRunHook) {
        this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
Property.dummyHook = () => {
};

// node_modules/fast-check/lib/esm/check/property/Property.js
function property(...args2) {
  if (args2.length < 2) {
    throw new Error("property expects at least two parameters");
  }
  const arbs = safeSlice(args2, 0, args2.length - 1);
  const p = args2[args2.length - 1];
  safeForEach(arbs, assertIsArbitrary);
  const mappedArbs = safeMap(arbs, (arb) => new AlwaysShrinkableArbitrary(arb));
  return new Property(tuple4(...mappedArbs), (t) => p(...t));
}

// node_modules/pure-rand/lib/esm/pure-rand-default.js
var pure_rand_default_exports = {};
__export(pure_rand_default_exports, {
  __commitHash: () => __commitHash,
  __type: () => __type,
  __version: () => __version,
  congruential32: () => congruential32,
  generateN: () => generateN,
  mersenne: () => MersenneTwister_default,
  skipN: () => skipN,
  uniformArrayIntDistribution: () => uniformArrayIntDistribution,
  uniformBigIntDistribution: () => uniformBigIntDistribution,
  uniformIntDistribution: () => uniformIntDistribution,
  unsafeGenerateN: () => unsafeGenerateN,
  unsafeSkipN: () => unsafeSkipN,
  unsafeUniformArrayIntDistribution: () => unsafeUniformArrayIntDistribution,
  unsafeUniformBigIntDistribution: () => unsafeUniformBigIntDistribution,
  unsafeUniformIntDistribution: () => unsafeUniformIntDistribution,
  xoroshiro128plus: () => xoroshiro128plus,
  xorshift128plus: () => xorshift128plus
});

// node_modules/pure-rand/lib/esm/generator/RandomGenerator.js
function unsafeGenerateN(rng2, num) {
  var out = [];
  for (var idx = 0; idx != num; ++idx) {
    out.push(rng2.unsafeNext());
  }
  return out;
}
function generateN(rng2, num) {
  var nextRng = rng2.clone();
  var out = unsafeGenerateN(nextRng, num);
  return [out, nextRng];
}
function unsafeSkipN(rng2, num) {
  for (var idx = 0; idx != num; ++idx) {
    rng2.unsafeNext();
  }
}
function skipN(rng2, num) {
  var nextRng = rng2.clone();
  unsafeSkipN(nextRng, num);
  return nextRng;
}

// node_modules/pure-rand/lib/esm/generator/LinearCongruential.js
var MULTIPLIER = 214013;
var INCREMENT = 2531011;
var MASK = 4294967295;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function(seed) {
  return seed * MULTIPLIER + INCREMENT & MASK;
};
var computeValueFromNextSeed = function(nextseed) {
  return (nextseed & MASK_2) >> 16;
};
var LinearCongruential32 = function() {
  function LinearCongruential322(seed) {
    this.seed = seed;
  }
  LinearCongruential322.prototype.clone = function() {
    return new LinearCongruential322(this.seed);
  };
  LinearCongruential322.prototype.next = function() {
    var nextRng = new LinearCongruential322(this.seed);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  LinearCongruential322.prototype.unsafeNext = function() {
    var s1 = computeNextSeed(this.seed);
    var v1 = computeValueFromNextSeed(s1);
    var s2 = computeNextSeed(s1);
    var v2 = computeValueFromNextSeed(s2);
    this.seed = computeNextSeed(s2);
    var v32 = computeValueFromNextSeed(this.seed);
    var vnext = v32 + (v2 + (v1 << 15) << 15);
    return vnext | 0;
  };
  LinearCongruential322.prototype.getState = function() {
    return [this.seed];
  };
  return LinearCongruential322;
}();
function fromState(state) {
  var valid = state.length === 1;
  if (!valid) {
    throw new Error("The state must have been produced by a congruential32 RandomGenerator");
  }
  return new LinearCongruential32(state[0]);
}
var congruential32 = Object.assign(function(seed) {
  return new LinearCongruential32(seed);
}, { fromState });

// node_modules/pure-rand/lib/esm/generator/MersenneTwister.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error4) {
    e = { error: error4 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to3, from29, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l = from29.length, ar; i < l; i++) {
    if (ar || !(i in from29)) {
      if (!ar) ar = Array.prototype.slice.call(from29, 0, i);
      ar[i] = from29[i];
    }
  }
  return to3.concat(ar || Array.prototype.slice.call(from29));
};
var MersenneTwister = function() {
  function MersenneTwister2(states, index3) {
    this.states = states;
    this.index = index3;
  }
  MersenneTwister2.twist = function(prev) {
    var mt = prev.slice();
    for (var idx = 0; idx !== MersenneTwister2.N - MersenneTwister2.M; ++idx) {
      var y_1 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister2.A;
    }
    for (var idx = MersenneTwister2.N - MersenneTwister2.M; idx !== MersenneTwister2.N - 1; ++idx) {
      var y_2 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M - MersenneTwister2.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister2.A;
    }
    var y = (mt[MersenneTwister2.N - 1] & MersenneTwister2.MASK_UPPER) + (mt[0] & MersenneTwister2.MASK_LOWER);
    mt[MersenneTwister2.N - 1] = mt[MersenneTwister2.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister2.A;
    return mt;
  };
  MersenneTwister2.seeded = function(seed) {
    var out = Array(MersenneTwister2.N);
    out[0] = seed;
    for (var idx = 1; idx !== MersenneTwister2.N; ++idx) {
      var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
      out[idx] = Math.imul(MersenneTwister2.F, xored) + idx | 0;
    }
    return out;
  };
  MersenneTwister2.from = function(seed) {
    return new MersenneTwister2(MersenneTwister2.twist(MersenneTwister2.seeded(seed)), 0);
  };
  MersenneTwister2.prototype.clone = function() {
    return new MersenneTwister2(this.states, this.index);
  };
  MersenneTwister2.prototype.next = function() {
    var nextRng = new MersenneTwister2(this.states, this.index);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  MersenneTwister2.prototype.unsafeNext = function() {
    var y = this.states[this.index];
    y ^= this.states[this.index] >>> MersenneTwister2.U;
    y ^= y << MersenneTwister2.S & MersenneTwister2.B;
    y ^= y << MersenneTwister2.T & MersenneTwister2.C;
    y ^= y >>> MersenneTwister2.L;
    if (++this.index >= MersenneTwister2.N) {
      this.states = MersenneTwister2.twist(this.states);
      this.index = 0;
    }
    return y;
  };
  MersenneTwister2.prototype.getState = function() {
    return __spreadArray([this.index], __read(this.states), false);
  };
  MersenneTwister2.fromState = function(state) {
    var valid = state.length === MersenneTwister2.N + 1 && state[0] >= 0 && state[0] < MersenneTwister2.N;
    if (!valid) {
      throw new Error("The state must have been produced by a mersenne RandomGenerator");
    }
    return new MersenneTwister2(state.slice(1), state[0]);
  };
  MersenneTwister2.N = 624;
  MersenneTwister2.M = 397;
  MersenneTwister2.R = 31;
  MersenneTwister2.A = 2567483615;
  MersenneTwister2.F = 1812433253;
  MersenneTwister2.U = 11;
  MersenneTwister2.S = 7;
  MersenneTwister2.B = 2636928640;
  MersenneTwister2.T = 15;
  MersenneTwister2.C = 4022730752;
  MersenneTwister2.L = 18;
  MersenneTwister2.MASK_LOWER = Math.pow(2, MersenneTwister2.R) - 1;
  MersenneTwister2.MASK_UPPER = Math.pow(2, MersenneTwister2.R);
  return MersenneTwister2;
}();
function fromState2(state) {
  return MersenneTwister.fromState(state);
}
var MersenneTwister_default = Object.assign(function(seed) {
  return MersenneTwister.from(seed);
}, { fromState: fromState2 });

// node_modules/pure-rand/lib/esm/generator/XorShift.js
var XorShift128Plus = function() {
  function XorShift128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XorShift128Plus2.prototype.clone = function() {
    return new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XorShift128Plus2.prototype.next = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XorShift128Plus2.prototype.unsafeNext = function() {
    var a0 = this.s00 ^ this.s00 << 23;
    var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
    var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
    var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
    var out = this.s00 + this.s10 | 0;
    this.s01 = this.s11;
    this.s00 = this.s10;
    this.s11 = b1;
    this.s10 = b0;
    return out;
  };
  XorShift128Plus2.prototype.jump = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XorShift128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [1667051007, 2321340297, 1548169110, 304075285];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XorShift128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XorShift128Plus2;
}();
function fromState3(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xorshift128plus RandomGenerator");
  }
  return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
var xorshift128plus = Object.assign(function(seed) {
  return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState3 });

// node_modules/pure-rand/lib/esm/generator/XoroShiro.js
var XoroShiro128Plus = function() {
  function XoroShiro128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XoroShiro128Plus2.prototype.clone = function() {
    return new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XoroShiro128Plus2.prototype.next = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XoroShiro128Plus2.prototype.unsafeNext = function() {
    var out = this.s00 + this.s10 | 0;
    var a0 = this.s10 ^ this.s00;
    var a1 = this.s11 ^ this.s01;
    var s00 = this.s00;
    var s01 = this.s01;
    this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
    this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
    this.s10 = a1 << 5 ^ a0 >>> 27;
    this.s11 = a0 << 5 ^ a1 >>> 27;
    return out;
  };
  XoroShiro128Plus2.prototype.jump = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XoroShiro128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [3639956645, 3750757012, 1261568508, 386426335];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XoroShiro128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XoroShiro128Plus2;
}();
function fromState4(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
  }
  return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var xoroshiro128plus = Object.assign(function(seed) {
  return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState4 });

// node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js
function addArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var data = [];
  var reminder = 0;
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA + vB + reminder;
    data.push(current2 >>> 0);
    reminder = ~~(current2 / 4294967296);
  }
  if (reminder !== 0) {
    data.push(reminder);
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function addOneToPositiveArrayInt(arrayInt) {
  arrayInt.sign = 1;
  var data = arrayInt.data;
  for (var index3 = data.length - 1; index3 >= 0; --index3) {
    if (data[index3] === 4294967295) {
      data[index3] = 0;
    } else {
      data[index3] += 1;
      return arrayInt;
    }
  }
  data.unshift(1);
  return arrayInt;
}
function isStrictlySmaller(dataA, dataB) {
  var maxLength2 = Math.max(dataA.length, dataB.length);
  for (var index3 = 0; index3 < maxLength2; ++index3) {
    var indexA = index3 + dataA.length - maxLength2;
    var indexB = index3 + dataB.length - maxLength2;
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    if (vA < vB)
      return true;
    if (vA > vB)
      return false;
  }
  return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  if (isStrictlySmaller(dataA, dataB)) {
    var out = substractArrayIntToNew(arrayIntB, arrayIntA);
    out.sign = -out.sign;
    return out;
  }
  var data = [];
  var reminder = 0;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA - vB - reminder;
    data.push(current2 >>> 0);
    reminder = current2 < 0 ? 1 : 0;
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function trimArrayIntInplace(arrayInt) {
  var data = arrayInt.data;
  var firstNonZero = 0;
  for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) {
  }
  if (firstNonZero === data.length) {
    arrayInt.sign = 1;
    arrayInt.data = [0];
    return arrayInt;
  }
  data.splice(0, firstNonZero);
  return arrayInt;
}
function fromNumberToArrayInt64(out, n) {
  if (n < 0) {
    var posN = -n;
    out.sign = -1;
    out.data[0] = ~~(posN / 4294967296);
    out.data[1] = posN >>> 0;
  } else {
    out.sign = 1;
    out.data[0] = ~~(n / 4294967296);
    out.data[1] = n >>> 0;
  }
  return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
  var lowA = arrayIntA.data[1];
  var highA = arrayIntA.data[0];
  var signA = arrayIntA.sign;
  var lowB = arrayIntB.data[1];
  var highB = arrayIntB.data[0];
  var signB = arrayIntB.sign;
  out.sign = 1;
  if (signA === 1 && signB === -1) {
    var low_1 = lowA + lowB;
    var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
    out.data[0] = high >>> 0;
    out.data[1] = low_1 >>> 0;
    return out;
  }
  var lowFirst = lowA;
  var highFirst = highA;
  var lowSecond = lowB;
  var highSecond = highB;
  if (signA === -1) {
    lowFirst = lowB;
    highFirst = highB;
    lowSecond = lowA;
    highSecond = highA;
  }
  var reminderLow = 0;
  var low = lowFirst - lowSecond;
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  out.data[0] = highFirst - highSecond - reminderLow;
  out.data[1] = low;
  return out;
}

// node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
function unsafeUniformIntDistributionInternal(rangeSize, rng2) {
  var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
  var deltaV = rng2.unsafeNext() + 2147483648;
  while (deltaV >= MaxAllowed) {
    deltaV = rng2.unsafeNext() + 2147483648;
  }
  return deltaV % rangeSize;
}

// node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng2) {
  var rangeLength = rangeSize.length;
  while (true) {
    for (var index3 = 0; index3 !== rangeLength; ++index3) {
      var indexRangeSize = index3 === 0 ? rangeSize[0] + 1 : 4294967296;
      var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng2);
      out[index3] = g;
    }
    for (var index3 = 0; index3 !== rangeLength; ++index3) {
      var current2 = out[index3];
      var currentInRange = rangeSize[index3];
      if (current2 < currentInRange) {
        return out;
      } else if (current2 > currentInRange) {
        break;
      }
    }
  }
}

// node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
function unsafeUniformArrayIntDistribution(from29, to3, rng2) {
  var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to3, from29)));
  var emptyArrayIntData = rangeSize.data.slice(0);
  var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng2);
  return trimArrayIntInplace(addArrayIntToNew({ sign: 1, data: g }, from29));
}

// node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
function uniformArrayIntDistribution(from29, to3, rng2) {
  if (rng2 != null) {
    var nextRng = rng2.clone();
    return [unsafeUniformArrayIntDistribution(from29, to3, nextRng), nextRng];
  }
  return function(rng3) {
    var nextRng2 = rng3.clone();
    return [unsafeUniformArrayIntDistribution(from29, to3, nextRng2), nextRng2];
  };
}

// node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
var SBigInt2 = typeof BigInt !== "undefined" ? BigInt : void 0;
function unsafeUniformBigIntDistribution(from29, to3, rng2) {
  var diff13 = to3 - from29 + SBigInt2(1);
  var MinRng = SBigInt2(-2147483648);
  var NumValues = SBigInt2(4294967296);
  var FinalNumValues = NumValues;
  var NumIterations = 1;
  while (FinalNumValues < diff13) {
    FinalNumValues *= NumValues;
    ++NumIterations;
  }
  var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff13;
  while (true) {
    var value10 = SBigInt2(0);
    for (var num = 0; num !== NumIterations; ++num) {
      var out = rng2.unsafeNext();
      value10 = NumValues * value10 + (SBigInt2(out) - MinRng);
    }
    if (value10 < MaxAcceptedRandom) {
      var inDiff = value10 % diff13;
      return inDiff + from29;
    }
  }
}

// node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
function uniformBigIntDistribution(from29, to3, rng2) {
  if (rng2 != null) {
    var nextRng = rng2.clone();
    return [unsafeUniformBigIntDistribution(from29, to3, nextRng), nextRng];
  }
  return function(rng3) {
    var nextRng2 = rng3.clone();
    return [unsafeUniformBigIntDistribution(from29, to3, nextRng2), nextRng2];
  };
}

// node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from29, to3, rangeSize, rng2) {
  var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to3), fromNumberToArrayInt64(sharedB, from29));
  if (rangeSizeArrayIntValue.data[1] === 4294967295) {
    rangeSizeArrayIntValue.data[0] += 1;
    rangeSizeArrayIntValue.data[1] = 0;
  } else {
    rangeSizeArrayIntValue.data[1] += 1;
  }
  unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng2);
  return sharedData[0] * 4294967296 + sharedData[1] + from29;
}
function unsafeUniformIntDistribution(from29, to3, rng2) {
  var rangeSize = to3 - from29;
  if (rangeSize <= 4294967295) {
    var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng2);
    return g + from29;
  }
  return uniformLargeIntInternal(from29, to3, rangeSize, rng2);
}

// node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
function uniformIntDistribution(from29, to3, rng2) {
  if (rng2 != null) {
    var nextRng = rng2.clone();
    return [unsafeUniformIntDistribution(from29, to3, nextRng), nextRng];
  }
  return function(rng3) {
    var nextRng2 = rng3.clone();
    return [unsafeUniformIntDistribution(from29, to3, nextRng2), nextRng2];
  };
}

// node_modules/pure-rand/lib/esm/pure-rand-default.js
var __type = "module";
var __version = "6.1.0";
var __commitHash = "a413dd2b721516be2ef29adffb515c5ae67bfbad";

// node_modules/pure-rand/lib/esm/pure-rand.js
var pure_rand_default = pure_rand_default_exports;

// node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js
var VerbosityLevel;
(function(VerbosityLevel2) {
  VerbosityLevel2[VerbosityLevel2["None"] = 0] = "None";
  VerbosityLevel2[VerbosityLevel2["Verbose"] = 1] = "Verbose";
  VerbosityLevel2[VerbosityLevel2["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel || (VerbosityLevel = {}));

// node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
var safeDateNow = Date.now;
var safeMathMin = Math.min;
var safeMathRandom = Math.random;
var QualifiedParameters = class _QualifiedParameters {
  constructor(op) {
    const p = op || {};
    this.seed = _QualifiedParameters.readSeed(p);
    this.randomType = _QualifiedParameters.readRandomType(p);
    this.numRuns = _QualifiedParameters.readNumRuns(p);
    this.verbose = _QualifiedParameters.readVerbose(p);
    this.maxSkipsPerRun = _QualifiedParameters.readOrDefault(p, "maxSkipsPerRun", 100);
    this.timeout = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "timeout", null));
    this.skipAllAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "skipAllAfterTimeLimit", null));
    this.interruptAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "interruptAfterTimeLimit", null));
    this.markInterruptAsFailure = _QualifiedParameters.readBoolean(p, "markInterruptAsFailure");
    this.skipEqualValues = _QualifiedParameters.readBoolean(p, "skipEqualValues");
    this.ignoreEqualValues = _QualifiedParameters.readBoolean(p, "ignoreEqualValues");
    this.logger = _QualifiedParameters.readOrDefault(p, "logger", (v) => {
      console.log(v);
    });
    this.path = _QualifiedParameters.readOrDefault(p, "path", "");
    this.unbiased = _QualifiedParameters.readBoolean(p, "unbiased");
    this.examples = _QualifiedParameters.readOrDefault(p, "examples", []);
    this.endOnFailure = _QualifiedParameters.readBoolean(p, "endOnFailure");
    this.reporter = _QualifiedParameters.readOrDefault(p, "reporter", null);
    this.asyncReporter = _QualifiedParameters.readOrDefault(p, "asyncReporter", null);
    this.errorWithCause = _QualifiedParameters.readBoolean(p, "errorWithCause");
  }
  toParameters() {
    const orUndefined2 = (value10) => value10 !== null ? value10 : void 0;
    const parameters = {
      seed: this.seed,
      randomType: this.randomType,
      numRuns: this.numRuns,
      maxSkipsPerRun: this.maxSkipsPerRun,
      timeout: orUndefined2(this.timeout),
      skipAllAfterTimeLimit: orUndefined2(this.skipAllAfterTimeLimit),
      interruptAfterTimeLimit: orUndefined2(this.interruptAfterTimeLimit),
      markInterruptAsFailure: this.markInterruptAsFailure,
      skipEqualValues: this.skipEqualValues,
      ignoreEqualValues: this.ignoreEqualValues,
      path: this.path,
      logger: this.logger,
      unbiased: this.unbiased,
      verbose: this.verbose,
      examples: this.examples,
      endOnFailure: this.endOnFailure,
      reporter: orUndefined2(this.reporter),
      asyncReporter: orUndefined2(this.asyncReporter),
      errorWithCause: this.errorWithCause
    };
    return parameters;
  }
  static read(op) {
    return new _QualifiedParameters(op);
  }
};
QualifiedParameters.createQualifiedRandomGenerator = (random6) => {
  return (seed) => {
    const rng2 = random6(seed);
    if (rng2.unsafeJump === void 0) {
      rng2.unsafeJump = () => unsafeSkipN(rng2, 42);
    }
    return rng2;
  };
};
QualifiedParameters.readSeed = (p) => {
  if (p.seed == null)
    return safeDateNow() ^ safeMathRandom() * 4294967296;
  const seed32 = p.seed | 0;
  if (p.seed === seed32)
    return seed32;
  const gap = p.seed - seed32;
  return seed32 ^ gap * 4294967296;
};
QualifiedParameters.readRandomType = (p) => {
  if (p.randomType == null)
    return pure_rand_default.xorshift128plus;
  if (typeof p.randomType === "string") {
    switch (p.randomType) {
      case "mersenne":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.mersenne);
      case "congruential":
      case "congruential32":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.congruential32);
      case "xorshift128plus":
        return pure_rand_default.xorshift128plus;
      case "xoroshiro128plus":
        return pure_rand_default.xoroshiro128plus;
      default:
        throw new Error(`Invalid random specified: '${p.randomType}'`);
    }
  }
  const mrng = p.randomType(0);
  if ("min" in mrng && mrng.min !== -2147483648) {
    throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
  }
  if ("max" in mrng && mrng.max !== 2147483647) {
    throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
  }
  if ("unsafeJump" in mrng) {
    return p.randomType;
  }
  return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
};
QualifiedParameters.readNumRuns = (p) => {
  const defaultValue = 100;
  if (p.numRuns != null)
    return p.numRuns;
  if (p.num_runs != null)
    return p.num_runs;
  return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
  if (p.verbose == null)
    return VerbosityLevel.None;
  if (typeof p.verbose === "boolean") {
    return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;
  }
  if (p.verbose <= VerbosityLevel.None) {
    return VerbosityLevel.None;
  }
  if (p.verbose >= VerbosityLevel.VeryVerbose) {
    return VerbosityLevel.VeryVerbose;
  }
  return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
  const value10 = p[key];
  return value10 != null ? value10 : defaultValue;
};
QualifiedParameters.safeTimeout = (value10) => {
  if (value10 === null) {
    return null;
  }
  return safeMathMin(value10, 2147483647);
};

// node_modules/fast-check/lib/esm/check/property/SkipAfterProperty.js
function interruptAfter(timeMs, setTimeoutSafe, clearTimeoutSafe) {
  let timeoutHandle = null;
  const promise4 = new Promise((resolve) => {
    timeoutHandle = setTimeoutSafe(() => {
      const preconditionFailure = new PreconditionFailure(true);
      resolve(preconditionFailure);
    }, timeMs);
  });
  return {
    clear: () => clearTimeoutSafe(timeoutHandle),
    promise: promise4
  };
}
var SkipAfterProperty = class {
  constructor(property2, getTime, timeLimit, interruptExecution, setTimeoutSafe, clearTimeoutSafe) {
    this.property = property2;
    this.getTime = getTime;
    this.interruptExecution = interruptExecution;
    this.setTimeoutSafe = setTimeoutSafe;
    this.clearTimeoutSafe = clearTimeoutSafe;
    this.skipAfterTime = this.getTime() + timeLimit;
    if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
      this.runBeforeEach = () => this.property.runBeforeEach();
      this.runAfterEach = () => this.property.runAfterEach();
    }
  }
  isAsync() {
    return this.property.isAsync();
  }
  generate(mrng, runId) {
    return this.property.generate(mrng, runId);
  }
  shrink(value10) {
    return this.property.shrink(value10);
  }
  run(v, dontRunHook) {
    const remainingTime = this.skipAfterTime - this.getTime();
    if (remainingTime <= 0) {
      const preconditionFailure = new PreconditionFailure(this.interruptExecution);
      if (this.isAsync()) {
        return Promise.resolve(preconditionFailure);
      } else {
        return preconditionFailure;
      }
    }
    if (this.interruptExecution && this.isAsync()) {
      const t = interruptAfter(remainingTime, this.setTimeoutSafe, this.clearTimeoutSafe);
      const propRun = Promise.race([this.property.run(v, dontRunHook), t.promise]);
      propRun.then(t.clear, t.clear);
      return propRun;
    }
    return this.property.run(v, dontRunHook);
  }
};

// node_modules/fast-check/lib/esm/check/property/TimeoutProperty.js
var timeoutAfter = (timeMs, setTimeoutSafe, clearTimeoutSafe) => {
  let timeoutHandle = null;
  const promise4 = new Promise((resolve) => {
    timeoutHandle = setTimeoutSafe(() => {
      resolve({
        error: new SError(`Property timeout: exceeded limit of ${timeMs} milliseconds`),
        errorMessage: `Property timeout: exceeded limit of ${timeMs} milliseconds`
      });
    }, timeMs);
  });
  return {
    clear: () => clearTimeoutSafe(timeoutHandle),
    promise: promise4
  };
};
var TimeoutProperty = class {
  constructor(property2, timeMs, setTimeoutSafe, clearTimeoutSafe) {
    this.property = property2;
    this.timeMs = timeMs;
    this.setTimeoutSafe = setTimeoutSafe;
    this.clearTimeoutSafe = clearTimeoutSafe;
    if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
      this.runBeforeEach = () => Promise.resolve(this.property.runBeforeEach());
      this.runAfterEach = () => Promise.resolve(this.property.runAfterEach());
    }
  }
  isAsync() {
    return true;
  }
  generate(mrng, runId) {
    return this.property.generate(mrng, runId);
  }
  shrink(value10) {
    return this.property.shrink(value10);
  }
  async run(v, dontRunHook) {
    const t = timeoutAfter(this.timeMs, this.setTimeoutSafe, this.clearTimeoutSafe);
    const propRun = Promise.race([this.property.run(v, dontRunHook), t.promise]);
    propRun.then(t.clear, t.clear);
    return propRun;
  }
};

// node_modules/fast-check/lib/esm/check/property/UnbiasedProperty.js
var UnbiasedProperty = class {
  constructor(property2) {
    this.property = property2;
    if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
      this.runBeforeEach = () => this.property.runBeforeEach();
      this.runAfterEach = () => this.property.runAfterEach();
    }
  }
  isAsync() {
    return this.property.isAsync();
  }
  generate(mrng, _runId) {
    return this.property.generate(mrng, void 0);
  }
  shrink(value10) {
    return this.property.shrink(value10);
  }
  run(v, dontRunHook) {
    return this.property.run(v, dontRunHook);
  }
};

// node_modules/fast-check/lib/esm/utils/stringify.js
var safeArrayFrom = Array.from;
var safeBufferIsBuffer = typeof Buffer !== "undefined" ? Buffer.isBuffer : void 0;
var safeJsonStringify = JSON.stringify;
var safeNumberIsNaN = Number.isNaN;
var safeObjectKeys = Object.keys;
var safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var safeObjectGetPrototypeOf = Object.getPrototypeOf;
var safeNegativeInfinity = Number.NEGATIVE_INFINITY;
var safePositiveInfinity = Number.POSITIVE_INFINITY;
var toStringMethod = Symbol.for("fast-check/toStringMethod");
function hasToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && toStringMethod in instance && typeof instance[toStringMethod] === "function";
}
var asyncToStringMethod = Symbol.for("fast-check/asyncToStringMethod");
function hasAsyncToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === "function";
}
var findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
  if (s.description !== void 0)
    return s.description;
  const m = findSymbolNameRegex.exec(SString(s));
  return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
  switch (numValue) {
    case 0:
      return 1 / numValue === safeNegativeInfinity ? "-0" : "0";
    case safeNegativeInfinity:
      return "Number.NEGATIVE_INFINITY";
    case safePositiveInfinity:
      return "Number.POSITIVE_INFINITY";
    default:
      return numValue === numValue ? SString(numValue) : "Number.NaN";
  }
}
function isSparseArray(arr) {
  let previousNumberedIndex = -1;
  for (const index3 in arr) {
    const numberedIndex = Number(index3);
    if (numberedIndex !== previousNumberedIndex + 1)
      return true;
    previousNumberedIndex = numberedIndex;
  }
  return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value10, previousValues, getAsyncContent) {
  const currentValues = [...previousValues, value10];
  if (typeof value10 === "object") {
    if (safeIndexOf(previousValues, value10) !== -1) {
      return "[cyclic]";
    }
  }
  if (hasAsyncToStringMethod(value10)) {
    const content = getAsyncContent(value10);
    if (content.state === "fulfilled") {
      return content.value;
    }
  }
  if (hasToStringMethod(value10)) {
    try {
      return value10[toStringMethod]();
    } catch (err2) {
    }
  }
  switch (safeToString(value10)) {
    case "[object Array]": {
      const arr = value10;
      if (arr.length >= 50 && isSparseArray(arr)) {
        const assignments = [];
        for (const index3 in arr) {
          if (!safeNumberIsNaN(Number(index3)))
            safePush(assignments, `${index3}:${stringifyInternal(arr[index3], currentValues, getAsyncContent)}`);
        }
        return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ",")}})` : `Array(${arr.length})`;
      }
      const stringifiedArray = safeJoin(safeMap(arr, (v) => stringifyInternal(v, currentValues, getAsyncContent)), ",");
      return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
    }
    case "[object BigInt]":
      return `${value10}n`;
    case "[object Boolean]": {
      const unboxedToString = value10 == true ? "true" : "false";
      return typeof value10 === "boolean" ? unboxedToString : `new Boolean(${unboxedToString})`;
    }
    case "[object Date]": {
      const d = value10;
      return safeNumberIsNaN(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;
    }
    case "[object Map]":
      return `new Map(${stringifyInternal(Array.from(value10), currentValues, getAsyncContent)})`;
    case "[object Null]":
      return `null`;
    case "[object Number]":
      return typeof value10 === "number" ? stringifyNumber(value10) : `new Number(${stringifyNumber(Number(value10))})`;
    case "[object Object]": {
      try {
        const toStringAccessor = value10.toString;
        if (typeof toStringAccessor === "function" && toStringAccessor !== Object.prototype.toString) {
          return value10.toString();
        }
      } catch (err2) {
        return "[object Object]";
      }
      const mapper = (k) => `${k === "__proto__" ? '["__proto__"]' : typeof k === "symbol" ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : safeJsonStringify(k)}:${stringifyInternal(value10[k], currentValues, getAsyncContent)}`;
      const stringifiedProperties = [
        ...safeMap(safeObjectKeys(value10), mapper),
        ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols(value10), (s) => {
          const descriptor3 = safeObjectGetOwnPropertyDescriptor(value10, s);
          return descriptor3 && descriptor3.enumerable;
        }), mapper)
      ];
      const rawRepr = "{" + safeJoin(stringifiedProperties, ",") + "}";
      if (safeObjectGetPrototypeOf(value10) === null) {
        return rawRepr === "{}" ? "Object.create(null)" : `Object.assign(Object.create(null),${rawRepr})`;
      }
      return rawRepr;
    }
    case "[object Set]":
      return `new Set(${stringifyInternal(Array.from(value10), currentValues, getAsyncContent)})`;
    case "[object String]":
      return typeof value10 === "string" ? safeJsonStringify(value10) : `new String(${safeJsonStringify(value10)})`;
    case "[object Symbol]": {
      const s = value10;
      if (SSymbol.keyFor(s) !== void 0) {
        return `Symbol.for(${safeJsonStringify(SSymbol.keyFor(s))})`;
      }
      const desc = getSymbolDescription(s);
      if (desc === null) {
        return "Symbol()";
      }
      const knownSymbol = desc.startsWith("Symbol.") && SSymbol[desc.substring(7)];
      return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;
    }
    case "[object Promise]": {
      const promiseContent = getAsyncContent(value10);
      switch (promiseContent.state) {
        case "fulfilled":
          return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "rejected":
          return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "pending":
          return `new Promise(() => {/*pending*/})`;
        case "unknown":
        default:
          return `new Promise(() => {/*unknown*/})`;
      }
    }
    case "[object Error]":
      if (value10 instanceof Error) {
        return `new Error(${stringifyInternal(value10.message, currentValues, getAsyncContent)})`;
      }
      break;
    case "[object Undefined]":
      return `undefined`;
    case "[object Int8Array]":
    case "[object Uint8Array]":
    case "[object Uint8ClampedArray]":
    case "[object Int16Array]":
    case "[object Uint16Array]":
    case "[object Int32Array]":
    case "[object Uint32Array]":
    case "[object Float32Array]":
    case "[object Float64Array]":
    case "[object BigInt64Array]":
    case "[object BigUint64Array]": {
      if (typeof safeBufferIsBuffer === "function" && safeBufferIsBuffer(value10)) {
        return `Buffer.from(${stringifyInternal(safeArrayFrom(value10.values()), currentValues, getAsyncContent)})`;
      }
      const valuePrototype = safeObjectGetPrototypeOf(value10);
      const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
      if (typeof className === "string") {
        const typedArray2 = value10;
        const valuesFromTypedArr = typedArray2.values();
        return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
      }
      break;
    }
  }
  try {
    return value10.toString();
  } catch (_a106) {
    return safeToString(value10);
  }
}
function stringify3(value10) {
  return stringifyInternal(value10, [], () => ({ state: "unknown", value: void 0 }));
}
function possiblyAsyncStringify(value10) {
  const stillPendingMarker = SSymbol();
  const pendingPromisesForCache = [];
  const cache = new SMap();
  function createDelay0() {
    let handleId = null;
    const cancel = () => {
      if (handleId !== null) {
        clearTimeout(handleId);
      }
    };
    const delay4 = new Promise((resolve) => {
      handleId = setTimeout(() => {
        handleId = null;
        resolve(stillPendingMarker);
      }, 0);
    });
    return { delay: delay4, cancel };
  }
  const unknownState = { state: "unknown", value: void 0 };
  const getAsyncContent = function getAsyncContent2(data) {
    const cacheKey2 = data;
    if (cache.has(cacheKey2)) {
      return cache.get(cacheKey2);
    }
    const delay0 = createDelay0();
    const p = asyncToStringMethod in data ? Promise.resolve().then(() => data[asyncToStringMethod]()) : data;
    p.catch(() => {
    });
    pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {
      if (successValue === stillPendingMarker)
        cache.set(cacheKey2, { state: "pending", value: void 0 });
      else
        cache.set(cacheKey2, { state: "fulfilled", value: successValue });
      delay0.cancel();
    }, (errorValue) => {
      cache.set(cacheKey2, { state: "rejected", value: errorValue });
      delay0.cancel();
    }));
    cache.set(cacheKey2, unknownState);
    return unknownState;
  };
  function loop5() {
    const stringifiedValue = stringifyInternal(value10, [], getAsyncContent);
    if (pendingPromisesForCache.length === 0) {
      return stringifiedValue;
    }
    return Promise.all(pendingPromisesForCache.splice(0)).then(loop5);
  }
  return loop5();
}
async function asyncStringify(value10) {
  return Promise.resolve(possiblyAsyncStringify(value10));
}

// node_modules/fast-check/lib/esm/check/property/IgnoreEqualValuesProperty.js
function fromSyncCached(cachedValue) {
  return cachedValue === null ? new PreconditionFailure() : cachedValue;
}
function fromCached(...data) {
  if (data[1])
    return data[0].then(fromSyncCached);
  return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
  return fromCached(cachedValue, isAsync);
}
var IgnoreEqualValuesProperty = class {
  constructor(property2, skipRuns) {
    this.property = property2;
    this.skipRuns = skipRuns;
    this.coveredCases = /* @__PURE__ */ new Map();
    if (this.property.runBeforeEach !== void 0 && this.property.runAfterEach !== void 0) {
      this.runBeforeEach = () => this.property.runBeforeEach();
      this.runAfterEach = () => this.property.runAfterEach();
    }
  }
  isAsync() {
    return this.property.isAsync();
  }
  generate(mrng, runId) {
    return this.property.generate(mrng, runId);
  }
  shrink(value10) {
    return this.property.shrink(value10);
  }
  run(v, dontRunHook) {
    const stringifiedValue = stringify3(v);
    if (this.coveredCases.has(stringifiedValue)) {
      const lastOutput = this.coveredCases.get(stringifiedValue);
      if (!this.skipRuns) {
        return lastOutput;
      }
      return fromCachedUnsafe(lastOutput, this.property.isAsync());
    }
    const out = this.property.run(v, dontRunHook);
    this.coveredCases.set(stringifiedValue, out);
    return out;
  }
};

// node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
var safeDateNow2 = Date.now;
var safeSetTimeout = setTimeout;
var safeClearTimeout = clearTimeout;
function decorateProperty(rawProperty, qParams) {
  let prop = rawProperty;
  if (rawProperty.isAsync() && qParams.timeout != null) {
    prop = new TimeoutProperty(prop, qParams.timeout, safeSetTimeout, safeClearTimeout);
  }
  if (qParams.unbiased) {
    prop = new UnbiasedProperty(prop);
  }
  if (qParams.skipAllAfterTimeLimit != null) {
    prop = new SkipAfterProperty(prop, safeDateNow2, qParams.skipAllAfterTimeLimit, false, safeSetTimeout, safeClearTimeout);
  }
  if (qParams.interruptAfterTimeLimit != null) {
    prop = new SkipAfterProperty(prop, safeDateNow2, qParams.interruptAfterTimeLimit, true, safeSetTimeout, safeClearTimeout);
  }
  if (qParams.skipEqualValues) {
    prop = new IgnoreEqualValuesProperty(prop, true);
  }
  if (qParams.ignoreEqualValues) {
    prop = new IgnoreEqualValuesProperty(prop, false);
  }
  return prop;
}

// node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js
var ExecutionStatus;
(function(ExecutionStatus2) {
  ExecutionStatus2[ExecutionStatus2["Success"] = 0] = "Success";
  ExecutionStatus2[ExecutionStatus2["Skipped"] = -1] = "Skipped";
  ExecutionStatus2[ExecutionStatus2["Failure"] = 1] = "Failure";
})(ExecutionStatus || (ExecutionStatus = {}));

// node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
var RunExecution = class _RunExecution {
  constructor(verbosity, interruptedAsFailure) {
    this.verbosity = verbosity;
    this.interruptedAsFailure = interruptedAsFailure;
    this.isSuccess = () => this.pathToFailure == null;
    this.firstFailure = () => this.pathToFailure ? +safeSplit(this.pathToFailure, ":")[0] : -1;
    this.numShrinks = () => this.pathToFailure ? safeSplit(this.pathToFailure, ":").length - 1 : 0;
    this.rootExecutionTrees = [];
    this.currentLevelExecutionTrees = this.rootExecutionTrees;
    this.failure = null;
    this.numSkips = 0;
    this.numSuccesses = 0;
    this.interrupted = false;
  }
  appendExecutionTree(status3, value10) {
    const currentTree = { status: status3, value: value10, children: [] };
    this.currentLevelExecutionTrees.push(currentTree);
    return currentTree;
  }
  fail(value10, id3, failure) {
    if (this.verbosity >= VerbosityLevel.Verbose) {
      const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value10);
      this.currentLevelExecutionTrees = currentTree.children;
    }
    if (this.pathToFailure == null)
      this.pathToFailure = `${id3}`;
    else
      this.pathToFailure += `:${id3}`;
    this.value = value10;
    this.failure = failure;
  }
  skip(value10) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Skipped, value10);
    }
    if (this.pathToFailure == null) {
      ++this.numSkips;
    }
  }
  success(value10) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Success, value10);
    }
    if (this.pathToFailure == null) {
      ++this.numSuccesses;
    }
  }
  interrupt() {
    this.interrupted = true;
  }
  extractFailures() {
    if (this.isSuccess()) {
      return [];
    }
    const failures3 = [];
    let cursor = this.rootExecutionTrees;
    while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {
      const failureTree = cursor[cursor.length - 1];
      failures3.push(failureTree.value);
      cursor = failureTree.children;
    }
    return failures3;
  }
  toRunDetails(seed, basePath, maxSkips, qParams) {
    if (!this.isSuccess()) {
      return {
        failed: true,
        interrupted: this.interrupted,
        numRuns: this.firstFailure() + 1 - this.numSkips,
        numSkips: this.numSkips,
        numShrinks: this.numShrinks(),
        seed,
        counterexample: this.value,
        counterexamplePath: _RunExecution.mergePaths(basePath, this.pathToFailure),
        error: this.failure.errorMessage,
        errorInstance: this.failure.error,
        failures: this.extractFailures(),
        executionSummary: this.rootExecutionTrees,
        verbose: this.verbosity,
        runConfiguration: qParams.toParameters()
      };
    }
    const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
    const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
    const out = {
      failed,
      interrupted: this.interrupted,
      numRuns: this.numSuccesses,
      numSkips: this.numSkips,
      numShrinks: 0,
      seed,
      counterexample: null,
      counterexamplePath: null,
      error: null,
      errorInstance: null,
      failures: [],
      executionSummary: this.rootExecutionTrees,
      verbose: this.verbosity,
      runConfiguration: qParams.toParameters()
    };
    return out;
  }
};
RunExecution.mergePaths = (offsetPath, path2) => {
  if (offsetPath.length === 0)
    return path2;
  const offsetItems = offsetPath.split(":");
  const remainingItems = path2.split(":");
  const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
  return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(":");
};

// node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js
var RunnerIterator = class {
  constructor(sourceValues, shrink2, verbose, interruptedAsFailure) {
    this.sourceValues = sourceValues;
    this.shrink = shrink2;
    this.runExecution = new RunExecution(verbose, interruptedAsFailure);
    this.currentIdx = -1;
    this.nextValues = sourceValues;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const nextValue = this.nextValues.next();
    if (nextValue.done || this.runExecution.interrupted) {
      return { done: true, value: void 0 };
    }
    this.currentValue = nextValue.value;
    ++this.currentIdx;
    return { done: false, value: nextValue.value.value_ };
  }
  handleResult(result) {
    if (result != null && typeof result === "object" && !PreconditionFailure.isFailure(result)) {
      this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);
      this.currentIdx = -1;
      this.nextValues = this.shrink(this.currentValue);
    } else if (result != null) {
      if (!result.interruptExecution) {
        this.runExecution.skip(this.currentValue.value_);
        this.sourceValues.skippedOne();
      } else {
        this.runExecution.interrupt();
      }
    } else {
      this.runExecution.success(this.currentValue.value_);
    }
  }
};

// node_modules/fast-check/lib/esm/check/runner/SourceValuesIterator.js
var SourceValuesIterator = class {
  constructor(initialValues, maxInitialIterations, remainingSkips) {
    this.initialValues = initialValues;
    this.maxInitialIterations = maxInitialIterations;
    this.remainingSkips = remainingSkips;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
      const n = this.initialValues.next();
      if (!n.done)
        return { value: n.value, done: false };
    }
    return { value: void 0, done: true };
  }
  skippedOne() {
    --this.remainingSkips;
    ++this.maxInitialIterations;
  }
};

// node_modules/fast-check/lib/esm/random/generator/Random.js
var Random = class _Random {
  constructor(sourceRng) {
    this.internalRng = sourceRng.clone();
  }
  clone() {
    return new _Random(this.internalRng);
  }
  next(bits2) {
    return unsafeUniformIntDistribution(0, (1 << bits2) - 1, this.internalRng);
  }
  nextBoolean() {
    return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
  }
  nextInt(min11, max14) {
    return unsafeUniformIntDistribution(min11 == null ? _Random.MIN_INT : min11, max14 == null ? _Random.MAX_INT : max14, this.internalRng);
  }
  nextBigInt(min11, max14) {
    return unsafeUniformBigIntDistribution(min11, max14, this.internalRng);
  }
  nextArrayInt(min11, max14) {
    return unsafeUniformArrayIntDistribution(min11, max14, this.internalRng);
  }
  nextDouble() {
    const a = this.next(26);
    const b = this.next(27);
    return (a * _Random.DBL_FACTOR + b) * _Random.DBL_DIVISOR;
  }
  getState() {
    if ("getState" in this.internalRng && typeof this.internalRng.getState === "function") {
      return this.internalRng.getState();
    }
    return void 0;
  }
};
Random.MIN_INT = 2147483648 | 0;
Random.MAX_INT = 2147483647 | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

// node_modules/fast-check/lib/esm/check/runner/Tosser.js
function tossNext(generator, rng2, index3) {
  rng2.unsafeJump();
  return generator.generate(new Random(rng2), index3);
}
function* toss(generator, seed, random6, examples) {
  for (let idx = 0; idx !== examples.length; ++idx) {
    yield new Value(examples[idx], void 0);
  }
  for (let idx = 0, rng2 = random6(seed); ; ++idx) {
    yield tossNext(generator, rng2, idx);
  }
}
function lazyGenerate(generator, rng2, idx) {
  return () => generator.generate(new Random(rng2), idx);
}
function* lazyToss(generator, seed, random6, examples) {
  yield* safeMap(examples, (e) => () => new Value(e, void 0));
  let idx = 0;
  let rng2 = random6(seed);
  for (; ; ) {
    rng2 = rng2.jump ? rng2.jump() : skipN(rng2, 42);
    yield lazyGenerate(generator, rng2, idx++);
  }
}

// node_modules/fast-check/lib/esm/check/runner/utils/PathWalker.js
function produce(producer) {
  return producer();
}
function pathWalk(path2, initialProducers, shrink2) {
  const producers = initialProducers;
  const segments = path2.split(":").map((text) => +text);
  if (segments.length === 0) {
    return producers.map(produce);
  }
  if (!segments.every((v) => !Number.isNaN(v))) {
    throw new Error(`Unable to replay, got invalid path=${path2}`);
  }
  let values15 = producers.drop(segments[0]).map(produce);
  for (const s of segments.slice(1)) {
    const valueToShrink = values15.getNthOrLast(0);
    if (valueToShrink === null) {
      throw new Error(`Unable to replay, got wrong path=${path2}`);
    }
    values15 = shrink2(valueToShrink).drop(s);
  }
  return values15;
}

// node_modules/fast-check/lib/esm/check/runner/utils/RunDetailsFormatter.js
var safeObjectAssign2 = Object.assign;
function formatHints(hints) {
  if (hints.length === 1) {
    return `Hint: ${hints[0]}`;
  }
  return hints.map((h2, idx) => `Hint (${idx + 1}): ${h2}`).join("\n");
}
function formatFailures(failures3, stringifyOne) {
  return `Encountered failures were:
- ${failures3.map(stringifyOne).join("\n- ")}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
  const summaryLines = [];
  const remainingTreesAndDepth = [];
  for (const tree of executionTrees.slice().reverse()) {
    remainingTreesAndDepth.push({ depth: 1, tree });
  }
  while (remainingTreesAndDepth.length !== 0) {
    const currentTreeAndDepth = remainingTreesAndDepth.pop();
    const currentTree = currentTreeAndDepth.tree;
    const currentDepth = currentTreeAndDepth.depth;
    const statusIcon = currentTree.status === ExecutionStatus.Success ? "\x1B[32m\x1B[0m" : currentTree.status === ExecutionStatus.Failure ? "\x1B[31m\x1B[0m" : "\x1B[33m!\x1B[0m";
    const leftPadding = Array(currentDepth).join(". ");
    summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
    for (const tree of currentTree.children.slice().reverse()) {
      remainingTreesAndDepth.push({ depth: currentDepth + 1, tree });
    }
  }
  return `Execution summary:
${summaryLines.join("\n")}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
  const message = `Failed to run property, too many pre-condition failures encountered
{ seed: ${out.seed} }

Ran ${out.numRuns} time(s)
Skipped ${out.numSkips} time(s)`;
  let details = null;
  const hints = [
    "Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries",
    "Increase failure tolerance by setting maxSkipsPerRun to an higher value"
  ];
  if (out.verbose >= VerbosityLevel.VeryVerbose) {
    details = formatExecutionSummary(out.executionSummary, stringifyOne);
  } else {
    safePush(hints, "Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status");
  }
  return { message, details, hints };
}
function preFormatFailure(out, stringifyOne) {
  const noErrorInMessage = out.runConfiguration.errorWithCause;
  const messageErrorPart = noErrorInMessage ? "" : `
Got ${safeReplace(out.error, /^Error: /, "error: ")}`;
  const message = `Property failed after ${out.numRuns} tests
{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }
Counterexample: ${stringifyOne(out.counterexample)}
Shrunk ${out.numShrinks} time(s)${messageErrorPart}`;
  let details = null;
  const hints = [];
  if (out.verbose >= VerbosityLevel.VeryVerbose) {
    details = formatExecutionSummary(out.executionSummary, stringifyOne);
  } else if (out.verbose === VerbosityLevel.Verbose) {
    details = formatFailures(out.failures, stringifyOne);
  } else {
    safePush(hints, "Enable verbose mode in order to have the list of all failing values encountered during the run");
  }
  return { message, details, hints };
}
function preFormatEarlyInterrupted(out, stringifyOne) {
  const message = `Property interrupted after ${out.numRuns} tests
{ seed: ${out.seed} }`;
  let details = null;
  const hints = [];
  if (out.verbose >= VerbosityLevel.VeryVerbose) {
    details = formatExecutionSummary(out.executionSummary, stringifyOne);
  } else {
    safePush(hints, "Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status");
  }
  return { message, details, hints };
}
function defaultReportMessageInternal(out, stringifyOne) {
  if (!out.failed)
    return;
  const { message, details, hints } = out.counterexamplePath === null ? out.interrupted ? preFormatEarlyInterrupted(out, stringifyOne) : preFormatTooManySkipped(out, stringifyOne) : preFormatFailure(out, stringifyOne);
  let errorMessage = message;
  if (details != null)
    errorMessage += `

${details}`;
  if (hints.length > 0)
    errorMessage += `

${formatHints(hints)}`;
  return errorMessage;
}
function defaultReportMessage(out) {
  return defaultReportMessageInternal(out, stringify3);
}
async function asyncDefaultReportMessage(out) {
  const pendingStringifieds = [];
  function stringifyOne(value10) {
    const stringified = possiblyAsyncStringify(value10);
    if (typeof stringified === "string") {
      return stringified;
    }
    pendingStringifieds.push(Promise.all([value10, stringified]));
    return "";
  }
  const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
  if (pendingStringifieds.length === 0) {
    return firstTryMessage;
  }
  const registeredValues = new SMap(await Promise.all(pendingStringifieds));
  function stringifySecond(value10) {
    const asyncStringifiedIfRegistered = safeMapGet(registeredValues, value10);
    if (asyncStringifiedIfRegistered !== void 0) {
      return asyncStringifiedIfRegistered;
    }
    return stringify3(value10);
  }
  return defaultReportMessageInternal(out, stringifySecond);
}
function buildError(errorMessage, out) {
  if (!out.runConfiguration.errorWithCause) {
    throw new SError(errorMessage);
  }
  const ErrorWithCause = SError;
  const error4 = new ErrorWithCause(errorMessage, { cause: out.errorInstance });
  if (!("cause" in error4)) {
    safeObjectAssign2(error4, { cause: out.errorInstance });
  }
  return error4;
}
function throwIfFailed(out) {
  if (!out.failed)
    return;
  throw buildError(defaultReportMessage(out), out);
}
async function asyncThrowIfFailed(out) {
  if (!out.failed)
    return;
  throw buildError(await asyncDefaultReportMessage(out), out);
}
function reportRunDetails(out) {
  if (out.runConfiguration.asyncReporter)
    return out.runConfiguration.asyncReporter(out);
  else if (out.runConfiguration.reporter)
    return out.runConfiguration.reporter(out);
  else
    return throwIfFailed(out);
}
async function asyncReportRunDetails(out) {
  if (out.runConfiguration.asyncReporter)
    return out.runConfiguration.asyncReporter(out);
  else if (out.runConfiguration.reporter)
    return out.runConfiguration.reporter(out);
  else
    return asyncThrowIfFailed(out);
}

// node_modules/fast-check/lib/esm/check/runner/Runner.js
var safeObjectAssign3 = Object.assign;
function runIt(property2, shrink2, sourceValues, verbose, interruptedAsFailure) {
  const isModernProperty = property2.runBeforeEach !== void 0 && property2.runAfterEach !== void 0;
  const runner = new RunnerIterator(sourceValues, shrink2, verbose, interruptedAsFailure);
  for (const v of runner) {
    if (isModernProperty) {
      property2.runBeforeEach();
    }
    const out = property2.run(v, isModernProperty);
    if (isModernProperty) {
      property2.runAfterEach();
    }
    runner.handleResult(out);
  }
  return runner.runExecution;
}
async function asyncRunIt(property2, shrink2, sourceValues, verbose, interruptedAsFailure) {
  const isModernProperty = property2.runBeforeEach !== void 0 && property2.runAfterEach !== void 0;
  const runner = new RunnerIterator(sourceValues, shrink2, verbose, interruptedAsFailure);
  for (const v of runner) {
    if (isModernProperty) {
      await property2.runBeforeEach();
    }
    const out = await property2.run(v, isModernProperty);
    if (isModernProperty) {
      await property2.runAfterEach();
    }
    runner.handleResult(out);
  }
  return runner.runExecution;
}
function check(rawProperty, params) {
  if (rawProperty == null || rawProperty.generate == null)
    throw new Error("Invalid property encountered, please use a valid property");
  if (rawProperty.run == null)
    throw new Error("Invalid property encountered, please use a valid property not an arbitrary");
  const qParams = QualifiedParameters.read(safeObjectAssign3(safeObjectAssign3({}, readConfigureGlobal()), params));
  if (qParams.reporter !== null && qParams.asyncReporter !== null)
    throw new Error("Invalid parameters encountered, reporter and asyncReporter cannot be specified together");
  if (qParams.asyncReporter !== null && !rawProperty.isAsync())
    throw new Error("Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified");
  const property2 = decorateProperty(rawProperty, qParams);
  const maxInitialIterations = qParams.path.length === 0 || qParams.path.indexOf(":") === -1 ? qParams.numRuns : -1;
  const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
  const shrink2 = (...args2) => property2.shrink(...args2);
  const initialValues = qParams.path.length === 0 ? toss(property2, qParams.seed, qParams.randomType, qParams.examples) : pathWalk(qParams.path, stream(lazyToss(property2, qParams.seed, qParams.randomType, qParams.examples)), shrink2);
  const sourceValues = new SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);
  const finalShrink = !qParams.endOnFailure ? shrink2 : Stream.nil;
  return property2.isAsync() ? asyncRunIt(property2, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams)) : runIt(property2, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
function assert(property2, params) {
  const out = check(property2, params);
  if (property2.isAsync())
    return out.then(asyncReportRunDetails);
  else
    reportRunDetails(out);
}

// node_modules/fast-check/lib/esm/check/runner/Sampler.js
function toProperty(generator, qParams) {
  const prop = !Object.prototype.hasOwnProperty.call(generator, "isAsync") ? new Property(generator, () => true) : generator;
  return qParams.unbiased === true ? new UnbiasedProperty(prop) : prop;
}
function streamSample(generator, params) {
  const extendedParams = typeof params === "number" ? Object.assign(Object.assign({}, readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, readConfigureGlobal()), params);
  const qParams = QualifiedParameters.read(extendedParams);
  const nextProperty = toProperty(generator, qParams);
  const shrink2 = nextProperty.shrink.bind(nextProperty);
  const tossedValues = qParams.path.length === 0 ? stream(toss(nextProperty, qParams.seed, qParams.randomType, qParams.examples)) : pathWalk(qParams.path, stream(lazyToss(nextProperty, qParams.seed, qParams.randomType, qParams.examples)), shrink2);
  return tossedValues.take(qParams.numRuns).map((s) => s.value_);
}
function sample(generator, params) {
  return [...streamSample(generator, params)];
}
function round2(n) {
  return (Math.round(n * 100) / 100).toFixed(2);
}
function statistics(generator, classify, params) {
  const extendedParams = typeof params === "number" ? Object.assign(Object.assign({}, readConfigureGlobal()), { numRuns: params }) : Object.assign(Object.assign({}, readConfigureGlobal()), params);
  const qParams = QualifiedParameters.read(extendedParams);
  const recorded = {};
  for (const g of streamSample(generator, params)) {
    const out = classify(g);
    const categories = Array.isArray(out) ? out : [out];
    for (const c of categories) {
      recorded[c] = (recorded[c] || 0) + 1;
    }
  }
  const data = Object.entries(recorded).sort((a, b) => b[1] - a[1]).map((i) => [i[0], `${round2(i[1] * 100 / qParams.numRuns)}%`]);
  const longestName = data.map((i) => i[0].length).reduce((p, c) => Math.max(p, c), 0);
  const longestPercent = data.map((i) => i[1].length).reduce((p, c) => Math.max(p, c), 0);
  for (const item of data) {
    qParams.logger(`${item[0].padEnd(longestName, ".")}..${item[1].padStart(longestPercent, ".")}`);
  }
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/GeneratorValueBuilder.js
var safeObjectAssign4 = Object.assign;
function buildGeneratorValue(mrng, biasFactor, computePreBuiltValues, arbitraryCache) {
  const preBuiltValues = computePreBuiltValues();
  let localMrng = mrng.clone();
  const context15 = { mrng: mrng.clone(), biasFactor, history: [] };
  const valueFunction = (arb) => {
    const preBuiltValue = preBuiltValues[context15.history.length];
    if (preBuiltValue !== void 0 && preBuiltValue.arb === arb) {
      const value11 = preBuiltValue.value;
      safePush(context15.history, { arb, value: value11, context: preBuiltValue.context, mrng: preBuiltValue.mrng });
      localMrng = preBuiltValue.mrng.clone();
      return value11;
    }
    const g = arb.generate(localMrng, biasFactor);
    safePush(context15.history, { arb, value: g.value_, context: g.context, mrng: localMrng.clone() });
    return g.value;
  };
  const memoedValueFunction = (arb, ...args2) => {
    return valueFunction(arbitraryCache(arb, args2));
  };
  const valueMethods = {
    values() {
      return safeMap(context15.history, (c) => c.value);
    },
    [cloneMethod]() {
      return buildGeneratorValue(mrng, biasFactor, computePreBuiltValues, arbitraryCache).value;
    },
    [toStringMethod]() {
      return stringify3(safeMap(context15.history, (c) => c.value));
    }
  };
  const value10 = safeObjectAssign4(memoedValueFunction, valueMethods);
  return new Value(value10, context15);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StableArbitraryGeneratorCache.js
var safeArrayIsArray2 = Array.isArray;
var safeObjectKeys2 = Object.keys;
var safeObjectIs = Object.is;
function buildStableArbitraryGeneratorCache(isEqual4) {
  const previousCallsPerBuilder = new SMap();
  return function stableArbitraryGeneratorCache(builder, args2) {
    const entriesForBuilder = safeMapGet(previousCallsPerBuilder, builder);
    if (entriesForBuilder === void 0) {
      const newValue2 = builder(...args2);
      safeMapSet(previousCallsPerBuilder, builder, [{ args: args2, value: newValue2 }]);
      return newValue2;
    }
    const safeEntriesForBuilder = entriesForBuilder;
    for (const entry of safeEntriesForBuilder) {
      if (isEqual4(args2, entry.args)) {
        return entry.value;
      }
    }
    const newValue = builder(...args2);
    safePush(safeEntriesForBuilder, { args: args2, value: newValue });
    return newValue;
  };
}
function naiveIsEqual(v1, v2) {
  if (v1 !== null && typeof v1 === "object" && v2 !== null && typeof v2 === "object") {
    if (safeArrayIsArray2(v1)) {
      if (!safeArrayIsArray2(v2))
        return false;
      if (v1.length !== v2.length)
        return false;
    } else if (safeArrayIsArray2(v2)) {
      return false;
    }
    if (safeObjectKeys2(v1).length !== safeObjectKeys2(v2).length) {
      return false;
    }
    for (const index3 in v1) {
      if (!(index3 in v2)) {
        return false;
      }
      if (!naiveIsEqual(v1[index3], v2[index3])) {
        return false;
      }
    }
    return true;
  } else {
    return safeObjectIs(v1, v2);
  }
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/GeneratorArbitrary.js
var GeneratorArbitrary = class extends Arbitrary {
  constructor() {
    super(...arguments);
    this.arbitraryCache = buildStableArbitraryGeneratorCache(naiveIsEqual);
  }
  generate(mrng, biasFactor) {
    return buildGeneratorValue(mrng, biasFactor, () => [], this.arbitraryCache);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  shrink(_value2, context15) {
    if (context15 === void 0) {
      return Stream.nil();
    }
    const safeContext = context15;
    const mrng = safeContext.mrng;
    const biasFactor = safeContext.biasFactor;
    const history = safeContext.history;
    return tupleShrink(history.map((c) => c.arb), history.map((c) => c.value), history.map((c) => c.context)).map((shrink2) => {
      function computePreBuiltValues() {
        const subValues = shrink2.value;
        const subContexts = shrink2.context;
        return safeMap(history, (entry, index3) => ({
          arb: entry.arb,
          value: subValues[index3],
          context: subContexts[index3],
          mrng: entry.mrng
        }));
      }
      return buildGeneratorValue(mrng, biasFactor, computePreBuiltValues, this.arbitraryCache);
    });
  }
};

// node_modules/fast-check/lib/esm/arbitrary/gen.js
function gen3() {
  return new GeneratorArbitrary();
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
var safeMathFloor = Math.floor;
var safeMathLog2 = Math.log;
function integerLogLike(v) {
  return safeMathFloor(safeMathLog2(v) / safeMathLog2(2));
}
function bigIntLogLike(v) {
  if (v === SBigInt(0))
    return SBigInt(0);
  return SBigInt(SString(v).length);
}
function biasNumericRange(min11, max14, logLike) {
  if (min11 === max14) {
    return [{ min: min11, max: max14 }];
  }
  if (min11 < 0 && max14 > 0) {
    const logMin = logLike(-min11);
    const logMax = logLike(max14);
    return [
      { min: -logMin, max: logMax },
      { min: max14 - logMax, max: max14 },
      { min: min11, max: min11 + logMin }
    ];
  }
  const logGap = logLike(max14 - min11);
  const arbCloseToMin = { min: min11, max: min11 + logGap };
  const arbCloseToMax = { min: max14 - logGap, max: max14 };
  return min11 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
var safeMathCeil = Math.ceil;
var safeMathFloor2 = Math.floor;
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
function shrinkInteger(current2, target, tryTargetAsap) {
  const realGap = current2 - target;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
      const next6 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next6, previous2);
      previous2 = next6;
    }
  }
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
      const next6 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next6, previous2);
      previous2 = next6;
    }
  }
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign = Math.sign;
var safeNumberIsInteger = Number.isInteger;
var safeObjectIs2 = Object.is;
var IntegerArbitrary = class _IntegerArbitrary extends Arbitrary {
  constructor(min11, max14) {
    super();
    this.min = min11;
    this.max = max14;
  }
  generate(mrng, biasFactor) {
    const range6 = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextInt(range6.min, range6.max), void 0);
  }
  canShrinkWithoutContext(value10) {
    return typeof value10 === "number" && safeNumberIsInteger(value10) && !safeObjectIs2(value10, -0) && this.min <= value10 && value10 <= this.max;
  }
  shrink(current2, context15) {
    if (!_IntegerArbitrary.isValidContext(current2, context15)) {
      const target = this.defaultTarget();
      return shrinkInteger(current2, target, true);
    }
    if (this.isLastChanceTry(current2, context15)) {
      return Stream.of(new Value(context15, void 0));
    }
    return shrinkInteger(current2, context15, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return 0;
    }
    return this.min < 0 ? this.max : this.min;
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, integerLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id3 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id3 < 0 ? ranges[0] : ranges[id3 + 1];
  }
  isLastChanceTry(current2, context15) {
    if (current2 > 0)
      return current2 === context15 + 1 && current2 > this.min;
    if (current2 < 0)
      return current2 === context15 - 1 && current2 < this.max;
    return false;
  }
  static isValidContext(current2, context15) {
    if (context15 === void 0) {
      return false;
    }
    if (typeof context15 !== "number") {
      throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
    }
    if (context15 !== 0 && safeMathSign(current2) !== safeMathSign(context15)) {
      throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
    }
    return true;
  }
};

// node_modules/fast-check/lib/esm/arbitrary/integer.js
var safeNumberIsInteger2 = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
  const min11 = constraints.min !== void 0 ? constraints.min : -2147483648;
  const max14 = constraints.max !== void 0 ? constraints.max : 2147483647;
  return { min: min11, max: max14 };
}
function integer(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
var depthContextCache = /* @__PURE__ */ new Map();
function getDepthContextFor(contextMeta) {
  if (contextMeta === void 0) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== void 0) {
    return cachedContext;
  }
  const context15 = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context15);
  return context15;
}
function createDepthIdentifier() {
  const identifier2 = { depth: 0 };
  return identifier2;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
var NoopSlicedGenerator = class {
  constructor(arb, mrng, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.biasFactor = biasFactor;
  }
  attemptExact() {
    return;
  }
  next() {
    return this.arb.generate(this.mrng, this.biasFactor);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
var safeMathMin2 = Math.min;
var safeMathMax = Math.max;
var SlicedBasedGenerator = class {
  constructor(arb, mrng, slices, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.slices = slices;
    this.biasFactor = biasFactor;
    this.activeSliceIndex = 0;
    this.nextIndexInSlice = 0;
    this.lastIndexInSlice = -1;
  }
  attemptExact(targetLength) {
    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
      const eligibleIndices = [];
      for (let index3 = 0; index3 !== this.slices.length; ++index3) {
        const slice5 = this.slices[index3];
        if (slice5.length === targetLength) {
          safePush(eligibleIndices, index3);
        }
      }
      if (eligibleIndices.length === 0) {
        return;
      }
      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
      this.nextIndexInSlice = 0;
      this.lastIndexInSlice = targetLength - 1;
    }
  }
  next() {
    if (this.nextIndexInSlice <= this.lastIndexInSlice) {
      return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], void 0);
    }
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      return this.arb.generate(this.mrng, this.biasFactor);
    }
    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
    const slice5 = this.slices[this.activeSliceIndex];
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      this.nextIndexInSlice = 1;
      this.lastIndexInSlice = slice5.length - 1;
      return new Value(slice5[0], void 0);
    }
    const rangeBoundaryA = this.mrng.nextInt(0, slice5.length - 1);
    const rangeBoundaryB = this.mrng.nextInt(0, slice5.length - 1);
    this.nextIndexInSlice = safeMathMin2(rangeBoundaryA, rangeBoundaryB);
    this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
    return new Value(slice5[this.nextIndexInSlice++], void 0);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === void 0 || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
var safeMathFloor3 = Math.floor;
var safeMathLog3 = Math.log;
var safeMathMax2 = Math.max;
var safeArrayIsArray3 = Array.isArray;
function biasedMaxLength(minLength2, maxLength2) {
  if (minLength2 === maxLength2) {
    return minLength2;
  }
  return minLength2 + safeMathFloor3(safeMathLog3(maxLength2 - minLength2) / safeMathLog3(2));
}
var ArrayArbitrary = class _ArrayArbitrary extends Arbitrary {
  constructor(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, setBuilder, customSlices) {
    super();
    this.arb = arb;
    this.minLength = minLength2;
    this.maxGeneratedLength = maxGeneratedLength;
    this.maxLength = maxLength2;
    this.setBuilder = setBuilder;
    this.customSlices = customSlices;
    this.lengthArb = integer({ min: minLength2, max: maxGeneratedLength });
    this.depthContext = getDepthContextFor(depthIdentifier);
  }
  preFilter(tab) {
    if (this.setBuilder === void 0) {
      return tab;
    }
    const s = this.setBuilder();
    for (let index3 = 0; index3 !== tab.length; ++index3) {
      s.tryAdd(tab[index3]);
    }
    return s.getData();
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    let numSkippedInRow = 0;
    const s = setBuilder();
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
      const current2 = slicedGenerator.next();
      if (s.tryAdd(current2)) {
        numSkippedInRow = 0;
      } else {
        numSkippedInRow += 1;
      }
    }
    return s.getData();
  }
  safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  generateNItems(N, mrng, biasFactorItems) {
    const items = [];
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    slicedGenerator.attemptExact(N);
    for (let index3 = 0; index3 !== N; ++index3) {
      const current2 = slicedGenerator.next();
      safePush(items, current2);
    }
    return items;
  }
  safeGenerateNItems(N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItems(N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
    let cloneable = false;
    const vs = [];
    const itemsContexts = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(itemsContexts, s.context);
    }
    if (cloneable) {
      _ArrayArbitrary.makeItCloneable(vs, items);
    }
    const context15 = {
      shrunkOnce,
      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== void 0 ? itemsRawLengthContext : void 0,
      itemsContexts,
      startIndex
    };
    return new Value(vs, context15);
  }
  generate(mrng, biasFactor) {
    const biasMeta = this.applyBias(mrng, biasFactor);
    const targetSize = biasMeta.size;
    const items = this.setBuilder !== void 0 ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
    return this.wrapper(items, false, void 0, 0);
  }
  applyBias(mrng, biasFactor) {
    if (biasFactor === void 0) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    if (mrng.nextInt(1, biasFactor) !== 1) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
    const targetSizeValue = integer({ min: this.minLength, max: maxBiasedLength }).generate(mrng, void 0);
    return { size: targetSizeValue.value, biasFactorItems: biasFactor };
  }
  canShrinkWithoutContext(value10) {
    if (!safeArrayIsArray3(value10) || this.minLength > value10.length || value10.length > this.maxLength) {
      return false;
    }
    for (let index3 = 0; index3 !== value10.length; ++index3) {
      if (!(index3 in value10)) {
        return false;
      }
      if (!this.arb.canShrinkWithoutContext(value10[index3])) {
        return false;
      }
    }
    const filtered = this.preFilter(safeMap(value10, (item) => new Value(item, void 0)));
    return filtered.length === value10.length;
  }
  shrinkItemByItem(value10, safeContext, endIndex) {
    const shrinks2 = [];
    for (let index3 = safeContext.startIndex; index3 < endIndex; ++index3) {
      safePush(shrinks2, makeLazy(() => this.arb.shrink(value10[index3], safeContext.itemsContexts[index3]).map((v) => {
        const beforeCurrent = safeMap(safeSlice(value10, 0, index3), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i]));
        const afterCurrent = safeMap(safeSlice(value10, index3 + 1), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i + index3 + 1]));
        return [
          [...beforeCurrent, v, ...afterCurrent],
          void 0,
          index3
        ];
      })));
    }
    return Stream.nil().join(...shrinks2);
  }
  shrinkImpl(value10, context15) {
    if (value10.length === 0) {
      return Stream.nil();
    }
    const safeContext = context15 !== void 0 ? context15 : { shrunkOnce: false, lengthContext: void 0, itemsContexts: [], startIndex: 0 };
    return this.lengthArb.shrink(value10.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === void 0 && value10.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
      const sliceStart = value10.length - lengthValue.value;
      return [
        safeMap(safeSlice(value10, sliceStart), (v, index3) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index3 + sliceStart])),
        lengthValue.context,
        0
      ];
    }).join(makeLazy(() => value10.length > this.minLength ? this.shrinkItemByItem(value10, safeContext, 1) : this.shrinkItemByItem(value10, safeContext, value10.length))).join(value10.length > this.minLength ? makeLazy(() => {
      const subContext = {
        shrunkOnce: false,
        lengthContext: void 0,
        itemsContexts: safeSlice(safeContext.itemsContexts, 1),
        startIndex: 0
      };
      return this.shrinkImpl(safeSlice(value10, 1), subContext).filter((v) => this.minLength <= v[0].length + 1).map((v) => {
        return [[new Value(cloneIfNeeded(value10[0]), safeContext.itemsContexts[0]), ...v[0]], void 0, 0];
      });
    }) : Stream.nil());
  }
  shrink(value10, context15) {
    return this.shrinkImpl(value10, context15).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
var safeMathFloor4 = Math.floor;
var safeMathMin3 = Math.min;
var MaxLengthUpperBound = 2147483647;
var orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
var orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
var DefaultSize = "small";
function maxLengthFromMinLength(minLength2, size45) {
  switch (size45) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength2) + 1;
    case "small":
      return 2 * minLength2 + 10;
    case "medium":
      return 11 * minLength2 + 100;
    case "large":
      return 101 * minLength2 + 1e3;
    case "xlarge":
      return 1001 * minLength2 + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size45}`);
  }
}
function relativeSizeToSize(size45, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size45);
  if (sizeInRelative === -1) {
    return size45;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size45, minLength2, maxLength2, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size45 !== void 0 ? size45 : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength2;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin3(maxLengthFromMinLength(minLength2, finalSize), maxLength2);
}
function depthBiasFromSizeForArbitrary(depthSizeOrSize, specifiedMaxDepth) {
  if (typeof depthSizeOrSize === "number") {
    return 1 / depthSizeOrSize;
  }
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = depthSizeOrSize !== void 0 ? depthSizeOrSize : specifiedMaxDepth && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return 0;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  switch (finalSize) {
    case "xsmall":
      return 1;
    case "small":
      return 0.5;
    case "medium":
      return 0.25;
    case "large":
      return 0.125;
    case "xlarge":
      return 0.0625;
  }
}
function resolveSize(size45) {
  const { baseSize: defaultSize = DefaultSize } = readConfigureGlobal() || {};
  if (size45 === void 0) {
    return defaultSize;
  }
  return relativeSizeToSize(size45, defaultSize);
}

// node_modules/fast-check/lib/esm/arbitrary/array.js
function array4(arb, constraints = {}) {
  const size45 = constraints.size;
  const minLength2 = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength2 = maxLengthOrUnset !== void 0 ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== void 0;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size45, minLength2, maxLength2, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, void 0, customSlices);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkBigInt.js
function halveBigInt(n) {
  return n / SBigInt(2);
}
function shrinkBigInt(current2, target, tryTargetAsap) {
  const realGap = current2 - target;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
    for (let toremove = gap; toremove > 0; toremove = halveBigInt(toremove)) {
      const next6 = current2 - toremove;
      yield new Value(next6, previous2);
      previous2 = next6;
    }
  }
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveBigInt(toremove)) {
      const next6 = current2 - toremove;
      yield new Value(next6, previous2);
      previous2 = next6;
    }
  }
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/BigIntArbitrary.js
var BigIntArbitrary = class _BigIntArbitrary extends Arbitrary {
  constructor(min11, max14) {
    super();
    this.min = min11;
    this.max = max14;
  }
  generate(mrng, biasFactor) {
    const range6 = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextBigInt(range6.min, range6.max), void 0);
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, bigIntLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id3 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id3 < 0 ? ranges[0] : ranges[id3 + 1];
  }
  canShrinkWithoutContext(value10) {
    return typeof value10 === "bigint" && this.min <= value10 && value10 <= this.max;
  }
  shrink(current2, context15) {
    if (!_BigIntArbitrary.isValidContext(current2, context15)) {
      const target = this.defaultTarget();
      return shrinkBigInt(current2, target, true);
    }
    if (this.isLastChanceTry(current2, context15)) {
      return Stream.of(new Value(context15, void 0));
    }
    return shrinkBigInt(current2, context15, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return SBigInt(0);
    }
    return this.min < 0 ? this.max : this.min;
  }
  isLastChanceTry(current2, context15) {
    if (current2 > 0)
      return current2 === context15 + SBigInt(1) && current2 > this.min;
    if (current2 < 0)
      return current2 === context15 - SBigInt(1) && current2 < this.max;
    return false;
  }
  static isValidContext(current2, context15) {
    if (context15 === void 0) {
      return false;
    }
    if (typeof context15 !== "bigint") {
      throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);
    }
    const differentSigns = current2 > 0 && context15 < 0 || current2 < 0 && context15 > 0;
    if (context15 !== SBigInt(0) && differentSigns) {
      throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);
    }
    return true;
  }
};

// node_modules/fast-check/lib/esm/arbitrary/bigInt.js
function buildCompleteBigIntConstraints(constraints) {
  const DefaultPow = 256;
  const DefaultMin = SBigInt(-1) << SBigInt(DefaultPow - 1);
  const DefaultMax = (SBigInt(1) << SBigInt(DefaultPow - 1)) - SBigInt(1);
  const min11 = constraints.min;
  const max14 = constraints.max;
  return {
    min: min11 !== void 0 ? min11 : DefaultMin - (max14 !== void 0 && max14 < SBigInt(0) ? max14 * max14 : SBigInt(0)),
    max: max14 !== void 0 ? max14 : DefaultMax + (min11 !== void 0 && min11 > SBigInt(0) ? min11 * min11 : SBigInt(0))
  };
}
function extractBigIntConstraints(args2) {
  if (args2[0] === void 0) {
    return {};
  }
  if (args2[1] === void 0) {
    const constraints = args2[0];
    return constraints;
  }
  return { min: args2[0], max: args2[1] };
}
function bigInt(...args2) {
  const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args2));
  if (constraints.min > constraints.max) {
    throw new Error("fc.bigInt expects max to be greater than or equal to min");
  }
  return new BigIntArbitrary(constraints.min, constraints.max);
}

// node_modules/fast-check/lib/esm/arbitrary/bigIntN.js
function bigIntN(n) {
  if (n < 1) {
    throw new Error("fc.bigIntN expects requested number of bits to be superior or equal to 1");
  }
  const min11 = SBigInt(-1) << SBigInt(n - 1);
  const max14 = (SBigInt(1) << SBigInt(n - 1)) - SBigInt(1);
  return new BigIntArbitrary(min11, max14);
}

// node_modules/fast-check/lib/esm/arbitrary/bigUint.js
function computeDefaultMax() {
  return (SBigInt(1) << SBigInt(256)) - SBigInt(1);
}
function bigUint(constraints) {
  const requestedMax = typeof constraints === "object" ? constraints.max : constraints;
  const max14 = requestedMax !== void 0 ? requestedMax : computeDefaultMax();
  if (max14 < 0) {
    throw new Error("fc.bigUint expects max to be greater than or equal to zero");
  }
  return new BigIntArbitrary(SBigInt(0), max14);
}

// node_modules/fast-check/lib/esm/arbitrary/bigUintN.js
function bigUintN(n) {
  if (n < 0) {
    throw new Error("fc.bigUintN expects requested number of bits to be superior or equal to 0");
  }
  const min11 = SBigInt(0);
  const max14 = (SBigInt(1) << SBigInt(n)) - SBigInt(1);
  return new BigIntArbitrary(min11, max14);
}

// node_modules/fast-check/lib/esm/arbitrary/noBias.js
function noBias(arb) {
  return arb.noBias();
}

// node_modules/fast-check/lib/esm/arbitrary/boolean.js
function booleanMapper(v) {
  return v === 1;
}
function booleanUnmapper(v) {
  if (typeof v !== "boolean")
    throw new Error("Unsupported input type");
  return v === true ? 1 : 0;
}
function boolean3() {
  return noBias(integer({ min: 0, max: 1 }).map(booleanMapper, booleanUnmapper));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js
var safeObjectIs3 = Object.is;
var ConstantArbitrary = class extends Arbitrary {
  constructor(values15) {
    super();
    this.values = values15;
  }
  generate(mrng, _biasFactor) {
    const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);
    const value10 = this.values[idx];
    if (!hasCloneMethod(value10)) {
      return new Value(value10, idx);
    }
    return new Value(value10, idx, () => value10[cloneMethod]());
  }
  canShrinkWithoutContext(value10) {
    if (this.values.length === 1) {
      return safeObjectIs3(this.values[0], value10);
    }
    if (this.fastValues === void 0) {
      this.fastValues = new FastConstantValuesLookup(this.values);
    }
    return this.fastValues.has(value10);
  }
  shrink(value10, context15) {
    if (context15 === 0 || safeObjectIs3(value10, this.values[0])) {
      return Stream.nil();
    }
    return Stream.of(new Value(this.values[0], 0));
  }
};
var FastConstantValuesLookup = class {
  constructor(values15) {
    this.values = values15;
    this.fastValues = new SSet(this.values);
    let hasMinusZero = false;
    let hasPlusZero = false;
    if (safeHas(this.fastValues, 0)) {
      for (let idx = 0; idx !== this.values.length; ++idx) {
        const value10 = this.values[idx];
        hasMinusZero = hasMinusZero || safeObjectIs3(value10, -0);
        hasPlusZero = hasPlusZero || safeObjectIs3(value10, 0);
      }
    }
    this.hasMinusZero = hasMinusZero;
    this.hasPlusZero = hasPlusZero;
  }
  has(value10) {
    if (value10 === 0) {
      if (safeObjectIs3(value10, 0)) {
        return this.hasPlusZero;
      }
      return this.hasMinusZero;
    }
    return safeHas(this.fastValues, value10);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/constantFrom.js
function constantFrom(...values15) {
  if (values15.length === 0) {
    throw new Error("fc.constantFrom expects at least one parameter");
  }
  return new ConstantArbitrary(values15);
}

// node_modules/fast-check/lib/esm/arbitrary/falsy.js
function falsy(constraints) {
  if (!constraints || !constraints.withBigInt) {
    return constantFrom(false, null, void 0, 0, "", NaN);
  }
  return constantFrom(false, null, void 0, 0, "", NaN, SBigInt(0));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js
var indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
  if (typeof c !== "string") {
    throw new Error("Cannot unmap non-string");
  }
  if (c.length === 0 || c.length > 2) {
    throw new Error("Cannot unmap string with more or less than one character");
  }
  const c1 = safeCharCodeAt(c, 0);
  if (c.length === 1) {
    return c1;
  }
  const c2 = safeCharCodeAt(c, 1);
  if (c1 < 55296 || c1 > 56319 || c2 < 56320 || c2 > 57343) {
    throw new Error("Cannot unmap invalid surrogate pairs");
  }
  return c.codePointAt(0);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
function buildCharacterArbitrary(min11, max14, mapToCode, unmapFromCode) {
  return integer({ min: min11, max: max14 }).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js
function indexToPrintableIndexMapper(v) {
  if (v < 95)
    return v + 32;
  if (v <= 126)
    return v - 95;
  return v;
}
function indexToPrintableIndexUnmapper(v) {
  if (v >= 32 && v <= 126)
    return v - 32;
  if (v >= 0 && v <= 31)
    return v + 95;
  return v;
}

// node_modules/fast-check/lib/esm/arbitrary/ascii.js
function ascii() {
  return buildCharacterArbitrary(0, 127, indexToPrintableIndexMapper, indexToPrintableIndexUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/base64.js
function base64Mapper(v) {
  if (v < 26)
    return v + 65;
  if (v < 52)
    return v + 97 - 26;
  if (v < 62)
    return v + 48 - 52;
  return v === 62 ? 43 : 47;
}
function base64Unmapper(v) {
  if (v >= 65 && v <= 90)
    return v - 65;
  if (v >= 97 && v <= 122)
    return v - 97 + 26;
  if (v >= 48 && v <= 57)
    return v - 48 + 52;
  return v === 43 ? 62 : v === 47 ? 63 : -1;
}
function base64() {
  return buildCharacterArbitrary(0, 63, base64Mapper, base64Unmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/char.js
function identity2(v) {
  return v;
}
function char() {
  return buildCharacterArbitrary(32, 126, identity2, identity2);
}

// node_modules/fast-check/lib/esm/arbitrary/char16bits.js
function char16bits() {
  return buildCharacterArbitrary(0, 65535, indexToPrintableIndexMapper, indexToPrintableIndexUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js
var gapSize = 57343 + 1 - 55296;
function unicodeMapper(v) {
  if (v < 55296)
    return indexToPrintableIndexMapper(v);
  return v + gapSize;
}
function unicodeUnmapper(v) {
  if (v < 55296)
    return indexToPrintableIndexUnmapper(v);
  if (v <= 57343)
    return -1;
  return v - gapSize;
}
function fullUnicode() {
  return buildCharacterArbitrary(0, 1114111 - gapSize, unicodeMapper, unicodeUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/hexa.js
function hexaMapper(v) {
  return v < 10 ? v + 48 : v + 97 - 10;
}
function hexaUnmapper(v) {
  return v < 58 ? v - 48 : v >= 97 && v < 103 ? v - 97 + 10 : -1;
}
function hexa() {
  return buildCharacterArbitrary(0, 15, hexaMapper, hexaUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/unicode.js
var gapSize2 = 57343 + 1 - 55296;
function unicodeMapper2(v) {
  if (v < 55296)
    return indexToPrintableIndexMapper(v);
  return v + gapSize2;
}
function unicodeUnmapper2(v) {
  if (v < 55296)
    return indexToPrintableIndexUnmapper(v);
  if (v <= 57343)
    return -1;
  return v - gapSize2;
}
function unicode() {
  return buildCharacterArbitrary(0, 65535 - gapSize2, unicodeMapper2, unicodeUnmapper2);
}

// node_modules/fast-check/lib/esm/arbitrary/constant.js
function constant2(value10) {
  return new ConstantArbitrary([value10]);
}

// node_modules/fast-check/lib/esm/arbitrary/context.js
var ContextImplem = class _ContextImplem {
  constructor() {
    this.receivedLogs = [];
  }
  log(data) {
    this.receivedLogs.push(data);
  }
  size() {
    return this.receivedLogs.length;
  }
  toString() {
    return JSON.stringify({ logs: this.receivedLogs });
  }
  [cloneMethod]() {
    return new _ContextImplem();
  }
};
function context() {
  return constant2(new ContextImplem());
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js
var safeNaN = Number.NaN;
var safeNumberIsNaN2 = Number.isNaN;
function timeToDateMapper(time3) {
  return new SDate(time3);
}
function timeToDateUnmapper(value10) {
  if (!(value10 instanceof SDate) || value10.constructor !== SDate) {
    throw new SError("Not a valid value for date unmapper");
  }
  return safeGetTime(value10);
}
function timeToDateMapperWithNaN(valueForNaN) {
  return (time3) => {
    return time3 === valueForNaN ? new SDate(safeNaN) : timeToDateMapper(time3);
  };
}
function timeToDateUnmapperWithNaN(valueForNaN) {
  return (value10) => {
    const time3 = timeToDateUnmapper(value10);
    return safeNumberIsNaN2(time3) ? valueForNaN : time3;
  };
}

// node_modules/fast-check/lib/esm/arbitrary/date.js
var safeNumberIsNaN3 = Number.isNaN;
function date(constraints = {}) {
  const intMin = constraints.min !== void 0 ? safeGetTime(constraints.min) : -864e13;
  const intMax = constraints.max !== void 0 ? safeGetTime(constraints.max) : 864e13;
  const noInvalidDate = constraints.noInvalidDate === void 0 || constraints.noInvalidDate;
  if (safeNumberIsNaN3(intMin))
    throw new Error("fc.date min must be valid instance of Date");
  if (safeNumberIsNaN3(intMax))
    throw new Error("fc.date max must be valid instance of Date");
  if (intMin > intMax)
    throw new Error("fc.date max must be greater or equal to min");
  if (noInvalidDate) {
    return integer({ min: intMin, max: intMax }).map(timeToDateMapper, timeToDateUnmapper);
  }
  const valueForNaN = intMax + 1;
  return integer({ min: intMin, max: intMax + 1 }).map(timeToDateMapperWithNaN(valueForNaN), timeToDateUnmapperWithNaN(valueForNaN));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js
var safeSymbolIterator2 = Symbol.iterator;
var safeIsArray = Array.isArray;
var safeObjectIs4 = Object.is;
var CloneArbitrary = class _CloneArbitrary extends Arbitrary {
  constructor(arb, numValues) {
    super();
    this.arb = arb;
    this.numValues = numValues;
  }
  generate(mrng, biasFactor) {
    const items = [];
    if (this.numValues <= 0) {
      return this.wrapper(items);
    }
    for (let idx = 0; idx !== this.numValues - 1; ++idx) {
      safePush(items, this.arb.generate(mrng.clone(), biasFactor));
    }
    safePush(items, this.arb.generate(mrng, biasFactor));
    return this.wrapper(items);
  }
  canShrinkWithoutContext(value10) {
    if (!safeIsArray(value10) || value10.length !== this.numValues) {
      return false;
    }
    if (value10.length === 0) {
      return true;
    }
    for (let index3 = 1; index3 < value10.length; ++index3) {
      if (!safeObjectIs4(value10[0], value10[index3])) {
        return false;
      }
    }
    return this.arb.canShrinkWithoutContext(value10[0]);
  }
  shrink(value10, context15) {
    if (value10.length === 0) {
      return Stream.nil();
    }
    return new Stream(this.shrinkImpl(value10, context15 !== void 0 ? context15 : [])).map((v) => this.wrapper(v));
  }
  *shrinkImpl(value10, contexts) {
    const its = safeMap(value10, (v, idx) => this.arb.shrink(v, contexts[idx])[safeSymbolIterator2]());
    let cur = safeMap(its, (it) => it.next());
    while (!cur[0].done) {
      yield safeMap(cur, (c) => c.value);
      cur = safeMap(its, (it) => it.next());
    }
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  wrapper(items) {
    let cloneable = false;
    const vs = [];
    const contexts = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(contexts, s.context);
    }
    if (cloneable) {
      _CloneArbitrary.makeItCloneable(vs, items);
    }
    return new Value(vs, contexts);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/clone.js
function clone(arb, numValues) {
  return new CloneArbitrary(arb, numValues);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/CustomEqualSet.js
var CustomEqualSet = class {
  constructor(isEqual4) {
    this.isEqual = isEqual4;
    this.data = [];
  }
  tryAdd(value10) {
    for (let idx = 0; idx !== this.data.length; ++idx) {
      if (this.isEqual(this.data[idx], value10)) {
        return false;
      }
    }
    safePush(this.data, value10);
    return true;
  }
  size() {
    return this.data.length;
  }
  getData() {
    return this.data;
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js
var safeNumberIsNaN4 = Number.isNaN;
var StrictlyEqualSet = class {
  constructor(selector) {
    this.selector = selector;
    this.selectedItemsExceptNaN = new SSet();
    this.data = [];
  }
  tryAdd(value10) {
    const selected = this.selector(value10);
    if (safeNumberIsNaN4(selected)) {
      safePush(this.data, value10);
      return true;
    }
    const sizeBefore = this.selectedItemsExceptNaN.size;
    safeAdd(this.selectedItemsExceptNaN, selected);
    if (sizeBefore !== this.selectedItemsExceptNaN.size) {
      safePush(this.data, value10);
      return true;
    }
    return false;
  }
  size() {
    return this.data.length;
  }
  getData() {
    return this.data;
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueSet.js
var safeObjectIs5 = Object.is;
var SameValueSet = class {
  constructor(selector) {
    this.selector = selector;
    this.selectedItemsExceptMinusZero = new SSet();
    this.data = [];
    this.hasMinusZero = false;
  }
  tryAdd(value10) {
    const selected = this.selector(value10);
    if (safeObjectIs5(selected, -0)) {
      if (this.hasMinusZero) {
        return false;
      }
      safePush(this.data, value10);
      this.hasMinusZero = true;
      return true;
    }
    const sizeBefore = this.selectedItemsExceptMinusZero.size;
    safeAdd(this.selectedItemsExceptMinusZero, selected);
    if (sizeBefore !== this.selectedItemsExceptMinusZero.size) {
      safePush(this.data, value10);
      return true;
    }
    return false;
  }
  size() {
    return this.data.length;
  }
  getData() {
    return this.data;
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueZeroSet.js
var SameValueZeroSet = class {
  constructor(selector) {
    this.selector = selector;
    this.selectedItems = new SSet();
    this.data = [];
  }
  tryAdd(value10) {
    const selected = this.selector(value10);
    const sizeBefore = this.selectedItems.size;
    safeAdd(this.selectedItems, selected);
    if (sizeBefore !== this.selectedItems.size) {
      safePush(this.data, value10);
      return true;
    }
    return false;
  }
  size() {
    return this.data.length;
  }
  getData() {
    return this.data;
  }
};

// node_modules/fast-check/lib/esm/arbitrary/uniqueArray.js
function buildUniqueArraySetBuilder(constraints) {
  if (typeof constraints.comparator === "function") {
    if (constraints.selector === void 0) {
      const comparator2 = constraints.comparator;
      const isEqualForBuilder2 = (nextA, nextB) => comparator2(nextA.value_, nextB.value_);
      return () => new CustomEqualSet(isEqualForBuilder2);
    }
    const comparator = constraints.comparator;
    const selector2 = constraints.selector;
    const refinedSelector2 = (next6) => selector2(next6.value_);
    const isEqualForBuilder = (nextA, nextB) => comparator(refinedSelector2(nextA), refinedSelector2(nextB));
    return () => new CustomEqualSet(isEqualForBuilder);
  }
  const selector = constraints.selector || ((v) => v);
  const refinedSelector = (next6) => selector(next6.value_);
  switch (constraints.comparator) {
    case "IsStrictlyEqual":
      return () => new StrictlyEqualSet(refinedSelector);
    case "SameValueZero":
      return () => new SameValueZeroSet(refinedSelector);
    case "SameValue":
    case void 0:
      return () => new SameValueSet(refinedSelector);
  }
}
function uniqueArray(arb, constraints = {}) {
  const minLength2 = constraints.minLength !== void 0 ? constraints.minLength : 0;
  const maxLength2 = constraints.maxLength !== void 0 ? constraints.maxLength : MaxLengthUpperBound;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(constraints.size, minLength2, maxLength2, constraints.maxLength !== void 0);
  const depthIdentifier = constraints.depthIdentifier;
  const setBuilder = buildUniqueArraySetBuilder(constraints);
  const arrayArb = new ArrayArbitrary(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, setBuilder, []);
  if (minLength2 === 0)
    return arrayArb;
  return arrayArb.filter((tab) => tab.length >= minLength2);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/KeyValuePairsToObject.js
var safeObjectCreate = Object.create;
var safeObjectDefineProperty3 = Object.defineProperty;
var safeObjectGetOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
var safeObjectGetPrototypeOf2 = Object.getPrototypeOf;
var safeObjectGetOwnPropertySymbols2 = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
var safeObjectEntries = Object.entries;
function keyValuePairsToObjectMapper(definition) {
  const obj = definition[1] ? safeObjectCreate(null) : {};
  for (const keyValue of definition[0]) {
    safeObjectDefineProperty3(obj, keyValue[0], {
      enumerable: true,
      configurable: true,
      writable: true,
      value: keyValue[1]
    });
  }
  return obj;
}
function buildIsValidPropertyNameFilter(obj) {
  return function isValidPropertyNameFilter(key) {
    const descriptor3 = safeObjectGetOwnPropertyDescriptor2(obj, key);
    return descriptor3 !== void 0 && !!descriptor3.configurable && !!descriptor3.enumerable && !!descriptor3.writable && descriptor3.get === void 0 && descriptor3.set === void 0;
  };
}
function keyValuePairsToObjectUnmapper(value10) {
  if (typeof value10 !== "object" || value10 === null) {
    throw new SError("Incompatible instance received: should be a non-null object");
  }
  const hasNullPrototype = safeObjectGetPrototypeOf2(value10) === null;
  const hasObjectPrototype = "constructor" in value10 && value10.constructor === Object;
  if (!hasNullPrototype && !hasObjectPrototype) {
    throw new SError("Incompatible instance received: should be of exact type Object");
  }
  if (safeObjectGetOwnPropertySymbols2(value10).length > 0) {
    throw new SError("Incompatible instance received: should contain symbols");
  }
  if (!safeEvery(safeObjectGetOwnPropertyNames(value10), buildIsValidPropertyNameFilter(value10))) {
    throw new SError("Incompatible instance received: should contain only c/e/w properties without get/set");
  }
  return [safeObjectEntries(value10), hasNullPrototype];
}

// node_modules/fast-check/lib/esm/arbitrary/dictionary.js
function dictionaryKeyExtractor(entry) {
  return entry[0];
}
function dictionary(keyArb, valueArb, constraints = {}) {
  const noNullPrototype = constraints.noNullPrototype !== false;
  return tuple4(uniqueArray(tuple4(keyArb, valueArb), {
    minLength: constraints.minKeys,
    maxLength: constraints.maxKeys,
    size: constraints.size,
    selector: dictionaryKeyExtractor,
    depthIdentifier: constraints.depthIdentifier
  }), noNullPrototype ? constant2(false) : boolean3()).map(keyValuePairsToObjectMapper, keyValuePairsToObjectUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js
var safePositiveInfinity2 = Number.POSITIVE_INFINITY;
var safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var safeNumberIsInteger3 = Number.isInteger;
var safeMathFloor5 = Math.floor;
var safeMathPow = Math.pow;
var safeMathMin4 = Math.min;
var FrequencyArbitrary = class _FrequencyArbitrary extends Arbitrary {
  static from(warbs, constraints, label) {
    if (warbs.length === 0) {
      throw new Error(`${label} expects at least one weighted arbitrary`);
    }
    let totalWeight = 0;
    for (let idx = 0; idx !== warbs.length; ++idx) {
      const currentArbitrary = warbs[idx].arbitrary;
      if (currentArbitrary === void 0) {
        throw new Error(`${label} expects arbitraries to be specified`);
      }
      const currentWeight = warbs[idx].weight;
      totalWeight += currentWeight;
      if (!safeNumberIsInteger3(currentWeight)) {
        throw new Error(`${label} expects weights to be integer values`);
      }
      if (currentWeight < 0) {
        throw new Error(`${label} expects weights to be superior or equal to 0`);
      }
    }
    if (totalWeight <= 0) {
      throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);
    }
    const sanitizedConstraints = {
      depthBias: depthBiasFromSizeForArbitrary(constraints.depthSize, constraints.maxDepth !== void 0),
      maxDepth: constraints.maxDepth != void 0 ? constraints.maxDepth : safePositiveInfinity2,
      withCrossShrink: !!constraints.withCrossShrink
    };
    return new _FrequencyArbitrary(warbs, sanitizedConstraints, getDepthContextFor(constraints.depthIdentifier));
  }
  constructor(warbs, constraints, context15) {
    super();
    this.warbs = warbs;
    this.constraints = constraints;
    this.context = context15;
    let currentWeight = 0;
    this.cumulatedWeights = [];
    for (let idx = 0; idx !== warbs.length; ++idx) {
      currentWeight += warbs[idx].weight;
      safePush(this.cumulatedWeights, currentWeight);
    }
    this.totalWeight = currentWeight;
  }
  generate(mrng, biasFactor) {
    if (this.mustGenerateFirst()) {
      return this.safeGenerateForIndex(mrng, 0, biasFactor);
    }
    const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);
    for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {
      if (selected < this.cumulatedWeights[idx]) {
        return this.safeGenerateForIndex(mrng, idx, biasFactor);
      }
    }
    throw new Error(`Unable to generate from fc.frequency`);
  }
  canShrinkWithoutContext(value10) {
    return this.canShrinkWithoutContextIndex(value10) !== -1;
  }
  shrink(value10, context15) {
    if (context15 !== void 0) {
      const safeContext = context15;
      const selectedIndex = safeContext.selectedIndex;
      const originalBias = safeContext.originalBias;
      const originalArbitrary = this.warbs[selectedIndex].arbitrary;
      const originalShrinks = originalArbitrary.shrink(value10, safeContext.originalContext).map((v) => this.mapIntoValue(selectedIndex, v, null, originalBias));
      if (safeContext.clonedMrngForFallbackFirst !== null) {
        if (safeContext.cachedGeneratedForFirst === void 0) {
          safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);
        }
        const valueFromFirst = safeContext.cachedGeneratedForFirst;
        return Stream.of(valueFromFirst).join(originalShrinks);
      }
      return originalShrinks;
    }
    const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value10);
    if (potentialSelectedIndex === -1) {
      return Stream.nil();
    }
    return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value10, void 0).map((v) => this.mapIntoValue(potentialSelectedIndex, v, null, void 0)));
  }
  defaultShrinkForFirst(selectedIndex) {
    ++this.context.depth;
    try {
      if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === void 0) {
        return Stream.nil();
      }
    } finally {
      --this.context.depth;
    }
    const rawShrinkValue = new Value(this.warbs[0].fallbackValue.default, void 0);
    return Stream.of(this.mapIntoValue(0, rawShrinkValue, null, void 0));
  }
  canShrinkWithoutContextIndex(value10) {
    if (this.mustGenerateFirst()) {
      return this.warbs[0].arbitrary.canShrinkWithoutContext(value10) ? 0 : -1;
    }
    try {
      ++this.context.depth;
      for (let idx = 0; idx !== this.warbs.length; ++idx) {
        const warb = this.warbs[idx];
        if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value10)) {
          return idx;
        }
      }
      return -1;
    } finally {
      --this.context.depth;
    }
  }
  mapIntoValue(idx, value10, clonedMrngForFallbackFirst, biasFactor) {
    const context15 = {
      selectedIndex: idx,
      originalBias: biasFactor,
      originalContext: value10.context,
      clonedMrngForFallbackFirst
    };
    return new Value(value10.value, context15);
  }
  safeGenerateForIndex(mrng, idx, biasFactor) {
    ++this.context.depth;
    try {
      const value10 = this.warbs[idx].arbitrary.generate(mrng, biasFactor);
      const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;
      return this.mapIntoValue(idx, value10, clonedMrngForFallbackFirst, biasFactor);
    } finally {
      --this.context.depth;
    }
  }
  mustGenerateFirst() {
    return this.constraints.maxDepth <= this.context.depth;
  }
  mustFallbackToFirstInShrink(idx) {
    return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;
  }
  computeNegDepthBenefit() {
    const depthBias = this.constraints.depthBias;
    if (depthBias <= 0 || this.warbs[0].weight === 0) {
      return 0;
    }
    const depthBenefit = safeMathFloor5(safeMathPow(1 + depthBias, this.context.depth)) - 1;
    return -safeMathMin4(this.totalWeight * depthBenefit, safeMaxSafeInteger) || 0;
  }
};

// node_modules/fast-check/lib/esm/arbitrary/oneof.js
function isOneOfContraints(param) {
  return param != null && typeof param === "object" && !("generate" in param) && !("arbitrary" in param) && !("weight" in param);
}
function toWeightedArbitrary(maybeWeightedArbitrary) {
  if (isArbitrary(maybeWeightedArbitrary)) {
    return { arbitrary: maybeWeightedArbitrary, weight: 1 };
  }
  return maybeWeightedArbitrary;
}
function oneof(...args2) {
  const constraints = args2[0];
  if (isOneOfContraints(constraints)) {
    const weightedArbs2 = safeMap(safeSlice(args2, 1), toWeightedArbitrary);
    return FrequencyArbitrary.from(weightedArbs2, constraints, "fc.oneof");
  }
  const weightedArbs = safeMap(args2, toWeightedArbitrary);
  return FrequencyArbitrary.from(weightedArbs, {}, "fc.oneof");
}

// node_modules/fast-check/lib/esm/arbitrary/nat.js
var safeNumberIsInteger4 = Number.isInteger;
function nat(arg) {
  const max14 = typeof arg === "number" ? arg : arg && arg.max !== void 0 ? arg.max : 2147483647;
  if (max14 < 0) {
    throw new Error("fc.nat value should be greater than or equal to 0");
  }
  if (!safeNumberIsInteger4(max14)) {
    throw new Error("fc.nat maximum value should be an integer");
  }
  return new IntegerArbitrary(0, max14);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js
var safeObjectIs6 = Object.is;
function buildDichotomyEntries(entries6) {
  let currentFrom = 0;
  const dichotomyEntries = [];
  for (const entry of entries6) {
    const from29 = currentFrom;
    currentFrom = from29 + entry.num;
    const to3 = currentFrom - 1;
    dichotomyEntries.push({ from: from29, to: to3, entry });
  }
  return dichotomyEntries;
}
function findDichotomyEntry(dichotomyEntries, choiceIndex) {
  let min11 = 0;
  let max14 = dichotomyEntries.length;
  while (max14 - min11 > 1) {
    const mid = ~~((min11 + max14) / 2);
    if (choiceIndex < dichotomyEntries[mid].from) {
      max14 = mid;
    } else {
      min11 = mid;
    }
  }
  return dichotomyEntries[min11];
}
function indexToMappedConstantMapperFor(entries6) {
  const dichotomyEntries = buildDichotomyEntries(entries6);
  return function indexToMappedConstantMapper(choiceIndex) {
    const dichotomyEntry = findDichotomyEntry(dichotomyEntries, choiceIndex);
    return dichotomyEntry.entry.build(choiceIndex - dichotomyEntry.from);
  };
}
function buildReverseMapping(entries6) {
  const reverseMapping = { mapping: new SMap(), negativeZeroIndex: void 0 };
  let choiceIndex = 0;
  for (let entryIdx = 0; entryIdx !== entries6.length; ++entryIdx) {
    const entry = entries6[entryIdx];
    for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {
      const value10 = entry.build(idxInEntry);
      if (value10 === 0 && 1 / value10 === SNumber.NEGATIVE_INFINITY) {
        reverseMapping.negativeZeroIndex = choiceIndex;
      } else {
        safeMapSet(reverseMapping.mapping, value10, choiceIndex);
      }
      ++choiceIndex;
    }
  }
  return reverseMapping;
}
function indexToMappedConstantUnmapperFor(entries6) {
  let reverseMapping = null;
  return function indexToMappedConstantUnmapper(value10) {
    if (reverseMapping === null) {
      reverseMapping = buildReverseMapping(entries6);
    }
    const choiceIndex = safeObjectIs6(value10, -0) ? reverseMapping.negativeZeroIndex : safeMapGet(reverseMapping.mapping, value10);
    if (choiceIndex === void 0) {
      throw new SError("Unknown value encountered cannot be built using this mapToConstant");
    }
    return choiceIndex;
  };
}

// node_modules/fast-check/lib/esm/arbitrary/mapToConstant.js
function computeNumChoices(options) {
  if (options.length === 0)
    throw new SError(`fc.mapToConstant expects at least one option`);
  let numChoices = 0;
  for (let idx = 0; idx !== options.length; ++idx) {
    if (options[idx].num < 0)
      throw new SError(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);
    numChoices += options[idx].num;
  }
  if (numChoices === 0)
    throw new SError(`fc.mapToConstant expects at least one choice among options`);
  return numChoices;
}
function mapToConstant(...entries6) {
  const numChoices = computeNumChoices(entries6);
  return nat({ max: numChoices - 1 }).map(indexToMappedConstantMapperFor(entries6), indexToMappedConstantUnmapperFor(entries6));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
var SMap2 = Map;
var safeStringFromCharCode = String.fromCharCode;
var lowerCaseMapper = { num: 26, build: (v) => safeStringFromCharCode(v + 97) };
var upperCaseMapper = { num: 26, build: (v) => safeStringFromCharCode(v + 65) };
var numericMapper = { num: 10, build: (v) => safeStringFromCharCode(v + 48) };
function percentCharArbMapper(c) {
  const encoded = SencodeURIComponent(c);
  return c !== encoded ? encoded : `%${safeNumberToString(safeCharCodeAt(c, 0), 16)}`;
}
function percentCharArbUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported");
  }
  const decoded = decodeURIComponent(value10);
  return decoded;
}
var percentCharArb = fullUnicode().map(percentCharArbMapper, percentCharArbUnmapper);
var lowerAlphaArbitrary = void 0;
function getOrCreateLowerAlphaArbitrary() {
  if (lowerAlphaArbitrary === void 0) {
    lowerAlphaArbitrary = mapToConstant(lowerCaseMapper);
  }
  return lowerAlphaArbitrary;
}
var lowerAlphaNumericArbitraries = void 0;
function getOrCreateLowerAlphaNumericArbitrary(others) {
  if (lowerAlphaNumericArbitraries === void 0) {
    lowerAlphaNumericArbitraries = new SMap2();
  }
  let match43 = safeMapGet(lowerAlphaNumericArbitraries, others);
  if (match43 === void 0) {
    match43 = mapToConstant(lowerCaseMapper, numericMapper, {
      num: others.length,
      build: (v) => others[v]
    });
    safeMapSet(lowerAlphaNumericArbitraries, others, match43);
  }
  return match43;
}
function buildAlphaNumericArbitrary(others) {
  return mapToConstant(lowerCaseMapper, upperCaseMapper, numericMapper, {
    num: others.length,
    build: (v) => others[v]
  });
}
var alphaNumericPercentArbitraries = void 0;
function getOrCreateAlphaNumericPercentArbitrary(others) {
  if (alphaNumericPercentArbitraries === void 0) {
    alphaNumericPercentArbitraries = new SMap2();
  }
  let match43 = safeMapGet(alphaNumericPercentArbitraries, others);
  if (match43 === void 0) {
    match43 = oneof({ weight: 10, arbitrary: buildAlphaNumericArbitrary(others) }, { weight: 1, arbitrary: percentCharArb });
    safeMapSet(alphaNumericPercentArbitraries, others, match43);
  }
  return match43;
}

// node_modules/fast-check/lib/esm/arbitrary/option.js
function option(arb, constraints = {}) {
  const freq = constraints.freq == null ? 5 : constraints.freq;
  const nilValue = safeHasOwnProperty(constraints, "nil") ? constraints.nil : null;
  const nilArb = constant2(nilValue);
  const weightedArbs = [
    { arbitrary: nilArb, weight: 1, fallbackValue: { default: nilValue } },
    { arbitrary: arb, weight: freq }
  ];
  const frequencyConstraints = {
    withCrossShrink: true,
    depthSize: constraints.depthSize,
    maxDepth: constraints.maxDepth,
    depthIdentifier: constraints.depthIdentifier
  };
  return FrequencyArbitrary.from(weightedArbs, frequencyConstraints, "fc.option");
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeString.js
function tokenizeString(patternsArb, value10, minLength2, maxLength2) {
  if (value10.length === 0) {
    if (minLength2 > 0) {
      return void 0;
    }
    return [];
  }
  if (maxLength2 <= 0) {
    return void 0;
  }
  const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];
  while (stack.length > 0) {
    const last8 = safePop(stack);
    for (let index3 = last8.nextStartIndex; index3 <= value10.length; ++index3) {
      const chunk7 = safeSubstring(value10, last8.endIndexChunks, index3);
      if (patternsArb.canShrinkWithoutContext(chunk7)) {
        const newChunks = [...last8.chunks, chunk7];
        if (index3 === value10.length) {
          if (newChunks.length < minLength2) {
            break;
          }
          return newChunks;
        }
        safePush(stack, { endIndexChunks: last8.endIndexChunks, nextStartIndex: index3 + 1, chunks: last8.chunks });
        if (newChunks.length < maxLength2) {
          safePush(stack, { endIndexChunks: index3, nextStartIndex: index3 + 1, chunks: newChunks });
        }
        break;
      }
    }
  }
  return void 0;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js
function patternsToStringMapper(tab) {
  return safeJoin(tab, "");
}
function minLengthFrom(constraints) {
  return constraints.minLength !== void 0 ? constraints.minLength : 0;
}
function maxLengthFrom(constraints) {
  return constraints.maxLength !== void 0 ? constraints.maxLength : MaxLengthUpperBound;
}
function patternsToStringUnmapperIsValidLength(tokens, constraints) {
  return minLengthFrom(constraints) <= tokens.length && tokens.length <= maxLengthFrom(constraints);
}
function patternsToStringUnmapperFor(patternsArb, constraints) {
  return function patternsToStringUnmapper(value10) {
    if (typeof value10 !== "string") {
      throw new SError("Unsupported value");
    }
    const tokens = tokenizeString(patternsArb, value10, minLengthFrom(constraints), maxLengthFrom(constraints));
    if (tokens === void 0) {
      throw new SError("Unable to unmap received string");
    }
    return tokens;
  };
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SlicesForStringBuilder.js
var dangerousStrings = [
  "__defineGetter__",
  "__defineSetter__",
  "__lookupGetter__",
  "__lookupSetter__",
  "__proto__",
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf",
  "apply",
  "arguments",
  "bind",
  "call",
  "caller",
  "length",
  "name",
  "prototype",
  "key",
  "ref"
];
function computeCandidateStringLegacy(dangerous, charArbitrary, stringSplitter) {
  let candidate;
  try {
    candidate = stringSplitter(dangerous);
  } catch (err2) {
    return void 0;
  }
  for (const entry of candidate) {
    if (!charArbitrary.canShrinkWithoutContext(entry)) {
      return void 0;
    }
  }
  return candidate;
}
function createSlicesForStringLegacy(charArbitrary, stringSplitter) {
  const slicesForString = [];
  for (const dangerous of dangerousStrings) {
    const candidate = computeCandidateStringLegacy(dangerous, charArbitrary, stringSplitter);
    if (candidate !== void 0) {
      safePush(slicesForString, candidate);
    }
  }
  return slicesForString;
}
var slicesPerArbitrary = /* @__PURE__ */ new WeakMap();
function createSlicesForStringNoConstraints(charArbitrary) {
  const slicesForString = [];
  for (const dangerous of dangerousStrings) {
    const candidate = tokenizeString(charArbitrary, dangerous, 0, MaxLengthUpperBound);
    if (candidate !== void 0) {
      safePush(slicesForString, candidate);
    }
  }
  return slicesForString;
}
function createSlicesForString(charArbitrary, constraints) {
  let slices = safeGet(slicesPerArbitrary, charArbitrary);
  if (slices === void 0) {
    slices = createSlicesForStringNoConstraints(charArbitrary);
    safeSet(slicesPerArbitrary, charArbitrary, slices);
  }
  const slicesForConstraints = [];
  for (const slice5 of slices) {
    if (patternsToStringUnmapperIsValidLength(slice5, constraints)) {
      safePush(slicesForConstraints, slice5);
    }
  }
  return slicesForConstraints;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/data/GraphemeRanges.js
var asciiAlphabetRanges = [[0, 127]];
var fullAlphabetRanges = [
  [0, 55295],
  [57344, 1114111]
];
var autonomousGraphemeRanges = [
  [32, 126],
  [160, 172],
  [174, 767],
  [880, 887],
  [890, 895],
  [900, 906],
  [908],
  [910, 929],
  [931, 1154],
  [1162, 1327],
  [1329, 1366],
  [1369, 1418],
  [1421, 1423],
  [1470],
  [1472],
  [1475],
  [1478],
  [1488, 1514],
  [1519, 1524],
  [1542, 1551],
  [1563],
  [1565, 1610],
  [1632, 1647],
  [1649, 1749],
  [1758],
  [1765, 1766],
  [1769],
  [1774, 1805],
  [1808],
  [1810, 1839],
  [1869, 1957],
  [1969],
  [1984, 2026],
  [2036, 2042],
  [2046, 2069],
  [2074],
  [2084],
  [2088],
  [2096, 2110],
  [2112, 2136],
  [2142],
  [2144, 2154],
  [2160, 2190],
  [2208, 2249],
  [2308, 2361],
  [2365],
  [2384],
  [2392, 2401],
  [2404, 2432],
  [2437, 2444],
  [2447, 2448],
  [2451, 2472],
  [2474, 2480],
  [2482],
  [2486, 2489],
  [2493],
  [2510],
  [2524, 2525],
  [2527, 2529],
  [2534, 2557],
  [2565, 2570],
  [2575, 2576],
  [2579, 2600],
  [2602, 2608],
  [2610, 2611],
  [2613, 2614],
  [2616, 2617],
  [2649, 2652],
  [2654],
  [2662, 2671],
  [2674, 2676],
  [2678],
  [2693, 2701],
  [2703, 2705],
  [2707, 2728],
  [2730, 2736],
  [2738, 2739],
  [2741, 2745],
  [2749],
  [2768],
  [2784, 2785],
  [2790, 2801],
  [2809],
  [2821, 2828],
  [2831, 2832],
  [2835, 2856],
  [2858, 2864],
  [2866, 2867],
  [2869, 2873],
  [2877],
  [2908, 2909],
  [2911, 2913],
  [2918, 2935],
  [2947],
  [2949, 2954],
  [2958, 2960],
  [2962, 2965],
  [2969, 2970],
  [2972],
  [2974, 2975],
  [2979, 2980],
  [2984, 2986],
  [2990, 3001],
  [3024],
  [3046, 3066],
  [3077, 3084],
  [3086, 3088],
  [3090, 3112],
  [3114, 3129],
  [3133],
  [3160, 3162],
  [3165],
  [3168, 3169],
  [3174, 3183],
  [3191, 3200],
  [3204, 3212],
  [3214, 3216],
  [3218, 3240],
  [3242, 3251],
  [3253, 3257],
  [3261],
  [3293, 3294],
  [3296, 3297],
  [3302, 3311],
  [3313, 3314],
  [3332, 3340],
  [3342, 3344],
  [3346, 3386],
  [3389],
  [3407],
  [3412, 3414],
  [3416, 3425],
  [3430, 3455],
  [3461, 3478],
  [3482, 3505],
  [3507, 3515],
  [3517],
  [3520, 3526],
  [3558, 3567],
  [3572],
  [3585, 3632],
  [3634],
  [3647, 3654],
  [3663, 3675],
  [3713, 3714],
  [3716],
  [3718, 3722],
  [3724, 3747],
  [3749],
  [3751, 3760],
  [3762],
  [3773],
  [3776, 3780],
  [3782],
  [3792, 3801],
  [3804, 3807],
  [3840, 3863],
  [3866, 3892],
  [3894],
  [3896],
  [3898, 3901],
  [3904, 3911],
  [3913, 3948],
  [3973],
  [3976, 3980],
  [4030, 4037],
  [4039, 4044],
  [4046, 4058],
  [4096, 4138],
  [4159, 4181],
  [4186, 4189],
  [4193],
  [4197, 4198],
  [4206, 4208],
  [4213, 4225],
  [4238],
  [4240, 4249],
  [4254, 4293],
  [4295],
  [4301],
  [4304, 4351],
  [4608, 4680],
  [4682, 4685],
  [4688, 4694],
  [4696],
  [4698, 4701],
  [4704, 4744],
  [4746, 4749],
  [4752, 4784],
  [4786, 4789],
  [4792, 4798],
  [4800],
  [4802, 4805],
  [4808, 4822],
  [4824, 4880],
  [4882, 4885],
  [4888, 4954],
  [4960, 4988],
  [4992, 5017],
  [5024, 5109],
  [5112, 5117],
  [5120, 5788],
  [5792, 5880],
  [5888, 5905],
  [5919, 5937],
  [5941, 5942],
  [5952, 5969],
  [5984, 5996],
  [5998, 6e3],
  [6016, 6067],
  [6100, 6108],
  [6112, 6121],
  [6128, 6137],
  [6144, 6154],
  [6160, 6169],
  [6176, 6264],
  [6272, 6276],
  [6279, 6312],
  [6314],
  [6320, 6389],
  [6400, 6430],
  [6464],
  [6468, 6509],
  [6512, 6516],
  [6528, 6571],
  [6576, 6601],
  [6608, 6618],
  [6622, 6678],
  [6686, 6740],
  [6784, 6793],
  [6800, 6809],
  [6816, 6829],
  [6917, 6963],
  [6981, 6988],
  [6992, 7018],
  [7028, 7038],
  [7043, 7072],
  [7086, 7141],
  [7164, 7203],
  [7227, 7241],
  [7245, 7304],
  [7312, 7354],
  [7357, 7367],
  [7379],
  [7401, 7404],
  [7406, 7411],
  [7413, 7414],
  [7418],
  [7424, 7615],
  [7680, 7957],
  [7960, 7965],
  [7968, 8005],
  [8008, 8013],
  [8016, 8023],
  [8025],
  [8027],
  [8029],
  [8031, 8061],
  [8064, 8116],
  [8118, 8132],
  [8134, 8147],
  [8150, 8155],
  [8157, 8175],
  [8178, 8180],
  [8182, 8190],
  [8192, 8202],
  [8208, 8233],
  [8239, 8287],
  [8304, 8305],
  [8308, 8334],
  [8336, 8348],
  [8352, 8384],
  [8448, 8587],
  [8592, 9254],
  [9280, 9290],
  [9312, 11123],
  [11126, 11157],
  [11159, 11502],
  [11506, 11507],
  [11513, 11557],
  [11559],
  [11565],
  [11568, 11623],
  [11631, 11632],
  [11648, 11670],
  [11680, 11686],
  [11688, 11694],
  [11696, 11702],
  [11704, 11710],
  [11712, 11718],
  [11720, 11726],
  [11728, 11734],
  [11736, 11742],
  [11776, 11869],
  [11904, 11929],
  [11931, 12019],
  [12032, 12245],
  [12272, 12329],
  [12336, 12351],
  [12353, 12438],
  [12443, 12543],
  [12549, 12591],
  [12593, 12686],
  [12688, 12771],
  [12783, 12830],
  [12832, 13312],
  [19903, 19968],
  [40959, 42124],
  [42128, 42182],
  [42192, 42539],
  [42560, 42606],
  [42611],
  [42622, 42653],
  [42656, 42735],
  [42738, 42743],
  [42752, 42954],
  [42960, 42961],
  [42963],
  [42965, 42969],
  [42994, 43009],
  [43011, 43013],
  [43015, 43018],
  [43020, 43042],
  [43048, 43051],
  [43056, 43065],
  [43072, 43127],
  [43138, 43187],
  [43214, 43225],
  [43250, 43262],
  [43264, 43301],
  [43310, 43334],
  [43359],
  [43396, 43442],
  [43457, 43469],
  [43471, 43481],
  [43486, 43492],
  [43494, 43518],
  [43520, 43560],
  [43584, 43586],
  [43588, 43595],
  [43600, 43609],
  [43612, 43642],
  [43646, 43695],
  [43697],
  [43701, 43702],
  [43705, 43709],
  [43712],
  [43714],
  [43739, 43754],
  [43760, 43764],
  [43777, 43782],
  [43785, 43790],
  [43793, 43798],
  [43808, 43814],
  [43816, 43822],
  [43824, 43883],
  [43888, 44002],
  [44011],
  [44016, 44025],
  [44032],
  [55203],
  [63744, 64109],
  [64112, 64217],
  [64256, 64262],
  [64275, 64279],
  [64285],
  [64287, 64310],
  [64312, 64316],
  [64318],
  [64320, 64321],
  [64323, 64324],
  [64326, 64450],
  [64467, 64911],
  [64914, 64967],
  [64975],
  [65008, 65023],
  [65040, 65049],
  [65072, 65106],
  [65108, 65126],
  [65128, 65131],
  [65136, 65140],
  [65142, 65276],
  [65281, 65437],
  [65440, 65470],
  [65474, 65479],
  [65482, 65487],
  [65490, 65495],
  [65498, 65500],
  [65504, 65510],
  [65512, 65518],
  [65532, 65533],
  [65536, 65547],
  [65549, 65574],
  [65576, 65594],
  [65596, 65597],
  [65599, 65613],
  [65616, 65629],
  [65664, 65786],
  [65792, 65794],
  [65799, 65843],
  [65847, 65934],
  [65936, 65948],
  [65952],
  [66e3, 66044],
  [66176, 66204],
  [66208, 66256],
  [66273, 66299],
  [66304, 66339],
  [66349, 66378],
  [66384, 66421],
  [66432, 66461],
  [66463, 66499],
  [66504, 66517],
  [66560, 66717],
  [66720, 66729],
  [66736, 66771],
  [66776, 66811],
  [66816, 66855],
  [66864, 66915],
  [66927, 66938],
  [66940, 66954],
  [66956, 66962],
  [66964, 66965],
  [66967, 66977],
  [66979, 66993],
  [66995, 67001],
  [67003, 67004],
  [67072, 67382],
  [67392, 67413],
  [67424, 67431],
  [67456, 67461],
  [67463, 67504],
  [67506, 67514],
  [67584, 67589],
  [67592],
  [67594, 67637],
  [67639, 67640],
  [67644],
  [67647, 67669],
  [67671, 67742],
  [67751, 67759],
  [67808, 67826],
  [67828, 67829],
  [67835, 67867],
  [67871, 67897],
  [67903],
  [67968, 68023],
  [68028, 68047],
  [68050, 68096],
  [68112, 68115],
  [68117, 68119],
  [68121, 68149],
  [68160, 68168],
  [68176, 68184],
  [68192, 68255],
  [68288, 68324],
  [68331, 68342],
  [68352, 68405],
  [68409, 68437],
  [68440, 68466],
  [68472, 68497],
  [68505, 68508],
  [68521, 68527],
  [68608, 68680],
  [68736, 68786],
  [68800, 68850],
  [68858, 68899],
  [68912, 68921],
  [69216, 69246],
  [69248, 69289],
  [69293],
  [69296, 69297],
  [69376, 69415],
  [69424, 69445],
  [69457, 69465],
  [69488, 69505],
  [69510, 69513],
  [69552, 69579],
  [69600, 69622],
  [69635, 69687],
  [69703, 69709],
  [69714, 69743],
  [69745, 69746],
  [69749],
  [69763, 69807],
  [69819, 69820],
  [69822, 69825],
  [69840, 69864],
  [69872, 69881],
  [69891, 69926],
  [69942, 69956],
  [69959],
  [69968, 70002],
  [70004, 70006],
  [70019, 70066],
  [70081],
  [70084, 70088],
  [70093],
  [70096, 70111],
  [70113, 70132],
  [70144, 70161],
  [70163, 70187],
  [70200, 70205],
  [70207, 70208],
  [70272, 70278],
  [70280],
  [70282, 70285],
  [70287, 70301],
  [70303, 70313],
  [70320, 70366],
  [70384, 70393],
  [70405, 70412],
  [70415, 70416],
  [70419, 70440],
  [70442, 70448],
  [70450, 70451],
  [70453, 70457],
  [70461],
  [70480],
  [70493, 70497],
  [70656, 70708],
  [70727, 70747],
  [70749],
  [70751, 70753],
  [70784, 70831],
  [70852, 70855],
  [70864, 70873],
  [71040, 71086],
  [71105, 71131],
  [71168, 71215],
  [71233, 71236],
  [71248, 71257],
  [71264, 71276],
  [71296, 71338],
  [71352, 71353],
  [71360, 71369],
  [71424, 71450],
  [71472, 71494],
  [71680, 71723],
  [71739],
  [71840, 71922],
  [71935, 71942],
  [71945],
  [71948, 71955],
  [71957, 71958],
  [71960, 71983],
  [72004, 72006],
  [72016, 72025],
  [72096, 72103],
  [72106, 72144],
  [72161, 72163],
  [72192],
  [72203, 72242],
  [72255, 72262],
  [72272],
  [72284, 72323],
  [72346, 72354],
  [72368, 72440],
  [72448, 72457],
  [72704, 72712],
  [72714, 72750],
  [72768, 72773],
  [72784, 72812],
  [72816, 72847],
  [72960, 72966],
  [72968, 72969],
  [72971, 73008],
  [73040, 73049],
  [73056, 73061],
  [73063, 73064],
  [73066, 73097],
  [73112],
  [73120, 73129],
  [73440, 73458],
  [73463, 73464],
  [73476, 73488],
  [73490, 73523],
  [73539, 73561],
  [73648],
  [73664, 73713],
  [73727, 74649],
  [74752, 74862],
  [74864, 74868],
  [74880, 75075],
  [77712, 77810],
  [77824, 78895],
  [78913, 78918],
  [82944, 83526],
  [92160, 92728],
  [92736, 92766],
  [92768, 92777],
  [92782, 92862],
  [92864, 92873],
  [92880, 92909],
  [92917],
  [92928, 92975],
  [92983, 92997],
  [93008, 93017],
  [93019, 93025],
  [93027, 93047],
  [93053, 93071],
  [93760, 93850],
  [93952, 94026],
  [94032],
  [94099, 94111],
  [94176, 94179],
  [94208],
  [100343],
  [100352, 101589],
  [101632],
  [101640],
  [110576, 110579],
  [110581, 110587],
  [110589, 110590],
  [110592, 110882],
  [110898],
  [110928, 110930],
  [110933],
  [110948, 110951],
  [110960, 111355],
  [113664, 113770],
  [113776, 113788],
  [113792, 113800],
  [113808, 113817],
  [113820],
  [113823],
  [118608, 118723],
  [118784, 119029],
  [119040, 119078],
  [119081, 119140],
  [119146, 119148],
  [119171, 119172],
  [119180, 119209],
  [119214, 119274],
  [119296, 119361],
  [119365],
  [119488, 119507],
  [119520, 119539],
  [119552, 119638],
  [119648, 119672],
  [119808, 119892],
  [119894, 119964],
  [119966, 119967],
  [119970],
  [119973, 119974],
  [119977, 119980],
  [119982, 119993],
  [119995],
  [119997, 120003],
  [120005, 120069],
  [120071, 120074],
  [120077, 120084],
  [120086, 120092],
  [120094, 120121],
  [120123, 120126],
  [120128, 120132],
  [120134],
  [120138, 120144],
  [120146, 120485],
  [120488, 120779],
  [120782, 121343],
  [121399, 121402],
  [121453, 121460],
  [121462, 121475],
  [121477, 121483],
  [122624, 122654],
  [122661, 122666],
  [122928, 122989],
  [123136, 123180],
  [123191, 123197],
  [123200, 123209],
  [123214, 123215],
  [123536, 123565],
  [123584, 123627],
  [123632, 123641],
  [123647],
  [124112, 124139],
  [124144, 124153],
  [124896, 124902],
  [124904, 124907],
  [124909, 124910],
  [124912, 124926],
  [124928, 125124],
  [125127, 125135],
  [125184, 125251],
  [125259],
  [125264, 125273],
  [125278, 125279],
  [126065, 126132],
  [126209, 126269],
  [126464, 126467],
  [126469, 126495],
  [126497, 126498],
  [126500],
  [126503],
  [126505, 126514],
  [126516, 126519],
  [126521],
  [126523],
  [126530],
  [126535],
  [126537],
  [126539],
  [126541, 126543],
  [126545, 126546],
  [126548],
  [126551],
  [126553],
  [126555],
  [126557],
  [126559],
  [126561, 126562],
  [126564],
  [126567, 126570],
  [126572, 126578],
  [126580, 126583],
  [126585, 126588],
  [126590],
  [126592, 126601],
  [126603, 126619],
  [126625, 126627],
  [126629, 126633],
  [126635, 126651],
  [126704, 126705],
  [126976, 127019],
  [127024, 127123],
  [127136, 127150],
  [127153, 127167],
  [127169, 127183],
  [127185, 127221],
  [127232, 127405],
  [127488, 127490],
  [127504, 127547],
  [127552, 127560],
  [127568, 127569],
  [127584, 127589],
  [127744, 127994],
  [128e3, 128727],
  [128732, 128748],
  [128752, 128764],
  [128768, 128886],
  [128891, 128985],
  [128992, 129003],
  [129008],
  [129024, 129035],
  [129040, 129095],
  [129104, 129113],
  [129120, 129159],
  [129168, 129197],
  [129200, 129201],
  [129280, 129619],
  [129632, 129645],
  [129648, 129660],
  [129664, 129672],
  [129680, 129725],
  [129727, 129733],
  [129742, 129755],
  [129760, 129768],
  [129776, 129784],
  [129792, 129938],
  [129940, 129994],
  [130032, 130041],
  [131072],
  [173791],
  [173824],
  [177977],
  [177984],
  [178205],
  [178208],
  [183969],
  [183984],
  [191456],
  [191472],
  [192093],
  [194560, 195101],
  [196608],
  [201546],
  [201552],
  [205743]
];
var autonomousDecomposableGraphemeRanges = [
  [192, 197],
  [199, 207],
  [209, 214],
  [217, 221],
  [224, 229],
  [231, 239],
  [241, 246],
  [249, 253],
  [255, 271],
  [274, 293],
  [296, 304],
  [308, 311],
  [313, 318],
  [323, 328],
  [332, 337],
  [340, 357],
  [360, 382],
  [416, 417],
  [431, 432],
  [461, 476],
  [478, 483],
  [486, 496],
  [500, 501],
  [504, 539],
  [542, 543],
  [550, 563],
  [901, 902],
  [904, 906],
  [908],
  [910, 912],
  [938, 944],
  [970, 974],
  [979, 980],
  [1024, 1025],
  [1027],
  [1031],
  [1036, 1038],
  [1049],
  [1081],
  [1104, 1105],
  [1107],
  [1111],
  [1116, 1118],
  [1142, 1143],
  [1217, 1218],
  [1232, 1235],
  [1238, 1239],
  [1242, 1247],
  [1250, 1255],
  [1258, 1269],
  [1272, 1273],
  [1570, 1574],
  [1728],
  [1730],
  [1747],
  [2345],
  [2353],
  [2356],
  [2392, 2399],
  [2524, 2525],
  [2527],
  [2611],
  [2614],
  [2649, 2651],
  [2654],
  [2908, 2909],
  [2964],
  [3907],
  [3917],
  [3922],
  [3927],
  [3932],
  [3945],
  [4134],
  [6918],
  [6920],
  [6922],
  [6924],
  [6926],
  [6930],
  [7680, 7833],
  [7835],
  [7840, 7929],
  [7936, 7957],
  [7960, 7965],
  [7968, 8005],
  [8008, 8013],
  [8016, 8023],
  [8025],
  [8027],
  [8029],
  [8031, 8048],
  [8050],
  [8052],
  [8054],
  [8056],
  [8058],
  [8060],
  [8064, 8116],
  [8118, 8122],
  [8124],
  [8129, 8132],
  [8134, 8136],
  [8138],
  [8140, 8146],
  [8150, 8154],
  [8157, 8162],
  [8164, 8170],
  [8172, 8173],
  [8178, 8180],
  [8182, 8184],
  [8186],
  [8188],
  [8602, 8603],
  [8622],
  [8653, 8655],
  [8708],
  [8713],
  [8716],
  [8740],
  [8742],
  [8769],
  [8772],
  [8775],
  [8777],
  [8800],
  [8802],
  [8813, 8817],
  [8820, 8821],
  [8824, 8825],
  [8832, 8833],
  [8836, 8837],
  [8840, 8841],
  [8876, 8879],
  [8928, 8931],
  [8938, 8941],
  [10972],
  [12364],
  [12366],
  [12368],
  [12370],
  [12372],
  [12374],
  [12376],
  [12378],
  [12380],
  [12382],
  [12384],
  [12386],
  [12389],
  [12391],
  [12393],
  [12400, 12401],
  [12403, 12404],
  [12406, 12407],
  [12409, 12410],
  [12412, 12413],
  [12436],
  [12446],
  [12460],
  [12462],
  [12464],
  [12466],
  [12468],
  [12470],
  [12472],
  [12474],
  [12476],
  [12478],
  [12480],
  [12482],
  [12485],
  [12487],
  [12489],
  [12496, 12497],
  [12499, 12500],
  [12502, 12503],
  [12505, 12506],
  [12508, 12509],
  [12532],
  [12535, 12538],
  [12542],
  [44032],
  [55203],
  [64285],
  [64287],
  [64298, 64310],
  [64312, 64316],
  [64318],
  [64320, 64321],
  [64323, 64324],
  [64326, 64334],
  [69786],
  [69788],
  [69803],
  [119134, 119140],
  [119227, 119232]
];

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js
var safeStringFromCodePoint = String.fromCodePoint;
var safeMathMin5 = Math.min;
var safeMathMax3 = Math.max;
function convertGraphemeRangeToMapToConstantEntry(range6) {
  if (range6.length === 1) {
    const codePointString = safeStringFromCodePoint(range6[0]);
    return { num: 1, build: () => codePointString };
  }
  const rangeStart = range6[0];
  return { num: range6[1] - range6[0] + 1, build: (idInGroup) => safeStringFromCodePoint(rangeStart + idInGroup) };
}
function intersectGraphemeRanges(rangesA, rangesB) {
  const mergedRanges = [];
  let cursorA = 0;
  let cursorB = 0;
  while (cursorA < rangesA.length && cursorB < rangesB.length) {
    const rangeA = rangesA[cursorA];
    const rangeAMin = rangeA[0];
    const rangeAMax = rangeA.length === 1 ? rangeA[0] : rangeA[1];
    const rangeB = rangesB[cursorB];
    const rangeBMin = rangeB[0];
    const rangeBMax = rangeB.length === 1 ? rangeB[0] : rangeB[1];
    if (rangeAMax < rangeBMin) {
      cursorA += 1;
    } else if (rangeBMax < rangeAMin) {
      cursorB += 1;
    } else {
      let min11 = safeMathMax3(rangeAMin, rangeBMin);
      const max14 = safeMathMin5(rangeAMax, rangeBMax);
      if (mergedRanges.length >= 1) {
        const lastMergedRange = mergedRanges[mergedRanges.length - 1];
        const lastMergedRangeMax = lastMergedRange.length === 1 ? lastMergedRange[0] : lastMergedRange[1];
        if (lastMergedRangeMax + 1 === min11) {
          min11 = lastMergedRange[0];
          safePop(mergedRanges);
        }
      }
      safePush(mergedRanges, min11 === max14 ? [min11] : [min11, max14]);
      if (rangeAMax <= max14) {
        cursorA += 1;
      }
      if (rangeBMax <= max14) {
        cursorB += 1;
      }
    }
  }
  return mergedRanges;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/StringUnitArbitrary.js
var registeredStringUnitInstancesMap = /* @__PURE__ */ Object.create(null);
function getAlphabetRanges(alphabet2) {
  switch (alphabet2) {
    case "full":
      return fullAlphabetRanges;
    case "ascii":
      return asciiAlphabetRanges;
  }
}
function getOrCreateStringUnitInstance(type8, alphabet2) {
  const key = `${type8}:${alphabet2}`;
  const registered = registeredStringUnitInstancesMap[key];
  if (registered !== void 0) {
    return registered;
  }
  const alphabetRanges = getAlphabetRanges(alphabet2);
  const ranges = type8 === "binary" ? alphabetRanges : intersectGraphemeRanges(alphabetRanges, autonomousGraphemeRanges);
  const entries6 = [];
  for (const range6 of ranges) {
    safePush(entries6, convertGraphemeRangeToMapToConstantEntry(range6));
  }
  if (type8 === "grapheme") {
    const decomposedRanges = intersectGraphemeRanges(alphabetRanges, autonomousDecomposableGraphemeRanges);
    for (const range6 of decomposedRanges) {
      const rawEntry = convertGraphemeRangeToMapToConstantEntry(range6);
      safePush(entries6, {
        num: rawEntry.num,
        build: (idInGroup) => safeNormalize(rawEntry.build(idInGroup), "NFD")
      });
    }
  }
  const stringUnitInstance = mapToConstant(...entries6);
  registeredStringUnitInstancesMap[key] = stringUnitInstance;
  return stringUnitInstance;
}
function stringUnit(type8, alphabet2) {
  return getOrCreateStringUnitInstance(type8, alphabet2);
}

// node_modules/fast-check/lib/esm/arbitrary/string.js
var safeObjectAssign5 = Object.assign;
function extractUnitArbitrary(constraints) {
  if (typeof constraints.unit === "object") {
    return constraints.unit;
  }
  switch (constraints.unit) {
    case "grapheme":
      return stringUnit("grapheme", "full");
    case "grapheme-composite":
      return stringUnit("composite", "full");
    case "grapheme-ascii":
    case void 0:
      return stringUnit("grapheme", "ascii");
    case "binary":
      return stringUnit("binary", "full");
    case "binary-ascii":
      return stringUnit("binary", "ascii");
  }
}
function string4(constraints = {}) {
  const charArbitrary = extractUnitArbitrary(constraints);
  const unmapper = patternsToStringUnmapperFor(charArbitrary, constraints);
  const experimentalCustomSlices = createSlicesForString(charArbitrary, constraints);
  const enrichedConstraints = safeObjectAssign5(safeObjectAssign5({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(patternsToStringMapper, unmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/InvalidSubdomainLabelFiIter.js
function filterInvalidSubdomainLabel(subdomainLabel2) {
  if (subdomainLabel2.length > 63) {
    return false;
  }
  return subdomainLabel2.length < 4 || subdomainLabel2[0] !== "x" || subdomainLabel2[1] !== "n" || subdomainLabel2[2] !== "-" || subdomainLabel2[3] !== "-";
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/AdapterArbitrary.js
var AdaptedValue = Symbol("adapted-value");
function toAdapterValue(rawValue, adapter5) {
  const adapted = adapter5(rawValue.value_);
  if (!adapted.adapted) {
    return rawValue;
  }
  return new Value(adapted.value, AdaptedValue);
}
var AdapterArbitrary = class extends Arbitrary {
  constructor(sourceArb, adapter5) {
    super();
    this.sourceArb = sourceArb;
    this.adapter = adapter5;
    this.adaptValue = (rawValue) => toAdapterValue(rawValue, adapter5);
  }
  generate(mrng, biasFactor) {
    const rawValue = this.sourceArb.generate(mrng, biasFactor);
    return this.adaptValue(rawValue);
  }
  canShrinkWithoutContext(value10) {
    return this.sourceArb.canShrinkWithoutContext(value10) && !this.adapter(value10).adapted;
  }
  shrink(value10, context15) {
    if (context15 === AdaptedValue) {
      if (!this.sourceArb.canShrinkWithoutContext(value10)) {
        return Stream.nil();
      }
      return this.sourceArb.shrink(value10, void 0).map(this.adaptValue);
    }
    return this.sourceArb.shrink(value10, context15).map(this.adaptValue);
  }
};
function adapter4(sourceArb, adapter5) {
  return new AdapterArbitrary(sourceArb, adapter5);
}

// node_modules/fast-check/lib/esm/arbitrary/domain.js
function toSubdomainLabelMapper([f2, d]) {
  return d === null ? f2 : `${f2}${d[0]}${d[1]}`;
}
function toSubdomainLabelUnmapper(value10) {
  if (typeof value10 !== "string" || value10.length === 0) {
    throw new Error("Unsupported");
  }
  if (value10.length === 1) {
    return [value10[0], null];
  }
  return [value10[0], [safeSubstring(value10, 1, value10.length - 1), value10[value10.length - 1]]];
}
function subdomainLabel(size45) {
  const alphaNumericArb = getOrCreateLowerAlphaNumericArbitrary("");
  const alphaNumericHyphenArb = getOrCreateLowerAlphaNumericArbitrary("-");
  return tuple4(alphaNumericArb, option(tuple4(string4({ unit: alphaNumericHyphenArb, size: size45, maxLength: 61 }), alphaNumericArb))).map(toSubdomainLabelMapper, toSubdomainLabelUnmapper).filter(filterInvalidSubdomainLabel);
}
function labelsMapper(elements) {
  return `${safeJoin(elements[0], ".")}.${elements[1]}`;
}
function labelsUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported type");
  }
  const lastDotIndex = value10.lastIndexOf(".");
  return [safeSplit(safeSubstring(value10, 0, lastDotIndex), "."), safeSubstring(value10, lastDotIndex + 1)];
}
function labelsAdapter(labels) {
  const [subDomains, suffix] = labels;
  let lengthNotIncludingIndex = suffix.length;
  for (let index3 = 0; index3 !== subDomains.length; ++index3) {
    lengthNotIncludingIndex += 1 + subDomains[index3].length;
    if (lengthNotIncludingIndex > 255) {
      return { adapted: true, value: [safeSlice(subDomains, 0, index3), suffix] };
    }
  }
  return { adapted: false, value: labels };
}
function domain(constraints = {}) {
  const resolvedSize = resolveSize(constraints.size);
  const resolvedSizeMinusOne = relativeSizeToSize("-1", resolvedSize);
  const lowerAlphaArb = getOrCreateLowerAlphaArbitrary();
  const publicSuffixArb = string4({ unit: lowerAlphaArb, minLength: 2, maxLength: 63, size: resolvedSizeMinusOne });
  return adapter4(tuple4(array4(subdomainLabel(resolvedSize), { size: resolvedSizeMinusOne, minLength: 1, maxLength: 127 }), publicSuffixArb), labelsAdapter).map(labelsMapper, labelsUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/emailAddress.js
function dotAdapter(a) {
  let currentLength = a[0].length;
  for (let index3 = 1; index3 !== a.length; ++index3) {
    currentLength += 1 + a[index3].length;
    if (currentLength > 64) {
      return { adapted: true, value: safeSlice(a, 0, index3) };
    }
  }
  return { adapted: false, value: a };
}
function dotMapper(a) {
  return safeJoin(a, ".");
}
function dotUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported");
  }
  return safeSplit(value10, ".");
}
function atMapper(data) {
  return `${data[0]}@${data[1]}`;
}
function atUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported");
  }
  return safeSplit(value10, "@", 2);
}
function emailAddress(constraints = {}) {
  const atextArb = getOrCreateLowerAlphaNumericArbitrary("!#$%&'*+-/=?^_`{|}~");
  const localPartArb = adapter4(array4(string4({
    unit: atextArb,
    minLength: 1,
    maxLength: 64,
    size: constraints.size
  }), { minLength: 1, maxLength: 32, size: constraints.size }), dotAdapter).map(dotMapper, dotUnmapper);
  return tuple4(localPartArb, domain({ size: constraints.size })).map(atMapper, atUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ArrayInt64.js
var Zero64 = { sign: 1, data: [0, 0] };
var Unit64 = { sign: 1, data: [0, 1] };
function isZero64(a) {
  return a.data[0] === 0 && a.data[1] === 0;
}
function isStrictlyNegative64(a) {
  return a.sign === -1 && !isZero64(a);
}
function isStrictlyPositive64(a) {
  return a.sign === 1 && !isZero64(a);
}
function isEqual64(a, b) {
  if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) {
    return a.sign === b.sign || a.data[0] === 0 && a.data[1] === 0;
  }
  return false;
}
function isStrictlySmaller64Internal(a, b) {
  return a[0] < b[0] || a[0] === b[0] && a[1] < b[1];
}
function isStrictlySmaller64(a, b) {
  if (a.sign === b.sign) {
    return a.sign === 1 ? isStrictlySmaller64Internal(a.data, b.data) : isStrictlySmaller64Internal(b.data, a.data);
  }
  return a.sign === -1 && (!isZero64(a) || !isZero64(b));
}
function clone64(a) {
  return { sign: a.sign, data: [a.data[0], a.data[1]] };
}
function substract64DataInternal(a, b) {
  let reminderLow = 0;
  let low = a[1] - b[1];
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  return [a[0] - b[0] - reminderLow, low];
}
function substract64Internal(a, b) {
  if (a.sign === 1 && b.sign === -1) {
    const low = a.data[1] + b.data[1];
    const high = a.data[0] + b.data[0] + (low > 4294967295 ? 1 : 0);
    return { sign: 1, data: [high >>> 0, low >>> 0] };
  }
  return {
    sign: 1,
    data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data)
  };
}
function substract64(arrayIntA, arrayIntB) {
  if (isStrictlySmaller64(arrayIntA, arrayIntB)) {
    const out = substract64Internal(arrayIntB, arrayIntA);
    out.sign = -1;
    return out;
  }
  return substract64Internal(arrayIntA, arrayIntB);
}
function negative64(arrayIntA) {
  return {
    sign: -arrayIntA.sign,
    data: [arrayIntA.data[0], arrayIntA.data[1]]
  };
}
function add642(arrayIntA, arrayIntB) {
  if (isZero64(arrayIntB)) {
    if (isZero64(arrayIntA)) {
      return clone64(Zero64);
    }
    return clone64(arrayIntA);
  }
  return substract64(arrayIntA, negative64(arrayIntB));
}
function halve64(a) {
  return {
    sign: a.sign,
    data: [Math.floor(a.data[0] / 2), (a.data[0] % 2 === 1 ? 2147483648 : 0) + Math.floor(a.data[1] / 2)]
  };
}
function logLike64(a) {
  return {
    sign: a.sign,
    data: [0, Math.floor(Math.log(a.data[0] * 4294967296 + a.data[1]) / Math.log(2))]
  };
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayInt64Arbitrary.js
var ArrayInt64Arbitrary = class _ArrayInt64Arbitrary extends Arbitrary {
  constructor(min11, max14) {
    super();
    this.min = min11;
    this.max = max14;
    this.biasedRanges = null;
  }
  generate(mrng, biasFactor) {
    const range6 = this.computeGenerateRange(mrng, biasFactor);
    const uncheckedValue = mrng.nextArrayInt(range6.min, range6.max);
    if (uncheckedValue.data.length === 1) {
      uncheckedValue.data.unshift(0);
    }
    return new Value(uncheckedValue, void 0);
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = this.retrieveBiasedRanges();
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id3 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id3 < 0 ? ranges[0] : ranges[id3 + 1];
  }
  canShrinkWithoutContext(value10) {
    const unsafeValue = value10;
    return typeof value10 === "object" && value10 !== null && (unsafeValue.sign === -1 || unsafeValue.sign === 1) && Array.isArray(unsafeValue.data) && unsafeValue.data.length === 2 && (isStrictlySmaller64(this.min, unsafeValue) && isStrictlySmaller64(unsafeValue, this.max) || isEqual64(this.min, unsafeValue) || isEqual64(this.max, unsafeValue));
  }
  shrinkArrayInt64(value10, target, tryTargetAsap) {
    const realGap = substract64(value10, target);
    function* shrinkGen() {
      let previous2 = tryTargetAsap ? void 0 : target;
      const gap = tryTargetAsap ? realGap : halve64(realGap);
      for (let toremove = gap; !isZero64(toremove); toremove = halve64(toremove)) {
        const next6 = substract64(value10, toremove);
        yield new Value(next6, previous2);
        previous2 = next6;
      }
    }
    return stream(shrinkGen());
  }
  shrink(current2, context15) {
    if (!_ArrayInt64Arbitrary.isValidContext(current2, context15)) {
      const target = this.defaultTarget();
      return this.shrinkArrayInt64(current2, target, true);
    }
    if (this.isLastChanceTry(current2, context15)) {
      return Stream.of(new Value(context15, void 0));
    }
    return this.shrinkArrayInt64(current2, context15, false);
  }
  defaultTarget() {
    if (!isStrictlyPositive64(this.min) && !isStrictlyNegative64(this.max)) {
      return Zero64;
    }
    return isStrictlyNegative64(this.min) ? this.max : this.min;
  }
  isLastChanceTry(current2, context15) {
    if (isZero64(current2)) {
      return false;
    }
    if (current2.sign === 1) {
      return isEqual64(current2, add642(context15, Unit64)) && isStrictlyPositive64(substract64(current2, this.min));
    } else {
      return isEqual64(current2, substract64(context15, Unit64)) && isStrictlyNegative64(substract64(current2, this.max));
    }
  }
  static isValidContext(_current, context15) {
    if (context15 === void 0) {
      return false;
    }
    if (typeof context15 !== "object" || context15 === null || !("sign" in context15) || !("data" in context15)) {
      throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);
    }
    return true;
  }
  retrieveBiasedRanges() {
    if (this.biasedRanges != null) {
      return this.biasedRanges;
    }
    if (isEqual64(this.min, this.max)) {
      this.biasedRanges = [{ min: this.min, max: this.max }];
      return this.biasedRanges;
    }
    const minStrictlySmallerZero = isStrictlyNegative64(this.min);
    const maxStrictlyGreaterZero = isStrictlyPositive64(this.max);
    if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
      const logMin = logLike64(this.min);
      const logMax = logLike64(this.max);
      this.biasedRanges = [
        { min: logMin, max: logMax },
        { min: substract64(this.max, logMax), max: this.max },
        { min: this.min, max: substract64(this.min, logMin) }
      ];
    } else {
      const logGap = logLike64(substract64(this.max, this.min));
      const arbCloseToMin = { min: this.min, max: add642(this.min, logGap) };
      const arbCloseToMax = { min: substract64(this.max, logGap), max: this.max };
      this.biasedRanges = minStrictlySmallerZero ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
    }
    return this.biasedRanges;
  }
};
function arrayInt64(min11, max14) {
  const arb = new ArrayInt64Arbitrary(min11, max14);
  return arb;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js
var safeNegativeInfinity2 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity3 = Number.POSITIVE_INFINITY;
var safeEpsilon = Number.EPSILON;
var INDEX_POSITIVE_INFINITY = { sign: 1, data: [2146435072, 0] };
var INDEX_NEGATIVE_INFINITY = { sign: -1, data: [2146435072, 1] };
var f64 = new Float64Array(1);
var u322 = new Uint32Array(f64.buffer, f64.byteOffset);
function bitCastDoubleToUInt64(f2) {
  f64[0] = f2;
  return [u322[1], u322[0]];
}
function decomposeDouble(d) {
  const { 0: hi, 1: lo } = bitCastDoubleToUInt64(d);
  const signBit = hi >>> 31;
  const exponentBits = hi >>> 20 & 2047;
  const significandBits = (hi & 1048575) * 4294967296 + lo;
  const exponent = exponentBits === 0 ? -1022 : exponentBits - 1023;
  let significand = exponentBits === 0 ? 0 : 1;
  significand += significandBits / 2 ** 52;
  significand *= signBit === 0 ? 1 : -1;
  return { exponent, significand };
}
function positiveNumberToInt64(n) {
  return [~~(n / 4294967296), n >>> 0];
}
function indexInDoubleFromDecomp(exponent, significand) {
  if (exponent === -1022) {
    const rescaledSignificand2 = significand * 2 ** 52;
    return positiveNumberToInt64(rescaledSignificand2);
  }
  const rescaledSignificand = (significand - 1) * 2 ** 52;
  const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;
  const index3 = positiveNumberToInt64(rescaledSignificand);
  index3[0] += exponentOnlyHigh;
  return index3;
}
function doubleToIndex(d) {
  if (d === safePositiveInfinity3) {
    return clone64(INDEX_POSITIVE_INFINITY);
  }
  if (d === safeNegativeInfinity2) {
    return clone64(INDEX_NEGATIVE_INFINITY);
  }
  const decomp = decomposeDouble(d);
  const exponent = decomp.exponent;
  const significand = decomp.significand;
  if (d > 0 || d === 0 && 1 / d === safePositiveInfinity3) {
    return { sign: 1, data: indexInDoubleFromDecomp(exponent, significand) };
  } else {
    const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);
    if (indexOpposite[1] === 4294967295) {
      indexOpposite[0] += 1;
      indexOpposite[1] = 0;
    } else {
      indexOpposite[1] += 1;
    }
    return { sign: -1, data: indexOpposite };
  }
}
function indexToDouble(index3) {
  if (index3.sign === -1) {
    const indexOpposite = { sign: 1, data: [index3.data[0], index3.data[1]] };
    if (indexOpposite.data[1] === 0) {
      indexOpposite.data[0] -= 1;
      indexOpposite.data[1] = 4294967295;
    } else {
      indexOpposite.data[1] -= 1;
    }
    return -indexToDouble(indexOpposite);
  }
  if (isEqual64(index3, INDEX_POSITIVE_INFINITY)) {
    return safePositiveInfinity3;
  }
  if (index3.data[0] < 2097152) {
    return (index3.data[0] * 4294967296 + index3.data[1]) * 2 ** -1074;
  }
  const postIndexHigh = index3.data[0] - 2097152;
  const exponent = -1021 + (postIndexHigh >> 20);
  const significand = 1 + ((postIndexHigh & 1048575) * 2 ** 32 + index3.data[1]) * safeEpsilon;
  return significand * 2 ** exponent;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js
var safeNumberIsInteger5 = Number.isInteger;
var safeObjectIs7 = Object.is;
var safeNegativeInfinity3 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity4 = Number.POSITIVE_INFINITY;
function refineConstraintsForFloatingOnly(constraints, maxValue, maxNonIntegerValue3, onlyIntegersAfterThisValue3) {
  const { noDefaultInfinity = false, minExcluded = false, maxExcluded = false, min: min11 = noDefaultInfinity ? -maxValue : safeNegativeInfinity3, max: max14 = noDefaultInfinity ? maxValue : safePositiveInfinity4 } = constraints;
  const effectiveMin = minExcluded ? min11 < -maxNonIntegerValue3 ? -onlyIntegersAfterThisValue3 : Math.max(min11, -maxNonIntegerValue3) : min11 === safeNegativeInfinity3 ? Math.max(min11, -onlyIntegersAfterThisValue3) : Math.max(min11, -maxNonIntegerValue3);
  const effectiveMax = maxExcluded ? max14 > maxNonIntegerValue3 ? onlyIntegersAfterThisValue3 : Math.min(max14, maxNonIntegerValue3) : max14 === safePositiveInfinity4 ? Math.min(max14, onlyIntegersAfterThisValue3) : Math.min(max14, maxNonIntegerValue3);
  const fullConstraints = {
    noDefaultInfinity: false,
    minExcluded: minExcluded || (min11 !== safeNegativeInfinity3 || minExcluded) && safeNumberIsInteger5(effectiveMin),
    maxExcluded: maxExcluded || (max14 !== safePositiveInfinity4 || maxExcluded) && safeNumberIsInteger5(effectiveMax),
    min: safeObjectIs7(effectiveMin, -0) ? 0 : effectiveMin,
    max: safeObjectIs7(effectiveMax, 0) ? -0 : effectiveMax,
    noNaN: constraints.noNaN || false
  };
  return fullConstraints;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
var safeNegativeInfinity4 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity5 = Number.POSITIVE_INFINITY;
var safeMaxValue = Number.MAX_VALUE;
var maxNonIntegerValue = 45035996273704955e-1;
var onlyIntegersAfterThisValue = 4503599627370496;
function refineConstraintsForDoubleOnly(constraints) {
  return refineConstraintsForFloatingOnly(constraints, safeMaxValue, maxNonIntegerValue, onlyIntegersAfterThisValue);
}
function doubleOnlyMapper(value10) {
  return value10 === onlyIntegersAfterThisValue ? safePositiveInfinity5 : value10 === -onlyIntegersAfterThisValue ? safeNegativeInfinity4 : value10;
}
function doubleOnlyUnmapper(value10) {
  if (typeof value10 !== "number")
    throw new Error("Unsupported type");
  return value10 === safePositiveInfinity5 ? onlyIntegersAfterThisValue : value10 === safeNegativeInfinity4 ? -onlyIntegersAfterThisValue : value10;
}

// node_modules/fast-check/lib/esm/arbitrary/double.js
var safeNumberIsInteger6 = Number.isInteger;
var safeNumberIsNaN5 = Number.isNaN;
var safeNegativeInfinity5 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity6 = Number.POSITIVE_INFINITY;
var safeMaxValue2 = Number.MAX_VALUE;
var safeNaN2 = Number.NaN;
function safeDoubleToIndex(d, constraintsLabel) {
  if (safeNumberIsNaN5(d)) {
    throw new Error("fc.double constraints." + constraintsLabel + " must be a 64-bit float");
  }
  return doubleToIndex(d);
}
function unmapperDoubleToIndex(value10) {
  if (typeof value10 !== "number")
    throw new Error("Unsupported type");
  return doubleToIndex(value10);
}
function numberIsNotInteger(value10) {
  return !safeNumberIsInteger6(value10);
}
function anyDouble(constraints) {
  const { noDefaultInfinity = false, noNaN = false, minExcluded = false, maxExcluded = false, min: min11 = noDefaultInfinity ? -safeMaxValue2 : safeNegativeInfinity5, max: max14 = noDefaultInfinity ? safeMaxValue2 : safePositiveInfinity6 } = constraints;
  const minIndexRaw = safeDoubleToIndex(min11, "min");
  const minIndex = minExcluded ? add642(minIndexRaw, Unit64) : minIndexRaw;
  const maxIndexRaw = safeDoubleToIndex(max14, "max");
  const maxIndex = maxExcluded ? substract64(maxIndexRaw, Unit64) : maxIndexRaw;
  if (isStrictlySmaller64(maxIndex, minIndex)) {
    throw new Error("fc.double constraints.min must be smaller or equal to constraints.max");
  }
  if (noNaN) {
    return arrayInt64(minIndex, maxIndex).map(indexToDouble, unmapperDoubleToIndex);
  }
  const positiveMaxIdx = isStrictlyPositive64(maxIndex);
  const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);
  const maxIndexWithNaN = positiveMaxIdx ? add642(maxIndex, Unit64) : maxIndex;
  return arrayInt64(minIndexWithNaN, maxIndexWithNaN).map((index3) => {
    if (isStrictlySmaller64(maxIndex, index3) || isStrictlySmaller64(index3, minIndex))
      return safeNaN2;
    else
      return indexToDouble(index3);
  }, (value10) => {
    if (typeof value10 !== "number")
      throw new Error("Unsupported type");
    if (safeNumberIsNaN5(value10))
      return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;
    return doubleToIndex(value10);
  });
}
function double(constraints = {}) {
  if (!constraints.noInteger) {
    return anyDouble(constraints);
  }
  return anyDouble(refineConstraintsForDoubleOnly(constraints)).map(doubleOnlyMapper, doubleOnlyUnmapper).filter(numberIsNotInteger);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js
var safeNegativeInfinity6 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity7 = Number.POSITIVE_INFINITY;
var MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
var MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
var EPSILON_32 = 2 ** -23;
var INDEX_POSITIVE_INFINITY2 = 2139095040;
var INDEX_NEGATIVE_INFINITY2 = -2139095041;
var f32 = new Float32Array(1);
var u323 = new Uint32Array(f32.buffer, f32.byteOffset);
function bitCastFloatToUInt32(f2) {
  f32[0] = f2;
  return u323[0];
}
function decomposeFloat(f2) {
  const bits2 = bitCastFloatToUInt32(f2);
  const signBit = bits2 >>> 31;
  const exponentBits = bits2 >>> 23 & 255;
  const significandBits = bits2 & 8388607;
  const exponent = exponentBits === 0 ? -126 : exponentBits - 127;
  let significand = exponentBits === 0 ? 0 : 1;
  significand += significandBits / 2 ** 23;
  significand *= signBit === 0 ? 1 : -1;
  return { exponent, significand };
}
function indexInFloatFromDecomp(exponent, significand) {
  if (exponent === -126) {
    return significand * 8388608;
  }
  return (exponent + 127) * 8388608 + (significand - 1) * 8388608;
}
function floatToIndex(f2) {
  if (f2 === safePositiveInfinity7) {
    return INDEX_POSITIVE_INFINITY2;
  }
  if (f2 === safeNegativeInfinity6) {
    return INDEX_NEGATIVE_INFINITY2;
  }
  const decomp = decomposeFloat(f2);
  const exponent = decomp.exponent;
  const significand = decomp.significand;
  if (f2 > 0 || f2 === 0 && 1 / f2 === safePositiveInfinity7) {
    return indexInFloatFromDecomp(exponent, significand);
  } else {
    return -indexInFloatFromDecomp(exponent, -significand) - 1;
  }
}
function indexToFloat(index3) {
  if (index3 < 0) {
    return -indexToFloat(-index3 - 1);
  }
  if (index3 === INDEX_POSITIVE_INFINITY2) {
    return safePositiveInfinity7;
  }
  if (index3 < 16777216) {
    return index3 * 2 ** -149;
  }
  const postIndex = index3 - 16777216;
  const exponent = -125 + (postIndex >> 23);
  const significand = 1 + (postIndex & 8388607) / 8388608;
  return significand * 2 ** exponent;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js
var safeNegativeInfinity7 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity8 = Number.POSITIVE_INFINITY;
var safeMaxValue3 = MAX_VALUE_32;
var maxNonIntegerValue2 = 83886075e-1;
var onlyIntegersAfterThisValue2 = 8388608;
function refineConstraintsForFloatOnly(constraints) {
  return refineConstraintsForFloatingOnly(constraints, safeMaxValue3, maxNonIntegerValue2, onlyIntegersAfterThisValue2);
}
function floatOnlyMapper(value10) {
  return value10 === onlyIntegersAfterThisValue2 ? safePositiveInfinity8 : value10 === -onlyIntegersAfterThisValue2 ? safeNegativeInfinity7 : value10;
}
function floatOnlyUnmapper(value10) {
  if (typeof value10 !== "number")
    throw new Error("Unsupported type");
  return value10 === safePositiveInfinity8 ? onlyIntegersAfterThisValue2 : value10 === safeNegativeInfinity7 ? -onlyIntegersAfterThisValue2 : value10;
}

// node_modules/fast-check/lib/esm/arbitrary/float.js
var safeNumberIsInteger7 = Number.isInteger;
var safeNumberIsNaN6 = Number.isNaN;
var safeMathFround = Math.fround;
var safeNegativeInfinity8 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity9 = Number.POSITIVE_INFINITY;
var safeNaN3 = Number.NaN;
function safeFloatToIndex(f2, constraintsLabel) {
  const conversionTrick = "you can convert any double to a 32-bit float by using `Math.fround(myDouble)`";
  const errorMessage = "fc.float constraints." + constraintsLabel + " must be a 32-bit float - " + conversionTrick;
  if (safeNumberIsNaN6(f2) || safeMathFround(f2) !== f2) {
    throw new Error(errorMessage);
  }
  return floatToIndex(f2);
}
function unmapperFloatToIndex(value10) {
  if (typeof value10 !== "number")
    throw new Error("Unsupported type");
  return floatToIndex(value10);
}
function numberIsNotInteger2(value10) {
  return !safeNumberIsInteger7(value10);
}
function anyFloat(constraints) {
  const { noDefaultInfinity = false, noNaN = false, minExcluded = false, maxExcluded = false, min: min11 = noDefaultInfinity ? -MAX_VALUE_32 : safeNegativeInfinity8, max: max14 = noDefaultInfinity ? MAX_VALUE_32 : safePositiveInfinity9 } = constraints;
  const minIndexRaw = safeFloatToIndex(min11, "min");
  const minIndex = minExcluded ? minIndexRaw + 1 : minIndexRaw;
  const maxIndexRaw = safeFloatToIndex(max14, "max");
  const maxIndex = maxExcluded ? maxIndexRaw - 1 : maxIndexRaw;
  if (minIndex > maxIndex) {
    throw new Error("fc.float constraints.min must be smaller or equal to constraints.max");
  }
  if (noNaN) {
    return integer({ min: minIndex, max: maxIndex }).map(indexToFloat, unmapperFloatToIndex);
  }
  const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;
  const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;
  return integer({ min: minIndexWithNaN, max: maxIndexWithNaN }).map((index3) => {
    if (index3 > maxIndex || index3 < minIndex)
      return safeNaN3;
    else
      return indexToFloat(index3);
  }, (value10) => {
    if (typeof value10 !== "number")
      throw new Error("Unsupported type");
    if (safeNumberIsNaN6(value10))
      return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;
    return floatToIndex(value10);
  });
}
function float(constraints = {}) {
  if (!constraints.noInteger) {
    return anyFloat(constraints);
  }
  return anyFloat(refineConstraintsForFloatOnly(constraints)).map(floatOnlyMapper, floatOnlyUnmapper).filter(numberIsNotInteger2);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TextEscaper.js
function escapeForTemplateString(originalText) {
  return originalText.replace(/([$`\\])/g, "\\$1").replace(/\r/g, "\\r");
}
function escapeForMultilineComments(originalText) {
  return originalText.replace(/\*\//g, "*\\/");
}

// node_modules/fast-check/lib/esm/utils/hash.js
var crc32Table = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
function hash2(repr) {
  let crc2 = 4294967295;
  for (let idx = 0; idx < repr.length; ++idx) {
    const c = safeCharCodeAt(repr, idx);
    if (c < 128) {
      crc2 = crc32Table[crc2 & 255 ^ c] ^ crc2 >> 8;
    } else if (c < 2048) {
      crc2 = crc32Table[crc2 & 255 ^ (192 | c >> 6 & 31)] ^ crc2 >> 8;
      crc2 = crc32Table[crc2 & 255 ^ (128 | c & 63)] ^ crc2 >> 8;
    } else if (c >= 55296 && c < 57344) {
      const cNext = safeCharCodeAt(repr, ++idx);
      if (c >= 56320 || cNext < 56320 || cNext > 57343 || Number.isNaN(cNext)) {
        idx -= 1;
        crc2 = crc32Table[crc2 & 255 ^ 239] ^ crc2 >> 8;
        crc2 = crc32Table[crc2 & 255 ^ 191] ^ crc2 >> 8;
        crc2 = crc32Table[crc2 & 255 ^ 189] ^ crc2 >> 8;
      } else {
        const c1 = (c & 1023) + 64;
        const c2 = cNext & 1023;
        crc2 = crc32Table[crc2 & 255 ^ (240 | c1 >> 8 & 7)] ^ crc2 >> 8;
        crc2 = crc32Table[crc2 & 255 ^ (128 | c1 >> 2 & 63)] ^ crc2 >> 8;
        crc2 = crc32Table[crc2 & 255 ^ (128 | c2 >> 6 & 15 | (c1 & 3) << 4)] ^ crc2 >> 8;
        crc2 = crc32Table[crc2 & 255 ^ (128 | c2 & 63)] ^ crc2 >> 8;
      }
    } else {
      crc2 = crc32Table[crc2 & 255 ^ (224 | c >> 12 & 15)] ^ crc2 >> 8;
      crc2 = crc32Table[crc2 & 255 ^ (128 | c >> 6 & 63)] ^ crc2 >> 8;
      crc2 = crc32Table[crc2 & 255 ^ (128 | c & 63)] ^ crc2 >> 8;
    }
  }
  return (crc2 | 0) + 2147483648;
}

// node_modules/fast-check/lib/esm/arbitrary/noShrink.js
function noShrink(arb) {
  return arb.noShrink();
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js
var safeObjectAssign6 = Object.assign;
var safeObjectKeys3 = Object.keys;
function buildCompareFunctionArbitrary(cmp) {
  return tuple4(noShrink(integer()), noShrink(integer({ min: 1, max: 4294967295 }))).map(([seed, hashEnvSize]) => {
    const producer = () => {
      const recorded = {};
      const f2 = (a, b) => {
        const reprA = stringify3(a);
        const reprB = stringify3(b);
        const hA = hash2(`${seed}${reprA}`) % hashEnvSize;
        const hB = hash2(`${seed}${reprB}`) % hashEnvSize;
        const val = cmp(hA, hB);
        recorded[`[${reprA},${reprB}]`] = val;
        return val;
      };
      return safeObjectAssign6(f2, {
        toString: () => {
          const seenValues = safeObjectKeys3(recorded).sort().map((k) => `${k} => ${stringify3(recorded[k])}`).map((line) => `/* ${escapeForMultilineComments(line)} */`);
          return `function(a, b) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `
  ${safeJoin(seenValues, "\n  ")}` : ""}
  const cmp = ${cmp};
  const hA = hash('${seed}' + stringify(a)) % ${hashEnvSize};
  const hB = hash('${seed}' + stringify(b)) % ${hashEnvSize};
  return cmp(hA, hB);
}`;
        },
        [cloneMethod]: producer
      });
    };
    return producer();
  });
}

// node_modules/fast-check/lib/esm/arbitrary/compareBooleanFunc.js
var safeObjectAssign7 = Object.assign;
function compareBooleanFunc() {
  return buildCompareFunctionArbitrary(safeObjectAssign7((hA, hB) => hA < hB, {
    toString() {
      return "(hA, hB) => hA < hB";
    }
  }));
}

// node_modules/fast-check/lib/esm/arbitrary/compareFunc.js
var safeObjectAssign8 = Object.assign;
function compareFunc() {
  return buildCompareFunctionArbitrary(safeObjectAssign8((hA, hB) => hA - hB, {
    toString() {
      return "(hA, hB) => hA - hB";
    }
  }));
}

// node_modules/fast-check/lib/esm/arbitrary/func.js
var safeObjectDefineProperties = Object.defineProperties;
var safeObjectKeys4 = Object.keys;
function func(arb) {
  return tuple4(array4(arb, { minLength: 1 }), noShrink(integer())).map(([outs, seed]) => {
    const producer = () => {
      const recorded = {};
      const f2 = (...args2) => {
        const repr = stringify3(args2);
        const val = outs[hash2(`${seed}${repr}`) % outs.length];
        recorded[repr] = val;
        return hasCloneMethod(val) ? val[cloneMethod]() : val;
      };
      function prettyPrint4(stringifiedOuts) {
        const seenValues = safeMap(safeMap(safeSort(safeObjectKeys4(recorded)), (k) => `${k} => ${stringify3(recorded[k])}`), (line) => `/* ${escapeForMultilineComments(line)} */`);
        return `function(...args) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `
  ${seenValues.join("\n  ")}` : ""}
  const outs = ${stringifiedOuts};
  return outs[hash('${seed}' + stringify(args)) % outs.length];
}`;
      }
      return safeObjectDefineProperties(f2, {
        toString: { value: () => prettyPrint4(stringify3(outs)) },
        [toStringMethod]: { value: () => prettyPrint4(stringify3(outs)) },
        [asyncToStringMethod]: { value: async () => prettyPrint4(await asyncStringify(outs)) },
        [cloneMethod]: { value: producer, configurable: true }
      });
    };
    return producer();
  });
}

// node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js
var safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
var safeMaxSafeInteger2 = Number.MAX_SAFE_INTEGER;
function maxSafeInteger() {
  return new IntegerArbitrary(safeMinSafeInteger, safeMaxSafeInteger2);
}

// node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js
var safeMaxSafeInteger3 = Number.MAX_SAFE_INTEGER;
function maxSafeNat() {
  return new IntegerArbitrary(0, safeMaxSafeInteger3);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js
var safeNumberParseInt = Number.parseInt;
function natToStringifiedNatMapper(options) {
  const [style, v] = options;
  switch (style) {
    case "oct":
      return `0${safeNumberToString(v, 8)}`;
    case "hex":
      return `0x${safeNumberToString(v, 16)}`;
    case "dec":
    default:
      return `${v}`;
  }
}
function tryParseStringifiedNat(stringValue, radix3) {
  const parsedNat = safeNumberParseInt(stringValue, radix3);
  if (safeNumberToString(parsedNat, radix3) !== stringValue) {
    throw new Error("Invalid value");
  }
  return parsedNat;
}
function natToStringifiedNatUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Invalid type");
  }
  if (value10.length >= 2 && value10[0] === "0") {
    if (value10[1] === "x") {
      return ["hex", tryParseStringifiedNat(safeSubstring(value10, 2), 16)];
    }
    return ["oct", tryParseStringifiedNat(safeSubstring(value10, 1), 8)];
  }
  return ["dec", tryParseStringifiedNat(value10, 10)];
}

// node_modules/fast-check/lib/esm/arbitrary/ipV4.js
function dotJoinerMapper(data) {
  return safeJoin(data, ".");
}
function dotJoinerUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Invalid type");
  }
  return safeMap(safeSplit(value10, "."), (v) => tryParseStringifiedNat(v, 10));
}
function ipV4() {
  return tuple4(nat(255), nat(255), nat(255), nat(255)).map(dotJoinerMapper, dotJoinerUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js
function buildStringifiedNatArbitrary(maxValue) {
  return tuple4(constantFrom("dec", "oct", "hex"), nat(maxValue)).map(natToStringifiedNatMapper, natToStringifiedNatUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/ipV4Extended.js
function dotJoinerMapper2(data) {
  return safeJoin(data, ".");
}
function dotJoinerUnmapper2(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Invalid type");
  }
  return safeSplit(value10, ".");
}
function ipV4Extended() {
  return oneof(tuple4(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255)).map(dotJoinerMapper2, dotJoinerUnmapper2), tuple4(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(65535)).map(dotJoinerMapper2, dotJoinerUnmapper2), tuple4(buildStringifiedNatArbitrary(255), buildStringifiedNatArbitrary(16777215)).map(dotJoinerMapper2, dotJoinerUnmapper2), buildStringifiedNatArbitrary(4294967295));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CodePointsToString.js
function codePointsToStringMapper(tab) {
  return safeJoin(tab, "");
}
function codePointsToStringUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Cannot unmap the passed value");
  }
  return [...value10];
}

// node_modules/fast-check/lib/esm/arbitrary/hexaString.js
var safeObjectAssign9 = Object.assign;
function hexaString(constraints = {}) {
  const charArbitrary = hexa();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign9(safeObjectAssign9({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/EntitiesToIPv6.js
function readBh(value10) {
  if (value10.length === 0)
    return [];
  else
    return safeSplit(value10, ":");
}
function extractEhAndL(value10) {
  const valueSplits = safeSplit(value10, ":");
  if (valueSplits.length >= 2 && valueSplits[valueSplits.length - 1].length <= 4) {
    return [
      safeSlice(valueSplits, 0, valueSplits.length - 2),
      `${valueSplits[valueSplits.length - 2]}:${valueSplits[valueSplits.length - 1]}`
    ];
  }
  return [safeSlice(valueSplits, 0, valueSplits.length - 1), valueSplits[valueSplits.length - 1]];
}
function fullySpecifiedMapper(data) {
  return `${safeJoin(data[0], ":")}:${data[1]}`;
}
function fullySpecifiedUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  return extractEhAndL(value10);
}
function onlyTrailingMapper(data) {
  return `::${safeJoin(data[0], ":")}:${data[1]}`;
}
function onlyTrailingUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  if (!safeStartsWith(value10, "::"))
    throw new Error("Invalid value");
  return extractEhAndL(safeSubstring(value10, 2));
}
function multiTrailingMapper(data) {
  return `${safeJoin(data[0], ":")}::${safeJoin(data[1], ":")}:${data[2]}`;
}
function multiTrailingUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  const [bhString, trailingString] = safeSplit(value10, "::", 2);
  const [eh, l] = extractEhAndL(trailingString);
  return [readBh(bhString), eh, l];
}
function multiTrailingMapperOne(data) {
  return multiTrailingMapper([data[0], [data[1]], data[2]]);
}
function multiTrailingUnmapperOne(value10) {
  const out = multiTrailingUnmapper(value10);
  return [out[0], safeJoin(out[1], ":"), out[2]];
}
function singleTrailingMapper(data) {
  return `${safeJoin(data[0], ":")}::${data[1]}`;
}
function singleTrailingUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  const [bhString, trailing] = safeSplit(value10, "::", 2);
  return [readBh(bhString), trailing];
}
function noTrailingMapper(data) {
  return `${safeJoin(data[0], ":")}::`;
}
function noTrailingUnmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  if (!safeEndsWith(value10, "::"))
    throw new Error("Invalid value");
  return [readBh(safeSubstring(value10, 0, value10.length - 2))];
}

// node_modules/fast-check/lib/esm/arbitrary/ipV6.js
function h16sTol32Mapper([a, b]) {
  return `${a}:${b}`;
}
function h16sTol32Unmapper(value10) {
  if (typeof value10 !== "string")
    throw new Error("Invalid type");
  if (!value10.includes(":"))
    throw new Error("Invalid value");
  return value10.split(":", 2);
}
function ipV6() {
  const h16Arb = hexaString({ minLength: 1, maxLength: 4, size: "max" });
  const ls32Arb = oneof(tuple4(h16Arb, h16Arb).map(h16sTol32Mapper, h16sTol32Unmapper), ipV4());
  return oneof(tuple4(array4(h16Arb, { minLength: 6, maxLength: 6, size: "max" }), ls32Arb).map(fullySpecifiedMapper, fullySpecifiedUnmapper), tuple4(array4(h16Arb, { minLength: 5, maxLength: 5, size: "max" }), ls32Arb).map(onlyTrailingMapper, onlyTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 1, size: "max" }), array4(h16Arb, { minLength: 4, maxLength: 4, size: "max" }), ls32Arb).map(multiTrailingMapper, multiTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 2, size: "max" }), array4(h16Arb, { minLength: 3, maxLength: 3, size: "max" }), ls32Arb).map(multiTrailingMapper, multiTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 3, size: "max" }), array4(h16Arb, { minLength: 2, maxLength: 2, size: "max" }), ls32Arb).map(multiTrailingMapper, multiTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 4, size: "max" }), h16Arb, ls32Arb).map(multiTrailingMapperOne, multiTrailingUnmapperOne), tuple4(array4(h16Arb, { minLength: 0, maxLength: 5, size: "max" }), ls32Arb).map(singleTrailingMapper, singleTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 6, size: "max" }), h16Arb).map(singleTrailingMapper, singleTrailingUnmapper), tuple4(array4(h16Arb, { minLength: 0, maxLength: 7, size: "max" })).map(noTrailingMapper, noTrailingUnmapper));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/LazyArbitrary.js
var LazyArbitrary = class extends Arbitrary {
  constructor(name) {
    super();
    this.name = name;
    this.underlying = null;
  }
  generate(mrng, biasFactor) {
    if (!this.underlying) {
      throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
    }
    return this.underlying.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value10) {
    if (!this.underlying) {
      throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
    }
    return this.underlying.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    if (!this.underlying) {
      throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
    }
    return this.underlying.shrink(value10, context15);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/letrec.js
var safeObjectCreate2 = Object.create;
function letrec(builder) {
  const lazyArbs = safeObjectCreate2(null);
  const tie = (key) => {
    if (!safeHasOwnProperty(lazyArbs, key)) {
      lazyArbs[key] = new LazyArbitrary(String(key));
    }
    return lazyArbs[key];
  };
  const strictArbs = builder(tie);
  for (const key in strictArbs) {
    if (!safeHasOwnProperty(strictArbs, key)) {
      continue;
    }
    const lazyAtKey = lazyArbs[key];
    const lazyArb = lazyAtKey !== void 0 ? lazyAtKey : new LazyArbitrary(key);
    lazyArb.underlying = strictArbs[key];
    lazyArbs[key] = lazyArb;
  }
  return strictArbs;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/WordsToLorem.js
function wordsToJoinedStringMapper(words) {
  return safeJoin(safeMap(words, (w) => w[w.length - 1] === "," ? safeSubstring(w, 0, w.length - 1) : w), " ");
}
function wordsToJoinedStringUnmapperFor(wordsArbitrary) {
  return function wordsToJoinedStringUnmapper(value10) {
    if (typeof value10 !== "string") {
      throw new Error("Unsupported type");
    }
    const words = [];
    for (const candidate of safeSplit(value10, " ")) {
      if (wordsArbitrary.canShrinkWithoutContext(candidate))
        safePush(words, candidate);
      else if (wordsArbitrary.canShrinkWithoutContext(candidate + ","))
        safePush(words, candidate + ",");
      else
        throw new Error("Unsupported word");
    }
    return words;
  };
}
function wordsToSentenceMapper(words) {
  let sentence = safeJoin(words, " ");
  if (sentence[sentence.length - 1] === ",") {
    sentence = safeSubstring(sentence, 0, sentence.length - 1);
  }
  return safeToUpperCase(sentence[0]) + safeSubstring(sentence, 1) + ".";
}
function wordsToSentenceUnmapperFor(wordsArbitrary) {
  return function wordsToSentenceUnmapper(value10) {
    if (typeof value10 !== "string") {
      throw new Error("Unsupported type");
    }
    if (value10.length < 2 || value10[value10.length - 1] !== "." || value10[value10.length - 2] === "," || safeToUpperCase(safeToLowerCase(value10[0])) !== value10[0]) {
      throw new Error("Unsupported value");
    }
    const adaptedValue = safeToLowerCase(value10[0]) + safeSubstring(value10, 1, value10.length - 1);
    const words = [];
    const candidates = safeSplit(adaptedValue, " ");
    for (let idx = 0; idx !== candidates.length; ++idx) {
      const candidate = candidates[idx];
      if (wordsArbitrary.canShrinkWithoutContext(candidate))
        safePush(words, candidate);
      else if (idx === candidates.length - 1 && wordsArbitrary.canShrinkWithoutContext(candidate + ","))
        safePush(words, candidate + ",");
      else
        throw new Error("Unsupported word");
    }
    return words;
  };
}
function sentencesToParagraphMapper(sentences) {
  return safeJoin(sentences, " ");
}
function sentencesToParagraphUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported type");
  }
  const sentences = safeSplit(value10, ". ");
  for (let idx = 0; idx < sentences.length - 1; ++idx) {
    sentences[idx] += ".";
  }
  return sentences;
}

// node_modules/fast-check/lib/esm/arbitrary/lorem.js
var h = (v, w) => {
  return { arbitrary: constant2(v), weight: w };
};
function loremWord() {
  return oneof(h("non", 6), h("adipiscing", 5), h("ligula", 5), h("enim", 5), h("pellentesque", 5), h("in", 5), h("augue", 5), h("et", 5), h("nulla", 5), h("lorem", 4), h("sit", 4), h("sed", 4), h("diam", 4), h("fermentum", 4), h("ut", 4), h("eu", 4), h("aliquam", 4), h("mauris", 4), h("vitae", 4), h("felis", 4), h("ipsum", 3), h("dolor", 3), h("amet,", 3), h("elit", 3), h("euismod", 3), h("mi", 3), h("orci", 3), h("erat", 3), h("praesent", 3), h("egestas", 3), h("leo", 3), h("vel", 3), h("sapien", 3), h("integer", 3), h("curabitur", 3), h("convallis", 3), h("purus", 3), h("risus", 2), h("suspendisse", 2), h("lectus", 2), h("nec,", 2), h("ultricies", 2), h("sed,", 2), h("cras", 2), h("elementum", 2), h("ultrices", 2), h("maecenas", 2), h("massa,", 2), h("varius", 2), h("a,", 2), h("semper", 2), h("proin", 2), h("nec", 2), h("nisl", 2), h("amet", 2), h("duis", 2), h("congue", 2), h("libero", 2), h("vestibulum", 2), h("pede", 2), h("blandit", 2), h("sodales", 2), h("ante", 2), h("nibh", 2), h("ac", 2), h("aenean", 2), h("massa", 2), h("suscipit", 2), h("sollicitudin", 2), h("fusce", 2), h("tempus", 2), h("aliquam,", 2), h("nunc", 2), h("ullamcorper", 2), h("rhoncus", 2), h("metus", 2), h("faucibus,", 2), h("justo", 2), h("magna", 2), h("at", 2), h("tincidunt", 2), h("consectetur", 1), h("tortor,", 1), h("dignissim", 1), h("congue,", 1), h("non,", 1), h("porttitor,", 1), h("nonummy", 1), h("molestie,", 1), h("est", 1), h("eleifend", 1), h("mi,", 1), h("arcu", 1), h("scelerisque", 1), h("vitae,", 1), h("consequat", 1), h("in,", 1), h("pretium", 1), h("volutpat", 1), h("pharetra", 1), h("tempor", 1), h("bibendum", 1), h("odio", 1), h("dui", 1), h("primis", 1), h("faucibus", 1), h("luctus", 1), h("posuere", 1), h("cubilia", 1), h("curae,", 1), h("hendrerit", 1), h("velit", 1), h("mauris,", 1), h("gravida", 1), h("ornare", 1), h("ut,", 1), h("pulvinar", 1), h("varius,", 1), h("turpis", 1), h("nibh,", 1), h("eros", 1), h("id", 1), h("aliquet", 1), h("quis", 1), h("lobortis", 1), h("consectetuer", 1), h("morbi", 1), h("vehicula", 1), h("tortor", 1), h("tellus,", 1), h("id,", 1), h("eu,", 1), h("quam", 1), h("feugiat,", 1), h("posuere,", 1), h("iaculis", 1), h("lectus,", 1), h("tristique", 1), h("mollis,", 1), h("nisl,", 1), h("vulputate", 1), h("sem", 1), h("vivamus", 1), h("placerat", 1), h("imperdiet", 1), h("cursus", 1), h("rutrum", 1), h("iaculis,", 1), h("augue,", 1), h("lacus", 1));
}
function lorem(constraints = {}) {
  const { maxCount, mode = "words", size: size45 } = constraints;
  if (maxCount !== void 0 && maxCount < 1) {
    throw new Error(`lorem has to produce at least one word/sentence`);
  }
  const wordArbitrary = loremWord();
  if (mode === "sentences") {
    const sentence = array4(wordArbitrary, { minLength: 1, size: "small" }).map(wordsToSentenceMapper, wordsToSentenceUnmapperFor(wordArbitrary));
    return array4(sentence, { minLength: 1, maxLength: maxCount, size: size45 }).map(sentencesToParagraphMapper, sentencesToParagraphUnmapper);
  } else {
    return array4(wordArbitrary, { minLength: 1, maxLength: maxCount, size: size45 }).map(wordsToJoinedStringMapper, wordsToJoinedStringUnmapperFor(wordArbitrary));
  }
}

// node_modules/fast-check/lib/esm/arbitrary/memo.js
var contextRemainingDepth = 10;
function memo(builder) {
  const previous2 = {};
  return (maxDepth) => {
    const n = maxDepth !== void 0 ? maxDepth : contextRemainingDepth;
    if (!safeHasOwnProperty(previous2, n)) {
      const prev = contextRemainingDepth;
      contextRemainingDepth = n - 1;
      previous2[n] = builder(n);
      contextRemainingDepth = prev;
    }
    return previous2[n];
  };
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ToggleFlags.js
function countToggledBits(n) {
  let count9 = 0;
  while (n > SBigInt(0)) {
    if (n & SBigInt(1))
      ++count9;
    n >>= SBigInt(1);
  }
  return count9;
}
function computeNextFlags(flags, nextSize) {
  const allowedMask = (SBigInt(1) << SBigInt(nextSize)) - SBigInt(1);
  const preservedFlags = flags & allowedMask;
  let numMissingFlags = countToggledBits(flags - preservedFlags);
  let nFlags = preservedFlags;
  for (let mask = SBigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= SBigInt(1)) {
    if (!(nFlags & mask)) {
      nFlags |= mask;
      --numMissingFlags;
    }
  }
  return nFlags;
}
function computeTogglePositions(chars, toggleCase) {
  const positions = [];
  for (let idx = chars.length - 1; idx !== -1; --idx) {
    if (toggleCase(chars[idx]) !== chars[idx])
      safePush(positions, idx);
  }
  return positions;
}
function computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {
  let flags = SBigInt(0);
  for (let idx = 0, mask = SBigInt(1); idx !== togglePositions.length; ++idx, mask <<= SBigInt(1)) {
    if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {
      flags |= mask;
    }
  }
  return flags;
}
function applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {
  for (let idx = 0, mask = SBigInt(1); idx !== togglePositions.length; ++idx, mask <<= SBigInt(1)) {
    if (flags & mask)
      chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);
  }
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/MixedCaseArbitrary.js
var MixedCaseArbitrary = class extends Arbitrary {
  constructor(stringArb, toggleCase, untoggleAll) {
    super();
    this.stringArb = stringArb;
    this.toggleCase = toggleCase;
    this.untoggleAll = untoggleAll;
  }
  buildContextFor(rawStringValue, flagsValue) {
    return {
      rawString: rawStringValue.value,
      rawStringContext: rawStringValue.context,
      flags: flagsValue.value,
      flagsContext: flagsValue.context
    };
  }
  generate(mrng, biasFactor) {
    const rawStringValue = this.stringArb.generate(mrng, biasFactor);
    const chars = [...rawStringValue.value];
    const togglePositions = computeTogglePositions(chars, this.toggleCase);
    const flagsArb = bigUintN(togglePositions.length);
    const flagsValue = flagsArb.generate(mrng, void 0);
    applyFlagsOnChars(chars, flagsValue.value, togglePositions, this.toggleCase);
    return new Value(safeJoin(chars, ""), this.buildContextFor(rawStringValue, flagsValue));
  }
  canShrinkWithoutContext(value10) {
    if (typeof value10 !== "string") {
      return false;
    }
    return this.untoggleAll !== void 0 ? this.stringArb.canShrinkWithoutContext(this.untoggleAll(value10)) : this.stringArb.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    let contextSafe;
    if (context15 !== void 0) {
      contextSafe = context15;
    } else {
      if (this.untoggleAll !== void 0) {
        const untoggledValue = this.untoggleAll(value10);
        const valueChars = [...value10];
        const untoggledValueChars = [...untoggledValue];
        const togglePositions = computeTogglePositions(untoggledValueChars, this.toggleCase);
        contextSafe = {
          rawString: untoggledValue,
          rawStringContext: void 0,
          flags: computeFlagsFromChars(untoggledValueChars, valueChars, togglePositions),
          flagsContext: void 0
        };
      } else {
        contextSafe = {
          rawString: value10,
          rawStringContext: void 0,
          flags: SBigInt(0),
          flagsContext: void 0
        };
      }
    }
    const rawString = contextSafe.rawString;
    const flags = contextSafe.flags;
    return this.stringArb.shrink(rawString, contextSafe.rawStringContext).map((nRawStringValue) => {
      const nChars = [...nRawStringValue.value];
      const nTogglePositions = computeTogglePositions(nChars, this.toggleCase);
      const nFlags = computeNextFlags(flags, nTogglePositions.length);
      applyFlagsOnChars(nChars, nFlags, nTogglePositions, this.toggleCase);
      return new Value(safeJoin(nChars, ""), this.buildContextFor(nRawStringValue, new Value(nFlags, void 0)));
    }).join(makeLazy(() => {
      const chars = [...rawString];
      const togglePositions = computeTogglePositions(chars, this.toggleCase);
      return bigUintN(togglePositions.length).shrink(flags, contextSafe.flagsContext).map((nFlagsValue) => {
        const nChars = safeSlice(chars);
        applyFlagsOnChars(nChars, nFlagsValue.value, togglePositions, this.toggleCase);
        return new Value(safeJoin(nChars, ""), this.buildContextFor(new Value(rawString, contextSafe.rawStringContext), nFlagsValue));
      });
    }));
  }
};

// node_modules/fast-check/lib/esm/arbitrary/mixedCase.js
function defaultToggleCase(rawChar) {
  const upper = safeToUpperCase(rawChar);
  if (upper !== rawChar)
    return upper;
  return safeToLowerCase(rawChar);
}
function mixedCase(stringArb, constraints) {
  if (typeof SBigInt === "undefined") {
    throw new SError(`mixedCase requires BigInt support`);
  }
  const toggleCase = constraints && constraints.toggleCase || defaultToggleCase;
  const untoggleAll = constraints && constraints.untoggleAll;
  return new MixedCaseArbitrary(stringArb, toggleCase, untoggleAll);
}

// node_modules/fast-check/lib/esm/arbitrary/float32Array.js
function toTypedMapper(data) {
  return SFloat32Array.from(data);
}
function fromTypedUnmapper(value10) {
  if (!(value10 instanceof SFloat32Array))
    throw new Error("Unexpected type");
  return [...value10];
}
function float32Array(constraints = {}) {
  return array4(float(constraints), constraints).map(toTypedMapper, fromTypedUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/float64Array.js
function toTypedMapper2(data) {
  return SFloat64Array.from(data);
}
function fromTypedUnmapper2(value10) {
  if (!(value10 instanceof SFloat64Array))
    throw new Error("Unexpected type");
  return [...value10];
}
function float64Array(constraints = {}) {
  return array4(double(constraints), constraints).map(toTypedMapper2, fromTypedUnmapper2);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {
  const generatorName = TypedArrayClass.name;
  const { min: min11 = defaultMin, max: max14 = defaultMax } = constraints, arrayConstraints = __rest(constraints, ["min", "max"]);
  if (min11 > max14) {
    throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);
  }
  if (min11 < defaultMin) {
    throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);
  }
  if (max14 > defaultMax) {
    throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);
  }
  return array4(arbitraryBuilder({ min: min11, max: max14 }), arrayConstraints).map((data) => TypedArrayClass.from(data), (value10) => {
    if (!(value10 instanceof TypedArrayClass))
      throw new Error("Invalid type");
    return [...value10];
  });
}

// node_modules/fast-check/lib/esm/arbitrary/int16Array.js
function int16Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, -32768, 32767, SInt16Array, integer);
}

// node_modules/fast-check/lib/esm/arbitrary/int32Array.js
function int32Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, -2147483648, 2147483647, SInt32Array, integer);
}

// node_modules/fast-check/lib/esm/arbitrary/int8Array.js
function int8Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, -128, 127, SInt8Array, integer);
}

// node_modules/fast-check/lib/esm/arbitrary/uint16Array.js
function uint16Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 65535, SUint16Array, integer);
}

// node_modules/fast-check/lib/esm/arbitrary/uint32Array.js
function uint32Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 4294967295, SUint32Array, integer);
}

// node_modules/fast-check/lib/esm/arbitrary/uint8Array.js
function uint8Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, SUint8Array, integer);
}

// node_modules/fast-check/lib/esm/arbitrary/uint8ClampedArray.js
function uint8ClampedArray(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, 0, 255, SUint8ClampedArray, integer);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/WithShrinkFromOtherArbitrary.js
function isSafeContext(context15) {
  return context15 !== void 0;
}
function toGeneratorValue(value10) {
  if (value10.hasToBeCloned) {
    return new Value(value10.value_, { generatorContext: value10.context }, () => value10.value);
  }
  return new Value(value10.value_, { generatorContext: value10.context });
}
function toShrinkerValue(value10) {
  if (value10.hasToBeCloned) {
    return new Value(value10.value_, { shrinkerContext: value10.context }, () => value10.value);
  }
  return new Value(value10.value_, { shrinkerContext: value10.context });
}
var WithShrinkFromOtherArbitrary = class extends Arbitrary {
  constructor(generatorArbitrary, shrinkerArbitrary) {
    super();
    this.generatorArbitrary = generatorArbitrary;
    this.shrinkerArbitrary = shrinkerArbitrary;
  }
  generate(mrng, biasFactor) {
    return toGeneratorValue(this.generatorArbitrary.generate(mrng, biasFactor));
  }
  canShrinkWithoutContext(value10) {
    return this.shrinkerArbitrary.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    if (!isSafeContext(context15)) {
      return this.shrinkerArbitrary.shrink(value10, void 0).map(toShrinkerValue);
    }
    if ("generatorContext" in context15) {
      return this.generatorArbitrary.shrink(value10, context15.generatorContext).map(toGeneratorValue);
    }
    return this.shrinkerArbitrary.shrink(value10, context15.shrinkerContext).map(toShrinkerValue);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/RestrictedIntegerArbitraryBuilder.js
function restrictedIntegerArbitraryBuilder(min11, maxGenerated, max14) {
  const generatorArbitrary = integer({ min: min11, max: maxGenerated });
  if (maxGenerated === max14) {
    return generatorArbitrary;
  }
  const shrinkerArbitrary = integer({ min: min11, max: max14 });
  return new WithShrinkFromOtherArbitrary(generatorArbitrary, shrinkerArbitrary);
}

// node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
var safeMathMin6 = Math.min;
var safeMathMax4 = Math.max;
var safeArrayIsArray4 = SArray.isArray;
var safeObjectEntries2 = Object.entries;
function extractMaxIndex(indexesAndValues) {
  let maxIndex = -1;
  for (let index3 = 0; index3 !== indexesAndValues.length; ++index3) {
    maxIndex = safeMathMax4(maxIndex, indexesAndValues[index3][0]);
  }
  return maxIndex;
}
function arrayFromItems(length6, indexesAndValues) {
  const array8 = SArray(length6);
  for (let index3 = 0; index3 !== indexesAndValues.length; ++index3) {
    const it = indexesAndValues[index3];
    if (it[0] < length6)
      array8[it[0]] = it[1];
  }
  return array8;
}
function sparseArray(arb, constraints = {}) {
  const { size: size45, minNumElements = 0, maxLength: maxLength2 = MaxLengthUpperBound, maxNumElements = maxLength2, noTrailingHole, depthIdentifier } = constraints;
  const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size45, minNumElements, maxNumElements, constraints.maxNumElements !== void 0);
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size45, maxGeneratedNumElements, maxLength2, constraints.maxLength !== void 0);
  if (minNumElements > maxLength2) {
    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
  }
  if (minNumElements > maxNumElements) {
    throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
  }
  const resultedMaxNumElements = safeMathMin6(maxNumElements, maxLength2);
  const resultedSizeMaxNumElements = constraints.maxNumElements !== void 0 || size45 !== void 0 ? size45 : "=";
  const maxGeneratedIndexAuthorized = safeMathMax4(maxGeneratedLength - 1, 0);
  const maxIndexAuthorized = safeMathMax4(maxLength2 - 1, 0);
  const sparseArrayNoTrailingHole = uniqueArray(tuple4(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {
    size: resultedSizeMaxNumElements,
    minLength: minNumElements,
    maxLength: resultedMaxNumElements,
    selector: (item) => item[0],
    depthIdentifier
  }).map((items) => {
    const lastIndex = extractMaxIndex(items);
    return arrayFromItems(lastIndex + 1, items);
  }, (value10) => {
    if (!safeArrayIsArray4(value10)) {
      throw new Error("Not supported entry type");
    }
    if (noTrailingHole && value10.length !== 0 && !(value10.length - 1 in value10)) {
      throw new Error("No trailing hole");
    }
    return safeMap(safeObjectEntries2(value10), (entry) => [Number(entry[0]), entry[1]]);
  });
  if (noTrailingHole || maxLength2 === minNumElements) {
    return sparseArrayNoTrailingHole;
  }
  return tuple4(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength2)).map((data) => {
    const sparse = data[0];
    const targetLength = data[1];
    if (sparse.length >= targetLength) {
      return sparse;
    }
    const longerSparse = safeSlice(sparse);
    longerSparse.length = targetLength;
    return longerSparse;
  }, (value10) => {
    if (!safeArrayIsArray4(value10)) {
      throw new Error("Not supported entry type");
    }
    return [value10, value10.length];
  });
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToMap.js
function arrayToMapMapper(data) {
  return new Map(data);
}
function arrayToMapUnmapper(value10) {
  if (typeof value10 !== "object" || value10 === null) {
    throw new Error("Incompatible instance received: should be a non-null object");
  }
  if (!("constructor" in value10) || value10.constructor !== Map) {
    throw new Error("Incompatible instance received: should be of exact type Map");
  }
  return Array.from(value10);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToSet.js
function arrayToSetMapper(data) {
  return new Set(data);
}
function arrayToSetUnmapper(value10) {
  if (typeof value10 !== "object" || value10 === null) {
    throw new Error("Incompatible instance received: should be a non-null object");
  }
  if (!("constructor" in value10) || value10.constructor !== Set) {
    throw new Error("Incompatible instance received: should be of exact type Set");
  }
  return Array.from(value10);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/AnyArbitraryBuilder.js
function mapOf(ka, va, maxKeys, size45, depthIdentifier) {
  return uniqueArray(tuple4(ka, va), {
    maxLength: maxKeys,
    size: size45,
    comparator: "SameValueZero",
    selector: (t) => t[0],
    depthIdentifier
  }).map(arrayToMapMapper, arrayToMapUnmapper);
}
function dictOf(ka, va, maxKeys, size45, depthIdentifier, withNullPrototype) {
  return dictionary(ka, va, {
    maxKeys,
    noNullPrototype: !withNullPrototype,
    size: size45,
    depthIdentifier
  });
}
function setOf(va, maxKeys, size45, depthIdentifier) {
  return uniqueArray(va, { maxLength: maxKeys, size: size45, comparator: "SameValueZero", depthIdentifier }).map(arrayToSetMapper, arrayToSetUnmapper);
}
function typedArray(constraints) {
  return oneof(int8Array(constraints), uint8Array(constraints), uint8ClampedArray(constraints), int16Array(constraints), uint16Array(constraints), int32Array(constraints), uint32Array(constraints), float32Array(constraints), float64Array(constraints));
}
function anyArbitraryBuilder(constraints) {
  const arbitrariesForBase = constraints.values;
  const depthSize = constraints.depthSize;
  const depthIdentifier = createDepthIdentifier();
  const maxDepth = constraints.maxDepth;
  const maxKeys = constraints.maxKeys;
  const size45 = constraints.size;
  const baseArb = oneof(...arbitrariesForBase, ...constraints.withBigInt ? [bigInt()] : [], ...constraints.withDate ? [date()] : []);
  return letrec((tie) => ({
    anything: oneof({ maxDepth, depthSize, depthIdentifier }, baseArb, tie("array"), tie("object"), ...constraints.withMap ? [tie("map")] : [], ...constraints.withSet ? [tie("set")] : [], ...constraints.withObjectString ? [tie("anything").map((o) => stringify3(o))] : [], ...constraints.withTypedArray ? [typedArray({ maxLength: maxKeys, size: size45 })] : [], ...constraints.withSparseArray ? [sparseArray(tie("anything"), { maxNumElements: maxKeys, size: size45, depthIdentifier })] : []),
    keys: constraints.withObjectString ? oneof({ arbitrary: constraints.key, weight: 10 }, { arbitrary: tie("anything").map((o) => stringify3(o)), weight: 1 }) : constraints.key,
    array: array4(tie("anything"), { maxLength: maxKeys, size: size45, depthIdentifier }),
    set: setOf(tie("anything"), maxKeys, size45, depthIdentifier),
    map: oneof(mapOf(tie("keys"), tie("anything"), maxKeys, size45, depthIdentifier), mapOf(tie("anything"), tie("anything"), maxKeys, size45, depthIdentifier)),
    object: dictOf(tie("keys"), tie("anything"), maxKeys, size45, depthIdentifier, constraints.withNullPrototype)
  })).anything;
}

// node_modules/fast-check/lib/esm/arbitrary/fullUnicodeString.js
var safeObjectAssign10 = Object.assign;
function fullUnicodeString(constraints = {}) {
  const charArbitrary = fullUnicode();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign10(safeObjectAssign10({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UnboxedToBoxed.js
function unboxedToBoxedMapper(value10) {
  switch (typeof value10) {
    case "boolean":
      return new SBoolean(value10);
    case "number":
      return new SNumber(value10);
    case "string":
      return new SString(value10);
    default:
      return value10;
  }
}
function unboxedToBoxedUnmapper(value10) {
  if (typeof value10 !== "object" || value10 === null || !("constructor" in value10)) {
    return value10;
  }
  return value10.constructor === SBoolean || value10.constructor === SNumber || value10.constructor === SString ? value10.valueOf() : value10;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/BoxedArbitraryBuilder.js
function boxedArbitraryBuilder(arb) {
  return arb.map(unboxedToBoxedMapper, unboxedToBoxedUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/QualifiedObjectConstraints.js
function defaultValues(constraints, stringArbitrary) {
  return [
    boolean3(),
    maxSafeInteger(),
    double(),
    stringArbitrary(constraints),
    oneof(stringArbitrary(constraints), constant2(null), constant2(void 0))
  ];
}
function boxArbitraries(arbs) {
  return arbs.map((arb) => boxedArbitraryBuilder(arb));
}
function boxArbitrariesIfNeeded(arbs, boxEnabled) {
  return boxEnabled ? boxArbitraries(arbs).concat(arbs) : arbs;
}
function toQualifiedObjectConstraints(settings = {}) {
  function orDefault(optionalValue, defaultValue) {
    return optionalValue !== void 0 ? optionalValue : defaultValue;
  }
  const stringArbitrary = "stringUnit" in settings ? string4 : settings.withUnicodeString ? fullUnicodeString : string4;
  const valueConstraints = { size: settings.size, unit: settings.stringUnit };
  return {
    key: orDefault(settings.key, stringArbitrary(valueConstraints)),
    values: boxArbitrariesIfNeeded(orDefault(settings.values, defaultValues(valueConstraints, stringArbitrary)), orDefault(settings.withBoxedValues, false)),
    depthSize: settings.depthSize,
    maxDepth: settings.maxDepth,
    maxKeys: settings.maxKeys,
    size: settings.size,
    withSet: orDefault(settings.withSet, false),
    withMap: orDefault(settings.withMap, false),
    withObjectString: orDefault(settings.withObjectString, false),
    withNullPrototype: orDefault(settings.withNullPrototype, false),
    withBigInt: orDefault(settings.withBigInt, false),
    withDate: orDefault(settings.withDate, false),
    withTypedArray: orDefault(settings.withTypedArray, false),
    withSparseArray: orDefault(settings.withSparseArray, false)
  };
}

// node_modules/fast-check/lib/esm/arbitrary/object.js
function objectInternal(constraints) {
  return dictionary(constraints.key, anyArbitraryBuilder(constraints), {
    maxKeys: constraints.maxKeys,
    noNullPrototype: !constraints.withNullPrototype,
    size: constraints.size
  });
}
function object(constraints) {
  return objectInternal(toQualifiedObjectConstraints(constraints));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/JsonConstraintsBuilder.js
function jsonConstraintsBuilder(stringArbitrary, constraints) {
  const { depthSize, maxDepth } = constraints;
  const key = stringArbitrary;
  const values15 = [
    boolean3(),
    double({ noDefaultInfinity: true, noNaN: true }),
    stringArbitrary,
    constant2(null)
  ];
  return { key, values: values15, depthSize, maxDepth };
}

// node_modules/fast-check/lib/esm/arbitrary/anything.js
function anything(constraints) {
  return anyArbitraryBuilder(toQualifiedObjectConstraints(constraints));
}

// node_modules/fast-check/lib/esm/arbitrary/jsonValue.js
function jsonValue(constraints = {}) {
  const noUnicodeString = constraints.noUnicodeString === void 0 || constraints.noUnicodeString === true;
  const stringArbitrary = "stringUnit" in constraints ? string4({ unit: constraints.stringUnit }) : noUnicodeString ? string4() : fullUnicodeString();
  return anything(jsonConstraintsBuilder(stringArbitrary, constraints));
}

// node_modules/fast-check/lib/esm/arbitrary/json.js
function json(constraints = {}) {
  const arb = jsonValue(constraints);
  return arb.map(JSON.stringify);
}

// node_modules/fast-check/lib/esm/arbitrary/unicodeString.js
var safeObjectAssign11 = Object.assign;
function unicodeString(constraints = {}) {
  const charArbitrary = unicode();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign11(safeObjectAssign11({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/unicodeJsonValue.js
function unicodeJsonValue(constraints = {}) {
  return anything(jsonConstraintsBuilder(unicodeString(), constraints));
}

// node_modules/fast-check/lib/esm/arbitrary/unicodeJson.js
function unicodeJson(constraints = {}) {
  const arb = unicodeJsonValue(constraints);
  return arb.map(JSON.stringify);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/EnumerableKeysExtractor.js
var safeObjectKeys5 = Object.keys;
var safeObjectGetOwnPropertySymbols3 = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyDescriptor3 = Object.getOwnPropertyDescriptor;
function extractEnumerableKeys(instance) {
  const keys15 = safeObjectKeys5(instance);
  const symbols = safeObjectGetOwnPropertySymbols3(instance);
  for (let index3 = 0; index3 !== symbols.length; ++index3) {
    const symbol6 = symbols[index3];
    const descriptor3 = safeObjectGetOwnPropertyDescriptor3(instance, symbol6);
    if (descriptor3 && descriptor3.enumerable) {
      keys15.push(symbol6);
    }
  }
  return keys15;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js
var safeObjectCreate3 = Object.create;
var safeObjectDefineProperty4 = Object.defineProperty;
var safeObjectGetOwnPropertyDescriptor4 = Object.getOwnPropertyDescriptor;
var safeObjectGetOwnPropertyNames2 = Object.getOwnPropertyNames;
var safeObjectGetOwnPropertySymbols4 = Object.getOwnPropertySymbols;
function buildValuesAndSeparateKeysToObjectMapper(keys15, noKeyValue2) {
  return function valuesAndSeparateKeysToObjectMapper(definition) {
    const obj = definition[1] ? safeObjectCreate3(null) : {};
    for (let idx = 0; idx !== keys15.length; ++idx) {
      const valueWrapper = definition[0][idx];
      if (valueWrapper !== noKeyValue2) {
        safeObjectDefineProperty4(obj, keys15[idx], {
          value: valueWrapper,
          configurable: true,
          enumerable: true,
          writable: true
        });
      }
    }
    return obj;
  };
}
function buildValuesAndSeparateKeysToObjectUnmapper(keys15, noKeyValue2) {
  return function valuesAndSeparateKeysToObjectUnmapper(value10) {
    if (typeof value10 !== "object" || value10 === null) {
      throw new Error("Incompatible instance received: should be a non-null object");
    }
    const hasNullPrototype = Object.getPrototypeOf(value10) === null;
    const hasObjectPrototype = "constructor" in value10 && value10.constructor === Object;
    if (!hasNullPrototype && !hasObjectPrototype) {
      throw new Error("Incompatible instance received: should be of exact type Object");
    }
    let extractedPropertiesCount = 0;
    const extractedValues = [];
    for (let idx = 0; idx !== keys15.length; ++idx) {
      const descriptor3 = safeObjectGetOwnPropertyDescriptor4(value10, keys15[idx]);
      if (descriptor3 !== void 0) {
        if (!descriptor3.configurable || !descriptor3.enumerable || !descriptor3.writable) {
          throw new Error("Incompatible instance received: should contain only c/e/w properties");
        }
        if (descriptor3.get !== void 0 || descriptor3.set !== void 0) {
          throw new Error("Incompatible instance received: should contain only no get/set properties");
        }
        ++extractedPropertiesCount;
        safePush(extractedValues, descriptor3.value);
      } else {
        safePush(extractedValues, noKeyValue2);
      }
    }
    const namePropertiesCount = safeObjectGetOwnPropertyNames2(value10).length;
    const symbolPropertiesCount = safeObjectGetOwnPropertySymbols4(value10).length;
    if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {
      throw new Error("Incompatible instance received: should not contain extra properties");
    }
    return [extractedValues, hasNullPrototype];
  };
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
var noKeyValue = Symbol("no-key");
function buildPartialRecordArbitrary(recordModel, requiredKeys, noNullPrototype) {
  const keys15 = extractEnumerableKeys(recordModel);
  const arbs = [];
  for (let index3 = 0; index3 !== keys15.length; ++index3) {
    const k = keys15[index3];
    const requiredArbitrary = recordModel[k];
    if (requiredKeys === void 0 || safeIndexOf(requiredKeys, k) !== -1) {
      safePush(arbs, requiredArbitrary);
    } else {
      safePush(arbs, option(requiredArbitrary, { nil: noKeyValue }));
    }
  }
  return tuple4(tuple4(...arbs), noNullPrototype ? constant2(false) : boolean3()).map(buildValuesAndSeparateKeysToObjectMapper(keys15, noKeyValue), buildValuesAndSeparateKeysToObjectUnmapper(keys15, noKeyValue));
}

// node_modules/fast-check/lib/esm/arbitrary/record.js
function record(recordModel, constraints) {
  const noNullPrototype = constraints === void 0 || constraints.noNullPrototype === void 0 || constraints.noNullPrototype;
  if (constraints == null) {
    return buildPartialRecordArbitrary(recordModel, void 0, noNullPrototype);
  }
  if ("withDeletedKeys" in constraints && "requiredKeys" in constraints) {
    throw new Error(`requiredKeys and withDeletedKeys cannot be used together in fc.record`);
  }
  const requireDeletedKeys = "requiredKeys" in constraints && constraints.requiredKeys !== void 0 || "withDeletedKeys" in constraints && !!constraints.withDeletedKeys;
  if (!requireDeletedKeys) {
    return buildPartialRecordArbitrary(recordModel, void 0, noNullPrototype);
  }
  const requiredKeys = ("requiredKeys" in constraints ? constraints.requiredKeys : void 0) || [];
  for (let idx = 0; idx !== requiredKeys.length; ++idx) {
    const descriptor3 = Object.getOwnPropertyDescriptor(recordModel, requiredKeys[idx]);
    if (descriptor3 === void 0) {
      throw new Error(`requiredKeys cannot reference keys that have not been defined in recordModel`);
    }
    if (!descriptor3.enumerable) {
      throw new Error(`requiredKeys cannot reference keys that have are enumerable in recordModel`);
    }
  }
  return buildPartialRecordArbitrary(recordModel, requiredKeys, noNullPrototype);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/StreamArbitrary.js
var safeObjectDefineProperties2 = Object.defineProperties;
function prettyPrint3(seenValuesStrings) {
  return `Stream(${safeJoin(seenValuesStrings, ",")})`;
}
var StreamArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    const appliedBiasFactor = biasFactor !== void 0 && mrng.nextInt(1, biasFactor) === 1 ? biasFactor : void 0;
    const enrichedProducer = () => {
      const seenValues = [];
      const g = function* (arb, clonedMrng) {
        while (true) {
          const value10 = arb.generate(clonedMrng, appliedBiasFactor).value;
          safePush(seenValues, value10);
          yield value10;
        }
      };
      const s = new Stream(g(this.arb, mrng.clone()));
      return safeObjectDefineProperties2(s, {
        toString: { value: () => prettyPrint3(seenValues.map(stringify3)) },
        [toStringMethod]: { value: () => prettyPrint3(seenValues.map(stringify3)) },
        [asyncToStringMethod]: { value: async () => prettyPrint3(await Promise.all(seenValues.map(asyncStringify))) },
        [cloneMethod]: { value: enrichedProducer, enumerable: true }
      });
    };
    return new Value(enrichedProducer(), void 0);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  shrink(_value2, _context) {
    return Stream.nil();
  }
};

// node_modules/fast-check/lib/esm/arbitrary/infiniteStream.js
function infiniteStream(arb) {
  return new StreamArbitrary(arb);
}

// node_modules/fast-check/lib/esm/arbitrary/asciiString.js
var safeObjectAssign12 = Object.assign;
function asciiString(constraints = {}) {
  const charArbitrary = ascii();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign12(safeObjectAssign12({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/StringToBase64.js
function stringToBase64Mapper(s) {
  switch (s.length % 4) {
    case 0:
      return s;
    case 3:
      return `${s}=`;
    case 2:
      return `${s}==`;
    default:
      return safeSubstring(s, 1);
  }
}
function stringToBase64Unmapper(value10) {
  if (typeof value10 !== "string" || value10.length % 4 !== 0) {
    throw new Error("Invalid string received");
  }
  const lastTrailingIndex = value10.indexOf("=");
  if (lastTrailingIndex === -1) {
    return value10;
  }
  const numTrailings = value10.length - lastTrailingIndex;
  if (numTrailings > 2) {
    throw new Error("Cannot unmap the passed value");
  }
  return safeSubstring(value10, 0, lastTrailingIndex);
}

// node_modules/fast-check/lib/esm/arbitrary/base64String.js
function base64String(constraints = {}) {
  const { minLength: unscaledMinLength = 0, maxLength: unscaledMaxLength = MaxLengthUpperBound, size: size45 } = constraints;
  const minLength2 = unscaledMinLength + 3 - (unscaledMinLength + 3) % 4;
  const maxLength2 = unscaledMaxLength - unscaledMaxLength % 4;
  const requestedSize = constraints.maxLength === void 0 && size45 === void 0 ? "=" : size45;
  if (minLength2 > maxLength2)
    throw new Error("Minimal length should be inferior or equal to maximal length");
  if (minLength2 % 4 !== 0)
    throw new Error("Minimal length of base64 strings must be a multiple of 4");
  if (maxLength2 % 4 !== 0)
    throw new Error("Maximal length of base64 strings must be a multiple of 4");
  const charArbitrary = base64();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, codePointsToStringUnmapper);
  const enrichedConstraints = {
    minLength: minLength2,
    maxLength: maxLength2,
    size: requestedSize,
    experimentalCustomSlices
  };
  return array4(charArbitrary, enrichedConstraints).map(codePointsToStringMapper, codePointsToStringUnmapper).map(stringToBase64Mapper, stringToBase64Unmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CharsToString.js
function charsToStringMapper(tab) {
  return safeJoin(tab, "");
}
function charsToStringUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Cannot unmap the passed value");
  }
  return safeSplit(value10, "");
}

// node_modules/fast-check/lib/esm/arbitrary/string16bits.js
var safeObjectAssign13 = Object.assign;
function string16bits(constraints = {}) {
  const charArbitrary = char16bits();
  const experimentalCustomSlices = createSlicesForStringLegacy(charArbitrary, charsToStringUnmapper);
  const enrichedConstraints = safeObjectAssign13(safeObjectAssign13({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArbitrary, enrichedConstraints).map(charsToStringMapper, charsToStringUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/stringOf.js
var safeObjectAssign14 = Object.assign;
function stringOf(charArb, constraints = {}) {
  const unmapper = patternsToStringUnmapperFor(charArb, constraints);
  const experimentalCustomSlices = createSlicesForStringLegacy(charArb, unmapper);
  const enrichedConstraints = safeObjectAssign14(safeObjectAssign14({}, constraints), {
    experimentalCustomSlices
  });
  return array4(charArb, enrichedConstraints).map(patternsToStringMapper, unmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/IsSubarrayOf.js
var safeObjectIs8 = Object.is;
function isSubarrayOf(source, small) {
  const countMap = new SMap();
  let countMinusZero = 0;
  for (const sourceEntry of source) {
    if (safeObjectIs8(sourceEntry, -0)) {
      ++countMinusZero;
    } else {
      const oldCount = safeMapGet(countMap, sourceEntry) || 0;
      safeMapSet(countMap, sourceEntry, oldCount + 1);
    }
  }
  for (let index3 = 0; index3 !== small.length; ++index3) {
    if (!(index3 in small)) {
      return false;
    }
    const smallEntry = small[index3];
    if (safeObjectIs8(smallEntry, -0)) {
      if (countMinusZero === 0)
        return false;
      --countMinusZero;
    } else {
      const oldCount = safeMapGet(countMap, smallEntry) || 0;
      if (oldCount === 0)
        return false;
      safeMapSet(countMap, smallEntry, oldCount - 1);
    }
  }
  return true;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js
var safeMathFloor6 = Math.floor;
var safeMathLog4 = Math.log;
var safeArrayIsArray5 = Array.isArray;
var SubarrayArbitrary = class extends Arbitrary {
  constructor(originalArray, isOrdered, minLength2, maxLength2) {
    super();
    this.originalArray = originalArray;
    this.isOrdered = isOrdered;
    this.minLength = minLength2;
    this.maxLength = maxLength2;
    if (minLength2 < 0 || minLength2 > originalArray.length)
      throw new Error("fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array");
    if (maxLength2 < 0 || maxLength2 > originalArray.length)
      throw new Error("fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array");
    if (minLength2 > maxLength2)
      throw new Error("fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length");
    this.lengthArb = new IntegerArbitrary(minLength2, maxLength2);
    this.biasedLengthArb = minLength2 !== maxLength2 ? new IntegerArbitrary(minLength2, minLength2 + safeMathFloor6(safeMathLog4(maxLength2 - minLength2) / safeMathLog4(2))) : this.lengthArb;
  }
  generate(mrng, biasFactor) {
    const lengthArb = biasFactor !== void 0 && mrng.nextInt(1, biasFactor) === 1 ? this.biasedLengthArb : this.lengthArb;
    const size45 = lengthArb.generate(mrng, void 0);
    const sizeValue = size45.value;
    const remainingElements = safeMap(this.originalArray, (_v, idx) => idx);
    const ids3 = [];
    for (let index3 = 0; index3 !== sizeValue; ++index3) {
      const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);
      safePush(ids3, remainingElements[selectedIdIndex]);
      safeSplice(remainingElements, selectedIdIndex, 1);
    }
    if (this.isOrdered) {
      safeSort(ids3, (a, b) => a - b);
    }
    return new Value(safeMap(ids3, (i) => this.originalArray[i]), size45.context);
  }
  canShrinkWithoutContext(value10) {
    if (!safeArrayIsArray5(value10)) {
      return false;
    }
    if (!this.lengthArb.canShrinkWithoutContext(value10.length)) {
      return false;
    }
    return isSubarrayOf(this.originalArray, value10);
  }
  shrink(value10, context15) {
    if (value10.length === 0) {
      return Stream.nil();
    }
    return this.lengthArb.shrink(value10.length, context15).map((newSize) => {
      return new Value(safeSlice(value10, value10.length - newSize.value), newSize.context);
    }).join(value10.length > this.minLength ? makeLazy(() => this.shrink(safeSlice(value10, 1), void 0).filter((newValue) => this.minLength <= newValue.value.length + 1).map((newValue) => new Value([value10[0], ...newValue.value], void 0))) : Stream.nil());
  }
};

// node_modules/fast-check/lib/esm/arbitrary/subarray.js
function subarray(originalArray, constraints = {}) {
  const { minLength: minLength2 = 0, maxLength: maxLength2 = originalArray.length } = constraints;
  return new SubarrayArbitrary(originalArray, true, minLength2, maxLength2);
}

// node_modules/fast-check/lib/esm/arbitrary/shuffledSubarray.js
function shuffledSubarray(originalArray, constraints = {}) {
  const { minLength: minLength2 = 0, maxLength: maxLength2 = originalArray.length } = constraints;
  return new SubarrayArbitrary(originalArray, false, minLength2, maxLength2);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UintToBase32String.js
var encodeSymbolLookupTable = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F",
  16: "G",
  17: "H",
  18: "J",
  19: "K",
  20: "M",
  21: "N",
  22: "P",
  23: "Q",
  24: "R",
  25: "S",
  26: "T",
  27: "V",
  28: "W",
  29: "X",
  30: "Y",
  31: "Z"
};
var decodeSymbolLookupTable = {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15,
  G: 16,
  H: 17,
  J: 18,
  K: 19,
  M: 20,
  N: 21,
  P: 22,
  Q: 23,
  R: 24,
  S: 25,
  T: 26,
  V: 27,
  W: 28,
  X: 29,
  Y: 30,
  Z: 31
};
function encodeSymbol(symbol6) {
  return symbol6 < 10 ? SString(symbol6) : encodeSymbolLookupTable[symbol6];
}
function pad3(value10, paddingLength) {
  let extraPadding = "";
  while (value10.length + extraPadding.length < paddingLength) {
    extraPadding += "0";
  }
  return extraPadding + value10;
}
function smallUintToBase32StringMapper(num) {
  let base32Str = "";
  for (let remaining = num; remaining !== 0; ) {
    const next6 = remaining >> 5;
    const current2 = remaining - (next6 << 5);
    base32Str = encodeSymbol(current2) + base32Str;
    remaining = next6;
  }
  return base32Str;
}
function uintToBase32StringMapper(num, paddingLength) {
  const head13 = ~~(num / 1073741824);
  const tail5 = num & 1073741823;
  return pad3(smallUintToBase32StringMapper(head13), paddingLength - 6) + pad3(smallUintToBase32StringMapper(tail5), 6);
}
function paddedUintToBase32StringMapper(paddingLength) {
  return function padded(num) {
    return uintToBase32StringMapper(num, paddingLength);
  };
}
function uintToBase32StringUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new SError("Unsupported type");
  }
  let accumulated = 0;
  let power = 1;
  for (let index3 = value10.length - 1; index3 >= 0; --index3) {
    const char2 = value10[index3];
    const numericForChar = decodeSymbolLookupTable[char2];
    if (numericForChar === void 0) {
      throw new SError("Unsupported type");
    }
    accumulated += numericForChar * power;
    power *= 32;
  }
  return accumulated;
}

// node_modules/fast-check/lib/esm/arbitrary/ulid.js
var padded10Mapper = paddedUintToBase32StringMapper(10);
var padded8Mapper = paddedUintToBase32StringMapper(8);
function ulidMapper(parts2) {
  return padded10Mapper(parts2[0]) + padded8Mapper(parts2[1]) + padded8Mapper(parts2[2]);
}
function ulidUnmapper(value10) {
  if (typeof value10 !== "string" || value10.length !== 26) {
    throw new Error("Unsupported type");
  }
  return [
    uintToBase32StringUnmapper(value10.slice(0, 10)),
    uintToBase32StringUnmapper(value10.slice(10, 18)),
    uintToBase32StringUnmapper(value10.slice(18))
  ];
}
function ulid() {
  const timestampPartArbitrary = integer({ min: 0, max: 281474976710655 });
  const randomnessPartOneArbitrary = integer({ min: 0, max: 1099511627775 });
  const randomnessPartTwoArbitrary = integer({ min: 0, max: 1099511627775 });
  return tuple4(timestampPartArbitrary, randomnessPartOneArbitrary, randomnessPartTwoArbitrary).map(ulidMapper, ulidUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NumberToPaddedEight.js
function numberToPaddedEightMapper(n) {
  return safePadStart(safeNumberToString(n, 16), 8, "0");
}
function numberToPaddedEightUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported type");
  }
  if (value10.length !== 8) {
    throw new Error("Unsupported value: invalid length");
  }
  const n = parseInt(value10, 16);
  if (value10 !== numberToPaddedEightMapper(n)) {
    throw new Error("Unsupported value: invalid content");
  }
  return n;
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PaddedNumberArbitraryBuilder.js
function buildPaddedNumberArbitrary(min11, max14) {
  return integer({ min: min11, max: max14 }).map(numberToPaddedEightMapper, numberToPaddedEightUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PaddedEightsToUuid.js
function paddedEightsToUuidMapper(t) {
  return `${t[0]}-${safeSubstring(t[1], 4)}-${safeSubstring(t[1], 0, 4)}-${safeSubstring(t[2], 0, 4)}-${safeSubstring(t[2], 4)}${t[3]}`;
}
var UuidRegex = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;
function paddedEightsToUuidUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported type");
  }
  const m = UuidRegex.exec(value10);
  if (m === null) {
    throw new Error("Unsupported type");
  }
  return [m[1], m[3] + m[2], m[4] + safeSubstring(m[5], 0, 4), safeSubstring(m[5], 4)];
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/VersionsApplierForUuid.js
var quickNumberToHexaString = "0123456789abcdef";
function buildVersionsAppliersForUuid(versions) {
  const mapping = {};
  const reversedMapping = {};
  for (let index3 = 0; index3 !== versions.length; ++index3) {
    const from29 = quickNumberToHexaString[index3];
    const to3 = quickNumberToHexaString[versions[index3]];
    mapping[from29] = to3;
    reversedMapping[to3] = from29;
  }
  function versionsApplierMapper(value10) {
    return mapping[value10[0]] + safeSubstring(value10, 1);
  }
  function versionsApplierUnmapper(value10) {
    if (typeof value10 !== "string") {
      throw new SError("Cannot produce non-string values");
    }
    const rev2 = reversedMapping[value10[0]];
    if (rev2 === void 0) {
      throw new SError("Cannot produce strings not starting by the version in hexa code");
    }
    return rev2 + safeSubstring(value10, 1);
  }
  return { versionsApplierMapper, versionsApplierUnmapper };
}

// node_modules/fast-check/lib/esm/arbitrary/uuid.js
function assertValidVersions(versions) {
  const found = {};
  for (const version of versions) {
    if (found[version]) {
      throw new SError(`Version ${version} has been requested at least twice for uuid`);
    }
    found[version] = true;
    if (version < 1 || version > 15) {
      throw new SError(`Version must be a value in [1-15] for uuid, but received ${version}`);
    }
    if (~~version !== version) {
      throw new SError(`Version must be an integer value for uuid, but received ${version}`);
    }
  }
  if (versions.length === 0) {
    throw new SError(`Must provide at least one version for uuid`);
  }
}
function uuid(constraints = {}) {
  const padded = buildPaddedNumberArbitrary(0, 4294967295);
  const version = constraints.version !== void 0 ? typeof constraints.version === "number" ? [constraints.version] : constraints.version : [1, 2, 3, 4, 5];
  assertValidVersions(version);
  const { versionsApplierMapper, versionsApplierUnmapper } = buildVersionsAppliersForUuid(version);
  const secondPadded = buildPaddedNumberArbitrary(0, 268435456 * version.length - 1).map(versionsApplierMapper, versionsApplierUnmapper);
  const thirdPadded = buildPaddedNumberArbitrary(2147483648, 3221225471);
  return tuple4(padded, secondPadded, thirdPadded, padded).map(paddedEightsToUuidMapper, paddedEightsToUuidUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/uuidV.js
function uuidV(versionNumber) {
  const padded = buildPaddedNumberArbitrary(0, 4294967295);
  const offsetSecond = versionNumber * 268435456;
  const secondPadded = buildPaddedNumberArbitrary(offsetSecond, offsetSecond + 268435455);
  const thirdPadded = buildPaddedNumberArbitrary(2147483648, 3221225471);
  return tuple4(padded, secondPadded, thirdPadded, padded).map(paddedEightsToUuidMapper, paddedEightsToUuidUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/webAuthority.js
function hostUserInfo(size45) {
  return string4({ unit: getOrCreateAlphaNumericPercentArbitrary("-._~!$&'()*+,;=:"), size: size45 });
}
function userHostPortMapper([u, h2, p]) {
  return (u === null ? "" : `${u}@`) + h2 + (p === null ? "" : `:${p}`);
}
function userHostPortUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Unsupported");
  }
  const atPosition = value10.indexOf("@");
  const user = atPosition !== -1 ? value10.substring(0, atPosition) : null;
  const portRegex = /:(\d+)$/;
  const m = portRegex.exec(value10);
  const port3 = m !== null ? Number(m[1]) : null;
  const host = m !== null ? value10.substring(atPosition + 1, value10.length - m[1].length - 1) : value10.substring(atPosition + 1);
  return [user, host, port3];
}
function bracketedMapper(s) {
  return `[${s}]`;
}
function bracketedUnmapper(value10) {
  if (typeof value10 !== "string" || value10[0] !== "[" || value10[value10.length - 1] !== "]") {
    throw new Error("Unsupported");
  }
  return value10.substring(1, value10.length - 1);
}
function webAuthority(constraints) {
  const c = constraints || {};
  const size45 = c.size;
  const hostnameArbs = [
    domain({ size: size45 }),
    ...c.withIPv4 === true ? [ipV4()] : [],
    ...c.withIPv6 === true ? [ipV6().map(bracketedMapper, bracketedUnmapper)] : [],
    ...c.withIPv4Extended === true ? [ipV4Extended()] : []
  ];
  return tuple4(c.withUserInfo === true ? option(hostUserInfo(size45)) : constant2(null), oneof(...hostnameArbs), c.withPort === true ? option(nat(65535)) : constant2(null)).map(userHostPortMapper, userHostPortUnmapper);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriQueryOrFragmentArbitraryBuilder.js
function buildUriQueryOrFragmentArbitrary(size45) {
  return string4({ unit: getOrCreateAlphaNumericPercentArbitrary("-._~!$&'()*+,;=:@/?"), size: size45 });
}

// node_modules/fast-check/lib/esm/arbitrary/webFragments.js
function webFragments(constraints = {}) {
  return buildUriQueryOrFragmentArbitrary(constraints.size);
}

// node_modules/fast-check/lib/esm/arbitrary/webSegment.js
function webSegment(constraints = {}) {
  return string4({ unit: getOrCreateAlphaNumericPercentArbitrary("-._~!$&'()*+,;=:@"), size: constraints.size });
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/SegmentsToPath.js
function segmentsToPathMapper(segments) {
  return safeJoin(safeMap(segments, (v) => `/${v}`), "");
}
function segmentsToPathUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Incompatible value received: type");
  }
  if (value10.length !== 0 && value10[0] !== "/") {
    throw new Error("Incompatible value received: start");
  }
  return safeSplice(safeSplit(value10, "/"), 1);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriPathArbitraryBuilder.js
function sqrtSize(size45) {
  switch (size45) {
    case "xsmall":
      return ["xsmall", "xsmall"];
    case "small":
      return ["small", "xsmall"];
    case "medium":
      return ["small", "small"];
    case "large":
      return ["medium", "small"];
    case "xlarge":
      return ["medium", "medium"];
  }
}
function buildUriPathArbitraryInternal(segmentSize, numSegmentSize) {
  return array4(webSegment({ size: segmentSize }), { size: numSegmentSize }).map(segmentsToPathMapper, segmentsToPathUnmapper);
}
function buildUriPathArbitrary(resolvedSize) {
  const [segmentSize, numSegmentSize] = sqrtSize(resolvedSize);
  if (segmentSize === numSegmentSize) {
    return buildUriPathArbitraryInternal(segmentSize, numSegmentSize);
  }
  return oneof(buildUriPathArbitraryInternal(segmentSize, numSegmentSize), buildUriPathArbitraryInternal(numSegmentSize, segmentSize));
}

// node_modules/fast-check/lib/esm/arbitrary/webPath.js
function webPath(constraints) {
  const c = constraints || {};
  const resolvedSize = resolveSize(c.size);
  return buildUriPathArbitrary(resolvedSize);
}

// node_modules/fast-check/lib/esm/arbitrary/webQueryParameters.js
function webQueryParameters(constraints = {}) {
  return buildUriQueryOrFragmentArbitrary(constraints.size);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PartsToUrl.js
function partsToUrlMapper(data) {
  const [scheme, authority, path2] = data;
  const query = data[3] === null ? "" : `?${data[3]}`;
  const fragments = data[4] === null ? "" : `#${data[4]}`;
  return `${scheme}://${authority}${path2}${query}${fragments}`;
}
var UrlSplitRegex = /^([[A-Za-z][A-Za-z0-9+.-]*):\/\/([^/?#]*)([^?#]*)(\?[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?(#[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?$/;
function partsToUrlUnmapper(value10) {
  if (typeof value10 !== "string") {
    throw new Error("Incompatible value received: type");
  }
  const m = UrlSplitRegex.exec(value10);
  if (m === null) {
    throw new Error("Incompatible value received");
  }
  const scheme = m[1];
  const authority = m[2];
  const path2 = m[3];
  const query = m[4];
  const fragments = m[5];
  return [
    scheme,
    authority,
    path2,
    query !== void 0 ? query.substring(1) : null,
    fragments !== void 0 ? fragments.substring(1) : null
  ];
}

// node_modules/fast-check/lib/esm/arbitrary/webUrl.js
var safeObjectAssign15 = Object.assign;
function webUrl(constraints) {
  const c = constraints || {};
  const resolvedSize = resolveSize(c.size);
  const resolvedAuthoritySettingsSize = c.authoritySettings !== void 0 && c.authoritySettings.size !== void 0 ? relativeSizeToSize(c.authoritySettings.size, resolvedSize) : resolvedSize;
  const resolvedAuthoritySettings = safeObjectAssign15(safeObjectAssign15({}, c.authoritySettings), {
    size: resolvedAuthoritySettingsSize
  });
  const validSchemes = c.validSchemes || ["http", "https"];
  const schemeArb = constantFrom(...validSchemes);
  const authorityArb = webAuthority(resolvedAuthoritySettings);
  return tuple4(schemeArb, authorityArb, webPath({ size: resolvedSize }), c.withQueryParameters === true ? option(webQueryParameters({ size: resolvedSize })) : constant2(null), c.withFragments === true ? option(webFragments({ size: resolvedSize })) : constant2(null)).map(partsToUrlMapper, partsToUrlUnmapper);
}

// node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js
var CommandsIterable = class _CommandsIterable {
  constructor(commands2, metadataForReplay) {
    this.commands = commands2;
    this.metadataForReplay = metadataForReplay;
  }
  [Symbol.iterator]() {
    return this.commands[Symbol.iterator]();
  }
  [cloneMethod]() {
    return new _CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
  }
  toString() {
    const serializedCommands = this.commands.filter((c) => c.hasRan).map((c) => c.toString()).join(",");
    const metadata = this.metadataForReplay();
    return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
  }
};

// node_modules/fast-check/lib/esm/check/model/commands/CommandWrapper.js
var CommandWrapper = class _CommandWrapper {
  constructor(cmd) {
    this.cmd = cmd;
    this.hasRan = false;
    if (hasToStringMethod(cmd)) {
      const method = cmd[toStringMethod];
      this[toStringMethod] = function toStringMethod2() {
        return method.call(cmd);
      };
    }
    if (hasAsyncToStringMethod(cmd)) {
      const method = cmd[asyncToStringMethod];
      this[asyncToStringMethod] = function asyncToStringMethod2() {
        return method.call(cmd);
      };
    }
  }
  check(m) {
    return this.cmd.check(m);
  }
  run(m, r) {
    this.hasRan = true;
    return this.cmd.run(m, r);
  }
  clone() {
    if (hasCloneMethod(this.cmd))
      return new _CommandWrapper(this.cmd[cloneMethod]());
    return new _CommandWrapper(this.cmd);
  }
  toString() {
    return this.cmd.toString();
  }
};

// node_modules/fast-check/lib/esm/check/model/ReplayPath.js
var ReplayPath = class {
  static parse(replayPathStr) {
    const [serializedCount, serializedChanges] = replayPathStr.split(":");
    const counts = this.parseCounts(serializedCount);
    const changes4 = this.parseChanges(serializedChanges);
    return this.parseOccurences(counts, changes4);
  }
  static stringify(replayPath) {
    const occurences = this.countOccurences(replayPath);
    const serializedCount = this.stringifyCounts(occurences);
    const serializedChanges = this.stringifyChanges(occurences);
    return `${serializedCount}:${serializedChanges}`;
  }
  static intToB64(n) {
    if (n < 26)
      return String.fromCharCode(n + 65);
    if (n < 52)
      return String.fromCharCode(n + 97 - 26);
    if (n < 62)
      return String.fromCharCode(n + 48 - 52);
    return String.fromCharCode(n === 62 ? 43 : 47);
  }
  static b64ToInt(c) {
    if (c >= "a")
      return c.charCodeAt(0) - 97 + 26;
    if (c >= "A")
      return c.charCodeAt(0) - 65;
    if (c >= "0")
      return c.charCodeAt(0) - 48 + 52;
    return c === "+" ? 62 : 63;
  }
  static countOccurences(replayPath) {
    return replayPath.reduce((counts, cur) => {
      if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)
        counts.push({ value: cur, count: 1 });
      else
        counts[counts.length - 1].count += 1;
      return counts;
    }, []);
  }
  static parseOccurences(counts, changes4) {
    const replayPath = [];
    for (let idx = 0; idx !== counts.length; ++idx) {
      const count9 = counts[idx];
      const value10 = changes4[idx];
      for (let num = 0; num !== count9; ++num)
        replayPath.push(value10);
    }
    return replayPath;
  }
  static stringifyChanges(occurences) {
    let serializedChanges = "";
    for (let idx = 0; idx < occurences.length; idx += 6) {
      const changesInt = occurences.slice(idx, idx + 6).reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);
      serializedChanges += this.intToB64(changesInt);
    }
    return serializedChanges;
  }
  static parseChanges(serializedChanges) {
    const changesInt = serializedChanges.split("").map((c) => this.b64ToInt(c));
    const changes4 = [];
    for (let idx = 0; idx !== changesInt.length; ++idx) {
      let current2 = changesInt[idx];
      for (let n = 0; n !== 6; ++n, current2 >>= 1) {
        changes4.push(current2 % 2 === 1);
      }
    }
    return changes4;
  }
  static stringifyCounts(occurences) {
    return occurences.map(({ count: count9 }) => this.intToB64(count9 - 1)).join("");
  }
  static parseCounts(serializedCount) {
    return serializedCount.split("").map((c) => this.b64ToInt(c) + 1);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/CommandsArbitrary.js
var CommandsArbitrary = class extends Arbitrary {
  constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog) {
    super();
    this.sourceReplayPath = sourceReplayPath;
    this.disableReplayLog = disableReplayLog;
    this.oneCommandArb = oneof(...commandArbs).map((c) => new CommandWrapper(c));
    this.lengthArb = restrictedIntegerArbitraryBuilder(0, maxGeneratedCommands, maxCommands);
    this.replayPath = [];
    this.replayPathPosition = 0;
  }
  metadataForReplay() {
    return this.disableReplayLog ? "" : `replayPath=${JSON.stringify(ReplayPath.stringify(this.replayPath))}`;
  }
  buildValueFor(items, shrunkOnce) {
    const commands2 = items.map((item) => item.value_);
    const context15 = { shrunkOnce, items };
    return new Value(new CommandsIterable(commands2, () => this.metadataForReplay()), context15);
  }
  generate(mrng) {
    const size45 = this.lengthArb.generate(mrng, void 0);
    const sizeValue = size45.value;
    const items = Array(sizeValue);
    for (let idx = 0; idx !== sizeValue; ++idx) {
      const item = this.oneCommandArb.generate(mrng, void 0);
      items[idx] = item;
    }
    this.replayPathPosition = 0;
    return this.buildValueFor(items, false);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  filterOnExecution(itemsRaw) {
    const items = [];
    for (const c of itemsRaw) {
      if (c.value_.hasRan) {
        this.replayPath.push(true);
        items.push(c);
      } else
        this.replayPath.push(false);
    }
    return items;
  }
  filterOnReplay(itemsRaw) {
    return itemsRaw.filter((c, idx) => {
      const state = this.replayPath[this.replayPathPosition + idx];
      if (state === void 0)
        throw new Error(`Too short replayPath`);
      if (!state && c.value_.hasRan)
        throw new Error(`Mismatch between replayPath and real execution`);
      return state;
    });
  }
  filterForShrinkImpl(itemsRaw) {
    if (this.replayPathPosition === 0) {
      this.replayPath = this.sourceReplayPath !== null ? ReplayPath.parse(this.sourceReplayPath) : [];
    }
    const items = this.replayPathPosition < this.replayPath.length ? this.filterOnReplay(itemsRaw) : this.filterOnExecution(itemsRaw);
    this.replayPathPosition += itemsRaw.length;
    return items;
  }
  shrink(_value2, context15) {
    if (context15 === void 0) {
      return Stream.nil();
    }
    const safeContext = context15;
    const shrunkOnce = safeContext.shrunkOnce;
    const itemsRaw = safeContext.items;
    const items = this.filterForShrinkImpl(itemsRaw);
    if (items.length === 0) {
      return Stream.nil();
    }
    const rootShrink = shrunkOnce ? Stream.nil() : new Stream([[]][Symbol.iterator]());
    const nextShrinks = [];
    for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {
      nextShrinks.push(makeLazy(() => {
        const fixedStart = items.slice(0, numToKeep);
        return this.lengthArb.shrink(items.length - 1 - numToKeep, void 0).map((l) => fixedStart.concat(items.slice(items.length - (l.value + 1))));
      }));
    }
    for (let itemAt = 0; itemAt !== items.length; ++itemAt) {
      nextShrinks.push(makeLazy(() => this.oneCommandArb.shrink(items[itemAt].value_, items[itemAt].context).map((v) => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));
    }
    return rootShrink.join(...nextShrinks).map((shrinkables) => {
      return this.buildValueFor(shrinkables.map((c) => new Value(c.value_.clone(), c.context)), true);
    });
  }
};

// node_modules/fast-check/lib/esm/arbitrary/commands.js
function commands(commandArbs, constraints = {}) {
  const { size: size45, maxCommands = MaxLengthUpperBound, disableReplayLog = false, replayPath = null } = constraints;
  const specifiedMaxCommands = constraints.maxCommands !== void 0;
  const maxGeneratedCommands = maxGeneratedLengthFromSizeForArbitrary(size45, 0, maxCommands, specifiedMaxCommands);
  return new CommandsArbitrary(commandArbs, maxGeneratedCommands, maxCommands, replayPath, disableReplayLog);
}

// node_modules/fast-check/lib/esm/check/model/commands/ScheduledCommand.js
var ScheduledCommand = class {
  constructor(s, cmd) {
    this.s = s;
    this.cmd = cmd;
  }
  async check(m) {
    let error4 = null;
    let checkPassed = false;
    const status3 = await this.s.scheduleSequence([
      {
        label: `check@${this.cmd.toString()}`,
        builder: async () => {
          try {
            checkPassed = await Promise.resolve(this.cmd.check(m));
          } catch (err2) {
            error4 = err2;
            throw err2;
          }
        }
      }
    ]).task;
    if (status3.faulty) {
      throw error4;
    }
    return checkPassed;
  }
  async run(m, r) {
    let error4 = null;
    const status3 = await this.s.scheduleSequence([
      {
        label: `run@${this.cmd.toString()}`,
        builder: async () => {
          try {
            await this.cmd.run(m, r);
          } catch (err2) {
            error4 = err2;
            throw err2;
          }
        }
      }
    ]).task;
    if (status3.faulty) {
      throw error4;
    }
  }
};
var scheduleCommands = function* (s, cmds) {
  for (const cmd of cmds) {
    yield new ScheduledCommand(s, cmd);
  }
};

// node_modules/fast-check/lib/esm/check/model/ModelRunner.js
var genericModelRun = (s, cmds, initialValue, runCmd, then) => {
  return s.then((o) => {
    const { model, real } = o;
    let state = initialValue;
    for (const c of cmds) {
      state = then(state, () => {
        return runCmd(c, model, real);
      });
    }
    return state;
  });
};
var internalModelRun = (s, cmds) => {
  const then = (_p, c) => c();
  const setupProducer = {
    then: (fun) => {
      fun(s());
      return void 0;
    }
  };
  const runSync4 = (cmd, m, r) => {
    if (cmd.check(m))
      cmd.run(m, r);
    return void 0;
  };
  return genericModelRun(setupProducer, cmds, void 0, runSync4, then);
};
var isAsyncSetup = (s) => {
  return typeof s.then === "function";
};
var internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve()) => {
  const then = (p, c) => p.then(c);
  const setupProducer = {
    then: (fun) => {
      const out = s();
      if (isAsyncSetup(out))
        return out.then(fun);
      else
        return fun(out);
    }
  };
  const runAsync = async (cmd, m, r) => {
    if (await cmd.check(m))
      await cmd.run(m, r);
  };
  return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);
};
function modelRun(s, cmds) {
  internalModelRun(s, cmds);
}
async function asyncModelRun(s, cmds) {
  await internalAsyncModelRun(s, cmds);
}
async function scheduledModelRun(scheduler2, s, cmds) {
  const scheduledCommands = scheduleCommands(scheduler2, cmds);
  const out = internalAsyncModelRun(s, scheduledCommands, scheduler2.schedule(Promise.resolve(), "startModel"));
  await scheduler2.waitFor(out);
  await scheduler2.waitAll();
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js
var defaultSchedulerAct = (f2) => f2();
var SchedulerImplem = class _SchedulerImplem {
  constructor(act, taskSelector) {
    this.act = act;
    this.taskSelector = taskSelector;
    this.lastTaskId = 0;
    this.sourceTaskSelector = taskSelector.clone();
    this.scheduledTasks = [];
    this.triggeredTasks = [];
    this.scheduledWatchers = [];
  }
  static buildLog(reportItem) {
    return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== void 0 ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ""}`;
  }
  log(schedulingType, taskId, label, metadata, status3, data) {
    this.triggeredTasks.push({
      status: status3,
      schedulingType,
      taskId,
      label,
      metadata,
      outputValue: data !== void 0 ? stringify3(data) : void 0
    });
  }
  scheduleInternal(schedulingType, label, task, metadata, customAct, thenTaskToBeAwaited) {
    let trigger = null;
    const taskId = ++this.lastTaskId;
    const scheduledPromise = new Promise((resolve, reject3) => {
      trigger = () => {
        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
          this.log(schedulingType, taskId, label, metadata, "resolved", data);
          return resolve(data);
        }, (err2) => {
          this.log(schedulingType, taskId, label, metadata, "rejected", err2);
          return reject3(err2);
        });
      };
    });
    this.scheduledTasks.push({
      original: task,
      scheduled: scheduledPromise,
      trigger,
      schedulingType,
      taskId,
      label,
      metadata,
      customAct
    });
    if (this.scheduledWatchers.length !== 0) {
      this.scheduledWatchers[0]();
    }
    return scheduledPromise;
  }
  schedule(task, label, metadata, customAct) {
    return this.scheduleInternal("promise", label || "", task, metadata, customAct || defaultSchedulerAct);
  }
  scheduleFunction(asyncFunction, customAct) {
    return (...args2) => this.scheduleInternal("function", `${asyncFunction.name}(${args2.map(stringify3).join(",")})`, asyncFunction(...args2), void 0, customAct || defaultSchedulerAct);
  }
  scheduleSequence(sequenceBuilders, customAct) {
    const status3 = { done: false, faulty: false };
    const dummyResolvedPromise = { then: (f2) => f2() };
    let resolveSequenceTask = () => {
    };
    const sequenceTask = new Promise((resolve) => resolveSequenceTask = resolve);
    sequenceBuilders.reduce((previouslyScheduled, item) => {
      const [builder, label, metadata] = typeof item === "function" ? [item, item.name, void 0] : [item.builder, item.label, item.metadata];
      return previouslyScheduled.then(() => {
        const scheduled = this.scheduleInternal("sequence", label, dummyResolvedPromise, metadata, customAct || defaultSchedulerAct, () => builder());
        scheduled.catch(() => {
          status3.faulty = true;
          resolveSequenceTask();
        });
        return scheduled;
      });
    }, dummyResolvedPromise).then(() => {
      status3.done = true;
      resolveSequenceTask();
    }, () => {
    });
    return Object.assign(status3, {
      task: Promise.resolve(sequenceTask).then(() => {
        return { done: status3.done, faulty: status3.faulty };
      })
    });
  }
  count() {
    return this.scheduledTasks.length;
  }
  internalWaitOne() {
    if (this.scheduledTasks.length === 0) {
      throw new Error("No task scheduled");
    }
    const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
    const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
    return scheduledTask.customAct(async () => {
      scheduledTask.trigger();
      try {
        await scheduledTask.scheduled;
      } catch (_err) {
      }
    });
  }
  async waitOne(customAct) {
    const waitAct = customAct || defaultSchedulerAct;
    await this.act(() => waitAct(async () => await this.internalWaitOne()));
  }
  async waitAll(customAct) {
    while (this.scheduledTasks.length > 0) {
      await this.waitOne(customAct);
    }
  }
  async waitFor(unscheduledTask, customAct) {
    let taskResolved = false;
    let awaiterPromise = null;
    const awaiter = async () => {
      while (!taskResolved && this.scheduledTasks.length > 0) {
        await this.waitOne(customAct);
      }
      awaiterPromise = null;
    };
    const handleNotified = () => {
      if (awaiterPromise !== null) {
        return;
      }
      awaiterPromise = Promise.resolve().then(awaiter);
    };
    const clearAndReplaceWatcher = () => {
      const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
      if (handleNotifiedIndex !== -1) {
        this.scheduledWatchers.splice(handleNotifiedIndex, 1);
      }
      if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {
        this.scheduledWatchers[0]();
      }
    };
    const rewrappedTask = unscheduledTask.then((ret) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        return ret;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        return ret;
      });
    }, (err2) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        throw err2;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        throw err2;
      });
    });
    if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {
      handleNotified();
    }
    this.scheduledWatchers.push(handleNotified);
    return rewrappedTask;
  }
  report() {
    return [
      ...this.triggeredTasks,
      ...this.scheduledTasks.map((t) => ({
        status: "pending",
        schedulingType: t.schedulingType,
        taskId: t.taskId,
        label: t.label,
        metadata: t.metadata
      }))
    ];
  }
  toString() {
    return "schedulerFor()`\n" + this.report().map(_SchedulerImplem.buildLog).map((log5) => `-> ${log5}`).join("\n") + "`";
  }
  [cloneMethod]() {
    return new _SchedulerImplem(this.act, this.sourceTaskSelector);
  }
};

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSchedulerFor.js
function buildNextTaskIndex(ordering) {
  let numTasks = 0;
  return {
    clone: () => buildNextTaskIndex(ordering),
    nextTaskIndex: (scheduledTasks) => {
      if (ordering.length <= numTasks) {
        throw new Error(`Invalid schedulerFor defined: too many tasks have been scheduled`);
      }
      const taskIndex = scheduledTasks.findIndex((t) => t.taskId === ordering[numTasks]);
      if (taskIndex === -1) {
        throw new Error(`Invalid schedulerFor defined: unable to find next task`);
      }
      ++numTasks;
      return taskIndex;
    }
  };
}
function buildSchedulerFor(act, ordering) {
  return new SchedulerImplem(act, buildNextTaskIndex(ordering));
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/SchedulerArbitrary.js
function buildNextTaskIndex2(mrng) {
  const clonedMrng = mrng.clone();
  return {
    clone: () => buildNextTaskIndex2(clonedMrng),
    nextTaskIndex: (scheduledTasks) => {
      return mrng.nextInt(0, scheduledTasks.length - 1);
    }
  };
}
var SchedulerArbitrary = class extends Arbitrary {
  constructor(act) {
    super();
    this.act = act;
  }
  generate(mrng, _biasFactor) {
    return new Value(new SchedulerImplem(this.act, buildNextTaskIndex2(mrng.clone())), void 0);
  }
  canShrinkWithoutContext(value10) {
    return false;
  }
  shrink(_value2, _context) {
    return Stream.nil();
  }
};

// node_modules/fast-check/lib/esm/arbitrary/scheduler.js
function scheduler(constraints) {
  const { act = (f2) => f2() } = constraints || {};
  return new SchedulerArbitrary(act);
}
function schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {
  const { act = (f2) => f2() } = Array.isArray(customOrderingOrConstraints) ? constraintsOrUndefined || {} : customOrderingOrConstraints || {};
  if (Array.isArray(customOrderingOrConstraints)) {
    return buildSchedulerFor(act, customOrderingOrConstraints);
  }
  return function(_strs, ...ordering) {
    return buildSchedulerFor(act, ordering);
  };
}

// node_modules/fast-check/lib/esm/arbitrary/bigInt64Array.js
function bigInt64Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, SBigInt("-9223372036854775808"), SBigInt("9223372036854775807"), SBigInt64Array, bigInt);
}

// node_modules/fast-check/lib/esm/arbitrary/bigUint64Array.js
function bigUint64Array(constraints = {}) {
  return typedIntArrayArbitraryArbitraryBuilder(constraints, SBigInt(0), SBigInt("18446744073709551615"), SBigUint64Array, bigInt);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SanitizeRegexAst.js
function raiseUnsupportedASTNode(astNode) {
  return new Error(`Unsupported AST node! Received: ${stringify3(astNode)}`);
}
function addMissingDotStarTraversalAddMissing(astNode, isFirst, isLast) {
  if (!isFirst && !isLast) {
    return astNode;
  }
  const traversalResults = { hasStart: false, hasEnd: false };
  const revampedNode = addMissingDotStarTraversal(astNode, isFirst, isLast, traversalResults);
  const missingStart = isFirst && !traversalResults.hasStart;
  const missingEnd = isLast && !traversalResults.hasEnd;
  if (!missingStart && !missingEnd) {
    return revampedNode;
  }
  const expressions = [];
  if (missingStart) {
    expressions.push({ type: "Assertion", kind: "^" });
    expressions.push({
      type: "Repetition",
      quantifier: { type: "Quantifier", kind: "*", greedy: true },
      expression: { type: "Char", kind: "meta", symbol: ".", value: ".", codePoint: Number.NaN }
    });
  }
  expressions.push(revampedNode);
  if (missingEnd) {
    expressions.push({
      type: "Repetition",
      quantifier: { type: "Quantifier", kind: "*", greedy: true },
      expression: { type: "Char", kind: "meta", symbol: ".", value: ".", codePoint: Number.NaN }
    });
    expressions.push({ type: "Assertion", kind: "$" });
  }
  return { type: "Group", capturing: false, expression: { type: "Alternative", expressions } };
}
function addMissingDotStarTraversal(astNode, isFirst, isLast, traversalResults) {
  switch (astNode.type) {
    case "Char":
      return astNode;
    case "Repetition":
      return astNode;
    case "Quantifier":
      throw new Error(`Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!`);
    case "Alternative":
      traversalResults.hasStart = true;
      traversalResults.hasEnd = true;
      return Object.assign(Object.assign({}, astNode), { expressions: astNode.expressions.map((node, index3) => addMissingDotStarTraversalAddMissing(node, isFirst && index3 === 0, isLast && index3 === astNode.expressions.length - 1)) });
    case "CharacterClass":
      return astNode;
    case "ClassRange":
      return astNode;
    case "Group": {
      return Object.assign(Object.assign({}, astNode), { expression: addMissingDotStarTraversal(astNode.expression, isFirst, isLast, traversalResults) });
    }
    case "Disjunction": {
      traversalResults.hasStart = true;
      traversalResults.hasEnd = true;
      return Object.assign(Object.assign({}, astNode), { left: astNode.left !== null ? addMissingDotStarTraversalAddMissing(astNode.left, isFirst, isLast) : null, right: astNode.right !== null ? addMissingDotStarTraversalAddMissing(astNode.right, isFirst, isLast) : null });
    }
    case "Assertion": {
      if (astNode.kind === "^" || astNode.kind === "Lookahead") {
        traversalResults.hasStart = true;
        return astNode;
      } else if (astNode.kind === "$" || astNode.kind === "Lookbehind") {
        traversalResults.hasEnd = true;
        return astNode;
      } else {
        throw new Error(`Assertions of kind ${astNode.kind} not implemented yet!`);
      }
    }
    case "Backreference":
      return astNode;
    default:
      throw raiseUnsupportedASTNode(astNode);
  }
}
function addMissingDotStar(astNode) {
  return addMissingDotStarTraversalAddMissing(astNode, true, true);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js
function charSizeAt(text, pos) {
  return text[pos] >= "\uD800" && text[pos] <= "\uDBFF" && text[pos + 1] >= "\uDC00" && text[pos + 1] <= "\uDFFF" ? 2 : 1;
}
function isHexaDigit(char2) {
  return char2 >= "0" && char2 <= "9" || char2 >= "a" && char2 <= "f" || char2 >= "A" && char2 <= "F";
}
function isDigit(char2) {
  return char2 >= "0" && char2 <= "9";
}
function squaredBracketBlockContentEndFrom(text, from29) {
  for (let index3 = from29; index3 !== text.length; ++index3) {
    const char2 = text[index3];
    if (char2 === "\\") {
      index3 += 1;
    } else if (char2 === "]") {
      return index3;
    }
  }
  throw new Error(`Missing closing ']'`);
}
function parenthesisBlockContentEndFrom(text, from29) {
  let numExtraOpened = 0;
  for (let index3 = from29; index3 !== text.length; ++index3) {
    const char2 = text[index3];
    if (char2 === "\\") {
      index3 += 1;
    } else if (char2 === ")") {
      if (numExtraOpened === 0) {
        return index3;
      }
      numExtraOpened -= 1;
    } else if (char2 === "[") {
      index3 = squaredBracketBlockContentEndFrom(text, index3);
    } else if (char2 === "(") {
      numExtraOpened += 1;
    }
  }
  throw new Error(`Missing closing ')'`);
}
function curlyBracketBlockContentEndFrom(text, from29) {
  let foundComma = false;
  for (let index3 = from29; index3 !== text.length; ++index3) {
    const char2 = text[index3];
    if (isDigit(char2)) {
    } else if (from29 === index3) {
      return -1;
    } else if (char2 === ",") {
      if (foundComma) {
        return -1;
      }
      foundComma = true;
    } else if (char2 === "}") {
      return index3;
    } else {
      return -1;
    }
  }
  return -1;
}
var TokenizerBlockMode;
(function(TokenizerBlockMode2) {
  TokenizerBlockMode2[TokenizerBlockMode2["Full"] = 0] = "Full";
  TokenizerBlockMode2[TokenizerBlockMode2["Character"] = 1] = "Character";
})(TokenizerBlockMode || (TokenizerBlockMode = {}));
function blockEndFrom(text, from29, unicodeMode, mode) {
  switch (text[from29]) {
    case "[": {
      if (mode === TokenizerBlockMode.Character) {
        return from29 + 1;
      }
      return squaredBracketBlockContentEndFrom(text, from29 + 1) + 1;
    }
    case "{": {
      if (mode === TokenizerBlockMode.Character) {
        return from29 + 1;
      }
      const foundEnd = curlyBracketBlockContentEndFrom(text, from29 + 1);
      if (foundEnd === -1) {
        return from29 + 1;
      }
      return foundEnd + 1;
    }
    case "(": {
      if (mode === TokenizerBlockMode.Character) {
        return from29 + 1;
      }
      return parenthesisBlockContentEndFrom(text, from29 + 1) + 1;
    }
    case "]":
    case "}":
    case ")":
      return from29 + 1;
    case "\\": {
      const next1 = text[from29 + 1];
      switch (next1) {
        case "x":
          if (isHexaDigit(text[from29 + 2]) && isHexaDigit(text[from29 + 3])) {
            return from29 + 4;
          }
          throw new Error(`Unexpected token '${text.substring(from29, from29 + 4)}' found`);
        case "u":
          if (text[from29 + 2] === "{") {
            if (!unicodeMode) {
              return from29 + 2;
            }
            if (text[from29 + 4] === "}") {
              if (isHexaDigit(text[from29 + 3])) {
                return from29 + 5;
              }
              throw new Error(`Unexpected token '${text.substring(from29, from29 + 5)}' found`);
            }
            if (text[from29 + 5] === "}") {
              if (isHexaDigit(text[from29 + 3]) && isHexaDigit(text[from29 + 4])) {
                return from29 + 6;
              }
              throw new Error(`Unexpected token '${text.substring(from29, from29 + 6)}' found`);
            }
            if (text[from29 + 6] === "}") {
              if (isHexaDigit(text[from29 + 3]) && isHexaDigit(text[from29 + 4]) && isHexaDigit(text[from29 + 5])) {
                return from29 + 7;
              }
              throw new Error(`Unexpected token '${text.substring(from29, from29 + 7)}' found`);
            }
            if (text[from29 + 7] === "}") {
              if (isHexaDigit(text[from29 + 3]) && isHexaDigit(text[from29 + 4]) && isHexaDigit(text[from29 + 5]) && isHexaDigit(text[from29 + 6])) {
                return from29 + 8;
              }
              throw new Error(`Unexpected token '${text.substring(from29, from29 + 8)}' found`);
            }
            if (text[from29 + 8] === "}" && isHexaDigit(text[from29 + 3]) && isHexaDigit(text[from29 + 4]) && isHexaDigit(text[from29 + 5]) && isHexaDigit(text[from29 + 6]) && isHexaDigit(text[from29 + 7])) {
              return from29 + 9;
            }
            throw new Error(`Unexpected token '${text.substring(from29, from29 + 9)}' found`);
          }
          if (isHexaDigit(text[from29 + 2]) && isHexaDigit(text[from29 + 3]) && isHexaDigit(text[from29 + 4]) && isHexaDigit(text[from29 + 5])) {
            return from29 + 6;
          }
          throw new Error(`Unexpected token '${text.substring(from29, from29 + 6)}' found`);
        case "p":
        case "P": {
          if (!unicodeMode) {
            return from29 + 2;
          }
          let subIndex = from29 + 2;
          for (; subIndex < text.length && text[subIndex] !== "}"; subIndex += text[subIndex] === "\\" ? 2 : 1) {
          }
          if (text[subIndex] !== "}") {
            throw new Error(`Invalid \\P definition`);
          }
          return subIndex + 1;
        }
        case "k": {
          let subIndex = from29 + 2;
          for (; subIndex < text.length && text[subIndex] !== ">"; ++subIndex) {
          }
          if (text[subIndex] !== ">") {
            if (!unicodeMode) {
              return from29 + 2;
            }
            throw new Error(`Invalid \\k definition`);
          }
          return subIndex + 1;
        }
        default: {
          if (isDigit(next1)) {
            const maxIndex = unicodeMode ? text.length : Math.min(from29 + 4, text.length);
            let subIndex = from29 + 2;
            for (; subIndex < maxIndex && isDigit(text[subIndex]); ++subIndex) {
            }
            return subIndex;
          }
          const charSize = unicodeMode ? charSizeAt(text, from29 + 1) : 1;
          return from29 + charSize + 1;
        }
      }
    }
    default: {
      const charSize = unicodeMode ? charSizeAt(text, from29) : 1;
      return from29 + charSize;
    }
  }
}
function readFrom(text, from29, unicodeMode, mode) {
  const to3 = blockEndFrom(text, from29, unicodeMode, mode);
  return text.substring(from29, to3);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
var safeStringFromCodePoint2 = String.fromCodePoint;
function safePop2(tokens) {
  const previous2 = tokens.pop();
  if (previous2 === void 0) {
    throw new Error("Unable to extract token preceeding the currently parsed one");
  }
  return previous2;
}
function isDigit2(char2) {
  return char2 >= "0" && char2 <= "9";
}
function simpleChar(char2, escaped) {
  return {
    type: "Char",
    kind: "simple",
    symbol: char2,
    value: char2,
    codePoint: char2.codePointAt(0) || -1,
    escaped
  };
}
function metaEscapedChar(block, symbol6) {
  return {
    type: "Char",
    kind: "meta",
    symbol: symbol6,
    value: block,
    codePoint: symbol6.codePointAt(0) || -1
  };
}
function toSingleToken(tokens, allowEmpty) {
  if (tokens.length > 1) {
    return {
      type: "Alternative",
      expressions: tokens
    };
  }
  if (!allowEmpty && tokens.length === 0) {
    throw new Error(`Unsupported no token`);
  }
  return tokens[0];
}
function blockToCharToken(block) {
  if (block[0] === "\\") {
    const next6 = block[1];
    switch (next6) {
      case "x": {
        const allDigits = block.substring(2);
        const codePoint = Number.parseInt(allDigits, 16);
        const symbol6 = safeStringFromCodePoint2(codePoint);
        return { type: "Char", kind: "hex", symbol: symbol6, value: block, codePoint };
      }
      case "u": {
        if (block === "\\u") {
          return simpleChar("u", true);
        }
        const allDigits = block[2] === "{" ? block.substring(3, block.length - 1) : block.substring(2);
        const codePoint = Number.parseInt(allDigits, 16);
        const symbol6 = safeStringFromCodePoint2(codePoint);
        return { type: "Char", kind: "unicode", symbol: symbol6, value: block, codePoint };
      }
      case "0": {
        return metaEscapedChar(block, "\0");
      }
      case "n": {
        return metaEscapedChar(block, "\n");
      }
      case "f": {
        return metaEscapedChar(block, "\f");
      }
      case "r": {
        return metaEscapedChar(block, "\r");
      }
      case "t": {
        return metaEscapedChar(block, "	");
      }
      case "v": {
        return metaEscapedChar(block, "\v");
      }
      case "w":
      case "W":
      case "d":
      case "D":
      case "s":
      case "S":
      case "b":
      case "B": {
        return { type: "Char", kind: "meta", symbol: void 0, value: block, codePoint: Number.NaN };
      }
      default: {
        if (isDigit2(next6)) {
          const allDigits = block.substring(1);
          const codePoint = Number(allDigits);
          const symbol6 = safeStringFromCodePoint2(codePoint);
          return { type: "Char", kind: "decimal", symbol: symbol6, value: block, codePoint };
        }
        if (block.length > 2 && (next6 === "p" || next6 === "P")) {
          throw new Error(`UnicodeProperty not implemented yet!`);
        }
        const char2 = block.substring(1);
        return simpleChar(char2, true);
      }
    }
  }
  return simpleChar(block);
}
function pushTokens(tokens, regexSource, unicodeMode, groups) {
  let disjunctions = null;
  for (let index3 = 0, block = readFrom(regexSource, index3, unicodeMode, TokenizerBlockMode.Full); index3 !== regexSource.length; index3 += block.length, block = readFrom(regexSource, index3, unicodeMode, TokenizerBlockMode.Full)) {
    const firstInBlock = block[0];
    switch (firstInBlock) {
      case "|": {
        if (disjunctions === null) {
          disjunctions = [];
        }
        disjunctions.push(toSingleToken(tokens.splice(0), true) || null);
        break;
      }
      case ".": {
        tokens.push({ type: "Char", kind: "meta", symbol: block, value: block, codePoint: Number.NaN });
        break;
      }
      case "*":
      case "+": {
        const previous2 = safePop2(tokens);
        tokens.push({
          type: "Repetition",
          expression: previous2,
          quantifier: { type: "Quantifier", kind: firstInBlock, greedy: true }
        });
        break;
      }
      case "?": {
        const previous2 = safePop2(tokens);
        if (previous2.type === "Repetition") {
          previous2.quantifier.greedy = false;
          tokens.push(previous2);
        } else {
          tokens.push({
            type: "Repetition",
            expression: previous2,
            quantifier: { type: "Quantifier", kind: firstInBlock, greedy: true }
          });
        }
        break;
      }
      case "{": {
        if (block === "{") {
          tokens.push(simpleChar(block));
          break;
        }
        const previous2 = safePop2(tokens);
        const quantifierText = block.substring(1, block.length - 1);
        const quantifierTokens = quantifierText.split(",");
        const from29 = Number(quantifierTokens[0]);
        const to3 = quantifierTokens.length === 1 ? from29 : quantifierTokens[1].length !== 0 ? Number(quantifierTokens[1]) : void 0;
        tokens.push({
          type: "Repetition",
          expression: previous2,
          quantifier: { type: "Quantifier", kind: "Range", greedy: true, from: from29, to: to3 }
        });
        break;
      }
      case "[": {
        const blockContent = block.substring(1, block.length - 1);
        const subTokens = [];
        let negative2 = void 0;
        let previousWasSimpleDash = false;
        for (let subIndex = 0, subBlock = readFrom(blockContent, subIndex, unicodeMode, TokenizerBlockMode.Character); subIndex !== blockContent.length; subIndex += subBlock.length, subBlock = readFrom(blockContent, subIndex, unicodeMode, TokenizerBlockMode.Character)) {
          if (subIndex === 0 && subBlock === "^") {
            negative2 = true;
            continue;
          }
          const newToken = blockToCharToken(subBlock);
          if (subBlock === "-") {
            subTokens.push(newToken);
            previousWasSimpleDash = true;
          } else {
            const operand1Token = subTokens.length >= 2 ? subTokens[subTokens.length - 2] : void 0;
            if (previousWasSimpleDash && operand1Token !== void 0 && operand1Token.type === "Char") {
              subTokens.pop();
              subTokens.pop();
              subTokens.push({ type: "ClassRange", from: operand1Token, to: newToken });
            } else {
              subTokens.push(newToken);
            }
            previousWasSimpleDash = false;
          }
        }
        tokens.push({ type: "CharacterClass", expressions: subTokens, negative: negative2 });
        break;
      }
      case "(": {
        const blockContent = block.substring(1, block.length - 1);
        const subTokens = [];
        if (blockContent[0] === "?") {
          if (blockContent[1] === ":") {
            pushTokens(subTokens, blockContent.substring(2), unicodeMode, groups);
            tokens.push({
              type: "Group",
              capturing: false,
              expression: toSingleToken(subTokens)
            });
          } else if (blockContent[1] === "=" || blockContent[1] === "!") {
            pushTokens(subTokens, blockContent.substring(2), unicodeMode, groups);
            tokens.push({
              type: "Assertion",
              kind: "Lookahead",
              negative: blockContent[1] === "!" ? true : void 0,
              assertion: toSingleToken(subTokens)
            });
          } else if (blockContent[1] === "<" && (blockContent[2] === "=" || blockContent[2] === "!")) {
            pushTokens(subTokens, blockContent.substring(3), unicodeMode, groups);
            tokens.push({
              type: "Assertion",
              kind: "Lookbehind",
              negative: blockContent[2] === "!" ? true : void 0,
              assertion: toSingleToken(subTokens)
            });
          } else {
            const chunks3 = blockContent.split(">");
            if (chunks3.length < 2 || chunks3[0][1] !== "<") {
              throw new Error(`Unsupported regex content found at ${JSON.stringify(block)}`);
            }
            const groupIndex = ++groups.lastIndex;
            const nameRaw = chunks3[0].substring(2);
            groups.named.set(nameRaw, groupIndex);
            pushTokens(subTokens, chunks3.slice(1).join(">"), unicodeMode, groups);
            tokens.push({
              type: "Group",
              capturing: true,
              nameRaw,
              name: nameRaw,
              number: groupIndex,
              expression: toSingleToken(subTokens)
            });
          }
        } else {
          const groupIndex = ++groups.lastIndex;
          pushTokens(subTokens, blockContent, unicodeMode, groups);
          tokens.push({
            type: "Group",
            capturing: true,
            number: groupIndex,
            expression: toSingleToken(subTokens)
          });
        }
        break;
      }
      default: {
        if (block === "^") {
          tokens.push({ type: "Assertion", kind: block });
        } else if (block === "$") {
          tokens.push({ type: "Assertion", kind: block });
        } else if (block[0] === "\\" && isDigit2(block[1])) {
          const reference = Number(block.substring(1));
          if (unicodeMode || reference <= groups.lastIndex) {
            tokens.push({ type: "Backreference", kind: "number", number: reference, reference });
          } else {
            tokens.push(blockToCharToken(block));
          }
        } else if (block[0] === "\\" && block[1] === "k" && block.length !== 2) {
          const referenceRaw = block.substring(3, block.length - 1);
          tokens.push({
            type: "Backreference",
            kind: "name",
            number: groups.named.get(referenceRaw) || 0,
            referenceRaw,
            reference: referenceRaw
          });
        } else {
          tokens.push(blockToCharToken(block));
        }
        break;
      }
    }
  }
  if (disjunctions !== null) {
    disjunctions.push(toSingleToken(tokens.splice(0), true) || null);
    let currentDisjunction = {
      type: "Disjunction",
      left: disjunctions[0],
      right: disjunctions[1]
    };
    for (let index3 = 2; index3 < disjunctions.length; ++index3) {
      currentDisjunction = {
        type: "Disjunction",
        left: currentDisjunction,
        right: disjunctions[index3]
      };
    }
    tokens.push(currentDisjunction);
  }
}
function tokenizeRegex(regex) {
  const unicodeMode = safeIndexOf([...regex.flags], "u") !== -1;
  const regexSource = regex.source;
  const tokens = [];
  pushTokens(tokens, regexSource, unicodeMode, { lastIndex: 0, named: /* @__PURE__ */ new Map() });
  return toSingleToken(tokens);
}

// node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
var safeStringFromCodePoint3 = String.fromCodePoint;
var wordChars = [..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"];
var digitChars = [..."0123456789"];
var spaceChars = [..." 	\r\n\v\f"];
var newLineChars = [..."\r\n"];
var terminatorChars = [...""];
var newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];
var defaultChar = char();
function raiseUnsupportedASTNode2(astNode) {
  return new SError(`Unsupported AST node! Received: ${stringify3(astNode)}`);
}
function toMatchingArbitrary(astNode, constraints, flags) {
  switch (astNode.type) {
    case "Char": {
      if (astNode.kind === "meta") {
        switch (astNode.value) {
          case "\\w": {
            return constantFrom(...wordChars);
          }
          case "\\W": {
            return defaultChar.filter((c) => safeIndexOf(wordChars, c) === -1);
          }
          case "\\d": {
            return constantFrom(...digitChars);
          }
          case "\\D": {
            return defaultChar.filter((c) => safeIndexOf(digitChars, c) === -1);
          }
          case "\\s": {
            return constantFrom(...spaceChars);
          }
          case "\\S": {
            return defaultChar.filter((c) => safeIndexOf(spaceChars, c) === -1);
          }
          case "\\b":
          case "\\B": {
            throw new SError(`Meta character ${astNode.value} not implemented yet!`);
          }
          case ".": {
            const forbiddenChars = flags.dotAll ? terminatorChars : newLineAndTerminatorChars;
            return defaultChar.filter((c) => safeIndexOf(forbiddenChars, c) === -1);
          }
        }
      }
      if (astNode.symbol === void 0) {
        throw new SError(`Unexpected undefined symbol received for non-meta Char! Received: ${stringify3(astNode)}`);
      }
      return constant2(astNode.symbol);
    }
    case "Repetition": {
      const node = toMatchingArbitrary(astNode.expression, constraints, flags);
      switch (astNode.quantifier.kind) {
        case "*": {
          return stringOf(node, constraints);
        }
        case "+": {
          return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: 1 }));
        }
        case "?": {
          return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: 0, maxLength: 1 }));
        }
        case "Range": {
          return stringOf(node, Object.assign(Object.assign({}, constraints), { minLength: astNode.quantifier.from, maxLength: astNode.quantifier.to }));
        }
        default: {
          throw raiseUnsupportedASTNode2(astNode.quantifier);
        }
      }
    }
    case "Quantifier": {
      throw new SError(`Wrongly defined AST tree, Quantifier nodes not supposed to be scanned!`);
    }
    case "Alternative": {
      return tuple4(...safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags))).map((vs) => safeJoin(vs, ""));
    }
    case "CharacterClass":
      if (astNode.negative) {
        const childrenArbitraries = safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags));
        return defaultChar.filter((c) => safeEvery(childrenArbitraries, (arb) => !arb.canShrinkWithoutContext(c)));
      }
      return oneof(...safeMap(astNode.expressions, (n) => toMatchingArbitrary(n, constraints, flags)));
    case "ClassRange": {
      const min11 = astNode.from.codePoint;
      const max14 = astNode.to.codePoint;
      return integer({ min: min11, max: max14 }).map((n) => safeStringFromCodePoint3(n), (c) => {
        if (typeof c !== "string")
          throw new SError("Invalid type");
        if ([...c].length !== 1)
          throw new SError("Invalid length");
        return safeCharCodeAt(c, 0);
      });
    }
    case "Group": {
      return toMatchingArbitrary(astNode.expression, constraints, flags);
    }
    case "Disjunction": {
      const left3 = astNode.left !== null ? toMatchingArbitrary(astNode.left, constraints, flags) : constant2("");
      const right3 = astNode.right !== null ? toMatchingArbitrary(astNode.right, constraints, flags) : constant2("");
      return oneof(left3, right3);
    }
    case "Assertion": {
      if (astNode.kind === "^" || astNode.kind === "$") {
        if (flags.multiline) {
          if (astNode.kind === "^") {
            return oneof(constant2(""), tuple4(stringOf(defaultChar), constantFrom(...newLineChars)).map((t) => `${t[0]}${t[1]}`, (value10) => {
              if (typeof value10 !== "string" || value10.length === 0)
                throw new SError("Invalid type");
              return [safeSubstring(value10, 0, value10.length - 1), value10[value10.length - 1]];
            }));
          } else {
            return oneof(constant2(""), tuple4(constantFrom(...newLineChars), stringOf(defaultChar)).map((t) => `${t[0]}${t[1]}`, (value10) => {
              if (typeof value10 !== "string" || value10.length === 0)
                throw new SError("Invalid type");
              return [value10[0], safeSubstring(value10, 1)];
            }));
          }
        }
        return constant2("");
      }
      throw new SError(`Assertions of kind ${astNode.kind} not implemented yet!`);
    }
    case "Backreference": {
      throw new SError(`Backreference nodes not implemented yet!`);
    }
    default: {
      throw raiseUnsupportedASTNode2(astNode);
    }
  }
}
function stringMatching(regex, constraints = {}) {
  for (const flag of regex.flags) {
    if (flag !== "d" && flag !== "g" && flag !== "m" && flag !== "s" && flag !== "u") {
      throw new SError(`Unable to use "stringMatching" against a regex using the flag ${flag}`);
    }
  }
  const sanitizedConstraints = { size: constraints.size };
  const flags = { multiline: regex.multiline, dotAll: regex.dotAll };
  const regexRootToken = addMissingDotStar(tokenizeRegex(regex));
  return toMatchingArbitrary(regexRootToken, sanitizedConstraints, flags);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ZipIterableIterators.js
function initZippedValues(its) {
  const vs = [];
  for (let index3 = 0; index3 !== its.length; ++index3) {
    vs.push(its[index3].next());
  }
  return vs;
}
function nextZippedValues(its, vs) {
  for (let index3 = 0; index3 !== its.length; ++index3) {
    vs[index3] = its[index3].next();
  }
}
function isDoneZippedValues(vs) {
  for (let index3 = 0; index3 !== vs.length; ++index3) {
    if (vs[index3].done) {
      return true;
    }
  }
  return false;
}
function* zipIterableIterators(...its) {
  const vs = initZippedValues(its);
  while (!isDoneZippedValues(vs)) {
    yield vs.map((v) => v.value);
    nextZippedValues(its, vs);
  }
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/LimitedShrinkArbitrary.js
function* iotaFrom(startValue) {
  let value10 = startValue;
  while (true) {
    yield value10;
    ++value10;
  }
}
var LimitedShrinkArbitrary = class extends Arbitrary {
  constructor(arb, maxShrinks) {
    super();
    this.arb = arb;
    this.maxShrinks = maxShrinks;
  }
  generate(mrng, biasFactor) {
    const value10 = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(value10, 0);
  }
  canShrinkWithoutContext(value10) {
    return this.arb.canShrinkWithoutContext(value10);
  }
  shrink(value10, context15) {
    if (this.isSafeContext(context15)) {
      return this.safeShrink(value10, context15.originalContext, context15.length);
    }
    return this.safeShrink(value10, void 0, 0);
  }
  safeShrink(value10, originalContext, currentLength) {
    const remaining = this.maxShrinks - currentLength;
    if (remaining <= 0) {
      return Stream.nil();
    }
    return new Stream(zipIterableIterators(this.arb.shrink(value10, originalContext), iotaFrom(currentLength + 1))).take(remaining).map((valueAndLength) => this.valueMapper(valueAndLength[0], valueAndLength[1]));
  }
  valueMapper(v, newLength) {
    const context15 = { originalContext: v.context, length: newLength };
    return new Value(v.value, context15);
  }
  isSafeContext(context15) {
    return context15 != null && typeof context15 === "object" && "originalContext" in context15 && "length" in context15;
  }
};

// node_modules/fast-check/lib/esm/arbitrary/limitShrink.js
function limitShrink(arbitrary, maxShrinks) {
  return new LimitedShrinkArbitrary(arbitrary, maxShrinks);
}

// node_modules/fast-check/lib/esm/fast-check-default.js
var __type2 = "module";
var __version2 = "3.23.2";
var __commitHash2 = "a4a600eaa08c833707067a877db144289a724b91";

// node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk = (f2) => {
  let done17 = false;
  let a;
  return () => {
    if (done17) {
      return a;
    }
    a = f2();
    done17 = true;
    return a;
  };
};
var formatDate = (date5) => {
  try {
    return date5.toISOString();
  } catch {
    return String(date5);
  }
};
var formatUnknown = (u, checkCircular = true) => {
  if (Array.isArray(u)) {
    return `[${u.map((i) => formatUnknown(i, checkCircular)).join(",")}]`;
  }
  if (isDate(u)) {
    return formatDate(u);
  }
  if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  if (isString(u)) {
    return JSON.stringify(u);
  }
  if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  }
  if (isBigInt(u)) {
    return String(u) + "n";
  }
  if (isIterable(u)) {
    return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
  }
  try {
    if (checkCircular) {
      JSON.stringify(u);
    }
    const pojo = `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
    const name = u.constructor.name;
    return u.constructor !== Object.prototype.constructor ? `${name}(${pojo})` : pojo;
  } catch {
    return "<circular structure>";
  }
};
var formatPropertyKey = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
var isNonEmpty = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path2) => isNonEmpty(path2) ? path2.map(formatPathKey).join("") : formatPathKey(path2);

// node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path2, ast) => {
  let out = reason;
  if (path2 && isNonEmptyReadonlyArray(path2)) {
    out += `
at path: ${formatPath(path2)}`;
  }
  if (details !== void 0) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getInvalidArgumentErrorMessage = (details) => getErrorMessage("Invalid Argument", details);
var getUnsupportedSchemaErrorMessage = (details, path2, ast) => getErrorMessage("Unsupported schema", details, path2, ast);
var getMissingAnnotationErrorMessage = (details, path2, ast) => getErrorMessage("Missing annotation", details, path2, ast);
var getArbitraryMissingAnnotationErrorMessage = (path2, ast) => getMissingAnnotationErrorMessage(`Generating an Arbitrary for this schema requires an "arbitrary" annotation`, path2, ast);
var getArbitraryEmptyEnumErrorMessage = (path2) => getErrorMessage("Empty Enums schema", "Generating an Arbitrary for this schema requires at least one enum", path2);
var getEquivalenceUnsupportedErrorMessage = (ast, path2) => getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path2, ast);
var getJSONSchemaMissingAnnotationErrorMessage = (path2, ast) => getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires a "jsonSchema" annotation`, path2, ast);
var getJSONSchemaMissingIdentifierAnnotationErrorMessage = (path2, ast) => getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires an "identifier" annotation`, path2, ast);
var getJSONSchemaUnsupportedPostRestElementsErrorMessage = (path2) => getErrorMessage("Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request", void 0, path2);
var getJSONSchemaUnsupportedKeyErrorMessage = (key, path2) => getErrorMessage("Unsupported key", `Cannot encode ${formatPropertyKey(key)} key to JSON Schema`, path2);
var getPrettyMissingAnnotationErrorMessage = (path2, ast) => getMissingAnnotationErrorMessage(`Generating a Pretty for this schema requires a "pretty" annotation`, path2, ast);
var getPrettyNeverErrorMessage = "Cannot pretty print a `never` value";
var getPrettyNoMatchingSchemaErrorMessage = (actual, path2, ast) => getErrorMessage("Unexpected Error", `Cannot find a matching schema for ${formatUnknown(actual)}`, path2, ast);
var getSchemaExtendErrorMessage = (x, y, path2) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path2);
var getSchemaUnsupportedLiteralSpanErrorMessage = (ast) => getErrorMessage("Unsupported template literal span", void 0, void 0, ast);
var getASTUnsupportedSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast);
var getASTUnsupportedLiteralErrorMessage = (literal3) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal3)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type8) => getErrorMessage("Duplicate index signature", `${type8} index signature`);
var getASTIndexSignatureParameterErrorMessage = getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTUnsupportedRenameSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = Symbol.for("effect/SchemaId/DateFromSelf");
var GreaterThanSchemaId = Symbol.for("effect/SchemaId/GreaterThan");
var GreaterThanOrEqualToSchemaId = Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
var LessThanSchemaId = Symbol.for("effect/SchemaId/LessThan");
var LessThanOrEqualToSchemaId = Symbol.for("effect/SchemaId/LessThanOrEqualTo");
var IntSchemaId = Symbol.for("effect/SchemaId/Int");
var NonNaNSchemaId = Symbol.for("effect/SchemaId/NonNaN");
var FiniteSchemaId = Symbol.for("effect/SchemaId/Finite");
var JsonNumberSchemaId = Symbol.for("effect/SchemaId/JsonNumber");
var BetweenSchemaId = Symbol.for("effect/SchemaId/Between");
var GreaterThanBigintSchemaId = Symbol.for("effect/SchemaId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntSchemaId = Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
var LessThanBigIntSchemaId = Symbol.for("effect/SchemaId/LessThanBigint");
var LessThanOrEqualToBigIntSchemaId = Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
var BetweenBigintSchemaId = Symbol.for("effect/SchemaId/BetweenBigint");
var MinLengthSchemaId = Symbol.for("effect/SchemaId/MinLength");
var MaxLengthSchemaId = Symbol.for("effect/SchemaId/MaxLength");
var LengthSchemaId = Symbol.for("effect/SchemaId/Length");
var MinItemsSchemaId = Symbol.for("effect/SchemaId/MinItems");
var MaxItemsSchemaId = Symbol.for("effect/SchemaId/MaxItems");
var ItemsCountSchemaId = Symbol.for("effect/SchemaId/ItemsCount");

// node_modules/effect/dist/esm/SchemaAST.js
var SchemaAST_exports = {};
__export(SchemaAST_exports, {
  AnyKeyword: () => AnyKeyword,
  ArbitraryAnnotationId: () => ArbitraryAnnotationId,
  AutoTitleAnnotationId: () => AutoTitleAnnotationId,
  BatchingAnnotationId: () => BatchingAnnotationId,
  BigIntKeyword: () => BigIntKeyword,
  BooleanKeyword: () => BooleanKeyword,
  BrandAnnotationId: () => BrandAnnotationId,
  ComposeTransformation: () => ComposeTransformation,
  ConcurrencyAnnotationId: () => ConcurrencyAnnotationId,
  Declaration: () => Declaration,
  DecodingFallbackAnnotationId: () => DecodingFallbackAnnotationId,
  DefaultAnnotationId: () => DefaultAnnotationId,
  DescriptionAnnotationId: () => DescriptionAnnotationId,
  DocumentationAnnotationId: () => DocumentationAnnotationId,
  Enums: () => Enums,
  EquivalenceAnnotationId: () => EquivalenceAnnotationId,
  ExamplesAnnotationId: () => ExamplesAnnotationId,
  FinalTransformation: () => FinalTransformation,
  IdentifierAnnotationId: () => IdentifierAnnotationId,
  IndexSignature: () => IndexSignature,
  JSONIdentifierAnnotationId: () => JSONIdentifierAnnotationId,
  JSONSchemaAnnotationId: () => JSONSchemaAnnotationId,
  Literal: () => Literal,
  MessageAnnotationId: () => MessageAnnotationId,
  MissingMessageAnnotationId: () => MissingMessageAnnotationId,
  NeverKeyword: () => NeverKeyword,
  NumberKeyword: () => NumberKeyword,
  ObjectKeyword: () => ObjectKeyword,
  OptionalType: () => OptionalType,
  ParseIssueTitleAnnotationId: () => ParseIssueTitleAnnotationId,
  ParseJsonSchemaId: () => ParseJsonSchemaId,
  ParseOptionsAnnotationId: () => ParseOptionsAnnotationId,
  PrettyAnnotationId: () => PrettyAnnotationId,
  PropertySignature: () => PropertySignature,
  PropertySignatureTransformation: () => PropertySignatureTransformation,
  Refinement: () => Refinement,
  SchemaIdAnnotationId: () => SchemaIdAnnotationId,
  StableFilterAnnotationId: () => StableFilterAnnotationId,
  StringKeyword: () => StringKeyword,
  SurrogateAnnotationId: () => SurrogateAnnotationId,
  Suspend: () => Suspend,
  SymbolKeyword: () => SymbolKeyword,
  TemplateLiteral: () => TemplateLiteral,
  TemplateLiteralSpan: () => TemplateLiteralSpan,
  TitleAnnotationId: () => TitleAnnotationId,
  Transformation: () => Transformation,
  TupleType: () => TupleType,
  Type: () => Type,
  TypeLiteral: () => TypeLiteral,
  TypeLiteralTransformation: () => TypeLiteralTransformation,
  UndefinedKeyword: () => UndefinedKeyword,
  Union: () => Union,
  UniqueSymbol: () => UniqueSymbol,
  UnknownKeyword: () => UnknownKeyword,
  VoidKeyword: () => VoidKeyword,
  annotations: () => annotations,
  anyKeyword: () => anyKeyword,
  bigIntKeyword: () => bigIntKeyword,
  booleanKeyword: () => booleanKeyword,
  compose: () => compose3,
  composeTransformation: () => composeTransformation,
  defaultParseOption: () => defaultParseOption,
  encodedAST: () => encodedAST,
  encodedBoundAST: () => encodedBoundAST,
  equals: () => equals2,
  flatten: () => flatten4,
  getAnnotation: () => getAnnotation,
  getAutoTitleAnnotation: () => getAutoTitleAnnotation,
  getBatchingAnnotation: () => getBatchingAnnotation,
  getBrandAnnotation: () => getBrandAnnotation,
  getCompiler: () => getCompiler,
  getConcurrencyAnnotation: () => getConcurrencyAnnotation,
  getDecodingFallbackAnnotation: () => getDecodingFallbackAnnotation,
  getDefaultAnnotation: () => getDefaultAnnotation,
  getDescriptionAnnotation: () => getDescriptionAnnotation,
  getDocumentationAnnotation: () => getDocumentationAnnotation,
  getEncodedParameter: () => getEncodedParameter,
  getExamplesAnnotation: () => getExamplesAnnotation,
  getIdentifierAnnotation: () => getIdentifierAnnotation,
  getJSONIdentifier: () => getJSONIdentifier,
  getJSONIdentifierAnnotation: () => getJSONIdentifierAnnotation,
  getJSONSchemaAnnotation: () => getJSONSchemaAnnotation,
  getMessageAnnotation: () => getMessageAnnotation,
  getMissingMessageAnnotation: () => getMissingMessageAnnotation,
  getNumberIndexedAccess: () => getNumberIndexedAccess,
  getParseIssueTitleAnnotation: () => getParseIssueTitleAnnotation,
  getParseOptionsAnnotation: () => getParseOptionsAnnotation,
  getPropertyKeyIndexedAccess: () => getPropertyKeyIndexedAccess,
  getPropertySignatures: () => getPropertySignatures,
  getSchemaIdAnnotation: () => getSchemaIdAnnotation,
  getSurrogateAnnotation: () => getSurrogateAnnotation,
  getTemplateLiteralCapturingRegExp: () => getTemplateLiteralCapturingRegExp,
  getTemplateLiteralRegExp: () => getTemplateLiteralRegExp,
  getTitleAnnotation: () => getTitleAnnotation,
  getTransformationFrom: () => getTransformationFrom,
  hasStableFilter: () => hasStableFilter,
  isAnyKeyword: () => isAnyKeyword,
  isBigIntKeyword: () => isBigIntKeyword,
  isBooleanKeyword: () => isBooleanKeyword,
  isComposeTransformation: () => isComposeTransformation,
  isDeclaration: () => isDeclaration,
  isEnums: () => isEnums,
  isFinalTransformation: () => isFinalTransformation,
  isLiteral: () => isLiteral,
  isMembers: () => isMembers,
  isNeverKeyword: () => isNeverKeyword,
  isNumberKeyword: () => isNumberKeyword,
  isObjectKeyword: () => isObjectKeyword,
  isParameter: () => isParameter,
  isRefinement: () => isRefinement,
  isStringKeyword: () => isStringKeyword,
  isSuspend: () => isSuspend,
  isSymbolKeyword: () => isSymbolKeyword,
  isTemplateLiteral: () => isTemplateLiteral,
  isTransformation: () => isTransformation,
  isTupleType: () => isTupleType,
  isTypeLiteral: () => isTypeLiteral,
  isTypeLiteralTransformation: () => isTypeLiteralTransformation,
  isUndefinedKeyword: () => isUndefinedKeyword,
  isUnion: () => isUnion,
  isUniqueSymbol: () => isUniqueSymbol,
  isUnknownKeyword: () => isUnknownKeyword,
  isVoidKeyword: () => isVoidKeyword,
  keyof: () => keyof,
  mapMembers: () => mapMembers,
  mutable: () => mutable,
  neverKeyword: () => neverKeyword,
  null: () => $null,
  numberKeyword: () => numberKeyword,
  objectKeyword: () => objectKeyword,
  omit: () => omit,
  omitAnnotations: () => omitAnnotations,
  orUndefined: () => orUndefined,
  partial: () => partial,
  pick: () => pick,
  pickAnnotations: () => pickAnnotations,
  pruneUndefined: () => pruneUndefined,
  record: () => record2,
  rename: () => rename,
  required: () => required,
  stringKeyword: () => stringKeyword,
  symbolKeyword: () => symbolKeyword,
  typeAST: () => typeAST,
  undefinedKeyword: () => undefinedKeyword,
  unify: () => unify,
  unknownKeyword: () => unknownKeyword,
  voidKeyword: () => voidKeyword
});

// node_modules/effect/dist/esm/Number.js
var Number_exports = {};
__export(Number_exports, {
  Equivalence: () => Equivalence,
  Order: () => Order,
  between: () => between2,
  clamp: () => clamp3,
  decrement: () => decrement,
  divide: () => divide,
  greaterThan: () => greaterThan2,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo2,
  increment: () => increment,
  isNumber: () => isNumber2,
  lessThan: () => lessThan2,
  lessThanOrEqualTo: () => lessThanOrEqualTo2,
  max: () => max3,
  min: () => min3,
  multiply: () => multiply,
  multiplyAll: () => multiplyAll,
  negate: () => negate,
  nextPow2: () => nextPow2,
  parse: () => parse,
  remainder: () => remainder,
  round: () => round,
  sign: () => sign,
  subtract: () => subtract,
  sum: () => sum,
  sumAll: () => sumAll,
  unsafeDivide: () => unsafeDivide
});
var isNumber2 = isNumber;
var negate = (n) => multiply(n, -1);
var sum = dual(2, (self, that) => self + that);
var sumAll = (collection) => reduce(collection, 0, sum);
var subtract = dual(2, (minuend, subtrahend) => minuend - subtrahend);
var multiply = dual(2, (multiplier, multiplicand) => multiplier * multiplicand);
var multiplyAll = (collection) => {
  let out = 1;
  for (const n of collection) {
    if (n === 0) {
      return 0;
    }
    out *= n;
  }
  return out;
};
var divide = dual(2, (dividend, divisor) => divisor === 0 ? none : some2(dividend / divisor));
var unsafeDivide = dual(2, (dividend, divisor) => dividend / divisor);
var increment = (n) => sum(n, 1);
var decrement = (n) => subtract(n, 1);
var Equivalence = number;
var Order = number3;
var lessThan2 = lessThan(Order);
var lessThanOrEqualTo2 = lessThanOrEqualTo(Order);
var greaterThan2 = greaterThan(Order);
var greaterThanOrEqualTo2 = greaterThanOrEqualTo(Order);
var between2 = between(Order);
var clamp3 = clamp(Order);
var min3 = min(Order);
var max3 = max(Order);
var sign = (n) => Order(n, 0);
var remainder = dual(2, (dividend, divisor) => {
  const selfDecCount = (dividend.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var nextPow2 = (n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
var parse = (s) => {
  if (s === "NaN") {
    return some2(NaN);
  }
  if (s === "Infinity") {
    return some2(Infinity);
  }
  if (s === "-Infinity") {
    return some2(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some2(n);
};
var round = dual(2, (self, precision) => {
  const factor = Math.pow(10, precision);
  return Math.round(self * factor) / factor;
});

// node_modules/effect/dist/esm/RegExp.js
var RegExp_exports = {};
__export(RegExp_exports, {
  escape: () => escape,
  isRegExp: () => isRegExp2
});
var isRegExp2 = isRegExp;
var escape = (string8) => string8.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = Symbol.for("effect/annotation/StableFilter");
var getAnnotation = dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some3(annotated.annotations[key]) : none2());
var getBrandAnnotation = getAnnotation(BrandAnnotationId);
var getSchemaIdAnnotation = getAnnotation(SchemaIdAnnotationId);
var getMessageAnnotation = getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = getAnnotation(DescriptionAnnotationId);
var getExamplesAnnotation = getAnnotation(ExamplesAnnotationId);
var getDefaultAnnotation = getAnnotation(DefaultAnnotationId);
var getJSONSchemaAnnotation = getAnnotation(JSONSchemaAnnotationId);
var getDocumentationAnnotation = getAnnotation(DocumentationAnnotationId);
var getConcurrencyAnnotation = getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse2(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
var ParseJsonSchemaId = Symbol.for("effect/schema/ParseJson");
var Declaration = class {
  constructor(typeParameters, decodeUnknown4, encodeUnknown3, annotations4 = {}) {
    __publicField(this, "typeParameters");
    __publicField(this, "decodeUnknown");
    __publicField(this, "encodeUnknown");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Declaration");
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown4;
    this.encodeUnknown = encodeUnknown3;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => "<declaration schema>");
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var createASTGuard = (tag5) => (ast) => ast._tag === tag5;
var isDeclaration = createASTGuard("Declaration");
var Literal = class {
  constructor(literal3, annotations4 = {}) {
    __publicField(this, "literal");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Literal");
    this.literal = literal3;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.literal));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isLiteral = createASTGuard("Literal");
var $null = new Literal(null);
var UniqueSymbol = class {
  constructor(symbol6, annotations4 = {}) {
    __publicField(this, "symbol");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "UniqueSymbol");
    this.symbol = symbol6;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.symbol));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isUniqueSymbol = createASTGuard("UniqueSymbol");
var UndefinedKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "UndefinedKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var undefinedKeyword = new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
var isUndefinedKeyword = createASTGuard("UndefinedKeyword");
var VoidKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "VoidKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var voidKeyword = new VoidKeyword({
  [TitleAnnotationId]: "void"
});
var isVoidKeyword = createASTGuard("VoidKeyword");
var NeverKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "NeverKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var neverKeyword = new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var isNeverKeyword = createASTGuard("NeverKeyword");
var UnknownKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "UnknownKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var unknownKeyword = new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
var isUnknownKeyword = createASTGuard("UnknownKeyword");
var AnyKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "AnyKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var anyKeyword = new AnyKeyword({
  [TitleAnnotationId]: "any"
});
var isAnyKeyword = createASTGuard("AnyKeyword");
var StringKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "StringKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var stringKeyword = new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = createASTGuard("StringKeyword");
var NumberKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "NumberKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var numberKeyword = new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = createASTGuard("NumberKeyword");
var BooleanKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "BooleanKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var booleanKeyword = new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = createASTGuard("BooleanKeyword");
var BigIntKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "BigIntKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var bigIntKeyword = new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
var isBigIntKeyword = createASTGuard("BigIntKeyword");
var SymbolKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "SymbolKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var symbolKeyword = new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = createASTGuard("SymbolKeyword");
var ObjectKeyword = class {
  constructor(annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "ObjectKeyword");
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var objectKeyword = new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
var isObjectKeyword = createASTGuard("ObjectKeyword");
var Enums = class {
  constructor(enums, annotations4 = {}) {
    __publicField(this, "enums");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Enums");
    this.enums = enums;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_, value10]) => JSON.stringify(value10)).join(" | ")}>`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isEnums = createASTGuard("Enums");
var isTemplateLiteralSpanType = (ast) => {
  switch (ast._tag) {
    case "Literal":
    case "NumberKeyword":
    case "StringKeyword":
    case "TemplateLiteral":
      return true;
    case "Union":
      return ast.types.every(isTemplateLiteralSpanType);
  }
  return false;
};
var templateLiteralSpanUnionTypeToString = (type8) => {
  switch (type8._tag) {
    case "Literal":
      return JSON.stringify(String(type8.literal));
    case "StringKeyword":
      return "string";
    case "NumberKeyword":
      return "number";
    case "TemplateLiteral":
      return String(type8);
    case "Union":
      return type8.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
  }
};
var templateLiteralSpanTypeToString = (type8) => {
  switch (type8._tag) {
    case "Literal":
      return String(type8.literal);
    case "StringKeyword":
      return "${string}";
    case "NumberKeyword":
      return "${number}";
    case "TemplateLiteral":
      return "${" + String(type8) + "}";
    case "Union":
      return "${" + type8.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
  }
};
var TemplateLiteralSpan = class {
  constructor(type8, literal3) {
    __publicField(this, "literal");
    /**
     * @since 3.10.0
     */
    __publicField(this, "type");
    this.literal = literal3;
    if (isTemplateLiteralSpanType(type8)) {
      this.type = type8;
    } else {
      throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage(type8));
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return templateLiteralSpanTypeToString(this.type) + this.literal;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
};
var TemplateLiteral = class {
  constructor(head13, spans, annotations4 = {}) {
    __publicField(this, "head");
    __publicField(this, "spans");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "TemplateLiteral");
    this.head = head13;
    this.spans = spans;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTemplateLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span4) => span4.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTemplateLiteral = (ast) => "`" + ast.head + ast.spans.map(String).join("") + "`";
var isTemplateLiteral = createASTGuard("TemplateLiteral");
var Type = class {
  constructor(type8, annotations4 = {}) {
    __publicField(this, "type");
    __publicField(this, "annotations");
    this.type = type8;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type);
  }
};
var OptionalType = class extends Type {
  constructor(type8, isOptional, annotations4 = {}) {
    super(type8, annotations4);
    __publicField(this, "isOptional");
    this.isOptional = isOptional;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
var TupleType = class {
  constructor(elements, rest, isReadonly, annotations4 = {}) {
    __publicField(this, "elements");
    __publicField(this, "rest");
    __publicField(this, "isReadonly");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "TupleType");
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations4;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTuple(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head13, tail5) => {
      const formattedHead = String(head13);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail5.length > 0) {
        const formattedTail = tail5.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
var isTupleType = createASTGuard("TupleType");
var PropertySignature = class extends OptionalType {
  constructor(name, type8, isOptional, isReadonly, annotations4) {
    super(type8, isOptional, annotations4);
    __publicField(this, "name");
    __publicField(this, "isReadonly");
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};
var IndexSignature = class {
  constructor(parameter, type8, isReadonly) {
    __publicField(this, "type");
    __publicField(this, "isReadonly");
    /**
     * @since 3.10.0
     */
    __publicField(this, "parameter");
    this.type = type8;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
var TypeLiteral = class {
  constructor(propertySignatures, indexSignatures, annotations4 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "TypeLiteral");
    /**
     * @since 3.10.0
     */
    __publicField(this, "propertySignatures");
    /**
     * @since 3.10.0
     */
    __publicField(this, "indexSignatures");
    this.annotations = annotations4;
    const keys15 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys15, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys15[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = createASTGuard("TypeLiteral");
var sortCandidates = sort(mapInput3(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten4 = (candidates) => flatMap4(candidates, (ast) => isUnion(ast) ? flatten4(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type8 = typeof ast.literal;
        switch (type8) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type8];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          // null
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};
var _Union = class _Union {
  constructor(types3, annotations4 = {}) {
    __publicField(this, "types");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Union");
    this.types = types3;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__publicField(_Union, "make", (types3, annotations4) => {
  return isMembers(types3) ? new _Union(types3, annotations4) : types3.length === 1 ? types3[0] : neverKeyword;
});
/** @internal */
__publicField(_Union, "unify", (candidates, annotations4) => {
  return _Union.make(unify(flatten4(candidates)), annotations4);
});
var Union = _Union;
var mapMembers = (members, f2) => members.map(f2);
var isMembers = (as18) => as18.length > 1;
var isUnion = createASTGuard("Union");
var toJSONMemoMap = globalValue(Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
  constructor(f2, annotations4 = {}) {
    __publicField(this, "f");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Suspend");
    this.f = f2;
    this.annotations = annotations4;
    this.f = memoizeThunk(f2);
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getExpected(this).pipe(orElse2(() => flatMap2(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse2(() => "<suspended schema>"));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
};
var isSuspend = createASTGuard("Suspend");
var Refinement = class {
  constructor(from29, filter26, annotations4 = {}) {
    __publicField(this, "from");
    __publicField(this, "filter");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Refinement");
    this.from = from29;
    this.filter = filter26;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse2(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isRefinement = createASTGuard("Refinement");
var defaultParseOption = {};
var Transformation = class {
  constructor(from29, to3, transformation, annotations4 = {}) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "transformation");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Transformation");
    this.from = from29;
    this.to = to3;
    this.transformation = transformation;
    this.annotations = annotations4;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isTransformation = createASTGuard("Transformation");
var FinalTransformation = class {
  constructor(decode11, encode16) {
    __publicField(this, "decode");
    __publicField(this, "encode");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "FinalTransformation");
    this.decode = decode11;
    this.encode = encode16;
  }
};
var createTransformationGuard = (tag5) => (ast) => ast._tag === tag5;
var isFinalTransformation = createTransformationGuard("FinalTransformation");
var ComposeTransformation = class {
  constructor() {
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "ComposeTransformation");
  }
};
var composeTransformation = new ComposeTransformation();
var isComposeTransformation = createTransformationGuard("ComposeTransformation");
var PropertySignatureTransformation = class {
  constructor(from29, to3, decode11, encode16) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "decode");
    __publicField(this, "encode");
    this.from = from29;
    this.to = to3;
    this.decode = decode11;
    this.encode = encode16;
  }
};
var isRenamingPropertySignatureTransformation = (t) => t.decode === identity && t.encode === identity;
var TypeLiteralTransformation = class {
  constructor(propertySignatureTransformations) {
    __publicField(this, "propertySignatureTransformations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "TypeLiteralTransformation");
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from29 = pst.from;
      if (fromKeys[from29]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from29));
      }
      fromKeys[from29] = true;
      const to3 = pst.to;
      if (toKeys[to3]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to3));
      }
      toKeys[to3] = true;
    }
  }
};
var isTypeLiteralTransformation = createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const value10 = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value10[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value10;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var keyof = (ast) => Union.unify(_keyof(ast));
var STRING_KEYWORD_PATTERN = "[\\s\\S]*";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type8, capture2) => {
  switch (type8._tag) {
    case "Literal":
      return escape(String(type8.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type8, capture2, false);
    case "Union":
      return type8.types.map((type9) => getTemplateLiteralSpanTypePattern(type9, capture2)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type8, s, capture2, top) => {
  if (isUnion(type8)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture2, top) => {
  let pattern2 = ``;
  if (ast.head !== "") {
    const head13 = escape(ast.head);
    pattern2 += capture2 && top ? `(${head13})` : head13;
  }
  for (const span4 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span4.type, capture2);
    pattern2 += handleTemplateLiteralSpanTypeParens(span4.type, spanPattern, capture2, top);
    if (span4.literal !== "") {
      const literal3 = escape(span4.literal);
      pattern2 += capture2 && top ? `(${literal3})` : literal3;
    }
  }
  return pattern2;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var getTemplateLiteralCapturingRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`);
var getPropertySignatures = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertySignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.slice();
    case "Suspend":
      return getPropertySignatures(ast.f());
    case "Refinement":
      return getPropertySignatures(ast.from);
  }
  return getPropertyKeys(ast).map((name) => getPropertyKeyIndexedAccess(ast, name));
};
var getIndexSignatures = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getIndexSignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.indexSignatures.slice();
    case "Suspend":
      return getIndexSignatures(ast.f());
    case "Refinement":
      return getIndexSignatures(ast.from);
  }
  return [];
};
var getNumberIndexedAccess = (ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out.push(e.type);
      }
      if (hasOptional) {
        out.push(undefinedKeyword);
      }
      out = out.concat(getRestASTs(ast.rest));
      return Union.make(out);
    }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getTypeLiteralPropertySignature = (ast, name) => {
  const ops = findFirst3(ast.propertySignatures, (ps) => ps.name === name);
  if (isSome2(ops)) {
    return ops.value;
  }
  if (isString(name)) {
    let out = void 0;
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      switch (encodedParameter._tag) {
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp(encodedParameter);
          if (regex.test(name)) {
            return new PropertySignature(name, is4.type, false, true);
          }
          break;
        }
        case "StringKeyword": {
          if (out === void 0) {
            out = new PropertySignature(name, is4.type, false, true);
          }
        }
      }
    }
    if (out) {
      return out;
    }
  } else if (isSymbol(name)) {
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      if (isSymbolKeyword(encodedParameter)) {
        return new PropertySignature(name, is4.type, false, true);
      }
    }
  }
};
var getPropertyKeyIndexedAccess = (ast, name) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeyIndexedAccess(annotation.value, name);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const ps = getTypeLiteralPropertySignature(ast, name);
      if (ps) {
        return ps;
      }
      break;
    }
    case "Union":
      return new PropertySignature(name, Union.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
    case "Refinement":
      return getPropertyKeyIndexedAccess(ast.from, name);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getPropertyKeys = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeys(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection2(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Refinement":
      return getPropertyKeys(ast.from);
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
};
var record2 = (key, value10) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go5 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value10, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value10, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value10, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value10, false, true));
        break;
      case "Union":
        key2.types.forEach(go5);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go5(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pick = (ast, keys15) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return pick(annotation.value, keys15);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const pss = [];
      const names = {};
      for (const ps of ast.propertySignatures) {
        names[ps.name] = null;
        if (keys15.includes(ps.name)) {
          pss.push(ps);
        }
      }
      for (const key of keys15) {
        if (!(key in names)) {
          const ps = getTypeLiteralPropertySignature(ast, key);
          if (ps) {
            pss.push(ps);
          }
        }
      }
      return new TypeLiteral(pss, []);
    }
    case "Union":
      return new TypeLiteral(keys15.map((name) => getPropertyKeyIndexedAccess(ast, name)), []);
    case "Suspend":
      return pick(ast.f(), keys15);
    case "Refinement":
      return pick(ast.from, keys15);
    case "Transformation": {
      switch (ast.transformation._tag) {
        case "ComposeTransformation":
          return new Transformation(pick(ast.from, keys15), pick(ast.to, keys15), composeTransformation);
        case "TypeLiteralTransformation": {
          const ts = [];
          const fromKeys = [];
          for (const k of keys15) {
            const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k);
            }
          }
          return isNonEmptyReadonlyArray(ts) ? new Transformation(pick(ast.from, fromKeys), pick(ast.to, keys15), new TypeLiteralTransformation(ts)) : pick(ast.from, fromKeys);
        }
      }
    }
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var omit = (ast, keys15) => {
  let indexSignatures = getIndexSignatures(ast);
  if (indexSignatures.length > 0) {
    if (indexSignatures.some((is4) => isStringKeyword(getEncodedParameter(is4.parameter)))) {
      indexSignatures = indexSignatures.filter((is4) => !isTemplateLiteral(getEncodedParameter(is4.parameter)));
    }
    return new TypeLiteral([], indexSignatures);
  }
  return pick(ast, getPropertyKeys(ast).filter((name) => !keys15.includes(name)));
};
var orUndefined = (ast) => Union.make([ast, undefinedKeyword]);
var partial = (ast, options) => {
  const exact = (options == null ? void 0 : options.exact) === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)), match3(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: (rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is4) => new IndexSignature(is4.parameter, orUndefined(is4.type), is4.isReadonly)));
    case "Union":
      return Union.make(ast.types.map((member) => partial(member, options)));
    case "Suspend":
      return new Suspend(() => partial(ast.f(), options));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var required = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((f2) => new PropertySignature(f2.name, f2.type, false, f2.isReadonly, f2.annotations)), ast.indexSignatures);
    case "Union":
      return Union.make(ast.types.map((member) => required(member)));
    case "Suspend":
      return new Suspend(() => required(ast.f()));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(required(ast.from), required(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var mutable = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => is4.isReadonly === false ? is4 : new IndexSignature(is4.parameter, is4.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types3 = changeMap(ast.types, mutable);
      return types3 === ast.types ? ast : Union.make(types3, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement": {
      const from29 = mutable(ast.from);
      return from29 === ast.from ? ast : new Refinement(from29, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from29 = mutable(ast.from);
      const to3 = mutable(ast.to);
      return from29 === ast.from && to3 === ast.to ? ast : new Transformation(from29, to3, ast.transformation, ast.annotations);
    }
  }
  return ast;
};
var getCompiler = (match43) => {
  const compile2 = (ast, path2) => match43[ast._tag](ast, compile2, path2);
  return compile2;
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = void 0;
  for (const id3 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id3)) {
      if (out === void 0) {
        out = {};
      }
      out[id3] = annotated.annotations[id3];
    }
  }
  return out;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id3 of annotationIds) {
    delete out[id3];
  }
  return out;
};
var preserveTransformationAnnotations = pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type8 = typeAST(e.type);
        return type8 === e.type ? e : new OptionalType(type8, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type8) => new Type(type8)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type8 = typeAST(p.type);
        return type8 === p.type ? p : new PropertySignature(p.name, type8, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type8 = typeAST(is4.type);
        return type8 === is4.type ? is4 : new IndexSignature(is4.parameter, type8, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types3 = changeMap(ast.types, typeAST);
      return types3 === ast.types ? ast : Union.make(types3, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from29 = typeAST(ast.from);
      return from29 === ast.from ? ast : new Refinement(from29, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
var createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier(annotated), {
  onNone: () => void 0,
  onSome: (identifier2) => ({
    [JSONIdentifierAnnotationId]: identifier2
  })
});
function changeMap(as18, f2) {
  let changed = false;
  const out = allocate(as18.length);
  for (let i = 0; i < as18.length; i++) {
    const a = as18[i];
    const fa = f2(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as18;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type8 = encodedAST_(e.type, isBound);
        return type8 === e.type ? e : new OptionalType(type8, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type8 = encodedAST_(ps.type, isBound);
        return type8 === ps.type ? ps : new PropertySignature(ps.name, type8, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type8 = encodedAST_(is4.type, isBound);
        return type8 === is4.type ? is4 : new IndexSignature(is4.parameter, type8, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types3 = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types3 === ast.types ? ast : Union.make(types3, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from29 = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from29 === ast.from) {
          return ast;
        }
        if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
          return new Refinement(from29, ast.filter, ast.annotations);
        }
      }
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return identifier2 ? annotations(from29, identifier2) : from29;
    }
    case "Transformation": {
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return encodedAST_(identifier2 ? annotations(ast.from, identifier2) : ast.from, isBound);
    }
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var encodedBoundAST = (ast) => encodedAST_(ast, true);
var toJSONAnnotations = (annotations4) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations4)) {
    out[String(k)] = annotations4[k];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var equals2 = (self, that) => {
  switch (self._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self.enums);
    case "Union":
      return isUnion(that) && equalsUnion(self.types, that.types);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self === that;
  }
};
var equalsTemplateLiteralSpan = getEquivalence5((self, that) => {
  return self.literal === that.literal && equals2(self.type, that.type);
});
var equalsEnums = getEquivalence5((self, that) => that[0] === self[0] && that[1] === self[1]);
var equalsUnion = getEquivalence5(equals2);
var intersection3 = intersectionWith(equals2);
var _keyof = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return _keyof(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is4) => getEncodedParameter(is4.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection3(out, _keyof(ast2)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var compose3 = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var rename = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of ownKeys(mapping)) {
        const name = mapping[key];
        if (name !== void 0) {
          propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps) => {
        const name = mapping[ps.name];
        return new PropertySignature(name === void 0 ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
    }
    case "Union":
      return Union.make(ast.types.map((ast2) => rename(ast2, mapping)));
    case "Suspend":
      return new Suspend(() => rename(ast.f(), mapping));
    case "Transformation":
      return compose3(ast, rename(typeAST(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchemaErrorMessage(ast));
};
var formatKeyword = (ast) => getOrElse2(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand2) => ` & Brand<${formatUnknown(brand2)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse2(() => getDescriptionAnnotation(ast)), orElse2(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse2(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
var pruneUndefined = (ast, self, onTransformation) => {
  switch (ast._tag) {
    case "UndefinedKeyword":
      return neverKeyword;
    case "Union": {
      const types3 = [];
      let hasUndefined = false;
      for (const type8 of ast.types) {
        const pruned = self(type8);
        if (pruned) {
          hasUndefined = true;
          if (!isNeverKeyword(pruned)) {
            types3.push(pruned);
          }
        } else {
          types3.push(type8);
        }
      }
      if (hasUndefined) {
        return Union.make(types3);
      }
      break;
    }
    case "Suspend":
      return self(ast.f());
    case "Transformation":
      return onTransformation(ast);
  }
};

// node_modules/effect/dist/esm/Arbitrary.js
var makeLazy2 = (schema) => {
  const description = getDescription(schema.ast, []);
  return go(description, {
    maxDepth: 2
  });
};
var make5 = (schema) => makeLazy2(schema)(FastCheck_exports);
var makeStringConstraints = (options) => {
  const out = {
    _tag: "StringConstraints",
    constraints: {}
  };
  if (isNumber(options.minLength)) {
    out.constraints.minLength = options.minLength;
  }
  if (isNumber(options.maxLength)) {
    out.constraints.maxLength = options.maxLength;
  }
  if (isString(options.pattern)) {
    out.pattern = options.pattern;
  }
  return out;
};
var makeNumberConstraints = (options) => {
  const out = {
    _tag: "NumberConstraints",
    constraints: {},
    isInteger: options.isInteger ?? false
  };
  if (isNumber(options.min)) {
    out.constraints.min = Math.fround(options.min);
  }
  if (isBoolean(options.minExcluded)) {
    out.constraints.minExcluded = options.minExcluded;
  }
  if (isNumber(options.max)) {
    out.constraints.max = Math.fround(options.max);
  }
  if (isBoolean(options.maxExcluded)) {
    out.constraints.maxExcluded = options.maxExcluded;
  }
  if (isBoolean(options.noNaN)) {
    out.constraints.noNaN = options.noNaN;
  }
  if (isBoolean(options.noDefaultInfinity)) {
    out.constraints.noDefaultInfinity = options.noDefaultInfinity;
  }
  return out;
};
var makeBigIntConstraints = (options) => {
  const out = {
    _tag: "BigIntConstraints",
    constraints: {}
  };
  if (isBigInt(options.min)) {
    out.constraints.min = options.min;
  }
  if (isBigInt(options.max)) {
    out.constraints.max = options.max;
  }
  return out;
};
var makeArrayConstraints = (options) => {
  const out = {
    _tag: "ArrayConstraints",
    constraints: {}
  };
  if (isNumber(options.minLength)) {
    out.constraints.minLength = options.minLength;
  }
  if (isNumber(options.maxLength)) {
    out.constraints.maxLength = options.maxLength;
  }
  return out;
};
var makeDateConstraints = (options) => {
  const out = {
    _tag: "DateConstraints",
    constraints: {}
  };
  if (isDate(options.min)) {
    out.constraints.min = options.min;
  }
  if (isDate(options.max)) {
    out.constraints.max = options.max;
  }
  if (isBoolean(options.noInvalidDate)) {
    out.constraints.noInvalidDate = options.noInvalidDate;
  }
  return out;
};
var getArbitraryAnnotation = getAnnotation(ArbitraryAnnotationId);
var getASTConstraints = (ast) => {
  const TypeAnnotationId = ast.annotations[SchemaIdAnnotationId];
  if (isPropertyKey(TypeAnnotationId)) {
    const out = ast.annotations[TypeAnnotationId];
    if (isReadonlyRecord(out)) {
      return out;
    }
  }
};
var idMemoMap = globalValue(Symbol.for("effect/Arbitrary/IdMemoMap"), () => /* @__PURE__ */ new Map());
var counter = 0;
function wrapGetDescription(f2, g) {
  return (ast, path2) => f2(ast, g(ast, path2));
}
function parseMeta(ast) {
  const jsonSchema = getJSONSchemaAnnotation(ast).pipe(filter(isReadonlyRecord), getOrUndefined2);
  const schemaId = getOrElse2(getSchemaIdAnnotation(ast), () => void 0);
  const schemaParams = fromNullable2(schemaId).pipe(map2((id3) => ast.annotations[id3]), filter(isReadonlyRecord), getOrUndefined2);
  return [schemaId, {
    ...schemaParams,
    ...jsonSchema
  }];
}
var getDescription = wrapGetDescription((ast, description) => {
  const annotation = getArbitraryAnnotation(ast);
  if (isSome2(annotation)) {
    return {
      ...description,
      annotations: [...description.annotations, annotation.value]
    };
  }
  return description;
}, (ast, path2) => {
  const [schemaId, meta] = parseMeta(ast);
  switch (ast._tag) {
    case "Refinement": {
      const from29 = getDescription(ast.from, path2);
      switch (from29._tag) {
        case "StringKeyword":
          return {
            ...from29,
            constraints: [...from29.constraints, makeStringConstraints(meta)],
            refinements: [...from29.refinements, ast]
          };
        case "NumberKeyword": {
          const c = schemaId === NonNaNSchemaId ? makeNumberConstraints({
            noNaN: true
          }) : makeNumberConstraints({
            isInteger: "type" in meta && meta.type === "integer",
            noNaN: "type" in meta && meta.type === "number" ? true : void 0,
            noDefaultInfinity: "type" in meta && meta.type === "number" ? true : void 0,
            min: meta.exclusiveMinimum ?? meta.minimum,
            minExcluded: "exclusiveMinimum" in meta ? true : void 0,
            max: meta.exclusiveMaximum ?? meta.maximum,
            maxExcluded: "exclusiveMaximum" in meta ? true : void 0
          });
          return {
            ...from29,
            constraints: [...from29.constraints, c],
            refinements: [...from29.refinements, ast]
          };
        }
        case "BigIntKeyword": {
          const c = getASTConstraints(ast);
          return {
            ...from29,
            constraints: c !== void 0 ? [...from29.constraints, makeBigIntConstraints(c)] : from29.constraints,
            refinements: [...from29.refinements, ast]
          };
        }
        case "TupleType":
          return {
            ...from29,
            constraints: [...from29.constraints, makeArrayConstraints({
              minLength: meta.minItems,
              maxLength: meta.maxItems
            })],
            refinements: [...from29.refinements, ast]
          };
        case "DateFromSelf":
          return {
            ...from29,
            constraints: [...from29.constraints, makeDateConstraints(meta)],
            refinements: [...from29.refinements, ast]
          };
        default:
          return {
            ...from29,
            refinements: [...from29.refinements, ast]
          };
      }
    }
    case "Declaration": {
      if (schemaId === DateFromSelfSchemaId) {
        return {
          _tag: "DateFromSelf",
          constraints: [makeDateConstraints(meta)],
          path: path2,
          refinements: [],
          annotations: []
        };
      }
      return {
        _tag: "Declaration",
        typeParameters: ast.typeParameters.map((ast2) => getDescription(ast2, path2)),
        path: path2,
        refinements: [],
        annotations: [],
        ast
      };
    }
    case "Literal": {
      return {
        _tag: "Literal",
        literal: ast.literal,
        path: path2,
        refinements: [],
        annotations: []
      };
    }
    case "UniqueSymbol": {
      return {
        _tag: "UniqueSymbol",
        symbol: ast.symbol,
        path: path2,
        refinements: [],
        annotations: []
      };
    }
    case "Enums": {
      return {
        _tag: "Enums",
        enums: ast.enums,
        path: path2,
        refinements: [],
        annotations: [],
        ast
      };
    }
    case "TemplateLiteral": {
      return {
        _tag: "TemplateLiteral",
        head: ast.head,
        spans: ast.spans.map((span4) => ({
          description: getDescription(span4.type, path2),
          literal: span4.literal
        })),
        path: path2,
        refinements: [],
        annotations: []
      };
    }
    case "StringKeyword":
      return {
        _tag: "StringKeyword",
        constraints: [],
        path: path2,
        refinements: [],
        annotations: []
      };
    case "NumberKeyword":
      return {
        _tag: "NumberKeyword",
        constraints: [],
        path: path2,
        refinements: [],
        annotations: []
      };
    case "BigIntKeyword":
      return {
        _tag: "BigIntKeyword",
        constraints: [],
        path: path2,
        refinements: [],
        annotations: []
      };
    case "TupleType":
      return {
        _tag: "TupleType",
        constraints: [],
        elements: ast.elements.map((element2, i) => ({
          isOptional: element2.isOptional,
          description: getDescription(element2.type, [...path2, i])
        })),
        rest: ast.rest.map((element2, i) => getDescription(element2.type, [...path2, i])),
        path: path2,
        refinements: [],
        annotations: []
      };
    case "TypeLiteral":
      return {
        _tag: "TypeLiteral",
        propertySignatures: ast.propertySignatures.map((ps) => ({
          isOptional: ps.isOptional,
          name: ps.name,
          value: getDescription(ps.type, [...path2, ps.name])
        })),
        indexSignatures: ast.indexSignatures.map((is4) => ({
          parameter: getDescription(is4.parameter, path2),
          value: getDescription(is4.type, path2)
        })),
        path: path2,
        refinements: [],
        annotations: []
      };
    case "Union":
      return {
        _tag: "Union",
        members: ast.types.map((member, i) => getDescription(member, [...path2, i])),
        path: path2,
        refinements: [],
        annotations: []
      };
    case "Suspend": {
      const memoId = idMemoMap.get(ast);
      if (memoId !== void 0) {
        return {
          _tag: "Ref",
          id: memoId,
          ast,
          path: path2,
          refinements: [],
          annotations: []
        };
      }
      counter++;
      const id3 = `__id-${counter}__`;
      idMemoMap.set(ast, id3);
      return {
        _tag: "Suspend",
        id: id3,
        ast,
        description: () => getDescription(ast.f(), path2),
        path: path2,
        refinements: [],
        annotations: []
      };
    }
    case "Transformation":
      return getDescription(ast.to, path2);
    case "NeverKeyword":
      return {
        _tag: "NeverKeyword",
        path: path2,
        refinements: [],
        annotations: [],
        ast
      };
    default: {
      return {
        _tag: "Keyword",
        value: ast._tag,
        path: path2,
        refinements: [],
        annotations: []
      };
    }
  }
});
function getMax(n1, n2) {
  return n1 === void 0 ? n2 : n2 === void 0 ? n1 : n1 <= n2 ? n2 : n1;
}
function getMin(n1, n2) {
  return n1 === void 0 ? n2 : n2 === void 0 ? n1 : n1 <= n2 ? n1 : n2;
}
var getOr = (a, b) => {
  return a === void 0 ? b : b === void 0 ? a : a || b;
};
function mergePattern(pattern1, pattern2) {
  if (pattern1 === void 0) {
    return pattern2;
  }
  if (pattern2 === void 0) {
    return pattern1;
  }
  return `(?:${pattern1})|(?:${pattern2})`;
}
function mergeStringConstraints(c1, c2) {
  return makeStringConstraints({
    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),
    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength),
    pattern: mergePattern(c1.pattern, c2.pattern)
  });
}
function buildStringConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeStringConstraints);
}
function mergeNumberConstraints(c1, c2) {
  return makeNumberConstraints({
    isInteger: c1.isInteger || c2.isInteger,
    min: getMax(c1.constraints.min, c2.constraints.min),
    minExcluded: getOr(c1.constraints.minExcluded, c2.constraints.minExcluded),
    max: getMin(c1.constraints.max, c2.constraints.max),
    maxExcluded: getOr(c1.constraints.maxExcluded, c2.constraints.maxExcluded),
    noNaN: getOr(c1.constraints.noNaN, c2.constraints.noNaN),
    noDefaultInfinity: getOr(c1.constraints.noDefaultInfinity, c2.constraints.noDefaultInfinity)
  });
}
function buildNumberConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeNumberConstraints);
}
function mergeBigIntConstraints(c1, c2) {
  return makeBigIntConstraints({
    min: getMax(c1.constraints.min, c2.constraints.min),
    max: getMin(c1.constraints.max, c2.constraints.max)
  });
}
function buildBigIntConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeBigIntConstraints);
}
function mergeDateConstraints(c1, c2) {
  return makeDateConstraints({
    min: getMax(c1.constraints.min, c2.constraints.min),
    max: getMin(c1.constraints.max, c2.constraints.max),
    noInvalidDate: getOr(c1.constraints.noInvalidDate, c2.constraints.noInvalidDate)
  });
}
function buildDateConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeDateConstraints);
}
var constArrayConstraints = makeArrayConstraints({});
function mergeArrayConstraints(c1, c2) {
  return makeArrayConstraints({
    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),
    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)
  });
}
function buildArrayConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeArrayConstraints);
}
var arbitraryMemoMap = globalValue(Symbol.for("effect/Arbitrary/arbitraryMemoMap"), () => /* @__PURE__ */ new WeakMap());
function applyFilters(filters, arb) {
  return (fc) => filters.reduce((arb2, filter26) => arb2.filter(filter26), arb(fc));
}
function absurd2(message) {
  return () => {
    throw new Error(message);
  };
}
function getContextConstraints(description) {
  switch (description._tag) {
    case "StringKeyword":
      return buildStringConstraints(description);
    case "NumberKeyword":
      return buildNumberConstraints(description);
    case "BigIntKeyword":
      return buildBigIntConstraints(description);
    case "DateFromSelf":
      return buildDateConstraints(description);
    case "TupleType":
      return buildArrayConstraints(description);
  }
}
function wrapGo(f2, g) {
  return (description, ctx) => f2(description, ctx, g(description, ctx));
}
var go = wrapGo((description, ctx, lazyArb) => {
  const annotation = description.annotations[description.annotations.length - 1];
  if (annotation === void 0) {
    switch (description._tag) {
      case "Declaration":
      case "NeverKeyword":
        throw new Error(getArbitraryMissingAnnotationErrorMessage(description.path, description.ast));
      case "Enums":
        if (description.enums.length === 0) {
          throw new Error(getArbitraryEmptyEnumErrorMessage(description.path));
        }
    }
  }
  const filters = description.refinements.map((ast) => (a) => isNone2(ast.filter(a, defaultParseOption, ast)));
  if (annotation === void 0) {
    return applyFilters(filters, lazyArb);
  }
  const constraints = getContextConstraints(description);
  if (constraints !== void 0) {
    ctx = {
      ...ctx,
      constraints
    };
  }
  if (description._tag === "Declaration") {
    return applyFilters(filters, annotation(...description.typeParameters.map((p) => go(p, ctx)), ctx));
  }
  if (description.refinements.length > 0) {
    return applyFilters(filters, annotation(lazyArb, ctx));
  }
  return annotation(ctx);
}, (description, ctx) => {
  switch (description._tag) {
    case "DateFromSelf": {
      const constraints = buildDateConstraints(description);
      return (fc) => fc.date(constraints == null ? void 0 : constraints.constraints);
    }
    case "Declaration":
    case "NeverKeyword":
      return absurd2(`BUG: cannot generate an arbitrary for ${description._tag}`);
    case "Literal":
      return (fc) => fc.constant(description.literal);
    case "UniqueSymbol":
      return (fc) => fc.constant(description.symbol);
    case "Keyword": {
      switch (description.value) {
        case "UndefinedKeyword":
          return (fc) => fc.constant(void 0);
        case "VoidKeyword":
        case "UnknownKeyword":
        case "AnyKeyword":
          return (fc) => fc.anything();
        case "BooleanKeyword":
          return (fc) => fc.boolean();
        case "SymbolKeyword":
          return (fc) => fc.string().map((s) => Symbol.for(s));
        case "ObjectKeyword":
          return (fc) => fc.oneof(fc.object(), fc.array(fc.anything()));
      }
    }
    case "Enums":
      return (fc) => fc.oneof(...description.enums.map(([_, value10]) => fc.constant(value10)));
    case "TemplateLiteral": {
      return (fc) => {
        const string8 = fc.string({
          maxLength: 5
        });
        const number7 = fc.float({
          noDefaultInfinity: true,
          noNaN: true
        });
        const getTemplateLiteralArb = (description2) => {
          const components = description2.head !== "" ? [fc.constant(description2.head)] : [];
          const getTemplateLiteralSpanTypeArb = (description3) => {
            switch (description3._tag) {
              case "StringKeyword":
                return string8;
              case "NumberKeyword":
                return number7;
              case "Literal":
                return fc.constant(String(description3.literal));
              case "Union":
                return fc.oneof(...description3.members.map(getTemplateLiteralSpanTypeArb));
              case "TemplateLiteral":
                return getTemplateLiteralArb(description3);
              default:
                return fc.constant("");
            }
          };
          description2.spans.forEach((span4) => {
            components.push(getTemplateLiteralSpanTypeArb(span4.description));
            if (span4.literal !== "") {
              components.push(fc.constant(span4.literal));
            }
          });
          return fc.tuple(...components).map((spans) => spans.join(""));
        };
        return getTemplateLiteralArb(description);
      };
    }
    case "StringKeyword": {
      const constraints = buildStringConstraints(description);
      const pattern2 = constraints == null ? void 0 : constraints.pattern;
      return pattern2 !== void 0 ? (fc) => fc.stringMatching(new RegExp(pattern2)) : (fc) => fc.string(constraints == null ? void 0 : constraints.constraints);
    }
    case "NumberKeyword": {
      const constraints = buildNumberConstraints(description);
      return (constraints == null ? void 0 : constraints.isInteger) ? (fc) => fc.integer(constraints.constraints) : (fc) => fc.float(constraints == null ? void 0 : constraints.constraints);
    }
    case "BigIntKeyword": {
      const constraints = buildBigIntConstraints(description);
      return (fc) => fc.bigInt((constraints == null ? void 0 : constraints.constraints) ?? {});
    }
    case "TupleType": {
      const elements = [];
      let hasOptionals = false;
      for (const element2 of description.elements) {
        elements.push(go(element2.description, ctx));
        if (element2.isOptional) {
          hasOptionals = true;
        }
      }
      const rest = description.rest.map((d) => go(d, ctx));
      return (fc) => {
        let output = fc.tuple(...elements.map((arb) => arb(fc)));
        if (hasOptionals) {
          const indexes = fc.tuple(...description.elements.map((element2) => element2.isOptional ? fc.boolean() : fc.constant(true)));
          output = output.chain((tuple7) => indexes.map((booleans) => {
            for (const [i, b] of booleans.reverse().entries()) {
              if (!b) {
                tuple7.splice(booleans.length - i, 1);
              }
            }
            return tuple7;
          }));
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const constraints = buildArrayConstraints(description) ?? constArrayConstraints;
          const [head13, ...tail5] = rest;
          const item = head13(fc);
          output = output.chain((as18) => {
            const len = as18.length;
            const restArrayConstraints = subtractElementsLength(constraints.constraints, len);
            if (restArrayConstraints.maxLength === 0) {
              return fc.constant(as18);
            }
            const arr = ctx.depthIdentifier !== void 0 ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, restArrayConstraints) : fc.array(item, restArrayConstraints);
            if (len === 0) {
              return arr;
            }
            return arr.map((rest2) => [...as18, ...rest2]);
          });
          for (let j = 0; j < tail5.length; j++) {
            output = output.chain((as18) => tail5[j](fc).map((a) => [...as18, a]));
          }
        }
        return output;
      };
    }
    case "TypeLiteral": {
      const propertySignatures = [];
      const requiredKeys = [];
      for (const ps of description.propertySignatures) {
        if (!ps.isOptional) {
          requiredKeys.push(ps.name);
        }
        propertySignatures.push(go(ps.value, ctx));
      }
      const indexSignatures = description.indexSignatures.map((is4) => [go(is4.parameter, ctx), go(is4.value, ctx)]);
      return (fc) => {
        const pps = {};
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = description.propertySignatures[i];
          pps[ps.name] = propertySignatures[i](fc);
        }
        let output = fc.record(pps, {
          requiredKeys
        });
        for (let i = 0; i < indexSignatures.length; i++) {
          const key = indexSignatures[i][0](fc);
          const value10 = indexSignatures[i][1](fc);
          output = output.chain((o) => {
            const item = fc.tuple(key, value10);
            const arr = ctx.depthIdentifier !== void 0 ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, {
              maxLength: 2
            }) : fc.array(item);
            return arr.map((tuples) => ({
              ...Object.fromEntries(tuples),
              ...o
            }));
          });
        }
        return output;
      };
    }
    case "Union": {
      const members = description.members.map((member) => go(member, ctx));
      return (fc) => fc.oneof(...members.map((arb) => arb(fc)));
    }
    case "Suspend": {
      const memo2 = arbitraryMemoMap.get(description.ast);
      if (memo2) {
        return memo2;
      }
      if (ctx.depthIdentifier === void 0) {
        ctx = {
          ...ctx,
          depthIdentifier: description.id
        };
      }
      const get48 = memoizeThunk(() => {
        return go(description.description(), ctx);
      });
      const out = (fc) => fc.constant(null).chain(() => get48()(fc));
      arbitraryMemoMap.set(description.ast, out);
      return out;
    }
    case "Ref": {
      const memo2 = arbitraryMemoMap.get(description.ast);
      if (memo2) {
        return memo2;
      }
      throw new Error(`BUG: Ref ${JSON.stringify(description.id)} not found`);
    }
  }
});
function subtractElementsLength(constraints, len) {
  if (len === 0 || constraints.minLength === void 0 && constraints.maxLength === void 0) {
    return constraints;
  }
  const out = {
    ...constraints
  };
  if (out.minLength !== void 0) {
    out.minLength = Math.max(out.minLength - len, 0);
  }
  if (out.maxLength !== void 0) {
    out.maxLength = Math.max(out.maxLength - len, 0);
  }
  return out;
}
var getSuspendedArray = (fc, depthIdentifier, maxDepth, item, constraints) => {
  const maxLengthLimit = Math.max(2, constraints.minLength ?? 0);
  if (constraints.maxLength !== void 0 && constraints.maxLength > maxLengthLimit) {
    constraints = {
      ...constraints,
      maxLength: maxLengthLimit
    };
  }
  return fc.oneof({
    maxDepth,
    depthIdentifier
  }, fc.constant([]), fc.array(item, constraints));
};

// node_modules/effect/dist/esm/BigDecimal.js
var BigDecimal_exports = {};
__export(BigDecimal_exports, {
  Equivalence: () => Equivalence2,
  Order: () => Order2,
  TypeId: () => TypeId5,
  abs: () => abs,
  between: () => between3,
  ceil: () => ceil,
  clamp: () => clamp4,
  digitAt: () => digitAt,
  divide: () => divide2,
  equals: () => equals3,
  floor: () => floor,
  format: () => format2,
  fromBigInt: () => fromBigInt,
  fromNumber: () => fromNumber3,
  fromString: () => fromString3,
  greaterThan: () => greaterThan3,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo3,
  isBigDecimal: () => isBigDecimal,
  isInteger: () => isInteger,
  isNegative: () => isNegative,
  isPositive: () => isPositive,
  isZero: () => isZero,
  lessThan: () => lessThan3,
  lessThanOrEqualTo: () => lessThanOrEqualTo3,
  make: () => make6,
  max: () => max4,
  min: () => min4,
  multiply: () => multiply2,
  negate: () => negate2,
  normalize: () => normalize,
  remainder: () => remainder2,
  round: () => round3,
  roundTerminal: () => roundTerminal,
  safeFromNumber: () => safeFromNumber,
  scale: () => scale,
  sign: () => sign2,
  subtract: () => subtract2,
  sum: () => sum2,
  sumAll: () => sumAll2,
  toExponential: () => toExponential,
  truncate: () => truncate,
  unsafeDivide: () => unsafeDivide2,
  unsafeFromNumber: () => unsafeFromNumber,
  unsafeFromString: () => unsafeFromString,
  unsafeMakeNormalized: () => unsafeMakeNormalized,
  unsafeRemainder: () => unsafeRemainder,
  unsafeToNumber: () => unsafeToNumber
});
var DEFAULT_PRECISION = 100;
var FINITE_INT_REGEX = /^[+-]?\d+$/;
var TypeId5 = Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId5]: TypeId5,
  [symbol2]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine2(number2(normalized.scale)), cached(this));
  },
  [symbol3](that) {
    return isBigDecimal(that) && equals3(this, that);
  },
  toString() {
    return `BigDecimal(${format2(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u) => hasProperty(u, TypeId5);
var make6 = (value10, scale2) => {
  const o = Object.create(BigDecimalProto);
  o.value = value10;
  o.scale = scale2;
  return o;
};
var unsafeMakeNormalized = (value10, scale2) => {
  if (value10 !== bigint0 && value10 % bigint10 === bigint0) {
    throw new RangeError("Value must be normalized");
  }
  const o = make6(value10, scale2);
  o.normalized = o;
  return o;
};
var bigint0 = BigInt(0);
var bigint1 = BigInt(1);
var bigint10 = BigInt(10);
var zero = unsafeMakeNormalized(bigint0, 0);
var normalize = (self) => {
  if (self.normalized === void 0) {
    if (self.value === bigint0) {
      self.normalized = zero;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value10 = BigInt(digits.substring(0, digits.length - trail));
      const scale2 = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value10, scale2);
    }
  }
  return self.normalized;
};
var scale = dual(2, (self, scale2) => {
  if (scale2 > self.scale) {
    return make6(self.value * bigint10 ** BigInt(scale2 - self.scale), scale2);
  }
  if (scale2 < self.scale) {
    return make6(self.value / bigint10 ** BigInt(self.scale - scale2), scale2);
  }
  return self;
});
var sum2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return that;
  }
  if (self.scale > that.scale) {
    return make6(scale(that, self.scale).value + self.value, self.scale);
  }
  if (self.scale < that.scale) {
    return make6(scale(self, that.scale).value + that.value, that.scale);
  }
  return make6(self.value + that.value, self.scale);
});
var multiply2 = dual(2, (self, that) => {
  if (that.value === bigint0 || self.value === bigint0) {
    return zero;
  }
  return make6(self.value * that.value, self.scale + that.scale);
});
var subtract2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return make6(-that.value, that.scale);
  }
  if (self.scale > that.scale) {
    return make6(self.value - scale(that, self.scale).value, self.scale);
  }
  if (self.scale < that.scale) {
    return make6(scale(self, that.scale).value - that.value, that.scale);
  }
  return make6(self.value - that.value, self.scale);
});
var divideWithPrecision = (num, den, scale2, precision) => {
  const numNegative = num < bigint0;
  const denNegative = den < bigint0;
  const negateResult = numNegative !== denNegative;
  num = numNegative ? -num : num;
  den = denNegative ? -den : den;
  while (num < den) {
    num *= bigint10;
    scale2++;
  }
  let quotient = num / den;
  let remainder3 = num % den;
  if (remainder3 === bigint0) {
    return make6(negateResult ? -quotient : quotient, scale2);
  }
  let count9 = `${quotient}`.length;
  remainder3 *= bigint10;
  while (remainder3 !== bigint0 && count9 < precision) {
    const q = remainder3 / den;
    const r = remainder3 % den;
    quotient = quotient * bigint10 + q;
    remainder3 = r * bigint10;
    count9++;
    scale2++;
  }
  if (remainder3 !== bigint0) {
    quotient += roundTerminal(remainder3 / den);
  }
  return make6(negateResult ? -quotient : quotient, scale2);
};
var roundTerminal = (n) => {
  const pos = n >= bigint0 ? 0 : 1;
  return Number(`${n}`[pos]) < 5 ? bigint0 : bigint1;
};
var divide2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return none2();
  }
  if (self.value === bigint0) {
    return some3(zero);
  }
  const scale2 = self.scale - that.scale;
  if (self.value === that.value) {
    return some3(make6(bigint1, scale2));
  }
  return some3(divideWithPrecision(self.value, that.value, scale2, DEFAULT_PRECISION));
});
var unsafeDivide2 = dual(2, (self, that) => {
  if (that.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  if (self.value === bigint0) {
    return zero;
  }
  const scale2 = self.scale - that.scale;
  if (self.value === that.value) {
    return make6(bigint1, scale2);
  }
  return divideWithPrecision(self.value, that.value, scale2, DEFAULT_PRECISION);
});
var Order2 = make2((self, that) => {
  const scmp = number3(sign2(self), sign2(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self.scale > that.scale) {
    return bigint2(self.value, scale(that, self.scale).value);
  }
  if (self.scale < that.scale) {
    return bigint2(scale(self, that.scale).value, that.value);
  }
  return bigint2(self.value, that.value);
});
var lessThan3 = lessThan(Order2);
var lessThanOrEqualTo3 = lessThanOrEqualTo(Order2);
var greaterThan3 = greaterThan(Order2);
var greaterThanOrEqualTo3 = greaterThanOrEqualTo(Order2);
var between3 = between(Order2);
var clamp4 = clamp(Order2);
var min4 = min(Order2);
var max4 = max(Order2);
var sign2 = (n) => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;
var abs = (n) => n.value < bigint0 ? make6(-n.value, n.scale) : n;
var negate2 = (n) => make6(-n.value, n.scale);
var remainder2 = dual(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    return none2();
  }
  const max14 = Math.max(self.scale, divisor.scale);
  return some3(make6(scale(self, max14).value % scale(divisor, max14).value, max14));
});
var unsafeRemainder = dual(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  const max14 = Math.max(self.scale, divisor.scale);
  return make6(scale(self, max14).value % scale(divisor, max14).value, max14);
});
var Equivalence2 = make((self, that) => {
  if (self.scale > that.scale) {
    return scale(that, self.scale).value === self.value;
  }
  if (self.scale < that.scale) {
    return scale(self, that.scale).value === that.value;
  }
  return self.value === that.value;
});
var equals3 = dual(2, (self, that) => Equivalence2(self, that));
var fromBigInt = (n) => make6(n, 0);
var unsafeFromNumber = (n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`));
var fromNumber3 = unsafeFromNumber;
var safeFromNumber = (n) => {
  if (!Number.isFinite(n)) {
    return none2();
  }
  const string8 = `${n}`;
  if (string8.includes("e")) {
    return fromString3(string8);
  }
  const [lead, trail = ""] = string8.split(".");
  return some3(make6(BigInt(`${lead}${trail}`), trail.length));
};
var fromString3 = (s) => {
  if (s === "") {
    return some3(zero);
  }
  let base;
  let exp;
  const seperator = s.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s.slice(seperator + 1);
    base = s.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none2();
    }
  } else {
    base = s;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none2();
  }
  const scale2 = offset - exp;
  if (!Number.isSafeInteger(scale2)) {
    return none2();
  }
  return some3(make6(BigInt(digits), scale2));
};
var unsafeFromString = (s) => getOrThrowWith2(fromString3(s), () => new Error("Invalid numerical string"));
var format2 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative2 = normalized.value < bigint0;
  const absolute = negative2 ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before3;
  let after3;
  if (normalized.scale >= absolute.length) {
    before3 = "0";
    after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - normalized.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before3 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location);
      before3 = absolute.slice(0, location);
    }
  }
  const complete6 = after3 === "" ? before3 : `${before3}.${after3}`;
  return negative2 ? `-${complete6}` : complete6;
};
var toExponential = (n) => {
  if (isZero(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head13 = digits.slice(0, 1);
  const tail5 = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head13}`;
  if (tail5 !== "") {
    output += `.${tail5}`;
  }
  const exp = tail5.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
var unsafeToNumber = (n) => Number(format2(n));
var isInteger = (n) => normalize(n).scale <= 0;
var isZero = (n) => n.value === bigint0;
var isNegative = (n) => n.value < bigint0;
var isPositive = (n) => n.value > bigint0;
var isBigDecimalArgs = (args2) => isBigDecimal(args2[0]);
var ceil = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  const truncated = truncate(self, scale2);
  if (isPositive(self) && lessThan3(truncated, self)) {
    return sum2(truncated, make6(1n, scale2));
  }
  return truncated;
});
var floor = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  const truncated = truncate(self, scale2);
  if (isNegative(self) && greaterThan3(truncated, self)) {
    return sum2(truncated, make6(-1n, scale2));
  }
  return truncated;
});
var truncate = dual(isBigDecimalArgs, (self, scale2 = 0) => {
  if (self.scale <= scale2) {
    return self;
  }
  return make6(self.value / 10n ** BigInt(self.scale - scale2), scale2);
});
var digitAt = dual(2, (self, scale2) => {
  if (self.scale < scale2) {
    return 0n;
  }
  const scaled = self.value / 10n ** BigInt(self.scale - scale2);
  return scaled % 10n;
});
var round3 = dual(isBigDecimalArgs, (self, options) => {
  const mode = (options == null ? void 0 : options.mode) ?? "half-from-zero";
  const scale2 = (options == null ? void 0 : options.scale) ?? 0;
  switch (mode) {
    case "ceil":
      return ceil(self, scale2);
    case "floor":
      return floor(self, scale2);
    case "to-zero":
      return truncate(self, scale2);
    case "from-zero":
      return isPositive(self) ? ceil(self, scale2) : floor(self, scale2);
    case "half-ceil":
      return floor(sum2(self, make6(5n, scale2 + 1)), scale2);
    case "half-floor":
      return ceil(sum2(self, make6(-5n, scale2 + 1)), scale2);
    case "half-to-zero":
      return isNegative(self) ? floor(sum2(self, make6(5n, scale2 + 1)), scale2) : ceil(sum2(self, make6(-5n, scale2 + 1)), scale2);
    case "half-from-zero":
      return isNegative(self) ? ceil(sum2(self, make6(-5n, scale2 + 1)), scale2) : floor(sum2(self, make6(5n, scale2 + 1)), scale2);
  }
  const halfCeil = floor(sum2(self, make6(5n, scale2 + 1)), scale2);
  const halfFloor = ceil(sum2(self, make6(-5n, scale2 + 1)), scale2);
  const digit = digitAt(halfCeil, scale2);
  switch (mode) {
    case "half-even":
      return equals3(halfCeil, halfFloor) ? halfCeil : digit % 2n === 0n ? halfCeil : halfFloor;
    case "half-odd":
      return equals3(halfCeil, halfFloor) ? halfCeil : digit % 2n === 0n ? halfFloor : halfCeil;
  }
});
var sumAll2 = (collection) => {
  let out = zero;
  for (const n of collection) {
    out = sum2(out, n);
  }
  return out;
};

// node_modules/effect/dist/esm/BigInt.js
var BigInt_exports = {};
__export(BigInt_exports, {
  Equivalence: () => Equivalence3,
  Order: () => Order3,
  abs: () => abs2,
  between: () => between4,
  clamp: () => clamp5,
  decrement: () => decrement2,
  divide: () => divide3,
  fromNumber: () => fromNumber4,
  fromString: () => fromString4,
  gcd: () => gcd,
  greaterThan: () => greaterThan4,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo4,
  increment: () => increment2,
  isBigInt: () => isBigInt2,
  lcm: () => lcm,
  lessThan: () => lessThan4,
  lessThanOrEqualTo: () => lessThanOrEqualTo4,
  max: () => max5,
  min: () => min5,
  multiply: () => multiply3,
  multiplyAll: () => multiplyAll2,
  sign: () => sign3,
  sqrt: () => sqrt,
  subtract: () => subtract3,
  sum: () => sum3,
  sumAll: () => sumAll3,
  toNumber: () => toNumber3,
  unsafeDivide: () => unsafeDivide3,
  unsafeSqrt: () => unsafeSqrt
});
var bigint02 = BigInt(0);
var bigint12 = BigInt(1);
var bigint22 = BigInt(2);
var isBigInt2 = isBigInt;
var sum3 = dual(2, (self, that) => self + that);
var multiply3 = dual(2, (self, that) => self * that);
var subtract3 = dual(2, (self, that) => self - that);
var divide3 = dual(2, (self, that) => that === bigint02 ? none2() : some3(self / that));
var unsafeDivide3 = dual(2, (self, that) => self / that);
var increment2 = (n) => n + bigint12;
var decrement2 = (n) => n - bigint12;
var Equivalence3 = bigint;
var Order3 = bigint2;
var lessThan4 = lessThan(Order3);
var lessThanOrEqualTo4 = lessThanOrEqualTo(Order3);
var greaterThan4 = greaterThan(Order3);
var greaterThanOrEqualTo4 = greaterThanOrEqualTo(Order3);
var between4 = between(Order3);
var clamp5 = clamp(Order3);
var min5 = min(Order3);
var max5 = max(Order3);
var sign3 = (n) => Order3(n, bigint02);
var abs2 = (n) => n < bigint02 ? -n : n;
var gcd = dual(2, (self, that) => {
  while (that !== bigint02) {
    const t = that;
    that = self % that;
    self = t;
  }
  return self;
});
var lcm = dual(2, (self, that) => self * that / gcd(self, that));
var unsafeSqrt = (n) => {
  if (n < bigint02) {
    throw new RangeError("Cannot take the square root of a negative number");
  }
  if (n < bigint22) {
    return n;
  }
  let x = n / bigint22;
  while (x * x > n) {
    x = (n / x + x) / bigint22;
  }
  return x;
};
var sqrt = (n) => greaterThanOrEqualTo4(n, bigint02) ? some3(unsafeSqrt(n)) : none2();
var sumAll3 = (collection) => {
  let out = bigint02;
  for (const n of collection) {
    out += n;
  }
  return out;
};
var multiplyAll2 = (collection) => {
  let out = bigint12;
  for (const n of collection) {
    if (n === bigint02) {
      return bigint02;
    }
    out *= n;
  }
  return out;
};
var toNumber3 = (b) => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some3(Number(b));
};
var fromString4 = (s) => {
  try {
    return s.trim() === "" ? none2() : some3(BigInt(s));
  } catch {
    return none2();
  }
};
var fromNumber4 = (n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some3(BigInt(n));
  } catch {
    return none2();
  }
};

// node_modules/effect/dist/esm/Boolean.js
var Boolean_exports = {};
__export(Boolean_exports, {
  Equivalence: () => Equivalence4,
  Order: () => Order4,
  and: () => and2,
  eqv: () => eqv2,
  every: () => every4,
  implies: () => implies2,
  isBoolean: () => isBoolean2,
  match: () => match4,
  nand: () => nand2,
  nor: () => nor2,
  not: () => not2,
  or: () => or2,
  some: () => some7,
  xor: () => xor2
});
var isBoolean2 = isBoolean;
var match4 = dual(2, (value10, options) => value10 ? options.onTrue() : options.onFalse());
var Equivalence4 = boolean;
var Order4 = boolean2;
var not2 = (self) => !self;
var and2 = dual(2, (self, that) => self && that);
var nand2 = dual(2, (self, that) => !(self && that));
var or2 = dual(2, (self, that) => self || that);
var nor2 = dual(2, (self, that) => !(self || that));
var xor2 = dual(2, (self, that) => !self && that || self && !that);
var eqv2 = dual(2, (self, that) => !xor2(self, that));
var implies2 = dual(2, (self, that) => self ? that : true);
var every4 = (collection) => {
  for (const b of collection) {
    if (!b) {
      return false;
    }
  }
  return true;
};
var some7 = (collection) => {
  for (const b of collection) {
    if (b) {
      return true;
    }
  }
  return false;
};

// node_modules/effect/dist/esm/Brand.js
var Brand_exports = {};
__export(Brand_exports, {
  BrandTypeId: () => BrandTypeId,
  RefinedConstructorsTypeId: () => RefinedConstructorsTypeId,
  all: () => all6,
  error: () => error,
  errors: () => errors,
  nominal: () => nominal,
  refined: () => refined,
  unbranded: () => unbranded
});
var BrandTypeId = Symbol.for("effect/Brand");
var RefinedConstructorsTypeId = Symbol.for("effect/Brand/Refined");
var error = (message, meta) => [{
  message,
  meta
}];
var errors = (...errors2) => flatten3(errors2);
function refined(...args2) {
  const either14 = args2.length === 2 ? (unbranded2) => args2[0](unbranded2) ? right2(unbranded2) : left2(args2[1](unbranded2)) : (unbranded2) => {
    return match2(args2[0](unbranded2), {
      onNone: () => right2(unbranded2),
      onSome: left2
    });
  };
  return Object.assign((unbranded2) => getOrThrowWith(either14(unbranded2), identity), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args3) => getRight3(either14(args3)),
    either: either14,
    is: (args3) => isRight2(either14(args3))
  });
}
var nominal = () => {
  return Object.assign((args2) => args2, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => some3(args2),
    either: (args2) => right2(args2),
    is: (_args) => true
  });
};
var all6 = (...brands) => {
  const either14 = (args2) => {
    let result = right2(args2);
    for (const brand2 of brands) {
      const nextResult = brand2.either(args2);
      if (isLeft2(result) && isLeft2(nextResult)) {
        result = left2([...result.left, ...nextResult.left]);
      } else {
        result = isLeft2(result) ? result : nextResult;
      }
    }
    return result;
  };
  return Object.assign((args2) => match(either14(args2), {
    onLeft: (e) => {
      throw e;
    },
    onRight: identity
  }), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => getRight3(either14(args2)),
    either: either14,
    is: (args2) => isRight2(either14(args2))
  });
};
var unbranded = unsafeCoerce;

// node_modules/effect/dist/esm/Cache.js
var Cache_exports = {};
__export(Cache_exports, {
  CacheTypeId: () => CacheTypeId2,
  ConsumerCacheTypeId: () => ConsumerCacheTypeId2,
  make: () => make50,
  makeCacheStats: () => makeCacheStats2,
  makeEntryStats: () => makeEntryStats2,
  makeWith: () => makeWith2
});

// node_modules/effect/dist/esm/Context.js
var Context_exports = {};
__export(Context_exports, {
  GenericTag: () => GenericTag,
  Reference: () => Reference2,
  Tag: () => Tag2,
  add: () => add3,
  empty: () => empty6,
  get: () => get4,
  getOption: () => getOption2,
  getOrElse: () => getOrElse4,
  isContext: () => isContext2,
  isReference: () => isReference2,
  isTag: () => isTag2,
  make: () => make8,
  merge: () => merge3,
  mergeAll: () => mergeAll2,
  omit: () => omit3,
  pick: () => pick3,
  unsafeGet: () => unsafeGet3,
  unsafeMake: () => unsafeMake
});

// node_modules/effect/dist/esm/internal/context.js
var TagTypeId = Symbol.for("effect/Context/Tag");
var ReferenceTypeId = Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make7(this, self);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit2;
  const tag5 = Object.create(TagProto);
  Object.defineProperty(tag5, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag5.key = key;
  return tag5;
};
var Tag = (id3) => () => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit2;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id3, options) => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit2;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id3;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId6 = Symbol.for("effect/Context");
var ContextProto = {
  [TypeId6]: {
    _Services: (_) => _
  },
  [symbol3](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol2]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context15 = Object.create(ContextProto);
  context15.unsafeMap = unsafeMap;
  return context15;
};
var serviceNotFoundError = (tag5) => {
  const error4 = new Error(`Service not found${tag5.key ? `: ${String(tag5.key)}` : ""}`);
  if (tag5.stack) {
    const lines = tag5.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error4.message = error4.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error4.stack) {
    const lines = error4.stack.split("\n");
    lines.splice(1, 3);
    error4.stack = lines.join("\n");
  }
  return error4;
};
var isContext = (u) => hasProperty(u, TypeId6);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = makeContext(/* @__PURE__ */ new Map());
var empty5 = () => _empty;
var make7 = (tag5, service4) => makeContext(/* @__PURE__ */ new Map([[tag5.key, service4]]));
var add2 = dual(3, (self, tag5, service4) => {
  const map49 = new Map(self.unsafeMap);
  map49.set(tag5.key, service4);
  return makeContext(map49);
});
var defaultValueCache = globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = (tag5) => {
  if (defaultValueCache.has(tag5.key)) {
    return defaultValueCache.get(tag5.key);
  }
  const value10 = tag5.defaultValue();
  defaultValueCache.set(tag5.key, value10);
  return value10;
};
var unsafeGetReference = (self, tag5) => {
  return self.unsafeMap.has(tag5.key) ? self.unsafeMap.get(tag5.key) : getDefaultValue(tag5);
};
var unsafeGet2 = dual(2, (self, tag5) => {
  if (!self.unsafeMap.has(tag5.key)) {
    if (ReferenceTypeId in tag5) return getDefaultValue(tag5);
    throw serviceNotFoundError(tag5);
  }
  return self.unsafeMap.get(tag5.key);
});
var get3 = unsafeGet2;
var getOrElse3 = dual(3, (self, tag5, orElse24) => {
  if (!self.unsafeMap.has(tag5.key)) {
    return isReference(tag5) ? getDefaultValue(tag5) : orElse24();
  }
  return self.unsafeMap.get(tag5.key);
});
var getOption = dual(2, (self, tag5) => {
  if (!self.unsafeMap.has(tag5.key)) {
    return isReference(tag5) ? some2(getDefaultValue(tag5)) : none;
  }
  return some2(self.unsafeMap.get(tag5.key));
});
var merge2 = dual(2, (self, that) => {
  const map49 = new Map(self.unsafeMap);
  for (const [tag5, s] of that.unsafeMap) {
    map49.set(tag5, s);
  }
  return makeContext(map49);
});
var mergeAll = (...ctxs) => {
  const map49 = /* @__PURE__ */ new Map();
  for (const ctx of ctxs) {
    for (const [tag5, s] of ctx.unsafeMap) {
      map49.set(tag5, s);
    }
  }
  return makeContext(map49);
};
var pick2 = (...tags3) => (self) => {
  const tagSet = new Set(tags3.map((_) => _.key));
  const newEnv = /* @__PURE__ */ new Map();
  for (const [tag5, s] of self.unsafeMap.entries()) {
    if (tagSet.has(tag5)) {
      newEnv.set(tag5, s);
    }
  }
  return makeContext(newEnv);
};
var omit2 = (...tags3) => (self) => {
  const newEnv = new Map(self.unsafeMap);
  for (const tag5 of tags3) {
    newEnv.delete(tag5.key);
  }
  return makeContext(newEnv);
};

// node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var isReference2 = isReference;
var empty6 = empty5;
var make8 = make7;
var add3 = add2;
var get4 = get3;
var getOrElse4 = getOrElse3;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var mergeAll2 = mergeAll;
var pick3 = pick2;
var omit3 = omit2;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/effect/dist/esm/Deferred.js
var Deferred_exports = {};
__export(Deferred_exports, {
  DeferredTypeId: () => DeferredTypeId2,
  await: () => _await,
  complete: () => complete,
  completeWith: () => completeWith,
  die: () => die3,
  dieSync: () => dieSync2,
  done: () => done2,
  fail: () => fail3,
  failCause: () => failCause2,
  failCauseSync: () => failCauseSync2,
  failSync: () => failSync2,
  interrupt: () => interrupt3,
  interruptWith: () => interruptWith2,
  isDone: () => isDone,
  make: () => make24,
  makeAs: () => makeAs,
  poll: () => poll,
  succeed: () => succeed2,
  sync: () => sync2,
  unsafeDone: () => unsafeDone,
  unsafeMake: () => unsafeMake4
});

// node_modules/effect/dist/esm/Chunk.js
var Chunk_exports = {};
__export(Chunk_exports, {
  append: () => append3,
  appendAll: () => appendAll3,
  chunksOf: () => chunksOf3,
  compact: () => compact,
  contains: () => contains4,
  containsWith: () => containsWith4,
  dedupe: () => dedupe2,
  dedupeAdjacent: () => dedupeAdjacent3,
  difference: () => difference3,
  differenceWith: () => differenceWith2,
  drop: () => drop3,
  dropRight: () => dropRight2,
  dropWhile: () => dropWhile2,
  empty: () => empty7,
  every: () => every5,
  filter: () => filter5,
  filterMap: () => filterMap5,
  filterMapWhile: () => filterMapWhile3,
  findFirst: () => findFirst4,
  findFirstIndex: () => findFirstIndex2,
  findLast: () => findLast3,
  findLastIndex: () => findLastIndex2,
  flatMap: () => flatMap5,
  flatten: () => flatten5,
  forEach: () => forEach3,
  fromIterable: () => fromIterable3,
  get: () => get5,
  getEquivalence: () => getEquivalence6,
  head: () => head3,
  headNonEmpty: () => headNonEmpty2,
  intersection: () => intersection4,
  isChunk: () => isChunk,
  isEmpty: () => isEmpty2,
  isNonEmpty: () => isNonEmpty2,
  join: () => join2,
  last: () => last2,
  lastNonEmpty: () => lastNonEmpty2,
  make: () => make9,
  makeBy: () => makeBy3,
  map: () => map7,
  mapAccum: () => mapAccum2,
  modify: () => modify3,
  modifyOption: () => modifyOption3,
  of: () => of3,
  partition: () => partition3,
  partitionMap: () => partitionMap4,
  prepend: () => prepend3,
  prependAll: () => prependAll3,
  range: () => range3,
  reduce: () => reduce4,
  reduceRight: () => reduceRight2,
  remove: () => remove3,
  removeOption: () => removeOption2,
  replace: () => replace3,
  replaceOption: () => replaceOption3,
  reverse: () => reverse3,
  separate: () => separate3,
  size: () => size6,
  some: () => some8,
  sort: () => sort2,
  sortWith: () => sortWith2,
  split: () => split2,
  splitAt: () => splitAt2,
  splitNonEmptyAt: () => splitNonEmptyAt2,
  splitWhere: () => splitWhere2,
  tail: () => tail2,
  tailNonEmpty: () => tailNonEmpty2,
  take: () => take3,
  takeRight: () => takeRight2,
  takeWhile: () => takeWhile3,
  toArray: () => toArray2,
  toReadonlyArray: () => toReadonlyArray,
  union: () => union3,
  unsafeFromArray: () => unsafeFromArray,
  unsafeFromNonEmptyArray: () => unsafeFromNonEmptyArray,
  unsafeGet: () => unsafeGet4,
  unsafeHead: () => unsafeHead2,
  unsafeLast: () => unsafeLast,
  unzip: () => unzip2,
  zip: () => zip3,
  zipWith: () => zipWith5
});
var TypeId7 = Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence6 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value10, i) => isEquivalent(value10, unsafeGet4(that, i))));
var _equivalence4 = getEquivalence6(equals);
var ChunkProto = {
  [TypeId7]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol3](that) {
    return isChunk(that) && _equivalence4(this, that);
  },
  [symbol2]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk7 = Object.create(ChunkProto);
  chunk7.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk7.length = 0;
      chunk7.depth = 0;
      chunk7.left = chunk7;
      chunk7.right = chunk7;
      break;
    }
    case "IConcat": {
      chunk7.length = backing.left.length + backing.right.length;
      chunk7.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk7.left = backing.left;
      chunk7.right = backing.right;
      break;
    }
    case "IArray": {
      chunk7.length = backing.array.length;
      chunk7.depth = 0;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk7.length = 1;
      chunk7.depth = 0;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk7.length = backing.length;
      chunk7.depth = backing.chunk.depth + 1;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
  }
  return chunk7;
};
var isChunk = (u) => hasProperty(u, TypeId7);
var _empty2 = makeChunk({
  _tag: "IEmpty"
});
var empty7 = () => _empty2;
var make9 = (...as18) => unsafeFromNonEmptyArray(as18);
var of3 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable3 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable2(self));
var copyToArray = (self, array8, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy2(self.backing.array, 0, array8, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array8, initial);
      copyToArray(self.right, array8, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array8[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array8[j] = unsafeGet4(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray_ = (self) => toReadonlyArray(self).slice();
var toArray2 = toArray_;
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse2(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse3(self.backing.right),
        right: reverse3(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse2(toReadonlyArray(self)));
  }
};
var reverse3 = reverseChunk;
var get5 = dual(2, (self, index3) => index3 < 0 || index3 >= self.length ? none2() : some3(unsafeGet4(self, index3)));
var unsafeFromArray = (self) => self.length === 0 ? empty7() : self.length === 1 ? of3(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet4 = dual(2, (self, index3) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index3 !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index3 >= self.length || index3 < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index3];
    }
    case "IConcat": {
      return index3 < self.left.length ? unsafeGet4(self.left, index3) : unsafeGet4(self.right, index3 - self.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self.backing.chunk, index3 + self.backing.offset);
    }
  }
});
var append3 = dual(2, (self, a) => appendAll3(self, of3(a)));
var prepend3 = dual(2, (self, elem) => appendAll3(of3(elem), self));
var take3 = dual(2, (self, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          length: n,
          offset: self.backing.offset
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: take3(self.right, n - self.left.length)
          });
        }
        return take3(self.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop3 = dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty2;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop3(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop3(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var dropRight2 = dual(2, (self, n) => take3(self, Math.max(0, self.length - n)));
var dropWhile2 = dual(2, (self, predicate) => {
  const arr = toReadonlyArray(self);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop3(self, i);
});
var prependAll3 = dual(2, (self, that) => appendAll3(that, self));
var appendAll3 = dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff13 = that.depth - self.depth;
  if (Math.abs(diff13) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff13 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll3(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll3(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll3(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll3(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap5 = dual(2, (self, f2) => unsafeFromArray(filterMap4(self, f2)));
var filter5 = dual(2, (self, predicate) => unsafeFromArray(filter4(self, predicate)));
var filterMapWhile3 = dual(2, (self, f2) => unsafeFromArray(filterMapWhile2(self, f2)));
var compact = (self) => filterMap5(self, identity);
var flatMap5 = dual(2, (self, f2) => {
  if (self.backing._tag === "ISingleton") {
    return f2(self.backing.a, 0);
  }
  let out = _empty2;
  let i = 0;
  for (const k of self) {
    out = appendAll3(out, f2(k, i++));
  }
  return out;
});
var forEach3 = dual(2, (self, f2) => toReadonlyArray(self).forEach(f2));
var flatten5 = flatMap5(identity);
var chunksOf3 = dual(2, (self, n) => {
  const gr = [];
  let current2 = [];
  toReadonlyArray(self).forEach((a) => {
    current2.push(a);
    if (current2.length >= n) {
      gr.push(unsafeFromArray(current2));
      current2 = [];
    }
  });
  if (current2.length > 0) {
    gr.push(unsafeFromArray(current2));
  }
  return unsafeFromArray(gr);
});
var intersection4 = dual(2, (self, that) => unsafeFromArray(intersection2(toReadonlyArray(self), toReadonlyArray(that))));
var isEmpty2 = (self) => self.length === 0;
var isNonEmpty2 = (self) => self.length > 0;
var head3 = get5(0);
var unsafeHead2 = (self) => unsafeGet4(self, 0);
var headNonEmpty2 = unsafeHead2;
var last2 = (self) => get5(self, self.length - 1);
var unsafeLast = (self) => unsafeGet4(self, self.length - 1);
var lastNonEmpty2 = unsafeLast;
var map7 = dual(2, (self, f2) => self.backing._tag === "ISingleton" ? of3(f2(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map6((a, i) => f2(a, i)))));
var mapAccum2 = dual(3, (self, s, f2) => {
  const [s1, as18] = mapAccum(self, s, f2);
  return [s1, unsafeFromArray(as18)];
});
var partition3 = dual(2, (self, predicate) => pipe(partition2(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var partitionMap4 = dual(2, (self, f2) => pipe(partitionMap3(toReadonlyArray(self), f2), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var separate3 = (self) => pipe(separate2(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);
var size6 = (self) => self.length;
var sort2 = dual(2, (self, O) => unsafeFromArray(sort(toReadonlyArray(self), O)));
var sortWith2 = dual(3, (self, f2, order) => sort2(self, mapInput3(order, f2)));
var splitAt2 = dual(2, (self, n) => [take3(self, n), drop3(self, n)]);
var splitNonEmptyAt2 = dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [self, empty7()] : [take3(self, _n), drop3(self, _n)];
});
var split2 = dual(2, (self, n) => chunksOf3(self, Math.ceil(self.length / Math.floor(n))));
var splitWhere2 = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self, i);
});
var tail2 = (self) => self.length > 0 ? some3(drop3(self, 1)) : none2();
var tailNonEmpty2 = (self) => drop3(self, 1);
var takeRight2 = dual(2, (self, n) => drop3(self, self.length - n));
var takeWhile3 = dual(2, (self, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var union3 = dual(2, (self, that) => unsafeFromArray(union2(toReadonlyArray(self), toReadonlyArray(that))));
var dedupe2 = (self) => unsafeFromArray(dedupe(toReadonlyArray(self)));
var dedupeAdjacent3 = (self) => unsafeFromArray(dedupeAdjacent2(self));
var unzip2 = (self) => {
  const [left3, right3] = unzip(self);
  return [unsafeFromArray(left3), unsafeFromArray(right3)];
};
var zipWith5 = dual(3, (self, that, f2) => unsafeFromArray(zipWith4(self, that, f2)));
var zip3 = dual(2, (self, that) => zipWith5(self, that, (a, b) => [a, b]));
var remove3 = dual(2, (self, i) => {
  if (i < 0 || i >= self.length) return self;
  return unsafeFromArray(remove2(toReadonlyArray(self), i));
});
var removeOption2 = dual(2, (self, i) => {
  if (i < 0 || i >= self.length) return none2();
  return some3(unsafeFromArray(remove2(toReadonlyArray(self), i)));
});
var modifyOption3 = dual(3, (self, i, f2) => {
  if (i < 0 || i >= self.length) return none2();
  return some3(unsafeFromArray(modify2(toReadonlyArray(self), i, f2)));
});
var modify3 = dual(3, (self, i, f2) => getOrElse2(modifyOption3(self, i, f2), () => self));
var replace3 = dual(3, (self, i, b) => modify3(self, i, () => b));
var replaceOption3 = dual(3, (self, i, b) => modifyOption3(self, i, () => b));
var makeBy3 = dual(2, (n, f2) => fromIterable3(makeBy2(n, f2)));
var range3 = (start5, end7) => start5 <= end7 ? makeBy3(end7 - start5 + 1, (i) => start5 + i) : of3(start5);
var contains4 = contains3;
var containsWith4 = containsWith3;
var findFirst4 = findFirst3;
var findFirstIndex2 = findFirstIndex;
var findLast3 = findLast2;
var findLastIndex2 = findLastIndex;
var every5 = dual(2, (self, refinement) => fromIterable2(self).every(refinement));
var some8 = dual(2, (self, predicate) => fromIterable2(self).some(predicate));
var join2 = join;
var reduce4 = reduce3;
var reduceRight2 = reduceRight;
var differenceWith2 = (isEquivalent) => {
  return dual(2, (self, that) => unsafeFromArray(differenceWith(isEquivalent)(that, self)));
};
var difference3 = dual(2, (self, that) => unsafeFromArray(difference2(that, self)));

// node_modules/effect/dist/esm/Duration.js
var Duration_exports = {};
__export(Duration_exports, {
  Equivalence: () => Equivalence5,
  Order: () => Order5,
  between: () => between5,
  clamp: () => clamp6,
  days: () => days,
  decode: () => decode,
  decodeUnknown: () => decodeUnknown,
  divide: () => divide4,
  equals: () => equals4,
  format: () => format3,
  formatIso: () => formatIso,
  fromIso: () => fromIso,
  greaterThan: () => greaterThan5,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo5,
  hours: () => hours,
  infinity: () => infinity,
  isDuration: () => isDuration,
  isFinite: () => isFinite,
  isZero: () => isZero2,
  lessThan: () => lessThan5,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  match: () => match5,
  matchWith: () => matchWith,
  max: () => max6,
  micros: () => micros,
  millis: () => millis,
  min: () => min6,
  minutes: () => minutes,
  nanos: () => nanos,
  parts: () => parts,
  seconds: () => seconds,
  subtract: () => subtract4,
  sum: () => sum4,
  times: () => times,
  toDays: () => toDays,
  toHours: () => toHours,
  toHrTime: () => toHrTime,
  toMillis: () => toMillis,
  toMinutes: () => toMinutes,
  toNanos: () => toNanos,
  toSeconds: () => toSeconds,
  toWeeks: () => toWeeks,
  unsafeDivide: () => unsafeDivide4,
  unsafeFormatIso: () => unsafeFormatIso,
  unsafeToNanos: () => unsafeToNanos,
  weeks: () => weeks,
  zero: () => zero2
});
var TypeId8 = Symbol.for("effect/Duration");
var bigint03 = BigInt(0);
var bigint24 = BigInt(24);
var bigint60 = BigInt(60);
var bigint1e3 = BigInt(1e3);
var bigint1e6 = BigInt(1e6);
var bigint1e9 = BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero2;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match43 = DURATION_REGEX.exec(input);
    if (match43) {
      const [_, valueStr, unit] = match43;
      const value10 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value10);
        case "second":
        case "seconds":
          return seconds(value10);
        case "minute":
        case "minutes":
          return minutes(value10);
        case "hour":
        case "hours":
          return hours(value10);
        case "day":
        case "days":
          return days(value10);
        case "week":
        case "weeks":
          return weeks(value10);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var decodeUnknown = liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId8]: TypeId8,
  [symbol2]() {
    return cached(this, structure(this.value));
  },
  [symbol3](that) {
    return isDuration(that) && equals4(this, that);
  },
  toString() {
    return `Duration(${format3(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make10 = (input) => {
  const duration5 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration5.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration5.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration5.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration5.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint03) {
    duration5.value = zeroValue;
  } else {
    duration5.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration5;
};
var isDuration = (u) => hasProperty(u, TypeId8);
var isFinite = (self) => self.value._tag !== "Infinity";
var isZero2 = (self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint03;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero2 = make10(0);
var infinity = make10(Infinity);
var nanos = (nanos2) => make10(nanos2);
var micros = (micros2) => make10(micros2 * bigint1e3);
var millis = (millis2) => make10(millis2);
var seconds = (seconds2) => make10(seconds2 * 1e3);
var minutes = (minutes2) => make10(minutes2 * 6e4);
var hours = (hours2) => make10(hours2 * 36e5);
var days = (days2) => make10(days2 * 864e5);
var weeks = (weeks2) => make10(weeks2 * 6048e5);
var toMillis = (self) => match5(self, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var toSeconds = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 1e3,
  onNanos: (nanos2) => Number(nanos2) / 1e9
});
var toMinutes = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 6e4,
  onNanos: (nanos2) => Number(nanos2) / 6e10
});
var toHours = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 36e5,
  onNanos: (nanos2) => Number(nanos2) / 36e11
});
var toDays = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 864e5,
  onNanos: (nanos2) => Number(nanos2) / 864e11
});
var toWeeks = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 6048e5,
  onNanos: (nanos2) => Number(nanos2) / 6048e11
});
var toNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some3(_self.value.nanos);
    case "Millis":
      return some3(BigInt(Math.round(_self.value.millis * 1e6)));
  }
};
var unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
};
var match5 = dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Order5 = make2((self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0,
  onNanos: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0
}));
var between5 = between(mapInput3(Order5, decode));
var Equivalence5 = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
});
var _min = min(Order5);
var min6 = dual(2, (self, that) => _min(decode(self), decode(that)));
var _max = max(Order5);
var max6 = dual(2, (self, that) => _max(decode(self), decode(that)));
var _clamp = clamp(Order5);
var clamp6 = dual(2, (self, options) => _clamp(decode(self), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
var divide4 = dual(2, (self, by) => match5(self, {
  onMillis: (millis2) => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return none2();
    }
    return some3(make10(millis2 / by));
  },
  onNanos: (nanos2) => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return none2();
    }
    try {
      return some3(make10(nanos2 / BigInt(by)));
    } catch {
      return none2();
    }
  }
}));
var unsafeDivide4 = dual(2, (self, by) => match5(self, {
  onMillis: (millis2) => make10(millis2 / by),
  onNanos: (nanos2) => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero2;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make10(nanos2 / BigInt(by));
  }
}));
var times = dual(2, (self, times2) => match5(self, {
  onMillis: (millis2) => make10(millis2 * times2),
  onNanos: (nanos2) => make10(nanos2 * BigInt(times2))
}));
var subtract4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make10(self2 - that2),
  onNanos: (self2, that2) => make10(self2 - that2)
}));
var sum4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make10(self2 + that2),
  onNanos: (self2, that2) => make10(self2 + that2)
}));
var lessThan5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2,
  onNanos: (self2, that2) => self2 < that2
}));
var lessThanOrEqualTo5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 <= that2,
  onNanos: (self2, that2) => self2 <= that2
}));
var greaterThan5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 > that2,
  onNanos: (self2, that2) => self2 > that2
}));
var greaterThanOrEqualTo5 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 >= that2,
  onNanos: (self2, that2) => self2 >= that2
}));
var equals4 = dual(2, (self, that) => Equivalence5(decode(self), decode(that)));
var parts = (self) => {
  const duration5 = decode(self);
  if (duration5.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration5);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min11 = sec / bigint60;
  const hr = min11 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min11 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format3 = (self) => {
  const duration5 = decode(self);
  if (duration5.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero2(duration5)) {
    return "0";
  }
  const fragments = parts(duration5);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};
var unsafeFormatIso = (self) => {
  const duration5 = decode(self);
  if (!isFinite(duration5)) {
    throw new RangeError("Cannot format infinite duration");
  }
  const fragments = [];
  const {
    days: days2,
    hours: hours2,
    millis: millis2,
    minutes: minutes2,
    nanos: nanos2,
    seconds: seconds2
  } = parts(duration5);
  let rest = days2;
  if (rest >= 365) {
    const years = Math.floor(rest / 365);
    rest %= 365;
    fragments.push(`${years}Y`);
  }
  if (rest >= 30) {
    const months = Math.floor(rest / 30);
    rest %= 30;
    fragments.push(`${months}M`);
  }
  if (rest >= 7) {
    const weeks2 = Math.floor(rest / 7);
    rest %= 7;
    fragments.push(`${weeks2}W`);
  }
  if (rest > 0) {
    fragments.push(`${rest}D`);
  }
  if (hours2 !== 0 || minutes2 !== 0 || seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
    fragments.push("T");
    if (hours2 !== 0) {
      fragments.push(`${hours2}H`);
    }
    if (minutes2 !== 0) {
      fragments.push(`${minutes2}M`);
    }
    if (seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
      const total = BigInt(seconds2) * bigint1e9 + BigInt(millis2) * bigint1e6 + BigInt(nanos2);
      const str = (Number(total) / 1e9).toFixed(9).replace(/\.?0+$/, "");
      fragments.push(`${str}S`);
    }
  }
  return `P${fragments.join("") || "T0S"}`;
};
var formatIso = (self) => {
  const duration5 = decode(self);
  return isFinite(duration5) ? some3(unsafeFormatIso(duration5)) : none2();
};
var fromIso = (iso) => {
  const result = DURATION_ISO_REGEX.exec(iso);
  if (result == null) {
    return none2();
  }
  const [years, months, weeks2, days2, hours2, mins, secs] = result.slice(1, 8).map((_) => _ ? Number(_) : 0);
  const value10 = years * 365 * 24 * 60 * 60 + months * 30 * 24 * 60 * 60 + weeks2 * 7 * 24 * 60 * 60 + days2 * 24 * 60 * 60 + hours2 * 60 * 60 + mins * 60 + secs;
  return some3(seconds(value10));
};
var DURATION_ISO_REGEX = /^P(?!$)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?!$)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

// node_modules/effect/dist/esm/FiberId.js
var FiberId_exports = {};
__export(FiberId_exports, {
  FiberIdTypeId: () => FiberIdTypeId2,
  combine: () => combine5,
  combineAll: () => combineAll4,
  composite: () => composite2,
  getOrElse: () => getOrElse6,
  ids: () => ids2,
  isComposite: () => isComposite2,
  isFiberId: () => isFiberId2,
  isNone: () => isNone4,
  isRuntime: () => isRuntime2,
  make: () => make17,
  none: () => none4,
  runtime: () => runtime2,
  threadName: () => threadName2,
  toOption: () => toOption2,
  toSet: () => toSet2,
  unsafeMake: () => unsafeMake3
});

// node_modules/effect/dist/esm/HashSet.js
var HashSet_exports = {};
__export(HashSet_exports, {
  add: () => add5,
  beginMutation: () => beginMutation3,
  difference: () => difference5,
  empty: () => empty10,
  endMutation: () => endMutation3,
  every: () => every8,
  filter: () => filter8,
  flatMap: () => flatMap8,
  forEach: () => forEach6,
  fromIterable: () => fromIterable6,
  has: () => has4,
  intersection: () => intersection6,
  isHashSet: () => isHashSet2,
  isSubset: () => isSubset2,
  make: () => make14,
  map: () => map10,
  mutate: () => mutate3,
  partition: () => partition5,
  reduce: () => reduce7,
  remove: () => remove6,
  size: () => size9,
  some: () => some11,
  toValues: () => toValues,
  toggle: () => toggle2,
  union: () => union6,
  values: () => values4
});

// node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = Math.pow(2, SIZE);
var MASK2 = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift2, h2) {
  return h2 >>> shift2 & MASK2;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/effect/dist/esm/internal/stack.js
var make11 = (value10, previous2) => ({
  value: value10,
  previous: previous2
});

// node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate7, at5, v, arr) {
  let out = arr;
  if (!mutate7) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at5] = v;
  return out;
}
function arraySpliceOut(mutate7, at5, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate7) {
    i = g = at5;
  } else {
    out = new Array(newLen);
    while (i < at5) out[g++] = arr[i++];
  }
  ;
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate7) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate7, at5, v, arr) {
  const len = arr.length;
  if (mutate7) {
    let i2 = len;
    while (i2 >= at5) arr[i2--] = arr[i2];
    arr[at5] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at5) out[g++] = arr[i++];
  out[at5] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}

// node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  constructor() {
    __publicField(this, "_tag", "EmptyNode");
  }
  modify(edit, _shift, f2, hash11, key, size45) {
    const v = f2(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size45.value;
    return new LeafNode(edit, hash11, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  constructor(edit, hash11, key, value10) {
    __publicField(this, "edit");
    __publicField(this, "hash");
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, "_tag", "LeafNode");
    this.edit = edit;
    this.hash = hash11;
    this.key = key;
    this.value = value10;
  }
  modify(edit, shift2, f2, hash11, key, size45) {
    if (equals(key, this.key)) {
      const v2 = f2(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        ;
        --size45.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash11, key, v2);
    }
    const v = f2(none2());
    if (isNone2(v)) return this;
    ++size45.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash11, new _LeafNode(edit, hash11, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  constructor(edit, hash11, children3) {
    __publicField(this, "edit");
    __publicField(this, "hash");
    __publicField(this, "children");
    __publicField(this, "_tag", "CollisionNode");
    this.edit = edit;
    this.hash = hash11;
    this.children = children3;
  }
  modify(edit, shift2, f2, hash11, key, size45) {
    if (hash11 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f2, key, size45);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f2(none2());
    if (isNone2(v)) return this;
    ++size45.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash11, new LeafNode(edit, hash11, key, v));
  }
  updateCollisionList(mutate7, edit, hash11, list, f2, key, size45) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value10 = child.value;
        const newValue2 = f2(value10);
        if (newValue2 === value10) return list;
        if (isNone2(newValue2)) {
          ;
          --size45.value;
          return arraySpliceOut(mutate7, i, list);
        }
        return arrayUpdate(mutate7, i, new LeafNode(edit, hash11, key, newValue2), list);
      }
    }
    const newValue = f2(none2());
    if (isNone2(newValue)) return list;
    ++size45.value;
    return arrayUpdate(mutate7, len, new LeafNode(edit, hash11, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  constructor(edit, mask, children3) {
    __publicField(this, "edit");
    __publicField(this, "mask");
    __publicField(this, "children");
    __publicField(this, "_tag", "IndexedNode");
    this.edit = edit;
    this.mask = mask;
    this.children = children3;
  }
  modify(edit, shift2, f2, hash11, key, size45) {
    const mask = this.mask;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash11);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists7 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists7) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f2, hash11, key, size45);
      if (!_newChild) return this;
      return children3.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children3) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children3));
    }
    const current2 = children3[indx];
    const child = current2.modify(edit, shift2 + SIZE, f2, hash11, key, size45);
    if (current2 === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children3.length <= 2 && isLeafNode(children3[indx ^ 1])) {
        return children3[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children3);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children3);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  constructor(edit, size45, children3) {
    __publicField(this, "edit");
    __publicField(this, "size");
    __publicField(this, "children");
    __publicField(this, "_tag", "ArrayNode");
    this.edit = edit;
    this.size = size45;
    this.children = children3;
  }
  modify(edit, shift2, f2, hash11, key, size45) {
    let count9 = this.size;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash11);
    const child = children3[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f2, hash11, key, size45);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ;
      ++count9;
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      ;
      --count9;
      if (count9 <= MIN_ARRAY_NODE) {
        return pack(edit, count9, frag, children3);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children3);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    }
    if (canEdit) {
      this.size = count9;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count9, newChildren);
  }
};
function pack(edit, count9, removed, elements) {
  const children3 = new Array(count9 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children3[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children3);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count9 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count9++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count9 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children3 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children3);
  }
}
function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make11(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol2]() {
    let hash11 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash11 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash11);
  },
  [symbol3](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size45) => {
  const map49 = Object.create(HashMapProto);
  map49._editable = editable;
  map49._edit = edit;
  map49._root = root;
  map49._size = size45;
  return map49;
};
var HashMapIterator = class _HashMapIterator {
  constructor(map49, f2) {
    __publicField(this, "map");
    __publicField(this, "f");
    __publicField(this, "v");
    this.map = map49;
    this.f = f2;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f2, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some3({
          value: f2(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children3 = node.children;
      return visitLazyChildren(children3.length, children3, 0, f2, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children3, i, f2, cont) => {
  while (i < len) {
    const child = children3[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f2, [len, children3, i, f2, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = makeImpl(false, 0, new EmptyNode(), 0);
var empty8 = () => _empty3;
var make12 = (...entries6) => fromIterable4(entries6);
var fromIterable4 = (entries6) => {
  const map49 = beginMutation(empty8());
  for (const entry of entries6) {
    set2(map49, entry[0], entry[1]);
  }
  return endMutation(map49);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty3 = (self) => self && isEmptyNode(self._root);
var get6 = dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = dual(3, (self, key, hash11) => {
  let node = self._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash11 === node.hash) {
          const children3 = node.children;
          for (let i = 0, len = children3.length; i < len; ++i) {
            const child = children3[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash11);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash11)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var unsafeGet5 = dual(2, (self, key) => {
  const element2 = getHash(self, key, hash(key));
  if (isNone2(element2)) {
    throw new Error("Expected map to contain key");
  }
  return element2.value;
});
var has2 = dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
var hasHash = dual(3, (self, key, hash11) => isSome2(getHash(self, key, hash11)));
var hasBy = dual(2, (self, predicate) => isSome2(findFirst5(self, predicate)));
var set2 = dual(3, (self, key, value10) => modifyAt(self, key, () => some3(value10)));
var setTree = dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys2 = (self) => new HashMapIterator(self, (key) => key);
var values2 = (self) => new HashMapIterator(self, (_, value10) => value10);
var entries = (self) => new HashMapIterator(self, (key, value10) => [key, value10]);
var size7 = (self) => self._size;
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var endMutation = (self) => {
  ;
  self._editable = false;
  return self;
};
var mutate = dual(2, (self, f2) => {
  const transient = beginMutation(self);
  f2(transient);
  return endMutation(transient);
});
var modifyAt = dual(3, (self, key, f2) => modifyHash(self, key, hash(key), f2));
var modifyHash = dual(4, (self, key, hash11, f2) => {
  const size45 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f2, hash11, key, size45);
  return pipe(self, setTree(newRoot, size45.value));
});
var modify4 = dual(3, (self, key, f2) => modifyAt(self, key, map2(f2)));
var union4 = dual(2, (self, that) => {
  const result = beginMutation(self);
  forEach4(that, (v, k) => set2(result, k, v));
  return endMutation(result);
});
var remove4 = dual(2, (self, key) => modifyAt(self, key, none2));
var removeMany = dual(2, (self, keys15) => mutate(self, (map49) => {
  for (const key of keys15) {
    remove4(key)(map49);
  }
}));
var map8 = dual(2, (self, f2) => reduce5(self, empty8(), (map49, value10, key) => set2(map49, key, f2(value10, key))));
var flatMap6 = dual(2, (self, f2) => reduce5(self, empty8(), (zero3, value10, key) => mutate(zero3, (map49) => forEach4(f2(value10, key), (value11, key2) => set2(map49, key2, value11)))));
var forEach4 = dual(2, (self, f2) => reduce5(self, void 0, (_, value10, key) => f2(value10, key)));
var reduce5 = dual(3, (self, zero3, f2) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f2(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children3;
  while (children3 = toVisit.pop()) {
    for (let i = 0, len = children3.length; i < len; ) {
      const child = children3[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f2(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});
var filter6 = dual(2, (self, f2) => mutate(empty8(), (map49) => {
  for (const [k, a] of self) {
    if (f2(a, k)) {
      set2(map49, k, a);
    }
  }
}));
var compact2 = (self) => filterMap6(self, identity);
var filterMap6 = dual(2, (self, f2) => mutate(empty8(), (map49) => {
  for (const [k, a] of self) {
    const option11 = f2(a, k);
    if (isSome2(option11)) {
      set2(map49, k, option11.value);
    }
  }
}));
var findFirst5 = dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return some3(ka);
    }
  }
  return none2();
});
var some9 = dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return true;
    }
  }
  return false;
});
var every6 = dual(2, (self, predicate) => !some9(self, (a, k) => !predicate(a, k)));

// node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol2]() {
    return cached(this, combine2(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol3](that) {
    if (isHashSet(that)) {
      return size7(this._keyMap) === size7(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set26 = Object.create(HashSetProto);
  set26._keyMap = keyMap;
  return set26;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = makeImpl2(empty8());
var empty9 = () => _empty4;
var fromIterable5 = (elements) => {
  const set26 = beginMutation2(empty9());
  for (const value10 of elements) {
    add4(set26, value10);
  }
  return endMutation2(set26);
};
var make13 = (...elements) => {
  const set26 = beginMutation2(empty9());
  for (const value10 of elements) {
    add4(set26, value10);
  }
  return endMutation2(set26);
};
var has3 = dual(2, (self, value10) => has2(self._keyMap, value10));
var some10 = dual(2, (self, f2) => {
  let found = false;
  for (const value10 of self) {
    found = f2(value10);
    if (found) {
      break;
    }
  }
  return found;
});
var every7 = dual(2, (self, refinement) => !some10(self, (a) => !refinement(a)));
var isSubset = dual(2, (self, that) => every7(self, (value10) => has3(that, value10)));
var values3 = (self) => keys2(self._keyMap);
var size8 = (self) => size7(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation2 = (self) => {
  ;
  self._keyMap._editable = false;
  return self;
};
var mutate2 = dual(2, (self, f2) => {
  const transient = beginMutation2(self);
  f2(transient);
  return endMutation2(transient);
});
var add4 = dual(2, (self, value10) => self._keyMap._editable ? (set2(value10, true)(self._keyMap), self) : makeImpl2(set2(value10, true)(self._keyMap)));
var remove5 = dual(2, (self, value10) => self._keyMap._editable ? (remove4(value10)(self._keyMap), self) : makeImpl2(remove4(value10)(self._keyMap)));
var difference4 = dual(2, (self, that) => mutate2(self, (set26) => {
  for (const value10 of that) {
    remove5(set26, value10);
  }
}));
var intersection5 = dual(2, (self, that) => mutate2(empty9(), (set26) => {
  for (const value10 of that) {
    if (has3(value10)(self)) {
      add4(value10)(set26);
    }
  }
}));
var union5 = dual(2, (self, that) => mutate2(empty9(), (set26) => {
  forEach5(self, (value10) => add4(set26, value10));
  for (const value10 of that) {
    add4(set26, value10);
  }
}));
var toggle = dual(2, (self, value10) => has3(self, value10) ? remove5(self, value10) : add4(self, value10));
var map9 = dual(2, (self, f2) => mutate2(empty9(), (set26) => {
  forEach5(self, (a) => {
    const b = f2(a);
    if (!has3(set26, b)) {
      add4(set26, b);
    }
  });
}));
var flatMap7 = dual(2, (self, f2) => mutate2(empty9(), (set26) => {
  forEach5(self, (a) => {
    for (const b of f2(a)) {
      if (!has3(set26, b)) {
        add4(set26, b);
      }
    }
  });
}));
var forEach5 = dual(2, (self, f2) => forEach4(self._keyMap, (_, k) => f2(k)));
var reduce6 = dual(3, (self, zero3, f2) => reduce5(self._keyMap, zero3, (z, _, a) => f2(z, a)));
var filter7 = dual(2, (self, f2) => {
  return mutate2(empty9(), (set26) => {
    const iterator = values3(self);
    let next6;
    while (!(next6 = iterator.next()).done) {
      const value10 = next6.value;
      if (f2(value10)) {
        add4(set26, value10);
      }
    }
  });
});
var partition4 = dual(2, (self, predicate) => {
  const iterator = values3(self);
  let next6;
  const right3 = beginMutation2(empty9());
  const left3 = beginMutation2(empty9());
  while (!(next6 = iterator.next()).done) {
    const value10 = next6.value;
    if (predicate(value10)) {
      add4(right3, value10);
    } else {
      add4(left3, value10);
    }
  }
  return [endMutation2(left3), endMutation2(right3)];
});

// node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty10 = empty9;
var fromIterable6 = fromIterable5;
var make14 = make13;
var has4 = has3;
var some11 = some10;
var every8 = every7;
var isSubset2 = isSubset;
var values4 = values3;
var toValues = (self) => Array.from(values4(self));
var size9 = size8;
var beginMutation3 = beginMutation2;
var endMutation3 = endMutation2;
var mutate3 = mutate2;
var add5 = add4;
var remove6 = remove5;
var difference5 = difference4;
var intersection6 = intersection5;
var union6 = union5;
var toggle2 = toggle;
var map10 = map9;
var flatMap8 = flatMap7;
var forEach6 = forEach5;
var reduce7 = reduce6;
var filter8 = filter7;
var partition5 = partition4;

// node_modules/effect/dist/esm/MutableRef.js
var MutableRef_exports = {};
__export(MutableRef_exports, {
  compareAndSet: () => compareAndSet,
  decrement: () => decrement3,
  decrementAndGet: () => decrementAndGet,
  get: () => get7,
  getAndDecrement: () => getAndDecrement,
  getAndIncrement: () => getAndIncrement,
  getAndSet: () => getAndSet,
  getAndUpdate: () => getAndUpdate,
  increment: () => increment3,
  incrementAndGet: () => incrementAndGet,
  make: () => make15,
  set: () => set3,
  setAndGet: () => setAndGet,
  toggle: () => toggle3,
  update: () => update,
  updateAndGet: () => updateAndGet
});
var TypeId9 = Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId9]: TypeId9,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make15 = (value10) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value10;
  return ref;
};
var compareAndSet = dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var decrement3 = (self) => update(self, (n) => n - 1);
var decrementAndGet = (self) => updateAndGet(self, (n) => n - 1);
var get7 = (self) => self.current;
var getAndDecrement = (self) => getAndUpdate(self, (n) => n - 1);
var getAndIncrement = (self) => getAndUpdate(self, (n) => n + 1);
var getAndSet = dual(2, (self, value10) => {
  const ret = self.current;
  self.current = value10;
  return ret;
});
var getAndUpdate = dual(2, (self, f2) => getAndSet(self, f2(get7(self))));
var increment3 = (self) => update(self, (n) => n + 1);
var incrementAndGet = (self) => updateAndGet(self, (n) => n + 1);
var set3 = dual(2, (self, value10) => {
  self.current = value10;
  return self;
});
var setAndGet = dual(2, (self, value10) => {
  self.current = value10;
  return self.current;
});
var update = dual(2, (self, f2) => set3(self, f2(get7(self))));
var updateAndGet = dual(2, (self, f2) => setAndGet(self, f2(get7(self))));
var toggle3 = (self) => update(self, (_) => !_);

// node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = string2(`${FiberIdSymbolKey}-${OP_NONE}`);
var _a3;
var None = class {
  constructor() {
    __publicField(this, _a3, FiberIdTypeId);
    __publicField(this, "_tag", OP_NONE);
    __publicField(this, "id", -1);
    __publicField(this, "startTimeMillis", -1);
  }
  [(_a3 = FiberIdTypeId, symbol2)]() {
    return emptyHash;
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var _a4;
var Runtime = class {
  constructor(id3, startTimeMillis) {
    __publicField(this, "id");
    __publicField(this, "startTimeMillis");
    __publicField(this, _a4, FiberIdTypeId);
    __publicField(this, "_tag", OP_RUNTIME);
    this.id = id3;
    this.startTimeMillis = startTimeMillis;
  }
  [(_a4 = FiberIdTypeId, symbol2)]() {
    return cached(this, string2(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var _a5;
var Composite = class {
  constructor(left3, right3) {
    __publicField(this, "left");
    __publicField(this, "right");
    __publicField(this, _a5, FiberIdTypeId);
    __publicField(this, "_tag", OP_COMPOSITE);
    __publicField(this, "_hash");
    this.left = left3;
    this.right = right3;
  }
  [(_a5 = FiberIdTypeId, symbol2)]() {
    return pipe(string2(`${FiberIdSymbolKey}-${this._tag}`), combine2(hash(this.left)), combine2(hash(this.right)), cached(this));
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = new None();
var runtime = (id3, startTimeMillis) => {
  return new Runtime(id3, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
var isNone3 = (self) => {
  return self._tag === OP_NONE || pipe(toSet(self), every8((id3) => isNone3(id3)));
};
var isRuntime = (self) => {
  return self._tag === OP_RUNTIME;
};
var isComposite = (self) => {
  return self._tag === OP_COMPOSITE;
};
var combine4 = dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var combineAll3 = (fiberIds) => {
  return pipe(fiberIds, reduce7(none3, (a, b) => combine4(b)(a)));
};
var getOrElse5 = dual(2, (self, that) => isNone3(self) ? that : self);
var ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty10();
    }
    case OP_RUNTIME: {
      return make14(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union6(ids(self.right)));
    }
  }
};
var _fiberCounter = globalValue(Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make15(0));
var make16 = (id3, startTimeSeconds) => {
  return new Runtime(id3, startTimeSeconds);
};
var threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var toOption = (self) => {
  const fiberIds = toSet(self);
  if (size9(fiberIds) === 0) {
    return none2();
  }
  let first5 = true;
  let acc;
  for (const fiberId5 of fiberIds) {
    if (first5) {
      acc = fiberId5;
      first5 = false;
    } else {
      acc = pipe(acc, combine4(fiberId5));
    }
  }
  return some3(acc);
};
var toSet = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty10();
    }
    case OP_RUNTIME: {
      return make14(self);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self.left), union6(toSet(self.right)));
    }
  }
};
var unsafeMake2 = () => {
  const id3 = get7(_fiberCounter);
  pipe(_fiberCounter, set3(id3 + 1));
  return new Runtime(id3, Date.now());
};

// node_modules/effect/dist/esm/FiberId.js
var FiberIdTypeId2 = FiberIdTypeId;
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var isNone4 = isNone3;
var isRuntime2 = isRuntime;
var isComposite2 = isComposite;
var combine5 = combine4;
var combineAll4 = combineAll3;
var getOrElse6 = getOrElse5;
var ids2 = ids;
var make17 = make16;
var threadName2 = threadName;
var toOption2 = toOption;
var toSet2 = toSet;
var unsafeMake3 = unsafeMake2;

// node_modules/effect/dist/esm/HashMap.js
var HashMap_exports = {};
__export(HashMap_exports, {
  beginMutation: () => beginMutation4,
  compact: () => compact3,
  empty: () => empty11,
  endMutation: () => endMutation4,
  entries: () => entries2,
  every: () => every9,
  filter: () => filter9,
  filterMap: () => filterMap7,
  findFirst: () => findFirst6,
  flatMap: () => flatMap9,
  forEach: () => forEach7,
  fromIterable: () => fromIterable7,
  get: () => get8,
  getHash: () => getHash2,
  has: () => has5,
  hasBy: () => hasBy2,
  hasHash: () => hasHash2,
  isEmpty: () => isEmpty4,
  isHashMap: () => isHashMap2,
  keySet: () => keySet2,
  keys: () => keys3,
  make: () => make18,
  map: () => map11,
  modify: () => modify5,
  modifyAt: () => modifyAt2,
  modifyHash: () => modifyHash2,
  mutate: () => mutate4,
  reduce: () => reduce8,
  remove: () => remove7,
  removeMany: () => removeMany2,
  set: () => set4,
  size: () => size10,
  some: () => some12,
  toEntries: () => toEntries2,
  toValues: () => toValues2,
  union: () => union7,
  unsafeGet: () => unsafeGet6,
  values: () => values5
});

// node_modules/effect/dist/esm/internal/hashMap/keySet.js
function keySet(self) {
  return makeImpl2(self);
}

// node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty11 = empty8;
var make18 = make12;
var fromIterable7 = fromIterable4;
var isEmpty4 = isEmpty3;
var get8 = get6;
var getHash2 = getHash;
var unsafeGet6 = unsafeGet5;
var has5 = has2;
var hasHash2 = hasHash;
var hasBy2 = hasBy;
var set4 = set2;
var keys3 = keys2;
var keySet2 = keySet;
var values5 = values2;
var toValues2 = (self) => Array.from(values5(self));
var entries2 = entries;
var toEntries2 = (self) => Array.from(entries2(self));
var size10 = size7;
var beginMutation4 = beginMutation;
var endMutation4 = endMutation;
var mutate4 = mutate;
var modifyAt2 = modifyAt;
var modifyHash2 = modifyHash;
var modify5 = modify4;
var union7 = union4;
var remove7 = remove4;
var removeMany2 = removeMany;
var map11 = map8;
var flatMap9 = flatMap6;
var forEach7 = forEach4;
var reduce8 = reduce5;
var filter9 = filter6;
var compact3 = compact2;
var filterMap7 = filterMap6;
var findFirst6 = findFirst5;
var some12 = some9;
var every9 = every6;

// node_modules/effect/dist/esm/List.js
var List_exports = {};
__export(List_exports, {
  TypeId: () => TypeId10,
  append: () => append4,
  appendAll: () => appendAll4,
  compact: () => compact4,
  cons: () => cons,
  drop: () => drop4,
  empty: () => empty12,
  every: () => every10,
  filter: () => filter10,
  filterMap: () => filterMap8,
  findFirst: () => findFirst7,
  flatMap: () => flatMap10,
  forEach: () => forEach8,
  fromIterable: () => fromIterable8,
  getEquivalence: () => getEquivalence7,
  head: () => head4,
  isCons: () => isCons,
  isList: () => isList,
  isNil: () => isNil,
  last: () => last3,
  make: () => make19,
  map: () => map12,
  nil: () => nil,
  of: () => of4,
  partition: () => partition6,
  partitionMap: () => partitionMap5,
  prepend: () => prepend4,
  prependAll: () => prependAll4,
  prependAllReversed: () => prependAllReversed,
  reduce: () => reduce9,
  reduceRight: () => reduceRight3,
  reverse: () => reverse4,
  size: () => size11,
  some: () => some13,
  splitAt: () => splitAt3,
  tail: () => tail3,
  take: () => take4,
  toArray: () => toArray3,
  toChunk: () => toChunk,
  unsafeHead: () => unsafeHead3,
  unsafeLast: () => unsafeLast2,
  unsafeTail: () => unsafeTail
});
var TypeId10 = Symbol.for("effect/List");
var toArray3 = (self) => fromIterable2(self);
var getEquivalence7 = (isEquivalent) => mapInput(getEquivalence5(isEquivalent), toArray3);
var _equivalence5 = getEquivalence7(equals);
var ConsProto = {
  [TypeId10]: TypeId10,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol3](that) {
    return isList(that) && this._tag === that._tag && _equivalence5(this, that);
  },
  [symbol2]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done17 = false;
    let self = this;
    return {
      next() {
        if (done17) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done17 = true;
          return this.return();
        }
        const value10 = self.head;
        self = self.tail;
        return {
          done: done17,
          value: value10
        };
      },
      return(value10) {
        if (!done17) {
          done17 = true;
        }
        return {
          done: true,
          value: value10
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head13, tail5) => {
  const cons2 = Object.create(ConsProto);
  cons2.head = head13;
  cons2.tail = tail5;
  return cons2;
};
var NilHash = string2("Nil");
var NilProto = {
  [TypeId10]: TypeId10,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2]() {
    return NilHash;
  },
  [symbol3](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId10);
var isNil = (self) => self._tag === "Nil";
var isCons = (self) => self._tag === "Cons";
var size11 = (self) => {
  let these = self;
  let len = 0;
  while (!isNil(these)) {
    len += 1;
    these = these.tail;
  }
  return len;
};
var nil = () => _Nil;
var cons = (head13, tail5) => makeCons(head13, tail5);
var empty12 = nil;
var of4 = (value10) => makeCons(value10, _Nil);
var fromIterable8 = (prefix) => {
  const iterator = prefix[Symbol.iterator]();
  let next6;
  if ((next6 = iterator.next()) && !next6.done) {
    const result = makeCons(next6.value, _Nil);
    let curr = result;
    while ((next6 = iterator.next()) && !next6.done) {
      const temp = makeCons(next6.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
};
var make19 = (...elements) => fromIterable8(elements);
var append4 = dual(2, (self, element2) => appendAll4(self, of4(element2)));
var appendAll4 = dual(2, (self, that) => prependAll4(that, self));
var prepend4 = dual(2, (self, element2) => cons(element2, self));
var prependAll4 = dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var prependAllReversed = dual(2, (self, prefix) => {
  let out = self;
  let pres = prefix;
  while (isCons(pres)) {
    out = makeCons(pres.head, out);
    pres = pres.tail;
  }
  return out;
});
var drop4 = dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  }
  if (n >= size11(self)) {
    return _Nil;
  }
  let these = self;
  let i = 0;
  while (!isNil(these) && i < n) {
    these = these.tail;
    i += 1;
  }
  return these;
});
var every10 = dual(2, (self, refinement) => {
  for (const a of self) {
    if (!refinement(a)) {
      return false;
    }
  }
  return true;
});
var some13 = dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return true;
    }
    these = these.tail;
  }
  return false;
});
var filter10 = dual(2, (self, predicate) => noneIn(self, predicate, false));
var noneIn = (self, predicate, isFlipped) => {
  while (true) {
    if (isNil(self)) {
      return _Nil;
    } else {
      if (predicate(self.head) !== isFlipped) {
        return allIn(self, self.tail, predicate, isFlipped);
      } else {
        self = self.tail;
      }
    }
  }
};
var allIn = (start5, remaining, predicate, isFlipped) => {
  while (true) {
    if (isNil(remaining)) {
      return start5;
    } else {
      if (predicate(remaining.head) !== isFlipped) {
        remaining = remaining.tail;
      } else {
        return partialFill(start5, remaining, predicate, isFlipped);
      }
    }
  }
};
var partialFill = (origStart, firstMiss, predicate, isFlipped) => {
  const newHead = makeCons(unsafeHead3(origStart), _Nil);
  let toProcess = unsafeTail(origStart);
  let currentLast = newHead;
  while (!(toProcess === firstMiss)) {
    const newElem = makeCons(unsafeHead3(toProcess), _Nil);
    currentLast.tail = newElem;
    currentLast = unsafeCoerce(newElem);
    toProcess = unsafeCoerce(toProcess.tail);
  }
  let next6 = firstMiss.tail;
  let nextToCopy = unsafeCoerce(next6);
  while (!isNil(next6)) {
    const head13 = unsafeHead3(next6);
    if (predicate(head13) !== isFlipped) {
      next6 = next6.tail;
    } else {
      while (!(nextToCopy === next6)) {
        const newElem = makeCons(unsafeHead3(nextToCopy), _Nil);
        currentLast.tail = newElem;
        currentLast = newElem;
        nextToCopy = unsafeCoerce(nextToCopy.tail);
      }
      nextToCopy = unsafeCoerce(next6.tail);
      next6 = next6.tail;
    }
  }
  if (!isNil(nextToCopy)) {
    currentLast.tail = nextToCopy;
  }
  return newHead;
};
var filterMap8 = dual(2, (self, f2) => {
  const bs = [];
  for (const a of self) {
    const oa = f2(a);
    if (isSome2(oa)) {
      bs.push(oa.value);
    }
  }
  return fromIterable8(bs);
});
var compact4 = (self) => filterMap8(self, identity);
var findFirst7 = dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return some3(these.head);
    }
    these = these.tail;
  }
  return none2();
});
var flatMap10 = dual(2, (self, f2) => {
  let rest = self;
  let head13 = void 0;
  let tail5 = void 0;
  while (!isNil(rest)) {
    let bs = f2(rest.head);
    while (!isNil(bs)) {
      const next6 = makeCons(bs.head, _Nil);
      if (tail5 === void 0) {
        head13 = next6;
      } else {
        tail5.tail = next6;
      }
      tail5 = next6;
      bs = bs.tail;
    }
    rest = rest.tail;
  }
  if (head13 === void 0) {
    return _Nil;
  }
  return head13;
});
var forEach8 = dual(2, (self, f2) => {
  let these = self;
  while (!isNil(these)) {
    f2(these.head);
    these = these.tail;
  }
});
var head4 = (self) => isNil(self) ? none2() : some3(self.head);
var last3 = (self) => isNil(self) ? none2() : some3(unsafeLast2(self));
var map12 = dual(2, (self, f2) => {
  if (isNil(self)) {
    return self;
  } else {
    let i = 0;
    const head13 = makeCons(f2(self.head, i++), _Nil);
    let nextHead = head13;
    let rest = self.tail;
    while (!isNil(rest)) {
      const next6 = makeCons(f2(rest.head, i++), _Nil);
      nextHead.tail = next6;
      nextHead = next6;
      rest = rest.tail;
    }
    return head13;
  }
});
var partition6 = dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  for (const a of self) {
    if (predicate(a)) {
      right3.push(a);
    } else {
      left3.push(a);
    }
  }
  return [fromIterable8(left3), fromIterable8(right3)];
});
var partitionMap5 = dual(2, (self, f2) => {
  const left3 = [];
  const right3 = [];
  for (const a of self) {
    const e = f2(a);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [fromIterable8(left3), fromIterable8(right3)];
});
var reduce9 = dual(3, (self, zero3, f2) => {
  let acc = zero3;
  let these = self;
  while (!isNil(these)) {
    acc = f2(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reduceRight3 = dual(3, (self, zero3, f2) => {
  let acc = zero3;
  let these = reverse4(self);
  while (!isNil(these)) {
    acc = f2(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse4 = (self) => {
  let result = empty12();
  let these = self;
  while (!isNil(these)) {
    result = prepend4(result, these.head);
    these = these.tail;
  }
  return result;
};
var splitAt3 = dual(2, (self, n) => [take4(self, n), drop4(self, n)]);
var tail3 = (self) => isNil(self) ? none2() : some3(self.tail);
var take4 = dual(2, (self, n) => {
  if (n <= 0) {
    return _Nil;
  }
  if (n >= size11(self)) {
    return self;
  }
  let these = make19(unsafeHead3(self));
  let current2 = unsafeTail(self);
  for (let i = 1; i < n; i++) {
    these = makeCons(unsafeHead3(current2), these);
    current2 = unsafeTail(current2);
  }
  return reverse4(these);
});
var toChunk = (self) => fromIterable3(self);
var getExpectedListToBeNonEmptyErrorMessage = "Expected List to be non-empty";
var unsafeHead3 = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.head;
};
var unsafeLast2 = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  let these = self;
  let scout = self.tail;
  while (!isNil(scout)) {
    these = scout;
    scout = scout.tail;
  }
  return these.head;
};
var unsafeTail = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.tail;
};

// node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var RuntimeFlagsPatch_exports = {};
__export(RuntimeFlagsPatch_exports, {
  andThen: () => andThen4,
  both: () => both2,
  disable: () => disable3,
  disabledSet: () => disabledSet2,
  either: () => either2,
  empty: () => empty20,
  enable: () => enable3,
  enabledSet: () => enabledSet2,
  exclude: () => exclude2,
  includes: () => includes,
  inverse: () => inverse2,
  isActive: () => isActive2,
  isDisabled: () => isDisabled3,
  isEmpty: () => isEmpty6,
  isEnabled: () => isEnabled3,
  make: () => make23,
  render: () => render2
});

// node_modules/effect/dist/esm/internal/data.js
var ArrayProto = Object.assign(Object.create(Array.prototype), {
  [symbol2]() {
    return cached(this, array2(this));
  },
  [symbol3](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = function() {
  function Structural3(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural3.prototype = StructuralPrototype;
  return Structural3;
}();
var struct4 = (as18) => Object.assign(Object.create(StructuralPrototype), as18);

// node_modules/effect/dist/esm/internal/differ/chunkPatch.js
var ChunkPatchTypeId = Symbol.for("effect/DifferChunkPatch");
function variance(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
var EmptyProto = Object.assign(Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = Object.create(EmptyProto);
var empty13 = () => _empty5;
var AndThenProto = Object.assign(Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first5, second) => {
  const o = Object.create(AndThenProto);
  o.first = first5;
  o.second = second;
  return o;
};
var AppendProto = Object.assign(Object.create(PatchProto), {
  _tag: "Append"
});
var makeAppend = (values15) => {
  const o = Object.create(AppendProto);
  o.values = values15;
  return o;
};
var SliceProto = Object.assign(Object.create(PatchProto), {
  _tag: "Slice"
});
var makeSlice = (from29, until) => {
  const o = Object.create(SliceProto);
  o.from = from29;
  o.until = until;
  return o;
};
var UpdateProto = Object.assign(Object.create(PatchProto), {
  _tag: "Update"
});
var makeUpdate = (index3, patch14) => {
  const o = Object.create(UpdateProto);
  o.index = index3;
  o.patch = patch14;
  return o;
};
var diff = (options) => {
  let i = 0;
  let patch14 = empty13();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = unsafeGet4(i)(options.oldValue);
    const newElement = unsafeGet4(i)(options.newValue);
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch14 = pipe(patch14, combine6(makeUpdate(i, valuePatch)));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch14 = pipe(patch14, combine6(makeSlice(0, i)));
  }
  if (i < options.newValue.length) {
    patch14 = pipe(patch14, combine6(makeAppend(drop3(i)(options.newValue))));
  }
  return patch14;
};
var combine6 = dual(2, (self, that) => makeAndThen(self, that));
var patch = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let chunk7 = oldValue;
  let patches = of3(self);
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(head13.first)(prepend3(head13.second)(tail5));
        break;
      }
      case "Append": {
        chunk7 = appendAll3(head13.values)(chunk7);
        patches = tail5;
        break;
      }
      case "Slice": {
        const array8 = toReadonlyArray(chunk7);
        chunk7 = unsafeFromArray(array8.slice(head13.from, head13.until));
        patches = tail5;
        break;
      }
      case "Update": {
        const array8 = toReadonlyArray(chunk7);
        array8[head13.index] = differ4.patch(head13.patch, array8[head13.index]);
        chunk7 = unsafeFromArray(array8);
        patches = tail5;
        break;
      }
    }
  }
  return chunk7;
});

// node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto2 = Object.assign(Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = Object.create(EmptyProto2);
var empty14 = () => _empty6;
var AndThenProto2 = Object.assign(Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first5, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first5;
  o.second = second;
  return o;
};
var AddServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "AddService"
});
var makeAddService = (key, service4) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service4;
  return o;
};
var RemoveServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update18) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update18;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch14 = empty14();
  for (const [tag5, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag5)) {
      const old = missingServices.get(tag5);
      missingServices.delete(tag5);
      if (!equals(old, newService)) {
        patch14 = combine7(makeUpdateService(tag5, () => newService))(patch14);
      }
    } else {
      missingServices.delete(tag5);
      patch14 = combine7(makeAddService(tag5, newService))(patch14);
    }
  }
  for (const [tag5] of missingServices.entries()) {
    patch14 = combine7(makeRemoveService(tag5))(patch14);
  }
  return patch14;
};
var combine7 = dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = dual(2, (self, context15) => {
  if (self._tag === "Empty") {
    return context15;
  }
  let wasServiceUpdated = false;
  let patches = of3(self);
  const updatedContext = new Map(context15.unsafeMap);
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AddService": {
        updatedContext.set(head13.key, head13.service);
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(prepend3(tail5, head13.second), head13.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head13.key);
        patches = tail5;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head13.key, head13.update(updatedContext.get(head13.key)));
        wasServiceUpdated = true;
        patches = tail5;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map49 = /* @__PURE__ */ new Map();
  for (const [tag5] of context15.unsafeMap) {
    if (updatedContext.has(tag5)) {
      map49.set(tag5, updatedContext.get(tag5));
      updatedContext.delete(tag5);
    }
  }
  for (const [tag5, s] of updatedContext) {
    map49.set(tag5, s);
  }
  return makeContext(map49);
});

// node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
var HashMapPatchTypeId = Symbol.for("effect/DifferHashMapPatch");
function variance3(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto3 = Object.assign(Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = Object.create(EmptyProto3);
var empty15 = () => _empty7;
var AndThenProto3 = Object.assign(Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first5, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first5;
  o.second = second;
  return o;
};
var AddProto = Object.assign(Object.create(PatchProto3), {
  _tag: "Add"
});
var makeAdd = (key, value10) => {
  const o = Object.create(AddProto);
  o.key = key;
  o.value = value10;
  return o;
};
var RemoveProto = Object.assign(Object.create(PatchProto3), {
  _tag: "Remove"
});
var makeRemove = (key) => {
  const o = Object.create(RemoveProto);
  o.key = key;
  return o;
};
var UpdateProto2 = Object.assign(Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate2 = (key, patch14) => {
  const o = Object.create(UpdateProto2);
  o.key = key;
  o.patch = patch14;
  return o;
};
var diff3 = (options) => {
  const [removed, patch14] = reduce8([options.oldValue, empty15()], ([map49, patch15], newValue, key) => {
    const option11 = get8(key)(map49);
    switch (option11._tag) {
      case "Some": {
        const valuePatch = options.differ.diff(option11.value, newValue);
        if (equals(valuePatch, options.differ.empty)) {
          return [remove7(key)(map49), patch15];
        }
        return [remove7(key)(map49), combine8(makeUpdate2(key, valuePatch))(patch15)];
      }
      case "None": {
        return [map49, combine8(makeAdd(key, newValue))(patch15)];
      }
    }
  })(options.newValue);
  return reduce8(patch14, (patch15, _, key) => combine8(makeRemove(key))(patch15))(removed);
};
var combine8 = dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let map49 = oldValue;
  let patches = of3(self);
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(head13.first)(prepend3(head13.second)(tail5));
        break;
      }
      case "Add": {
        map49 = set4(head13.key, head13.value)(map49);
        patches = tail5;
        break;
      }
      case "Remove": {
        map49 = remove7(head13.key)(map49);
        patches = tail5;
        break;
      }
      case "Update": {
        const option11 = get8(head13.key)(map49);
        if (option11._tag === "Some") {
          map49 = set4(head13.key, differ4.patch(head13.patch, option11.value))(map49);
        }
        patches = tail5;
        break;
      }
    }
  }
  return map49;
});

// node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = Symbol.for("effect/DifferHashSetPatch");
function variance4(a) {
  return a;
}
var PatchProto4 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance4,
    _Key: variance4,
    _Patch: variance4
  }
};
var EmptyProto4 = Object.assign(Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty8 = Object.create(EmptyProto4);
var empty16 = () => _empty8;
var AndThenProto4 = Object.assign(Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen4 = (first5, second) => {
  const o = Object.create(AndThenProto4);
  o.first = first5;
  o.second = second;
  return o;
};
var AddProto2 = Object.assign(Object.create(PatchProto4), {
  _tag: "Add"
});
var makeAdd2 = (value10) => {
  const o = Object.create(AddProto2);
  o.value = value10;
  return o;
};
var RemoveProto2 = Object.assign(Object.create(PatchProto4), {
  _tag: "Remove"
});
var makeRemove2 = (value10) => {
  const o = Object.create(RemoveProto2);
  o.value = value10;
  return o;
};
var diff4 = (oldValue, newValue) => {
  const [removed, patch14] = reduce7([oldValue, empty16()], ([set26, patch15], value10) => {
    if (has4(value10)(set26)) {
      return [remove6(value10)(set26), patch15];
    }
    return [set26, combine9(makeAdd2(value10))(patch15)];
  })(newValue);
  return reduce7(patch14, (patch15, value10) => combine9(makeRemove2(value10))(patch15))(removed);
};
var combine9 = dual(2, (self, that) => makeAndThen4(self, that));
var patch4 = dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set26 = oldValue;
  let patches = of3(self);
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(head13.first)(prepend3(head13.second)(tail5));
        break;
      }
      case "Add": {
        set26 = add5(head13.value)(set26);
        patches = tail5;
        break;
      }
      case "Remove": {
        set26 = remove6(head13.value)(set26);
        patches = tail5;
      }
    }
  }
  return set26;
});

// node_modules/effect/dist/esm/internal/differ/orPatch.js
var OrPatchTypeId = Symbol.for("effect/DifferOrPatch");
function variance5(a) {
  return a;
}
var PatchProto5 = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance5,
    _Key: variance5,
    _Patch: variance5
  }
};
var EmptyProto5 = Object.assign(Object.create(PatchProto5), {
  _tag: "Empty"
});
var _empty9 = Object.create(EmptyProto5);
var empty17 = () => _empty9;
var AndThenProto5 = Object.assign(Object.create(PatchProto5), {
  _tag: "AndThen"
});
var makeAndThen5 = (first5, second) => {
  const o = Object.create(AndThenProto5);
  o.first = first5;
  o.second = second;
  return o;
};
var SetLeftProto = Object.assign(Object.create(PatchProto5), {
  _tag: "SetLeft"
});
var makeSetLeft = (value10) => {
  const o = Object.create(SetLeftProto);
  o.value = value10;
  return o;
};
var SetRightProto = Object.assign(Object.create(PatchProto5), {
  _tag: "SetRight"
});
var makeSetRight = (value10) => {
  const o = Object.create(SetRightProto);
  o.value = value10;
  return o;
};
var UpdateLeftProto = Object.assign(Object.create(PatchProto5), {
  _tag: "UpdateLeft"
});
var makeUpdateLeft = (patch14) => {
  const o = Object.create(UpdateLeftProto);
  o.patch = patch14;
  return o;
};
var UpdateRightProto = Object.assign(Object.create(PatchProto5), {
  _tag: "UpdateRight"
});
var makeUpdateRight = (patch14) => {
  const o = Object.create(UpdateRightProto);
  o.patch = patch14;
  return o;
};
var diff5 = (options) => {
  switch (options.oldValue._tag) {
    case "Left": {
      switch (options.newValue._tag) {
        case "Left": {
          const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);
          if (equals(valuePatch, options.left.empty)) {
            return empty17();
          }
          return makeUpdateLeft(valuePatch);
        }
        case "Right": {
          return makeSetRight(options.newValue.right);
        }
      }
    }
    case "Right": {
      switch (options.newValue._tag) {
        case "Left": {
          return makeSetLeft(options.newValue.left);
        }
        case "Right": {
          const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);
          if (equals(valuePatch, options.right.empty)) {
            return empty17();
          }
          return makeUpdateRight(valuePatch);
        }
      }
    }
  }
};
var combine10 = dual(2, (self, that) => makeAndThen5(self, that));
var patch5 = dual(2, (self, {
  left: left3,
  oldValue,
  right: right3
}) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let patches = of3(self);
  let result = oldValue;
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail5 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        patches = prepend3(head13.first)(prepend3(head13.second)(tail5));
        break;
      }
      case "UpdateLeft": {
        if (result._tag === "Left") {
          result = left2(left3.patch(head13.patch, result.left));
        }
        patches = tail5;
        break;
      }
      case "UpdateRight": {
        if (result._tag === "Right") {
          result = right2(right3.patch(head13.patch, result.right));
        }
        patches = tail5;
        break;
      }
      case "SetLeft": {
        result = left2(head13.value);
        patches = tail5;
        break;
      }
      case "SetRight": {
        result = right2(head13.value);
        patches = tail5;
        break;
      }
    }
  }
  return result;
});

// node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = Symbol.for("effect/DifferReadonlyArrayPatch");
function variance6(a) {
  return a;
}
var PatchProto6 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance6,
    _Patch: variance6
  }
};
var EmptyProto6 = Object.assign(Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty10 = Object.create(EmptyProto6);
var empty18 = () => _empty10;
var AndThenProto6 = Object.assign(Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen6 = (first5, second) => {
  const o = Object.create(AndThenProto6);
  o.first = first5;
  o.second = second;
  return o;
};
var AppendProto2 = Object.assign(Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend2 = (values15) => {
  const o = Object.create(AppendProto2);
  o.values = values15;
  return o;
};
var SliceProto2 = Object.assign(Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice2 = (from29, until) => {
  const o = Object.create(SliceProto2);
  o.from = from29;
  o.until = until;
  return o;
};
var UpdateProto3 = Object.assign(Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate3 = (index3, patch14) => {
  const o = Object.create(UpdateProto3);
  o.index = index3;
  o.patch = patch14;
  return o;
};
var diff6 = (options) => {
  let i = 0;
  let patch14 = empty18();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch14 = combine11(patch14, makeUpdate3(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch14 = combine11(patch14, makeSlice2(0, i));
  }
  if (i < options.newValue.length) {
    patch14 = combine11(patch14, makeAppend2(drop2(i)(options.newValue)));
  }
  return patch14;
};
var combine11 = dual(2, (self, that) => makeAndThen6(self, that));
var patch6 = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray3 = oldValue.slice();
  let patches = of2(self);
  while (isNonEmptyArray2(patches)) {
    const head13 = headNonEmpty(patches);
    const tail5 = tailNonEmpty(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail5;
        break;
      }
      case "AndThen": {
        tail5.unshift(head13.first, head13.second);
        patches = tail5;
        break;
      }
      case "Append": {
        for (const value10 of head13.values) {
          readonlyArray3.push(value10);
        }
        patches = tail5;
        break;
      }
      case "Slice": {
        readonlyArray3 = readonlyArray3.slice(head13.from, head13.until);
        patches = tail5;
        break;
      }
      case "Update": {
        readonlyArray3[head13.index] = differ4.patch(head13.patch, readonlyArray3[head13.index]);
        patches = tail5;
        break;
      }
    }
  }
  return readonlyArray3;
});

// node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make20 = (params) => {
  const differ4 = Object.create(DifferProto);
  differ4.empty = params.empty;
  differ4.diff = params.diff;
  differ4.combine = params.combine;
  differ4.patch = params.patch;
  return differ4;
};
var environment = () => make20({
  empty: empty14(),
  combine: (first5, second) => combine7(second)(first5),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch14, oldValue) => patch2(oldValue)(patch14)
});
var chunk = (differ4) => make20({
  empty: empty13(),
  combine: (first5, second) => combine6(second)(first5),
  diff: (oldValue, newValue) => diff({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch(oldValue, differ4)(patch14)
});
var hashMap = (differ4) => make20({
  empty: empty15(),
  combine: (first5, second) => combine8(second)(first5),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch3(oldValue, differ4)(patch14)
});
var hashSet = () => make20({
  empty: empty16(),
  combine: (first5, second) => combine9(second)(first5),
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  patch: (patch14, oldValue) => patch4(oldValue)(patch14)
});
var orElseEither2 = dual(2, (self, that) => make20({
  empty: empty17(),
  combine: (first5, second) => combine10(first5, second),
  diff: (oldValue, newValue) => diff5({
    oldValue,
    newValue,
    left: self,
    right: that
  }),
  patch: (patch14, oldValue) => patch5(patch14, {
    oldValue,
    left: self,
    right: that
  })
}));
var readonlyArray = (differ4) => make20({
  empty: empty18(),
  combine: (first5, second) => combine11(first5, second),
  diff: (oldValue, newValue) => diff6({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch6(patch14, oldValue, differ4)
});
var transform = dual(2, (self, {
  toNew,
  toOld
}) => make20({
  empty: self.empty,
  combine: (first5, second) => self.combine(first5, second),
  diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),
  patch: (patch14, oldValue) => toNew(self.patch(patch14, toOld(oldValue)))
}));
var update2 = () => updateWith((_, a) => a);
var updateWith = (f2) => make20({
  empty: identity,
  combine: (first5, second) => {
    if (first5 === identity) {
      return second;
    }
    if (second === identity) {
      return first5;
    }
    return (a) => second(first5(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch14, oldValue) => f2(oldValue, patch14(oldValue))
});
var zip4 = dual(2, (self, that) => make20({
  empty: [self.empty, that.empty],
  combine: (first5, second) => [self.combine(first5[0], second[0]), that.combine(first5[1], second[1])],
  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],
  patch: (patch14, oldValue) => [self.patch(patch14[0], oldValue[0]), that.patch(patch14[1], oldValue[1])]
}));

// node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch14) => patch14 & BIT_MASK;
var enabled = (patch14) => patch14 >> BIT_SHIFT & BIT_MASK;
var make21 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty19 = make21(0, 0);
var enable = (flag) => make21(flag, flag);
var disable = (flag) => make21(flag, 0);
var isEmpty5 = (patch14) => patch14 === 0;
var isActive = dual(2, (self, flag) => (active(self) & flag) !== 0);
var isEnabled = dual(2, (self, flag) => (enabled(self) & flag) !== 0);
var isDisabled = dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
var exclude = dual(2, (self, flag) => make21(active(self) & ~flag, enabled(self)));
var both = dual(2, (self, that) => make21(active(self) | active(that), enabled(self) & enabled(that)));
var either = dual(2, (self, that) => make21(active(self) | active(that), enabled(self) | enabled(that)));
var andThen3 = dual(2, (self, that) => self | that);
var inverse = (patch14) => make21(enabled(patch14), invert(active(patch14)));
var invert = (n) => ~n >>> 0 & BIT_MASK;

// node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var allFlags = [None2, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];
var print = (flag) => {
  switch (flag) {
    case CooperativeYielding: {
      return "CooperativeYielding";
    }
    case WindDown: {
      return "WindDown";
    }
    case RuntimeMetrics: {
      return "RuntimeMetrics";
    }
    case OpSupervision: {
      return "OpSupervision";
    }
    case Interruption: {
      return "Interruption";
    }
    case None2: {
      return "None";
    }
  }
};
var cooperativeYielding = (self) => isEnabled2(self, CooperativeYielding);
var disable2 = dual(2, (self, flag) => self & ~flag);
var disableAll = dual(2, (self, flags) => self & ~flags);
var enable2 = dual(2, (self, flag) => self | flag);
var enableAll = dual(2, (self, flags) => self | flags);
var interruptible = (self) => interruption(self) && !windDown(self);
var interruption = (self) => isEnabled2(self, Interruption);
var isDisabled2 = dual(2, (self, flag) => !isEnabled2(self, flag));
var isEnabled2 = dual(2, (self, flag) => (self & flag) !== 0);
var make22 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = make22(None2);
var opSupervision = (self) => isEnabled2(self, OpSupervision);
var render = (self) => {
  const active2 = [];
  allFlags.forEach((flag) => {
    if (isEnabled2(self, flag)) {
      active2.push(`${print(flag)}`);
    }
  });
  return `RuntimeFlags(${active2.join(", ")})`;
};
var runtimeMetrics = (self) => isEnabled2(self, RuntimeMetrics);
var toSet3 = (self) => new Set(allFlags.filter((flag) => isEnabled2(self, flag)));
var windDown = (self) => isEnabled2(self, WindDown);
var enabledSet = (self) => toSet3(active(self) & enabled(self));
var disabledSet = (self) => toSet3(active(self) & ~enabled(self));
var diff7 = dual(2, (self, that) => make21(self ^ that, that));
var patch7 = dual(2, (self, patch14) => self & (invert(active(patch14)) | enabled(patch14)) | active(patch14) & enabled(patch14));
var renderPatch = (self) => {
  const enabled2 = Array.from(enabledSet(self)).map((flag) => print(flag)).join(", ");
  const disabled = Array.from(disabledSet(self)).map((flag) => print(flag)).join(", ");
  return `RuntimeFlagsPatch(enabled = (${enabled2}), disabled = (${disabled}))`;
};
var differ = make20({
  empty: empty19,
  diff: (oldValue, newValue) => diff7(oldValue, newValue),
  combine: (first5, second) => andThen3(second)(first5),
  patch: (_patch, oldValue) => patch7(oldValue, _patch)
});

// node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty20 = empty19;
var make23 = make21;
var enable3 = enable;
var disable3 = disable;
var isEmpty6 = isEmpty5;
var isActive2 = isActive;
var isEnabled3 = isEnabled;
var isDisabled3 = isDisabled;
var includes = isActive;
var andThen4 = andThen3;
var both2 = both;
var either2 = either;
var exclude2 = exclude;
var inverse2 = inverse;
var enabledSet2 = enabledSet;
var disabledSet2 = disabledSet;
var render2 = renderPatch;

// node_modules/effect/dist/esm/internal/blockedRequests.js
var empty21 = {
  _tag: "Empty"
};
var par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
var seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var MapRequestResolversReducer = (f2) => ({
  emptyCase: () => empty21,
  parCase: (left3, right3) => par(left3, right3),
  seqCase: (left3, right3) => seq(left3, right3),
  singleCase: (dataSource, blockedRequest) => single(f2(dataSource), blockedRequest)
});
var mapRequestResolvers = (self, f2) => reduce10(self, MapRequestResolversReducer(f2));
var reduce10 = (self, reducer) => {
  let input = of4(self);
  let output = empty12();
  while (isCons(input)) {
    const current2 = input.head;
    switch (current2._tag) {
      case "Empty": {
        output = cons(right2(reducer.emptyCase()), output);
        input = input.tail;
        break;
      }
      case "Par": {
        output = cons(left2({
          _tag: "ParCase"
        }), output);
        input = cons(current2.left, cons(current2.right, input.tail));
        break;
      }
      case "Seq": {
        output = cons(left2({
          _tag: "SeqCase"
        }), output);
        input = cons(current2.left, cons(current2.right, input.tail));
        break;
      }
      case "Single": {
        const result2 = reducer.singleCase(current2.dataSource, current2.blockedRequest);
        output = cons(right2(result2), output);
        input = input.tail;
        break;
      }
    }
  }
  const result = reduce9(output, empty12(), (acc, current2) => {
    switch (current2._tag) {
      case "Left": {
        const left3 = unsafeHead3(acc);
        const right3 = unsafeHead3(unsafeTail(acc));
        const tail5 = unsafeTail(unsafeTail(acc));
        switch (current2.left._tag) {
          case "ParCase": {
            return cons(reducer.parCase(left3, right3), tail5);
          }
          case "SeqCase": {
            return cons(reducer.seqCase(left3, right3), tail5);
          }
        }
      }
      case "Right": {
        return cons(current2.right, acc);
      }
    }
  });
  if (isNil(result)) {
    throw new Error("BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return result.head;
};
var flatten6 = (self) => {
  let current2 = of4(self);
  let updated = empty12();
  while (1) {
    const [parallel6, sequential6] = reduce9(current2, [parallelCollectionEmpty(), empty12()], ([parallel7, sequential7], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel7, par2), appendAll4(sequential7, seq2)];
    });
    updated = merge4(updated, parallel6);
    if (isNil(sequential6)) {
      return reverse4(updated);
    }
    current2 = sequential6;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current2 = requests;
  let parallel6 = parallelCollectionEmpty();
  let stack = empty12();
  let sequential6 = empty12();
  while (1) {
    switch (current2._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel6, sequential6];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current2.right, stack);
        current2 = current2.left;
        break;
      }
      case "Seq": {
        const left3 = current2.left;
        const right3 = current2.right;
        switch (left3._tag) {
          case "Empty": {
            current2 = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current2 = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current2 = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current2 = left3;
            sequential6 = cons(right3, sequential6);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel6 = parallelCollectionAdd(parallel6, current2);
        if (isNil(stack)) {
          return [parallel6, sequential6];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential6, parallel6) => {
  if (isNil(sequential6)) {
    return of4(parallelCollectionToSequentialCollection(parallel6));
  }
  if (parallelCollectionIsEmpty(parallel6)) {
    return sequential6;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential6.head);
  const parKeys = parallelCollectionKeys(parallel6);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential6.head, parallelCollectionToSequentialCollection(parallel6)), sequential6.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel6), sequential6);
};
var EntryTypeId = Symbol.for("effect/RequestBlock/Entry");
var _a6;
_a6 = EntryTypeId;
var EntryImpl = class {
  constructor(request2, result, listeners, ownerId, state) {
    __publicField(this, "request");
    __publicField(this, "result");
    __publicField(this, "listeners");
    __publicField(this, "ownerId");
    __publicField(this, "state");
    __publicField(this, _a6, blockedRequestVariance);
    this.request = request2;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var isEntry = (u) => hasProperty(u, EntryTypeId);
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var _a7;
_a7 = RequestBlockParallelTypeId;
var ParallelImpl = class {
  constructor(map49) {
    __publicField(this, "map");
    __publicField(this, _a7, parallelVariance);
    this.map = map49;
  }
};
var parallelCollectionEmpty = () => new ParallelImpl(empty11());
var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append3(blockedRequest.blockedRequest)), () => of3(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce8(self.map, that.map, (map49, value10, key) => set4(map49, key, match2(get8(map49, key), {
  onNone: () => value10,
  onSome: (other) => appendAll3(value10, other)
}))));
var parallelCollectionIsEmpty = (self) => isEmpty4(self.map);
var parallelCollectionKeys = (self) => Array.from(keys3(self.map));
var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map11(self.map, (x) => of3(x)));
var SequentialCollectionTypeId = Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var _a8;
_a8 = SequentialCollectionTypeId;
var SequentialImpl = class {
  constructor(map49) {
    __publicField(this, "map");
    __publicField(this, _a8, sequentialVariance);
    this.map = map49;
  }
};
var sequentialCollectionMake = (map49) => new SequentialImpl(map49);
var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce8(that.map, self.map, (map49, value10, key) => set4(map49, key, match2(get8(map49, key), {
  onNone: () => empty7(),
  onSome: (a) => appendAll3(a, value10)
}))));
var sequentialCollectionKeys = (self) => Array.from(keys3(self.map));
var sequentialCollectionToChunk = (self) => Array.from(self.map);

// node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = Symbol.for(CauseSymbolKey);
var variance7 = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance7,
  [symbol2]() {
    return pipe(hash(CauseSymbolKey), combine2(hash(flattenCause(this))), cached(this));
  },
  [symbol3](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty22 = (() => {
  const o = Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error4) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error4;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId5) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId5;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self) => self._tag === OP_EMPTY;
var isFailType = (self) => self._tag === OP_FAIL;
var isDieType = (self) => self._tag === OP_DIE;
var isInterruptType = (self) => self._tag === OP_INTERRUPT;
var isSequentialType = (self) => self._tag === OP_SEQUENTIAL;
var isParallelType = (self) => self._tag === OP_PARALLEL;
var size12 = (self) => reduceWithContext(self, void 0, SizeCauseReducer);
var isEmpty7 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce11(self, true, (acc, cause3) => {
    switch (cause3._tag) {
      case OP_EMPTY: {
        return some3(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some3(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isFailure = (self) => isSome2(failureOption(self));
var isDie = (self) => isSome2(dieOption(self));
var isInterrupted = (self) => isSome2(interruptOption(self));
var isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
var failures = (self) => reverse3(reduce11(self, empty7(), (list, cause3) => cause3._tag === OP_FAIL ? some3(pipe(list, prepend3(cause3.error))) : none2()));
var defects = (self) => reverse3(reduce11(self, empty7(), (list, cause3) => cause3._tag === OP_DIE ? some3(pipe(list, prepend3(cause3.defect))) : none2()));
var interruptors = (self) => reduce11(self, empty10(), (set26, cause3) => cause3._tag === OP_INTERRUPT ? some3(pipe(set26, add5(cause3.fiberId))) : none2());
var failureOption = (self) => find(self, (cause3) => cause3._tag === OP_FAIL ? some3(cause3.error) : none2());
var failureOrCause = (self) => {
  const option11 = failureOption(self);
  switch (option11._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option11.value);
    }
  }
};
var dieOption = (self) => find(self, (cause3) => cause3._tag === OP_DIE ? some3(cause3.defect) : none2());
var flipCauseOption = (self) => match6(self, {
  onEmpty: some3(empty22),
  onFail: map2(fail),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: (fiberId5) => some3(interrupt(fiberId5)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self) => find(self, (cause3) => cause3._tag === OP_INTERRUPT ? some3(cause3.fiberId) : none2());
var keepDefects = (self) => match6(self, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self) => match6(self, {
  onEmpty: none2(),
  onFail: (failure) => some3(die(failure)),
  onDie: (defect) => some3(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var linearize = (self) => match6(self, {
  onEmpty: empty10(),
  onFail: (error4) => make14(fail(error4)),
  onDie: (defect) => make14(die(defect)),
  onInterrupt: (fiberId5) => make14(interrupt(fiberId5)),
  onSequential: (leftSet, rightSet) => flatMap8(leftSet, (leftCause) => map10(rightSet, (rightCause) => sequential(leftCause, rightCause))),
  onParallel: (leftSet, rightSet) => flatMap8(leftSet, (leftCause) => map10(rightSet, (rightCause) => parallel(leftCause, rightCause)))
});
var stripFailures = (self) => match6(self, {
  onEmpty: empty22,
  onFail: () => empty22,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self) => match6(self, {
  onEmpty: empty22,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var stripSomeDefects = dual(2, (self, pf) => match6(self, {
  onEmpty: some3(empty22),
  onFail: (error4) => some3(fail(error4)),
  onDie: (defect) => {
    const option11 = pf(defect);
    return isSome2(option11) ? none2() : some3(die(defect));
  },
  onInterrupt: (fiberId5) => some3(interrupt(fiberId5)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}));
var as2 = dual(2, (self, error4) => map13(self, () => error4));
var map13 = dual(2, (self, f2) => flatMap11(self, (e) => fail(f2(e))));
var flatMap11 = dual(2, (self, f2) => match6(self, {
  onEmpty: empty22,
  onFail: (error4) => f2(error4),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId5) => interrupt(fiberId5),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten7 = (self) => flatMap11(self, identity);
var andThen5 = dual(2, (self, f2) => isFunction2(f2) ? flatMap11(self, f2) : flatMap11(self, () => f2));
var contains5 = dual(2, (self, that) => {
  if (that._tag === OP_EMPTY || self === that) {
    return true;
  }
  return reduce11(self, false, (accumulator, cause3) => {
    return some3(accumulator || causeEquals(cause3, that));
  });
});
var causeEquals = (left3, right3) => {
  let leftStack = of3(left3);
  let rightStack = of3(right3);
  while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce11([empty10(), empty7()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some3([pipe(parallel6, union6(par2)), pipe(sequential6, appendAll3(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce11([empty10(), empty7()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some3([pipe(parallel6, union6(par2)), pipe(sequential6, appendAll3(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause3) => {
  return flattenCauseLoop(of3(cause3), empty7());
};
var flattenCauseLoop = (causes, flattened) => {
  while (1) {
    const [parallel6, sequential6] = pipe(causes, reduce3([empty10(), empty7()], ([parallel7, sequential7], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return [pipe(parallel7, union6(par2)), pipe(sequential7, appendAll3(seq2))];
    }));
    const updated = size9(parallel6) > 0 ? pipe(flattened, prepend3(parallel6)) : flattened;
    if (isEmpty2(sequential6)) {
      return reverse3(updated);
    }
    causes = sequential6;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option11 = pf(item);
    switch (option11._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option11;
      }
    }
  }
  return none2();
});
var filter11 = dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));
var evaluateCause = (self) => {
  let cause3 = self;
  const stack = [];
  let _parallel = empty10();
  let _sequential = empty7();
  while (cause3 !== void 0) {
    switch (cause3._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add5(_parallel, make9(cause3._tag, cause3.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add5(_parallel, make9(cause3._tag, cause3.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add5(_parallel, make9(cause3._tag, cause3.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause3.left._tag) {
          case OP_EMPTY: {
            cause3 = cause3.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause3 = sequential(cause3.left.left, sequential(cause3.left.right, cause3.right));
            break;
          }
          case OP_PARALLEL: {
            cause3 = parallel(sequential(cause3.left.left, cause3.right), sequential(cause3.left.right, cause3.right));
            break;
          }
          default: {
            _sequential = prepend3(_sequential, cause3.right);
            cause3 = cause3.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var SizeCauseReducer = {
  emptyCase: () => 0,
  failCase: () => 1,
  dieCase: () => 1,
  interruptCase: () => 1,
  sequentialCase: (_, left3, right3) => left3 + right3,
  parallelCase: (_, left3, right3) => left3 + right3
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var FilterCauseReducer = (predicate) => ({
  emptyCase: () => empty22,
  failCase: (_, error4) => fail(error4),
  dieCase: (_, defect) => die(defect),
  interruptCase: (_, fiberId5) => interrupt(fiberId5),
  sequentialCase: (_, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return sequential(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty22;
  },
  parallelCase: (_, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return parallel(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty22;
  }
});
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match6 = dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt4,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error4) => onFail(error4),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId5) => onInterrupt4(fiberId5),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce11 = dual(3, (self, zero3, pf) => {
  let accumulator = zero3;
  let cause3 = self;
  const causes = [];
  while (cause3 !== void 0) {
    const option11 = pf(accumulator, cause3);
    accumulator = isSome2(option11) ? option11.value : accumulator;
    switch (cause3._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      default: {
        cause3 = void 0;
        break;
      }
    }
    if (cause3 === void 0 && causes.length > 0) {
      cause3 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = dual(3, (self, context15, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause3 = input.pop();
    switch (cause3._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context15)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context15, cause3.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context15, cause3.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context15, cause3.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either14 = output.pop();
    switch (either14._tag) {
      case "Left": {
        switch (either14.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value10 = reducer.sequentialCase(context15, left3, right3);
            accumulator.push(value10);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value10 = reducer.parallelCase(context15, left3, right3);
            accumulator.push(value10);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either14.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause3, options) => {
  if (isInterruptedOnly(cause3)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause3).map(function(e) {
    if ((options == null ? void 0 : options.renderErrorCause) !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause3, prefix) => {
  const lines = cause3.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause3.cause) {
    stack += ` {
${renderErrorCause(cause3.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  constructor(originalError2) {
    const originalErrorIsObject = typeof originalError2 === "object" && originalError2 !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError2), originalErrorIsObject && "cause" in originalError2 && typeof originalError2.cause !== "undefined" ? {
      cause: new _PrettyError(originalError2.cause)
    } : void 0);
    __publicField(this, "span");
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError2 instanceof Error ? originalError2.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError2) {
        this.span = originalError2[spanSymbol];
      }
      Object.keys(originalError2).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError2[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError2 instanceof Error && originalError2.stack ? originalError2.stack : "", this.span);
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span4) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span4) {
    let current2 = span4;
    let i = 0;
    while (current2 && current2._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current2);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match43 = false;
          for (const [, location] of locationMatchAll) {
            match43 = true;
            out.push(`    at ${current2.name} (${location})`);
          }
          if (!match43) {
            out.push(`    at ${current2.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current2.name}`);
        }
      } else {
        out.push(`    at ${current2.name}`);
      }
      current2 = getOrUndefined2(current2.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause3) => reduceWithContext(cause3, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error4) => {
    return [new PrettyError(error4)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect4) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect4
  };
};

// node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "called", false);
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue3) => {
  const effect4 = new EffectPrimitive("Blocked");
  effect4.effect_instruction_i0 = blockedRequests;
  effect4.effect_instruction_i1 = _continue3;
  return effect4;
};
var runRequestBlock = (blockedRequests) => {
  const effect4 = new EffectPrimitive("RunBlocked");
  effect4.effect_instruction_i0 = blockedRequests;
  return effect4;
};
var EffectTypeId2 = Symbol.for("effect/Effect");
var RevertFlags = class {
  constructor(patch14, op) {
    __publicField(this, "patch");
    __publicField(this, "op");
    __publicField(this, "_op", OP_REVERT_FLAGS);
    this.patch = patch14;
    this.op = op;
  }
};
var _a9;
var EffectPrimitive = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a9, effectVariance);
    this._op = _op;
  }
  [(_a9 = EffectTypeId2, symbol3)](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random2(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var _a10;
var EffectPrimitiveFailure = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a10, effectVariance);
    this._op = _op;
    this._tag = _op;
  }
  [(_a10 = EffectTypeId2, symbol3)](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol2]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine2(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var _a11;
var EffectPrimitiveSuccess = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a11, effectVariance);
    this._op = _op;
    this._tag = _op;
  }
  [(_a11 = EffectTypeId2, symbol3)](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol2]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine2(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect4.effect_instruction_i0 = withRuntime;
  return effect4;
};
var acquireUseRelease = dual(3, (acquire4, use2, release4) => uninterruptibleMask((restore) => flatMap12(acquire4, (a) => flatMap12(exit(suspend(() => restore(use2(a)))), (exit4) => {
  return suspend(() => release4(a, exit4)).pipe(matchCauseEffect({
    onFailure: (cause3) => {
      switch (exit4._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit4.effect_instruction_i0, cause3));
        case OP_SUCCESS:
          return failCause(cause3);
      }
    },
    onSuccess: () => exit4
  }));
}))));
var as3 = dual(2, (self, value10) => flatMap12(self, () => succeed(value10)));
var asVoid2 = (self) => as3(self, void 0);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect4 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect4.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect4.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect4, (_) => isEffect(cancelerRef) ? cancelerRef : void_3);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect5) {
      if (backingResume) {
        backingResume(effect5);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect5;
      }
    }
    const effect4 = new EffectPrimitive(OP_ASYNC);
    effect4.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect4.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect4, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_3;
    }) : effect4;
  });
};
var catchAllCause = dual(2, (self, f2) => {
  const effect4 = new EffectPrimitive(OP_ON_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f2;
  return effect4;
});
var catchAll = dual(2, (self, f2) => matchEffect(self, {
  onFailure: f2,
  onSuccess: succeed
}));
var catchIf = dual(3, (self, predicate, f2) => catchAllCause(self, (cause3) => {
  const either14 = failureOrCause(cause3);
  switch (either14._tag) {
    case "Left":
      return predicate(either14.left) ? f2(either14.left) : failCause(cause3);
    case "Right":
      return failCause(either14.right);
  }
}));
var catchSome = dual(2, (self, pf) => catchAllCause(self, (cause3) => {
  const either14 = failureOrCause(cause3);
  switch (either14._tag) {
    case "Left":
      return pipe(pf(either14.left), getOrElse2(() => failCause(cause3)));
    case "Right":
      return failCause(either14.right);
  }
}));
var checkInterruptible = (f2) => withFiberRuntime((_, status3) => f2(interruption(status3.runtimeFlags)));
var originalSymbol = Symbol.for("effect/OriginalAnnotation");
var originalInstance = (obj) => {
  if (hasProperty(obj, originalSymbol)) {
    return obj[originalSymbol];
  }
  return obj;
};
var capture = (obj, span4) => {
  if (isSome2(span4)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span4.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate4) => flatMap12(sync(evaluate4), die2);
var either3 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error4) => isObject(error4) && !(spanSymbol in error4) ? withFiberRuntime((fiber) => failCause(fail(capture(error4, currentSpanFromFiber(fiber))))) : failCause(fail(error4));
var failSync = (evaluate4) => flatMap12(sync(evaluate4), fail2);
var failCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var failCauseSync = (evaluate4) => flatMap12(sync(evaluate4), failCause);
var fiberId = withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f2) => withFiberRuntime((state) => f2(state.id()));
var flatMap12 = dual(2, (self, f2) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f2;
  return effect4;
});
var andThen6 = dual(2, (self, f2) => flatMap12(self, (a) => {
  const b = typeof f2 === "function" ? f2(a) : f2;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self) => {
  const effect4 = new EffectPrimitive("OnStep");
  effect4.effect_instruction_i0 = self;
  return effect4;
};
var flatten8 = (self) => flatMap12(self, identity);
var flip3 = (self) => matchEffect(self, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause3) => succeed(options.onFailure(cause3)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = dual(2, (self, options) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = options.onFailure;
  effect4.effect_instruction_i2 = options.onSuccess;
  return effect4;
});
var matchEffect = dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(electFailures(cause3));
    }
    const failures3 = failures(cause3);
    if (failures3.length > 0) {
      return options.onFailure(unsafeHead2(failures3));
    }
    return failCause(cause3);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = dual(2, (self, f2) => suspend(() => {
  const arr = fromIterable2(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as3(whileLoop({
    while: () => i < arr.length,
    body: () => f2(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = dual(2, (self, f2) => suspend(() => {
  const arr = fromIterable2(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f2(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self, options) => isEffect(self) ? flatMap12(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
var interrupt2 = flatMap12(fiberId, (fiberId5) => interruptWith(fiberId5));
var interruptWith = (fiberId5) => failCause(interrupt(fiberId5));
var interruptible2 = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var interruptibleMask = (f2) => custom(f2, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var intoDeferred = dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap12(exit(restore(self)), (exit4) => deferredDone(deferred, exit4))));
var map14 = dual(2, (self, f2) => flatMap12(self, (a) => sync(() => f2(a))));
var mapBoth3 = dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either14 = failureOrCause(cause3);
    switch (either14._tag) {
      case "Left": {
        return failSync(() => f2(either14.left));
      }
      case "Right": {
        return failCause(either14.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = dual(2, (self, cleanup) => onExit(self, (exit4) => exitIsSuccess(exit4) ? void_3 : cleanup(exit4.effect_instruction_i0)));
var onExit = dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause22) => exitFailCause(sequential(cause1, cause22)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight2(cleanup(result), result);
  }
})));
var onInterrupt = dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: (cause3) => isInterruptedOnly(cause3) ? asVoid2(cleanup(interruptors(cause3))) : void_3,
  onSuccess: () => void_3
})));
var orElse3 = dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = (self) => orDieWith(self, identity);
var orDieWith = dual(2, (self, f2) => matchEffect(self, {
  onFailure: (e) => die2(f2(e)),
  onSuccess: succeed
}));
var partitionMap6 = partitionMap3;
var runtimeFlags = withFiberRuntime((_, status3) => succeed(status3.runtimeFlags));
var succeed = (value10) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value10;
  return effect4;
};
var suspend = (evaluate4) => {
  const effect4 = new EffectPrimitive(OP_COMMIT);
  effect4.commit = evaluate4;
  return effect4;
};
var sync = (thunk) => {
  const effect4 = new EffectPrimitive(OP_SYNC);
  effect4.effect_instruction_i0 = thunk;
  return effect4;
};
var tap2 = dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self, f2) => flatMap12(self, (a) => {
  const b = typeof f2 === "function" ? f2(a) : f2;
  if (isEffect(b)) {
    return as3(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f2) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope6 = pipe(scopeOverride, getOrElse2(() => state.scope()));
  return f2(fiberRefLocally(currentForkScopeOverride, some3(scope6)));
});
var attemptOrElse = dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause3)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var uninterruptibleMask = (f2) => custom(f2, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var void_3 = succeed(void 0);
var updateRuntimeFlags = (patch14) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = patch14;
  effect4.effect_instruction_i1 = void 0;
  return effect4;
};
var whenEffect = dual(2, (self, condition) => flatMap12(condition, (b) => {
  if (b) {
    return pipe(self, map14(some3));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect4 = new EffectPrimitive(OP_WHILE);
  effect4.effect_instruction_i0 = options.while;
  effect4.effect_instruction_i1 = options.body;
  effect4.effect_instruction_i2 = options.step;
  return effect4;
};
var fromIterator = (iterator) => suspend(() => {
  const effect4 = new EffectPrimitive(OP_ITERATOR);
  effect4.effect_instruction_i0 = iterator();
  return effect4;
});
var gen4 = function() {
  const f2 = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f2(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body.apply(this, args2));
} : function(...args2) {
  let effect4 = fromIterator(() => body.apply(this, args2));
  for (const x of pipeables) {
    effect4 = x(effect4, ...args2);
  }
  return effect4;
}, "length", {
  value: body.length,
  configurable: true
});
var withConcurrency = dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
var withRequestBatching = dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
var withRuntimeFlags = dual(2, (self, update18) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = update18;
  effect4.effect_instruction_i1 = () => self;
  return effect4;
});
var withTracerEnabled = dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
var withTracerTiming = dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect4 = new EffectPrimitive(OP_YIELD);
  return typeof (options == null ? void 0 : options.priority) !== "undefined" ? withSchedulingPriority(effect4, options.priority) : effect4;
};
var zip5 = dual(2, (self, that) => flatMap12(self, (a) => map14(that, (b) => [a, b])));
var zipFlatten = dual(2, (self, that) => flatMap12(self, (a) => map14(that, (b) => [...a, b])));
var zipLeft2 = dual(2, (self, that) => flatMap12(self, (a) => as3(that, a)));
var zipRight2 = dual(2, (self, that) => flatMap12(self, () => that));
var zipWith6 = dual(3, (self, that, f2) => flatMap12(self, (a) => map14(that, (b) => f2(a, b))));
var never = asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self) => flatMap12(fiberId, (fiberId5) => pipe(self, interruptAsFiber(fiberId5)));
var interruptAsFiber = dual(2, (self, fiberId5) => flatMap12(self.interruptAsFork(fiberId5), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)));
var fiberRefGetAndSet = dual(2, (self, value10) => fiberRefModify(self, (v) => [v, value10]));
var fiberRefGetAndUpdate = dual(2, (self, f2) => fiberRefModify(self, (v) => [v, f2(v)]));
var fiberRefGetAndUpdateSome = dual(2, (self, pf) => fiberRefModify(self, (v) => [v, getOrElse2(pf(v), () => v)]));
var fiberRefGetWith = dual(2, (self, f2) => flatMap12(fiberRefGet(self), f2));
var fiberRefSet = dual(2, (self, value10) => fiberRefModify(self, () => [void 0, value10]));
var fiberRefDelete = (self) => withFiberRuntime((state) => {
  state.unsafeDeleteFiberRef(self);
  return void_3;
});
var fiberRefReset = (self) => fiberRefSet(self, self.initial);
var fiberRefModify = dual(2, (self, f2) => withFiberRuntime((state) => {
  const [b, a] = f2(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
var fiberRefModifySome = (self, def, f2) => fiberRefModify(self, (v) => getOrElse2(f2(v), () => [def, v]));
var fiberRefUpdate = dual(2, (self, f2) => fiberRefModify(self, (v) => [void 0, f2(v)]));
var fiberRefUpdateSome = dual(2, (self, pf) => fiberRefModify(self, (v) => [void 0, getOrElse2(pf(v), () => v)]));
var fiberRefUpdateAndGet = dual(2, (self, f2) => fiberRefModify(self, (v) => {
  const result = f2(v);
  return [result, result];
}));
var fiberRefUpdateSomeAndGet = dual(2, (self, pf) => fiberRefModify(self, (v) => {
  const result = getOrElse2(pf(v), () => v);
  return [result, result];
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a12;
var RequestResolverImpl = class _RequestResolverImpl {
  constructor(runAll, target) {
    __publicField(this, "runAll");
    __publicField(this, "target");
    __publicField(this, _a12, requestResolverVariance);
    this.runAll = runAll;
    this.target = target;
  }
  [(_a12 = RequestResolverTypeId, symbol2)]() {
    return cached(this, this.target ? hash(this.target) : random2(this));
  }
  [symbol3](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids3) {
    return new _RequestResolverImpl(this.runAll, fromIterable3(ids3));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
var resolverLocally = dual(3, (use2, self, value10) => new RequestResolverImpl((requests) => fiberRefLocally(use2.runAll(requests), self, value10), make9("Locally", use2, self, value10)));
var fiberRefLocally = dual(3, (use2, self, value10) => acquireUseRelease(zipLeft2(fiberRefGet(self), fiberRefSet(self, value10)), () => use2, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = dual(3, (use2, self, f2) => fiberRefGetWith(self, (a) => fiberRefLocally(use2, self, f2(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update2(),
  fork: (options == null ? void 0 : options.fork) ?? identity,
  join: options == null ? void 0 : options.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ4 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ4 = readonlyArray(update2());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ4 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first5, second) => options.differ.combine(first5, second),
    patch: (patch14) => (oldValue) => options.differ.patch(patch14, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = globalValue(Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty6()));
var currentSchedulingPriority = globalValue(Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = globalValue(Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = globalValue(Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty11()));
var currentLogLevel = globalValue(Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = globalValue(Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty12()));
var withSchedulingPriority = dual(2, (self, scheduler2) => fiberRefLocally(self, currentSchedulingPriority, scheduler2));
var withMaxOpsBeforeYield = dual(2, (self, scheduler2) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler2));
var currentConcurrency = globalValue(Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = globalValue(Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = globalValue(Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some3(logLevelDebug)));
var withUnhandledErrorLogLevel = dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = globalValue(Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty4()));
var metricLabels = fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = globalValue(Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = globalValue(Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty22, {
  fork: () => empty22,
  join: (parent, _) => parent
}));
var currentTracerEnabled = globalValue(Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = globalValue(Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = globalValue(Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty11()));
var currentTracerSpanLinks = globalValue(Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty7()));
var ScopeTypeId = Symbol.for("effect/Scope");
var CloseableScopeTypeId = Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self, finalizer3) => self.addFinalizer(() => asVoid2(finalizer3));
var scopeAddFinalizerExit = (self, finalizer3) => self.addFinalizer(finalizer3);
var scopeClose = (self, exit4) => self.close(exit4);
var scopeFork = (self, strategy) => self.fork(strategy);
var causeSquash = (self) => {
  return causeSquashWith(identity)(self);
};
var causeSquashWith = dual(2, (self, f2) => {
  const option11 = pipe(self, failureOption, map2(f2));
  switch (option11._tag) {
    case "None": {
      return pipe(defects(self), head3, match2({
        onNone: () => {
          const interrupts = fromIterable2(interruptors(self)).flatMap((fiberId5) => fromIterable2(ids2(fiberId5)).map((id3) => `#${id3}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option11.value;
    }
  }
});
var YieldableError = function() {
  class YieldableError4 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError4.prototype, StructuralCommitPrototype);
  return YieldableError4;
}();
var makeException = (proto16, tag5) => {
  class Base4 extends YieldableError {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag5);
    }
  }
  Object.assign(Base4.prototype, proto16);
  Base4.prototype.name = tag5;
  return Base4;
};
var RuntimeExceptionTypeId = Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
var InterruptedExceptionTypeId = Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var isIllegalArgumentException = (u) => hasProperty(u, IllegalArgumentExceptionTypeId);
var NoSuchElementExceptionTypeId = Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var isExceededCapacityException = (u) => hasProperty(u, ExceededCapacityExceptionTypeId);
var TimeoutExceptionTypeId = Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration5) => new TimeoutException(`Operation timed out after '${format3(duration5)}'`);
var isTimeoutException = (u) => hasProperty(u, TimeoutExceptionTypeId);
var UnknownExceptionTypeId = Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = function() {
  class UnknownException3 extends YieldableError {
    constructor(cause3, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause3
      });
      __publicField(this, "_tag", "UnknownException");
      __publicField(this, "error");
      this.error = cause3;
    }
  }
  Object.assign(UnknownException3.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException3;
}();
var isUnknownException = (u) => hasProperty(u, UnknownExceptionTypeId);
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self) => self._tag === "Failure";
var exitIsSuccess = (self) => self._tag === "Success";
var exitIsInterrupted = (self) => {
  switch (self._tag) {
    case OP_FAILURE:
      return isInterrupted(self.effect_instruction_i0);
    case OP_SUCCESS:
      return false;
  }
};
var exitAs = dual(2, (self, value10) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value10);
    }
  }
});
var exitAsVoid = (self) => exitAs(self, void 0);
var exitCauseOption = (self) => {
  switch (self._tag) {
    case OP_FAILURE:
      return some3(self.effect_instruction_i0);
    case OP_SUCCESS:
      return none2();
  }
};
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, (options == null ? void 0 : options.parallel) ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitExists = dual(2, (self, refinement) => {
  switch (self._tag) {
    case OP_FAILURE:
      return false;
    case OP_SUCCESS:
      return refinement(self.effect_instruction_i0);
  }
});
var exitFail = (error4) => exitFailCause(fail(error4));
var exitFailCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var exitFlatMap = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f2(self.effect_instruction_i0);
    }
  }
});
var exitFlatMapEffect = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return f2(self.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self) => pipe(self, exitFlatMap(identity));
var exitForEachEffect = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return exit(f2(self.effect_instruction_i0));
    }
  }
});
var exitFromEither = (either14) => {
  switch (either14._tag) {
    case "Left":
      return exitFail(either14.left);
    case "Right":
      return exitSucceed(either14.right);
  }
};
var exitFromOption = (option11) => {
  switch (option11._tag) {
    case "None":
      return exitFail(void 0);
    case "Some":
      return exitSucceed(option11.value);
  }
};
var exitGetOrElse = dual(2, (self, orElse24) => {
  switch (self._tag) {
    case OP_FAILURE:
      return orElse24(self.effect_instruction_i0);
    case OP_SUCCESS:
      return self.effect_instruction_i0;
  }
});
var exitInterrupt = (fiberId5) => exitFailCause(interrupt(fiberId5));
var exitMap = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f2(self.effect_instruction_i0));
  }
});
var exitMapBoth = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map13(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
var exitMapError = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map13(f2)));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
var exitMapErrorCause = dual(2, (self, f2) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(f2(self.effect_instruction_i0));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
var exitMatch = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = (value10) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value10;
  return effect4;
};
var exitVoid = exitSucceed(void 0);
var exitZip = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipLeft = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: sequential
}));
var exitZipRight = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipPar = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: parallel
}));
var exitZipParLeft = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: parallel
}));
var exitZipParRight = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: parallel
}));
var exitZipWith = dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable3(exits);
  if (!isNonEmpty2(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce3(pipe(headNonEmpty2(list), exitMap(of3)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
    onSuccess: (list2, value10) => pipe(list2, prepend3(value10)),
    onFailure: combineCauses
  }))), exitMap(reverse3), exitMap((chunk7) => toReadonlyArray(chunk7)), some3);
};
var deferredUnsafeMake = (fiberId5) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make15(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId5
  };
  return _deferred;
};
var deferredMake = () => flatMap12(fiberId, (id3) => deferredMakeAs(id3));
var deferredMakeAs = (fiberId5) => sync(() => deferredUnsafeMake(fiberId5));
var deferredAwait = (self) => asyncInterrupt((resume2) => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self, resume2);
    }
  }
}, self.blockingOn);
var deferredComplete = dual(2, (self, effect4) => intoDeferred(effect4, self));
var deferredCompleteWith = dual(2, (self, effect4) => sync(() => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set3(self.state, done(effect4));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect4);
      }
      return true;
    }
  }
}));
var deferredDone = dual(2, (self, exit4) => deferredCompleteWith(self, exit4));
var deferredFail = dual(2, (self, error4) => deferredCompleteWith(self, fail2(error4)));
var deferredFailSync = dual(2, (self, evaluate4) => deferredCompleteWith(self, failSync(evaluate4)));
var deferredFailCause = dual(2, (self, cause3) => deferredCompleteWith(self, failCause(cause3)));
var deferredFailCauseSync = dual(2, (self, evaluate4) => deferredCompleteWith(self, failCauseSync(evaluate4)));
var deferredDie = dual(2, (self, defect) => deferredCompleteWith(self, die2(defect)));
var deferredDieSync = dual(2, (self, evaluate4) => deferredCompleteWith(self, dieSync(evaluate4)));
var deferredInterrupt = (self) => flatMap12(fiberId, (fiberId5) => deferredCompleteWith(self, interruptWith(fiberId5)));
var deferredInterruptWith = dual(2, (self, fiberId5) => deferredCompleteWith(self, interruptWith(fiberId5)));
var deferredIsDone = (self) => sync(() => get7(self.state)._tag === OP_STATE_DONE);
var deferredPoll = (self) => sync(() => {
  const state = get7(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some3(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
});
var deferredSucceed = dual(2, (self, value10) => deferredCompleteWith(self, succeed(value10)));
var deferredSync = dual(2, (self, evaluate4) => deferredCompleteWith(self, sync(evaluate4)));
var deferredUnsafeDone = (self, effect4) => {
  const state = get7(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set3(self.state, done(effect4));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect4);
    }
  }
};
var deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get7(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index3 = state.joiners.indexOf(joiner);
    if (index3 >= 0) {
      state.joiners.splice(index3, 1);
    }
  }
});
var constContext = withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context2 = () => constContext;
var contextWithEffect = (f2) => flatMap12(context2(), f2);
var provideContext = dual(2, (self, context15) => fiberRefLocally(currentContext, context15)(self));
var provideSomeContext = dual(2, (self, context15) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context15))(self));
var mapInputContext = dual(2, (self, f2) => contextWithEffect((context15) => provideContext(self, f2(context15))));
var filterEffectOrElse = dual(2, (self, options) => flatMap12(self, (a) => flatMap12(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = dual(2, (self, options) => filterEffectOrElse(self, {
  predicate: options.predicate,
  orElse: (a) => fail2(options.orFailWith(a))
}));
var currentSpanFromFiber = (fiber) => {
  const span4 = fiber.currentSpan;
  return span4 !== void 0 && span4._tag === "Span" ? some3(span4) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: BigInt(0),
    endTime: BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

// node_modules/effect/dist/esm/Deferred.js
var DeferredTypeId2 = DeferredTypeId;
var make24 = deferredMake;
var makeAs = deferredMakeAs;
var _await = deferredAwait;
var complete = deferredComplete;
var completeWith = deferredCompleteWith;
var done2 = deferredDone;
var fail3 = deferredFail;
var failSync2 = deferredFailSync;
var failCause2 = deferredFailCause;
var failCauseSync2 = deferredFailCauseSync;
var die3 = deferredDie;
var dieSync2 = deferredDieSync;
var interrupt3 = deferredInterrupt;
var interruptWith2 = deferredInterruptWith;
var isDone = deferredIsDone;
var poll = deferredPoll;
var succeed2 = deferredSucceed;
var sync2 = deferredSync;
var unsafeMake4 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// node_modules/effect/dist/esm/Exit.js
var Exit_exports = {};
__export(Exit_exports, {
  all: () => all7,
  as: () => as4,
  asVoid: () => asVoid3,
  causeOption: () => causeOption,
  die: () => die4,
  exists: () => exists2,
  fail: () => fail4,
  failCause: () => failCause3,
  flatMap: () => flatMap13,
  flatMapEffect: () => flatMapEffect,
  flatten: () => flatten9,
  forEachEffect: () => forEachEffect,
  fromEither: () => fromEither,
  fromOption: () => fromOption4,
  getOrElse: () => getOrElse7,
  interrupt: () => interrupt4,
  isExit: () => isExit,
  isFailure: () => isFailure2,
  isInterrupted: () => isInterrupted2,
  isSuccess: () => isSuccess,
  map: () => map15,
  mapBoth: () => mapBoth4,
  mapError: () => mapError2,
  mapErrorCause: () => mapErrorCause,
  match: () => match7,
  matchEffect: () => matchEffect2,
  succeed: () => succeed3,
  void: () => void_4,
  zip: () => zip6,
  zipLeft: () => zipLeft3,
  zipPar: () => zipPar,
  zipParLeft: () => zipParLeft,
  zipParRight: () => zipParRight,
  zipRight: () => zipRight3,
  zipWith: () => zipWith7
});
var isExit = exitIsExit;
var isFailure2 = exitIsFailure;
var isSuccess = exitIsSuccess;
var isInterrupted2 = exitIsInterrupted;
var as4 = exitAs;
var asVoid3 = exitAsVoid;
var causeOption = exitCauseOption;
var all7 = exitCollectAll;
var die4 = exitDie;
var exists2 = exitExists;
var fail4 = exitFail;
var failCause3 = exitFailCause;
var flatMap13 = exitFlatMap;
var flatMapEffect = exitFlatMapEffect;
var flatten9 = exitFlatten;
var forEachEffect = exitForEachEffect;
var fromEither = exitFromEither;
var fromOption4 = exitFromOption;
var getOrElse7 = exitGetOrElse;
var interrupt4 = exitInterrupt;
var map15 = exitMap;
var mapBoth4 = exitMapBoth;
var mapError2 = exitMapError;
var mapErrorCause = exitMapErrorCause;
var match7 = exitMatch;
var matchEffect2 = exitMatchEffect;
var succeed3 = exitSucceed;
var void_4 = exitVoid;
var zip6 = exitZip;
var zipLeft3 = exitZipLeft;
var zipRight3 = exitZipRight;
var zipPar = exitZipPar;
var zipParLeft = exitZipParLeft;
var zipParRight = exitZipParRight;
var zipWith7 = exitZipWith;

// node_modules/effect/dist/esm/MutableHashMap.js
var MutableHashMap_exports = {};
__export(MutableHashMap_exports, {
  clear: () => clear,
  empty: () => empty23,
  forEach: () => forEach9,
  fromIterable: () => fromIterable9,
  get: () => get9,
  has: () => has6,
  isEmpty: () => isEmpty8,
  keys: () => keys4,
  make: () => make25,
  modify: () => modify6,
  modifyAt: () => modifyAt3,
  remove: () => remove8,
  set: () => set5,
  size: () => size13,
  values: () => values6
});
var TypeId11 = Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "referentialIterator");
    __publicField(this, "bucketIterator");
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  constructor(backing) {
    __publicField(this, "backing");
    __publicField(this, "currentBucket");
    this.backing = backing;
  }
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty23 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
};
var make25 = (...entries6) => fromIterable9(entries6);
var fromIterable9 = (entries6) => {
  const self = empty23();
  for (const [key, value10] of entries6) {
    set5(self, key, value10);
  }
  return self;
};
var get9 = dual(2, (self, key) => {
  if (isEqual2(key) === false) {
    return self.referential.has(key) ? some3(self.referential.get(key)) : none2();
  }
  const hash11 = key[symbol2]();
  const bucket = self.buckets.get(hash11);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var keys4 = (self) => {
  const keys15 = Array.from(self.referential.keys());
  for (const bucket of self.buckets.values()) {
    for (let i = 0, len = bucket.length; i < len; i++) {
      keys15.push(bucket[i][0]);
    }
  }
  return keys15;
};
var values6 = (self) => {
  const values15 = Array.from(self.referential.values());
  for (const bucket of self.buckets.values()) {
    for (let i = 0, len = bucket.length; i < len; i++) {
      values15.push(bucket[i][1]);
    }
  }
  return values15;
};
var getFromBucket = (self, bucket, key, remove21 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol3](bucket[i][0])) {
      const value10 = bucket[i][1];
      if (remove21) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some3(value10);
    }
  }
  return none2();
};
var has6 = dual(2, (self, key) => isSome2(get9(self, key)));
var set5 = dual(3, (self, key, value10) => {
  if (isEqual2(key) === false) {
    self.referential.set(key, value10);
    return self;
  }
  const hash11 = key[symbol2]();
  const bucket = self.buckets.get(hash11);
  if (bucket === void 0) {
    self.buckets.set(hash11, [[key, value10]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value10]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol3](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};
var modify6 = dual(3, (self, key, f2) => {
  if (isEqual2(key) === false) {
    if (self.referential.has(key)) {
      self.referential.set(key, f2(self.referential.get(key)));
    }
    return self;
  }
  const hash11 = key[symbol2]();
  const bucket = self.buckets.get(hash11);
  if (bucket === void 0) {
    return self;
  }
  const value10 = getFromBucket(self, bucket, key, true);
  if (isNone2(value10)) {
    return self;
  }
  bucket.push([key, f2(value10.value)]);
  self.bucketsSize++;
  return self;
});
var modifyAt3 = dual(3, (self, key, f2) => {
  if (isEqual2(key) === false) {
    const result2 = f2(get9(self, key));
    if (isSome2(result2)) {
      set5(self, key, result2.value);
    } else {
      remove8(self, key);
    }
    return self;
  }
  const hash11 = key[symbol2]();
  const bucket = self.buckets.get(hash11);
  if (bucket === void 0) {
    const result2 = f2(none2());
    return isSome2(result2) ? set5(self, key, result2.value) : self;
  }
  const result = f2(getFromBucket(self, bucket, key, true));
  if (isNone2(result)) {
    if (bucket.length === 0) {
      self.buckets.delete(hash11);
    }
    return self;
  }
  bucket.push([key, result.value]);
  self.bucketsSize++;
  return self;
});
var remove8 = dual(2, (self, key) => {
  if (isEqual2(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash11 = key[symbol2]();
  const bucket = self.buckets.get(hash11);
  if (bucket === void 0) {
    return self;
  }
  removeFromBucket(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash11);
  }
  return self;
});
var clear = (self) => {
  self.referential.clear();
  self.buckets.clear();
  self.bucketsSize = 0;
  return self;
};
var size13 = (self) => {
  return self.referential.size + self.bucketsSize;
};
var isEmpty8 = (self) => size13(self) === 0;
var forEach9 = dual(2, (self, f2) => {
  self.referential.forEach(f2);
  for (const bucket of self.buckets.values()) {
    for (const [key, value10] of bucket) {
      f2(value10, key);
    }
  }
});

// node_modules/effect/dist/esm/MutableQueue.js
var MutableQueue_exports = {};
__export(MutableQueue_exports, {
  EmptyMutableQueue: () => EmptyMutableQueue,
  bounded: () => bounded,
  capacity: () => capacity,
  isEmpty: () => isEmpty10,
  isFull: () => isFull,
  length: () => length3,
  offer: () => offer,
  offerAll: () => offerAll,
  poll: () => poll2,
  pollUpTo: () => pollUpTo,
  unbounded: () => unbounded
});

// node_modules/effect/dist/esm/MutableList.js
var MutableList_exports = {};
__export(MutableList_exports, {
  append: () => append5,
  empty: () => empty24,
  forEach: () => forEach10,
  fromIterable: () => fromIterable10,
  head: () => head5,
  isEmpty: () => isEmpty9,
  length: () => length2,
  make: () => make26,
  pop: () => pop2,
  prepend: () => prepend5,
  reset: () => reset,
  shift: () => shift,
  tail: () => tail4
});
var TypeId12 = Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId12]: TypeId12,
  [Symbol.iterator]() {
    let done17 = false;
    let head13 = this.head;
    return {
      next() {
        if (done17) {
          return this.return();
        }
        if (head13 == null) {
          done17 = true;
          return this.return();
        }
        const value10 = head13.value;
        head13 = head13.next;
        return {
          done: done17,
          value: value10
        };
      },
      return(value10) {
        if (!done17) {
          done17 = true;
        }
        return {
          done: true,
          value: value10
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value10) => ({
  value: value10,
  removed: false,
  prev: void 0,
  next: void 0
});
var empty24 = () => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
};
var fromIterable10 = (iterable) => {
  const list = empty24();
  for (const element2 of iterable) {
    append5(list, element2);
  }
  return list;
};
var make26 = (...elements) => fromIterable10(elements);
var isEmpty9 = (self) => length2(self) === 0;
var length2 = (self) => self._length;
var tail4 = (self) => self.tail === void 0 ? void 0 : self.tail.value;
var head5 = (self) => self.head === void 0 ? void 0 : self.head.value;
var forEach10 = dual(2, (self, f2) => {
  let current2 = self.head;
  while (current2 !== void 0) {
    f2(current2.value);
    current2 = current2.next;
  }
});
var reset = (self) => {
  ;
  self._length = 0;
  self.head = void 0;
  self.tail = void 0;
  return self;
};
var append5 = dual(2, (self, value10) => {
  const node = makeNode(value10);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var shift = (self) => {
  const head13 = self.head;
  if (head13 !== void 0) {
    remove9(self, head13);
    return head13.value;
  }
  return void 0;
};
var pop2 = (self) => {
  const tail5 = self.tail;
  if (tail5 !== void 0) {
    remove9(self, tail5);
    return tail5.value;
  }
  return void 0;
};
var prepend5 = dual(2, (self, value10) => {
  const node = makeNode(value10);
  node.next = self.head;
  if (self.head !== void 0) {
    self.head.prev = node;
  }
  self.head = node;
  if (self.tail === void 0) {
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var remove9 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
};

// node_modules/effect/dist/esm/MutableQueue.js
var TypeId13 = Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId13]: TypeId13,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make27 = (capacity10) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty24();
  queue.capacity = capacity10;
  return queue;
};
var bounded = (capacity10) => make27(capacity10);
var unbounded = () => make27(void 0);
var length3 = (self) => length2(self.queue);
var isEmpty10 = (self) => isEmpty9(self.queue);
var isFull = (self) => self.capacity === void 0 ? false : length2(self.queue) === self.capacity;
var capacity = (self) => self.capacity === void 0 ? Infinity : self.capacity;
var offer = dual(2, (self, value10) => {
  const queueLength = length2(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append5(value10)(self.queue);
  return true;
});
var offerAll = dual(2, (self, values15) => {
  const iterator = values15[Symbol.iterator]();
  let next6;
  let remainder3 = empty7();
  let offering = true;
  while (offering && (next6 = iterator.next()) && !next6.done) {
    offering = offer(next6.value)(self);
  }
  while (next6 != null && !next6.done) {
    remainder3 = prepend3(next6.value)(remainder3);
    next6 = iterator.next();
  }
  return reverse3(remainder3);
});
var poll2 = dual(2, (self, def) => {
  if (isEmpty9(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
var pollUpTo = dual(2, (self, n) => {
  let result = empty7();
  let count9 = 0;
  while (count9 < n) {
    const element2 = poll2(EmptyMutableQueue)(self);
    if (element2 === EmptyMutableQueue) {
      break;
    }
    result = prepend3(element2)(result);
    count9 += 1;
  }
  return reverse3(result);
});

// node_modules/effect/dist/esm/Clock.js
var Clock_exports = {};
__export(Clock_exports, {
  Clock: () => Clock,
  ClockTypeId: () => ClockTypeId2,
  clockWith: () => clockWith2,
  currentTimeMillis: () => currentTimeMillis2,
  currentTimeNanos: () => currentTimeNanos2,
  make: () => make32,
  sleep: () => sleep2
});

// node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = Symbol.for(ClockSymbolKey);
var clockTag = GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration5) {
    const millis2 = toMillis(duration5);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = function() {
  const bigint1e62 = BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = performanceNowNanos() - processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
var _a13;
_a13 = ClockTypeId;
var ClockImpl = class {
  constructor() {
    __publicField(this, _a13, ClockTypeId);
    __publicField(this, "currentTimeMillis", sync(() => this.unsafeCurrentTimeMillis()));
    __publicField(this, "currentTimeNanos", sync(() => this.unsafeCurrentTimeNanos()));
  }
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration5) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_3), duration5);
      return asVoid2(sync(canceler));
    });
  }
};
var make28 = () => new ClockImpl();

// node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_AND;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error4, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error4;
};
var Or = (self, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_OR;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error4, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error4;
};
var InvalidData = (path2, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_INVALID_DATA;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var MissingData = (path2, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_MISSING_DATA;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var SourceUnavailable = (path2, message, cause3, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_SOURCE_UNAVAILABLE;
  error4.path = path2;
  error4.message = message;
  error4.cause = cause3;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var Unsupported = (path2, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_UNSUPPORTED;
  error4.path = path2;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path3 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path3}: "${this.message}")`;
    }
  });
  return error4;
};
var isConfigError = (u) => hasProperty(u, ConfigErrorTypeId);
var isAnd = (self) => self._op === OP_AND;
var isOr = (self) => self._op === OP_OR;
var isInvalidData = (self) => self._op === OP_INVALID_DATA;
var isMissingData = (self) => self._op === OP_MISSING_DATA;
var isSourceUnavailable = (self) => self._op === OP_SOURCE_UNAVAILABLE;
var isUnsupported = (self) => self._op === OP_UNSUPPORTED;
var prefixed = dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_, left3, right3) => left3 && right3,
  orCase: (_, left3, right3) => left3 && right3,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = dual(3, (self, context15, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const error4 = input.pop();
    switch (error4._op) {
      case OP_AND: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context15, error4.path, error4.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context15, error4.path, error4.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context15, error4.path, error4.message, error4.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context15, error4.path, error4.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either14 = output.pop();
    switch (either14._op) {
      case "Left": {
        switch (either14.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value10 = reducer.andCase(context15, left3, right3);
            accumulator.push(value10);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value10 = reducer.orCase(context15, left3, right3);
            accumulator.push(value10);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either14.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self) => reduceWithContext2(self, void 0, IsMissingDataOnlyReducer);

// node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty25 = {
  _tag: "Empty"
};
var andThen7 = dual(2, (self, that) => ({
  _tag: "AndThen",
  first: self,
  second: that
}));
var mapName = dual(2, (self, f2) => andThen7(self, {
  _tag: "MapName",
  f: f2
}));
var nested = dual(2, (self, name) => andThen7(self, {
  _tag: "Nested",
  name
}));
var unnested = dual(2, (self, name) => andThen7(self, {
  _tag: "Unnested",
  name
}));
var patch8 = dual(2, (path2, patch14) => {
  let input = of4(patch14);
  let output = path2;
  while (isCons(input)) {
    const patch15 = input.head;
    switch (patch15._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch15.first, cons(patch15.second, input.tail));
        break;
      }
      case "MapName": {
        output = map6(output, patch15.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend2(output, patch15.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head2(output), contains(patch15.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch15.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/effect/dist/esm/internal/string-utils.js
var lowerCase = (str) => str.toLowerCase();
var upperCase = (str) => str.toUpperCase();
var replace4 = (input, re, value10) => re instanceof RegExp ? input.replace(re, value10) : re.reduce((input2, re2) => input2.replace(re2, value10), input);
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
var noCase = (input, options = {}) => {
  const {
    delimiter = " ",
    splitRegexp = DEFAULT_SPLIT_REGEXP,
    stripRegexp = DEFAULT_STRIP_REGEXP,
    transform: transform10 = lowerCase
  } = options;
  const result = replace4(replace4(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  let start5 = 0;
  let end7 = result.length;
  while (result.charAt(start5) === "\0") {
    start5++;
  }
  while (result.charAt(end7 - 1) === "\0") {
    end7--;
  }
  return result.slice(start5, end7).split("\0").map(transform10).join(delimiter);
};
var constantCase = (input, options) => noCase(input, {
  delimiter: "_",
  transform: upperCase,
  ...options
});
var kebabCase = (input, options) => noCase(input, {
  delimiter: "-",
  ...options
});
var snakeCase = (input, options) => noCase(input, {
  delimiter: "_",
  ...options
});

// node_modules/effect/dist/esm/internal/configProvider.js
var concat4 = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = Symbol.for(FlatConfigProviderSymbolKey);
var make29 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path2, config2, split8 = true) => options.load(path2, config2, split8),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make29({
  load: (config2) => flatMap12(fromFlatLoop(flat, empty4(), config2, false), (chunk7) => match2(head2(chunk7), {
    onNone: () => fail2(MissingData(empty4(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path2) => pipe(path2, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path2, primitive3, split8 = true) => {
    const pathString = makePathString(path2);
    const current2 = getEnv();
    const valueOpt = pathString in current2 ? some3(current2[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path2, `Expected ${pathString} to exist in the process context`)), flatMap12((value10) => parsePrimitive(value10, path2, primitive3, seqDelim, split8)));
  };
  const enumerateChildren = (path2) => sync(() => {
    const current2 = getEnv();
    const keys15 = Object.keys(current2);
    const keyPaths = keys15.map((value10) => unmakePathString(value10.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path2.length; i++) {
        const pathComponent = pipe(path2, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path2.length, path2.length + 1));
    return fromIterable6(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty25
  }));
};
var fromMap = (map49, config2) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({
    seqDelim: ",",
    pathDelim: "."
  }, config2);
  const makePathString = (path2) => pipe(path2, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const mapWithIndexSplit = splitIndexInKeys(map49, (str) => unmakePathString(str), makePathString);
  const load = (path2, primitive3, split8 = true) => {
    const pathString = makePathString(path2);
    const valueOpt = mapWithIndexSplit.has(pathString) ? some3(mapWithIndexSplit.get(pathString)) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path2, `Expected ${pathString} to exist in the provided map`)), flatMap12((value10) => parsePrimitive(value10, path2, primitive3, seqDelim, split8)));
  };
  const enumerateChildren = (path2) => sync(() => {
    const keyPaths = fromIterable2(mapWithIndexSplit.keys()).map(unmakePathString);
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path2.length; i++) {
        const pathComponent = pipe(path2, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path2.length, path2.length + 1));
    return fromIterable6(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty25
  }));
};
var extend2 = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold2(left3.length, (index3) => index3 >= right3.length ? none2() : some3([leftDef(index3), index3 + 1]));
  const rightPad = unfold2(right3.length, (index3) => index3 >= left3.length ? none2() : some3([rightDef(index3), index3 + 1]));
  const leftExtension = concat4(left3, leftPad);
  const rightExtension = concat4(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path2, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out = path2.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path2;
};
var fromFlatLoop = (flat, prefix, config2, split8) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of2(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split8));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split8)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split8), catchAll((error22) => fail2(Or(error1, error22))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split8));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split8), flatMap12(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat4(prefix, of2(op.name)), op.config, split8));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap12((prefix2) => pipe(flat.load(prefix2, op, split8), flatMap12((values15) => {
        if (values15.length === 0) {
          const name = pipe(last(prefix2), getOrElse2(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values15);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap12((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap12(indicesFrom), flatMap12((indices) => {
        if (indices.length === 0) {
          return suspend(() => map14(fromFlatLoop(flat, prefix, op.config, true), of2));
        }
        return pipe(forEachSequential(indices, (index3) => fromFlatLoop(flat, append2(prefix, `[${index3}]`), op.config, true)), map14((chunkChunk) => {
          const flattened = flatten3(chunkChunk);
          if (flattened.length === 0) {
            return of2(empty4());
          }
          return of2(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap12((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap12((keys15) => {
        return pipe(keys15, forEachSequential((key) => fromFlatLoop(flat, concat4(prefix2, of2(key)), op.valueConfig, split8)), map14((matrix) => {
          if (matrix.length === 0) {
            return of2(empty11());
          }
          return pipe(transpose(matrix), map6((values15) => fromIterable7(zip2(fromIterable2(keys15), values15))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split8), either3, flatMap12((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split8), either3, flatMap12((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path2 = pipe(prefix, join("."));
          const fail30 = fromFlatLoopFail(prefix, path2);
          const [lefts, rights] = extend2(fail30, fail30, pipe(left3.right, map6(right2)), pipe(right3.right, map6(right2)));
          return pipe(lefts, zip2(rights), forEachSequential(([left4, right4]) => pipe(zip5(left4, right4), map14(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path2) => (index3) => left2(MissingData(prefix, `The element at index ${index3} in a sequence at path "${path2}" was missing`));
var mapInputPath = dual(2, (self, f2) => fromFlat(mapInputPathFlat(self.flattened, f2)));
var mapInputPathFlat = (self, f2) => makeFlat({
  load: (path2, config2, split8 = true) => self.load(path2, config2, split8),
  enumerateChildren: (path2) => self.enumerateChildren(path2),
  patch: mapName(self.patch, f2)
});
var nested2 = dual(2, (self, name) => fromFlat(makeFlat({
  load: (path2, config2) => self.flattened.load(path2, config2, true),
  enumerateChildren: (path2) => self.flattened.enumerateChildren(path2),
  patch: nested(self.flattened.patch, name)
})));
var unnested2 = dual(2, (self, name) => fromFlat(makeFlat({
  load: (path2, config2) => self.flattened.load(path2, config2, true),
  enumerateChildren: (path2) => self.flattened.enumerateChildren(path2),
  patch: unnested(self.flattened.patch, name)
})));
var orElse4 = dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));
var orElseFlat = (self, that) => makeFlat({
  load: (path2, config2, split8) => pipe(patch8(path2, self.patch), flatMap12((patch14) => self.load(patch14, config2, split8)), catchAll((error1) => pipe(sync(that), flatMap12((that2) => pipe(patch8(path2, that2.patch), flatMap12((patch14) => that2.load(patch14, config2, split8)), catchAll((error22) => fail2(Or(error1, error22)))))))),
  enumerateChildren: (path2) => pipe(patch8(path2, self.patch), flatMap12((patch14) => self.enumerateChildren(patch14)), either3, flatMap12((left3) => pipe(sync(that), flatMap12((that2) => pipe(patch8(path2, that2.patch), flatMap12((patch14) => that2.enumerateChildren(patch14)), either3, flatMap12((right3) => {
    if (isLeft2(left3) && isLeft2(right3)) {
      return fail2(And(left3.left, right3.left));
    }
    if (isLeft2(left3) && isRight2(right3)) {
      return succeed(right3.right);
    }
    if (isRight2(left3) && isLeft2(right3)) {
      return succeed(left3.right);
    }
    if (isRight2(left3) && isRight2(right3)) {
      return succeed(pipe(left3.right, union6(right3.right)));
    }
    throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
  })))))),
  patch: empty25
});
var constantCase2 = (self) => mapInputPath(self, constantCase);
var kebabCase2 = (self) => mapInputPath(self, kebabCase);
var lowerCase2 = (self) => mapInputPath(self, lowerCase);
var snakeCase2 = (self) => mapInputPath(self, snakeCase);
var upperCase2 = (self) => mapInputPath(self, upperCase);
var within = dual(3, (self, path2, f2) => {
  const unnest = reduce3(path2, self, (provider, name) => unnested2(provider, name));
  const nest = reduceRight(path2, f2(unnest), (provider, name) => nested2(provider, name));
  return orElse4(nest, () => self);
});
var splitPathString = (text, delim) => {
  const split8 = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split8;
};
var parsePrimitive = (text, path2, primitive3, delimiter, split8) => {
  if (!split8) {
    return pipe(primitive3.parse(text), mapBoth3({
      onFailure: prefixed(path2),
      onSuccess: of2
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char2) => primitive3.parse(char2.trim())), mapError(prefixed(path2)));
};
var transpose = (array8) => {
  return Object.keys(array8[0]).map((column) => array8.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth3({
  onFailure: () => empty4(),
  onSuccess: sort(Order)
}), either3, map14(merge));
var STR_INDEX_REGEX = /(^.+)(\[(\d+)\])$/;
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match43 = str.match(QUOTED_INDEX_REGEX);
  if (match43 !== null) {
    const matchedIndex = match43[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some3(matchedIndex) : none2(), flatMap2(parseInteger));
  }
  return none2();
};
var splitIndexInKeys = (map49, unmakePathString, makePathString) => {
  const newMap = /* @__PURE__ */ new Map();
  for (const [pathString, value10] of map49) {
    const keyWithIndex = pipe(unmakePathString(pathString), flatMap4((key) => match2(splitIndexFrom(key), {
      onNone: () => of2(key),
      onSome: ([key2, index3]) => make4(key2, `[${index3}]`)
    })));
    newMap.set(makePathString(keyWithIndex), value10);
  }
  return newMap;
};
var splitIndexFrom = (key) => {
  const match43 = key.match(STR_INDEX_REGEX);
  if (match43 !== null) {
    const matchedString = match43[1];
    const matchedIndex = match43[3];
    const optionalString = matchedString !== void 0 && matchedString.length > 0 ? some3(matchedString) : none2();
    const optionalIndex = pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some3(matchedIndex) : none2(), flatMap2(parseInteger));
    return all5([optionalString, optionalIndex]);
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some3(parsedIndex);
};
var keyName = (name) => ({
  _tag: "KeyName",
  name
});
var keyIndex = (index3) => ({
  _tag: "KeyIndex",
  index: index3
});
var fromJson = (json3) => {
  const hiddenDelimiter = "\uFEFF";
  const indexedEntries = map6(getIndexedEntries(json3), ([key, value10]) => [configPathToString(key).join(hiddenDelimiter), value10]);
  return fromMap(new Map(indexedEntries), {
    pathDelim: hiddenDelimiter,
    seqDelim: hiddenDelimiter
  });
};
var configPathToString = (path2) => {
  const output = [];
  let i = 0;
  while (i < path2.length) {
    const component = path2[i];
    if (component._tag === "KeyName") {
      if (i + 1 < path2.length) {
        const nextComponent = path2[i + 1];
        if (nextComponent._tag === "KeyIndex") {
          output.push(`${component.name}[${nextComponent.index}]`);
          i += 2;
        } else {
          output.push(component.name);
          i += 1;
        }
      } else {
        output.push(component.name);
        i += 1;
      }
    }
  }
  return output;
};
var getIndexedEntries = (config2) => {
  const loopAny = (path2, value10) => {
    if (typeof value10 === "string") {
      return make4([path2, value10]);
    }
    if (typeof value10 === "number" || typeof value10 === "boolean") {
      return make4([path2, String(value10)]);
    }
    if (isArray(value10)) {
      return loopArray(path2, value10);
    }
    if (typeof value10 === "object" && value10 !== null) {
      return loopObject(path2, value10);
    }
    return empty4();
  };
  const loopArray = (path2, values15) => match3(values15, {
    onEmpty: () => make4([path2, "<nil>"]),
    onNonEmpty: flatMap4((value10, index3) => loopAny(append2(path2, keyIndex(index3)), value10))
  });
  const loopObject = (path2, value10) => Object.entries(value10).filter(([, value11]) => isNotNullable(value11)).flatMap(([key, value11]) => {
    const newPath = append2(path2, keyName(key));
    const result = loopAny(newPath, value11);
    if (isEmptyReadonlyArray(result)) {
      return make4([newPath, ""]);
    }
    return result;
  });
  return loopObject(empty4(), config2);
};

// node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId14 = Symbol.for("effect/Console");
var consoleTag = GenericTag("effect/Console");
var defaultConsole = {
  [TypeId14]: TypeId14,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options) {
    return (options == null ? void 0 : options.collapsed) ? sync(() => console.groupCollapsed(options == null ? void 0 : options.label)) : sync(() => console.group(options == null ? void 0 : options.label));
  },
  groupEnd: sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = Symbol.for(RandomSymbolKey);
var randomTag = GenericTag("effect/Random");
var _a14;
_a14 = RandomTypeId;
var RandomImpl = class {
  constructor(seed) {
    __publicField(this, "seed");
    __publicField(this, _a14, RandomTypeId);
    __publicField(this, "PRNG");
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map14(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min11, max14) {
    return map14(this.next, (n) => (max14 - min11) * n + min11);
  }
  nextIntBetween(min11, max14) {
    return sync(() => this.PRNG.integer(max14 - min11) + min11);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap12((buffer7) => {
    const numbers = [];
    for (let i = buffer7.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map14((k) => swap2(buffer7, n - 1, k)))), as3(fromIterable3(buffer7)));
  })));
};
var swap2 = (buffer7, index1, index22) => {
  const tmp = buffer7[index1];
  buffer7[index1] = buffer7[index22];
  buffer7[index22] = tmp;
  return buffer7;
};
var make30 = (seed) => new RandomImpl(hash(seed));

// node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = Symbol.for("effect/Tracer");
var make31 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = GenericTag("effect/Tracer");
var spanTag = GenericTag("effect/ParentSpan");
var randomHexString = function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length6) {
    let result = "";
    for (let i = 0; i < length6; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
var NativeSpan = class {
  constructor(name, parent, context15, links, startTime, kind) {
    __publicField(this, "name");
    __publicField(this, "parent");
    __publicField(this, "context");
    __publicField(this, "startTime");
    __publicField(this, "kind");
    __publicField(this, "_tag", "Span");
    __publicField(this, "spanId");
    __publicField(this, "traceId", "native");
    __publicField(this, "sampled", true);
    __publicField(this, "status");
    __publicField(this, "attributes");
    __publicField(this, "events", []);
    __publicField(this, "links");
    this.name = name;
    this.parent = parent;
    this.context = context15;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
  }
  attribute(key, value10) {
    this.attributes.set(key, value10);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = make31({
  span: (name, parent, context15, links, startTime, kind) => new NativeSpan(name, parent, context15, links, startTime, kind),
  context: (f2) => f2()
});
var externalSpan = (options) => ({
  _tag: "ExternalSpan",
  spanId: options.spanId,
  traceId: options.traceId,
  sampled: options.sampled ?? true,
  context: options.context ?? empty6()
});
var addSpanStackTrace = (options) => {
  if ((options == null ? void 0 : options.captureStackTrace) === false) {
    return options;
  } else if ((options == null ? void 0 : options.captureStackTrace) !== void 0 && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit2;
  let cache = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = pipe(empty6(), add3(clockTag, make28()), add3(consoleTag, defaultConsole), add3(randomTag, make30(Math.random())), add3(configProviderTag, fromEnv()), add3(tracerTag, nativeTracer));
var currentServices = globalValue(Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration5) => {
  const decodedDuration = decode(duration5);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
};
var defaultServicesWith = (f2) => withFiberRuntime((fiber) => f2(fiber.currentDefaultServices));
var clockWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = clockWith((clock3) => clock3.currentTimeMillis);
var currentTimeNanos = clockWith((clock3) => clock3.currentTimeNanos);
var withClock = dual(2, (effect4, c) => fiberRefLocallyWith(currentServices, add3(clockTag, c))(effect4));
var withConfigProvider = dual(2, (self, provider) => fiberRefLocallyWith(currentServices, add3(configProviderTag, provider))(self));
var configProviderWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_) => _.load(config2));
var randomWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(randomTag.key)));
var withRandom = dual(2, (effect4, value10) => fiberRefLocallyWith(currentServices, add3(randomTag, value10))(effect4));
var next = randomWith((random6) => random6.next);
var nextInt = randomWith((random6) => random6.nextInt);
var nextBoolean = randomWith((random6) => random6.nextBoolean);
var nextRange = (min11, max14) => randomWith((random6) => random6.nextRange(min11, max14));
var nextIntBetween = (min11, max14) => randomWith((random6) => random6.nextIntBetween(min11, max14));
var shuffle = (elements) => randomWith((random6) => random6.shuffle(elements));
var choice = (elements) => {
  const array8 = fromIterable2(elements);
  return map14(array8.length === 0 ? fail2(new NoSuchElementException("Cannot select a random element from an empty array")) : randomWith((random6) => random6.nextIntBetween(0, array8.length)), (i) => array8[i]);
};
var tracerWith = (f2) => defaultServicesWith((services) => f2(services.unsafeMap.get(tracerTag.key)));
var withTracer = dual(2, (effect4, value10) => fiberRefLocallyWith(currentServices, add3(tracerTag, value10))(effect4));

// node_modules/effect/dist/esm/Clock.js
var ClockTypeId2 = ClockTypeId;
var make32 = make28;
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// node_modules/effect/dist/esm/FiberRefs.js
var FiberRefs_exports = {};
__export(FiberRefs_exports, {
  FiberRefsSym: () => FiberRefsSym2,
  delete: () => delete_2,
  empty: () => empty27,
  fiberRefs: () => fiberRefs2,
  forkAs: () => forkAs2,
  get: () => get11,
  getOrDefault: () => getOrDefault2,
  joinAs: () => joinAs2,
  setAll: () => setAll2,
  unsafeMake: () => unsafeMake6,
  updateAs: () => updateAs2,
  updateManyAs: () => updateManyAs2
});

// node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty26() {
  return unsafeMake5(/* @__PURE__ */ new Map());
}
var FiberRefsSym = Symbol.for("effect/FiberRefs");
var _a15;
_a15 = FiberRefsSym;
var FiberRefsImpl = class {
  constructor(locals) {
    __publicField(this, "locals");
    __publicField(this, _a15, FiberRefsSym);
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = dual(3, (self, fiberId5, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol3](fiberId5)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId5, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch14 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch14)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol3](fiberId5)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId5, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = dual(2, (self, childId) => {
  const map49 = /* @__PURE__ */ new Map();
  unsafeForkAs(self, map49, childId);
  return new FiberRefsImpl(map49);
});
var unsafeForkAs = (self, map49, fiberId5) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map49.set(fiberRef, stack);
    } else {
      map49.set(fiberRef, [[fiberId5, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self) => fromIterable6(self.locals.keys());
var setAll = (self) => forEachSequentialDiscard(fiberRefs(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self, fiberRef)));
var delete_ = dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get10 = dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some3(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = dual(2, (self, fiberRef) => pipe(get10(self, fiberRef), getOrElse2(() => fiberRef.initial)));
var updateAs = dual(2, (self, {
  fiberId: fiberId5,
  fiberRef,
  value: value10
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId5, value10]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId5, fiberRef, value10);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId5, fiberRef, value10) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol3](fiberId5)) {
      if (equals(currentValue, value10)) {
        return;
      } else {
        newStack = [[fiberId5, value10], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId5, value10], ...oldStack];
    }
  } else {
    newStack = [[fiberId5, value10]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = dual(2, (self, {
  entries: entries6,
  forkAs: forkAs3
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries6));
  }
  const locals = new Map(self.locals);
  if (forkAs3 !== void 0) {
    unsafeForkAs(self, locals, forkAs3);
  }
  entries6.forEach(([fiberRef, values15]) => {
    if (values15.length === 1) {
      unsafeUpdateAs(locals, values15[0][0], fiberRef, values15[0][1]);
    } else {
      values15.forEach(([fiberId5, value10]) => {
        unsafeUpdateAs(locals, fiberId5, fiberRef, value10);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/effect/dist/esm/FiberRefs.js
var FiberRefsSym2 = FiberRefsSym;
var delete_2 = delete_;
var fiberRefs2 = fiberRefs;
var forkAs2 = forkAs;
var get11 = get10;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var unsafeMake6 = unsafeMake5;
var empty27 = empty26;

// node_modules/effect/dist/esm/LogLevel.js
var LogLevel_exports = {};
__export(LogLevel_exports, {
  All: () => All,
  Debug: () => Debug,
  Error: () => Error2,
  Fatal: () => Fatal,
  Info: () => Info,
  None: () => None3,
  Order: () => Order6,
  Trace: () => Trace,
  Warning: () => Warning,
  allLevels: () => allLevels,
  fromLiteral: () => fromLiteral,
  greaterThan: () => greaterThan6,
  greaterThanEqual: () => greaterThanEqual,
  lessThan: () => lessThan6,
  lessThanEqual: () => lessThanEqual,
  locally: () => locally
});
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var locally = dual(2, (use2, self) => fiberRefLocally(use2, currentLogLevel, self));
var Order6 = pipe(Order, mapInput3((level) => level.ordinal));
var lessThan6 = lessThan(Order6);
var lessThanEqual = lessThanOrEqualTo(Order6);
var greaterThan6 = greaterThan(Order6);
var greaterThanEqual = greaterThanOrEqualTo(Order6);
var fromLiteral = (literal3) => {
  switch (literal3) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// node_modules/effect/dist/esm/LogSpan.js
var LogSpan_exports = {};
__export(LogSpan_exports, {
  make: () => make34,
  render: () => render4
});

// node_modules/effect/dist/esm/internal/logSpan.js
var make33 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render3 = (now3) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now3 - self.startTime}ms`;
};

// node_modules/effect/dist/esm/LogSpan.js
var make34 = make33;
var render4 = render3;

// node_modules/effect/dist/esm/Ref.js
var Ref_exports = {};
__export(Ref_exports, {
  RefTypeId: () => RefTypeId2,
  get: () => get13,
  getAndSet: () => getAndSet3,
  getAndUpdate: () => getAndUpdate3,
  getAndUpdateSome: () => getAndUpdateSome2,
  make: () => make37,
  modify: () => modify8,
  modifySome: () => modifySome2,
  set: () => set7,
  setAndGet: () => setAndGet3,
  unsafeMake: () => unsafeMake8,
  update: () => update4,
  updateAndGet: () => updateAndGet3,
  updateSome: () => updateSome2,
  updateSomeAndGet: () => updateSomeAndGet2
});

// node_modules/effect/dist/esm/Effectable.js
var Effectable_exports = {};
__export(Effectable_exports, {
  ChannelTypeId: () => ChannelTypeId2,
  Class: () => Class3,
  CommitPrototype: () => CommitPrototype2,
  EffectPrototype: () => EffectPrototype2,
  EffectTypeId: () => EffectTypeId3,
  SinkTypeId: () => SinkTypeId2,
  StreamTypeId: () => StreamTypeId2,
  StructuralClass: () => StructuralClass,
  StructuralCommitPrototype: () => StructuralCommitPrototype2
});
var EffectTypeId3 = EffectTypeId;
var StreamTypeId2 = StreamTypeId;
var SinkTypeId2 = SinkTypeId;
var ChannelTypeId2 = ChannelTypeId;
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var StructuralCommitPrototype2 = StructuralCommitPrototype;
var Base3 = Base2;
var StructuralBase2 = StructuralBase;
var Class3 = class extends Base3 {
};
var StructuralClass = class extends StructuralBase2 {
};

// node_modules/effect/dist/esm/Readable.js
var Readable_exports = {};
__export(Readable_exports, {
  TypeId: () => TypeId15,
  isReadable: () => isReadable,
  make: () => make35,
  map: () => map16,
  mapEffect: () => mapEffect,
  unwrap: () => unwrap
});
var TypeId15 = Symbol.for("effect/Readable");
var isReadable = (u) => hasProperty(u, TypeId15);
var Proto = {
  [TypeId15]: TypeId15,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make35 = (get48) => {
  const self = Object.create(Proto);
  self.get = get48;
  return self;
};
var map16 = dual(2, (self, f2) => make35(map14(self.get, f2)));
var mapEffect = dual(2, (self, f2) => make35(flatMap12(self.get, f2)));
var unwrap = (effect4) => make35(flatMap12(effect4, (s) => s.get));

// node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a16, _b, _c;
var RefImpl = class extends (_c = Class3, _b = RefTypeId, _a16 = TypeId15, _c) {
  constructor(ref) {
    super();
    __publicField(this, "ref");
    __publicField(this, _b, refVariance);
    __publicField(this, _a16, TypeId15);
    __publicField(this, "get");
    this.ref = ref;
    this.get = sync(() => get7(this.ref));
  }
  commit() {
    return this.get;
  }
  modify(f2) {
    return sync(() => {
      const current2 = get7(this.ref);
      const [b, a] = f2(current2);
      if (current2 !== a) {
        set3(a)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake7 = (value10) => new RefImpl(make15(value10));
var make36 = (value10) => sync(() => unsafeMake7(value10));
var get12 = (self) => self.get;
var set6 = dual(2, (self, value10) => self.modify(() => [void 0, value10]));
var getAndSet2 = dual(2, (self, value10) => self.modify((a) => [a, value10]));
var getAndUpdate2 = dual(2, (self, f2) => self.modify((a) => [a, f2(a)]));
var getAndUpdateSome = dual(2, (self, pf) => self.modify((value10) => {
  const option11 = pf(value10);
  switch (option11._tag) {
    case "None": {
      return [value10, value10];
    }
    case "Some": {
      return [value10, option11.value];
    }
  }
}));
var setAndGet2 = dual(2, (self, value10) => self.modify(() => [value10, value10]));
var modify7 = dual(2, (self, f2) => self.modify(f2));
var modifySome = dual(3, (self, fallback3, pf) => self.modify((value10) => {
  const option11 = pf(value10);
  switch (option11._tag) {
    case "None": {
      return [fallback3, value10];
    }
    case "Some": {
      return option11.value;
    }
  }
}));
var update3 = dual(2, (self, f2) => self.modify((a) => [void 0, f2(a)]));
var updateAndGet2 = dual(2, (self, f2) => self.modify((a) => {
  const result = f2(a);
  return [result, result];
}));
var updateSome = dual(2, (self, f2) => self.modify((a) => [void 0, match2(f2(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet = dual(2, (self, pf) => self.modify((value10) => {
  const option11 = pf(value10);
  switch (option11._tag) {
    case "None": {
      return [value10, value10];
    }
    case "Some": {
      return [option11.value, option11.value];
    }
  }
}));
var unsafeGet7 = (self) => get7(self.ref);

// node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make37 = make36;
var get13 = get12;
var getAndSet3 = getAndSet2;
var getAndUpdate3 = getAndUpdate2;
var getAndUpdateSome2 = getAndUpdateSome;
var modify8 = modify7;
var modifySome2 = modifySome;
var set7 = set6;
var setAndGet3 = setAndGet2;
var update4 = update3;
var updateAndGet3 = updateAndGet2;
var updateSome2 = updateSome;
var updateSomeAndGet2 = updateSomeAndGet;
var unsafeMake8 = unsafeMake7;

// node_modules/effect/dist/esm/Tracer.js
var Tracer_exports = {};
__export(Tracer_exports, {
  DisablePropagation: () => DisablePropagation2,
  ParentSpan: () => ParentSpan,
  Tracer: () => Tracer,
  TracerTypeId: () => TracerTypeId2,
  externalSpan: () => externalSpan2,
  make: () => make38,
  tracerWith: () => tracerWith2
});
var TracerTypeId2 = TracerTypeId;
var ParentSpan = spanTag;
var Tracer = tracerTag;
var make38 = make31;
var externalSpan2 = externalSpan;
var tracerWith2 = tracerWith;
var DisablePropagation2 = DisablePropagation;

// node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty28 = {
  _tag: OP_EMPTY2
};
var diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch14 = empty28;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch14 = combine12({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch14);
      }
    } else {
      patch14 = combine12({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch14);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch14 = combine12({
      _tag: OP_REMOVE,
      fiberRef
    })(patch14);
  }
  return patch14;
};
var combine12 = dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch9 = dual(3, (self, fiberId5, oldValue) => {
  let fiberRefs4 = oldValue;
  let patches = of2(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head13 = headNonEmpty(patches);
    const tail5 = tailNonEmpty(patches);
    switch (head13._tag) {
      case OP_EMPTY2: {
        patches = tail5;
        break;
      }
      case OP_ADD: {
        fiberRefs4 = updateAs(fiberRefs4, {
          fiberId: fiberId5,
          fiberRef: head13.fiberRef,
          value: head13.value
        });
        patches = tail5;
        break;
      }
      case OP_REMOVE: {
        fiberRefs4 = delete_(fiberRefs4, head13.fiberRef);
        patches = tail5;
        break;
      }
      case OP_UPDATE: {
        const value10 = getOrDefault(fiberRefs4, head13.fiberRef);
        fiberRefs4 = updateAs(fiberRefs4, {
          fiberId: fiberId5,
          fiberRef: head13.fiberRef,
          value: head13.fiberRef.patch(head13.patch)(value10)
        });
        patches = tail5;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend2(head13.first)(prepend2(head13.second)(tail5));
        break;
      }
    }
  }
  return fiberRefs4;
});

// node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = Symbol.for(MetricLabelSymbolKey);
var _a17;
var MetricLabelImpl = class {
  constructor(key, value10) {
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, _a17, MetricLabelTypeId);
    __publicField(this, "_hash");
    this.key = key;
    this.value = value10;
    this._hash = string2(MetricLabelSymbolKey + this.key + this.value);
  }
  [(_a17 = MetricLabelTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make39 = (key, value10) => {
  return new MetricLabelImpl(key, value10);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations4) => Object.entries(args2[1]).reduce((acc, [key, value10]) => set4(acc, key, value10), annotations4));
});
var asSome = (self) => map14(self, some3);
var asSomeError = (self) => mapError(self, some3);
var try_2 = (arg) => {
  let evaluate4;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate4 = arg;
  } else {
    evaluate4 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate4));
    } catch (error4) {
      return fail2(onFailure ? internalCall(() => onFailure(error4)) : new UnknownException(error4, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = dual(3, (self, tag5, options) => catchAll(self, (e) => {
  if (hasProperty(e, tag5) && e[tag5] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = dual(2, (self, f2) => catchAllCause(self, (cause3) => {
  const option11 = find(cause3, (_) => isDieType(_) ? some3(_) : none2());
  switch (option11._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      return f2(option11.value.defect);
    }
  }
}));
var catchSomeCause = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const option11 = f2(cause3);
    switch (option11._tag) {
      case "None": {
        return failCause(cause3);
      }
      case "Some": {
        return option11.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = dual(2, (self, pf) => catchAllCause(self, (cause3) => {
  const option11 = find(cause3, (_) => isDieType(_) ? some3(_) : none2());
  switch (option11._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      const optionEffect = pf(option11.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause3);
    }
  }
}));
var catchTag = dual((args2) => isEffect(args2[0]), (self, ...args2) => {
  const f2 = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = (e) => {
      const tag5 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag5) return false;
      for (let i = 0; i < args2.length - 1; i++) {
        if (args2[i] === tag5) return true;
      }
      return false;
    };
  }
  return catchIf(self, predicate, f2);
});
var catchTags = dual(2, (self, cases) => {
  let keys15;
  return catchIf(self, (e) => {
    keys15 ?? (keys15 = Object.keys(cases));
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys15.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self) => matchCause(self, {
  onFailure: identity,
  onSuccess: () => empty22
});
var clockWith3 = clockWith2;
var clock = clockWith3(succeed);
var delay = dual(2, (self, duration5) => zipRight2(sleep2(duration5), self));
var descriptorWith = (f2) => withFiberRuntime((state, status3) => f2({
  id: state.id(),
  status: status3,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = descriptorWith((descriptor3) => size9(descriptor3.interruptors) > 0 ? interrupt2 : void_3);
var descriptor = descriptorWith(succeed);
var diffFiberRefs = (self) => summarized(self, fiberRefs3, diff8);
var diffFiberRefsAndRuntimeFlags = (self) => summarized(self, zip5(fiberRefs3, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff8(refs, refsNew), diff7(flags, flagsNew)]);
var Do4 = succeed({});
var bind5 = bind(map14, flatMap12);
var bindTo5 = bindTo(map14);
var let_5 = let_(map14);
var dropUntil = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let dropping9 = succeed(false);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index3 = i++;
    dropping9 = flatMap12(dropping9, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index3);
    });
  }
  return map14(dropping9, () => builder);
}));
var dropWhile3 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let dropping9 = succeed(true);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index3 = i++;
    dropping9 = flatMap12(dropping9, (d) => map14(d ? predicate(a, index3) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map14(dropping9, () => builder);
}));
var contextWith = (f2) => map14(context2(), f2);
var eventually = (self) => orElse3(self, () => flatMap12(yieldNow(), () => eventually(self)));
var filterMap9 = dual(2, (elements, pf) => map14(forEachSequential(elements, identity), filterMap4(pf)));
var filterOrDie = dual(3, (self, predicate, orDieWith9) => filterOrElse(self, predicate, (a) => dieSync(() => orDieWith9(a))));
var filterOrDieMessage = dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = dual(3, (self, predicate, orElse24) => flatMap12(self, (a) => predicate(a) ? succeed(a) : orElse24(a)));
var liftPredicate4 = dual(3, (self, predicate, orFailWith) => suspend(() => predicate(self) ? succeed(self) : fail2(orFailWith(self))));
var filterOrFail = dual((args2) => isEffect(args2[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
var findFirst8 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next6 = iterator.next();
  if (!next6.done) {
    return findLoop(iterator, 0, predicate, next6.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index3, f2, value10) => flatMap12(f2(value10, index3), (result) => {
  if (result) {
    return succeed(some3(value10));
  }
  const next6 = iterator.next();
  if (!next6.done) {
    return findLoop(iterator, index3 + 1, f2, next6.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce3(headNonEmpty2(list), (left3, right3) => orElse3(left3, () => right3)));
});
var flipWith = dual(2, (self, f2) => flip3(f2(flip3(self))));
var match8 = dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every11 = dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index3, f2) => {
  const next6 = iterator.next();
  return next6.done ? succeed(true) : flatMap12(f2(next6.value, index3), (b) => b ? forAllLoop(iterator, index3 + 1, f2) : succeed(b));
};
var forever = (self) => {
  const loop5 = flatMap12(flatMap12(self, () => yieldNow()), () => loop5);
  return loop5;
};
var fiberRefs3 = withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head6 = (self) => flatMap12(self, (as18) => {
  const iterator = as18[Symbol.iterator]();
  const next6 = iterator.next();
  if (next6.done) {
    return fail2(new NoSuchElementException());
  }
  return succeed(next6.value);
});
var ignore = (self) => match8(self, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self) => matchCauseEffect(self, {
  onFailure: (cause3) => logDebug(cause3, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_3
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure3 = (self) => match8(self, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess2 = (self) => match8(self, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap12(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable2(level);
  let cause3 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause3 !== void 0) {
        cause3 = sequential(cause3, msg);
      } else {
        cause3 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause3 === void 0) {
    cause3 = empty22;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause3, levelOption);
    return void_3;
  });
};
var log = logWithLevel();
var logTrace = logWithLevel(Trace);
var logDebug = logWithLevel(Debug);
var logInfo = logWithLevel(Info);
var logWarning = logWithLevel(Warning);
var logError = logWithLevel(Error2);
var logFatal = logWithLevel(Fatal);
var withLogSpan = dual(2, (effect4, label) => flatMap12(currentTimeMillis2, (now3) => fiberRefLocallyWith(effect4, currentLogSpan, prepend4(make34(label, now3)))));
var logAnnotations = fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map14(loopInternal(initial, options.while, options.step, options.body), fromIterable2);
var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap12(body(initial), (a) => map14(loopInternal(inc(initial), cont, inc, body), prepend4(a))) : sync(() => empty12()));
var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap12(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_3);
var mapAccum3 = dual(3, (elements, initial, f2) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next6;
  let i = 0;
  while (!(next6 = iterator.next()).done) {
    const index3 = i++;
    const value10 = next6.value;
    result = flatMap12(result, (state) => map14(f2(state, value10, index3), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map14(result, (z) => [z, builder]);
}));
var mapErrorCause2 = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (c) => failCauseSync(() => f2(c)),
  onSuccess: succeed
}));
var memoize = (self) => pipe(deferredMake(), flatMap12((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map14((complete6) => zipRight2(complete6, pipe(deferredAwait(deferred), flatMap12(([patch14, a]) => as3(zip5(patchFiberRefs(patch14[0]), updateRuntimeFlags(patch14[1])), a))))))));
var merge5 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate3 = (self) => map14(self, (b) => !b);
var none6 = (self) => flatMap12(self, (option11) => {
  switch (option11._tag) {
    case "None":
      return void_3;
    case "Some":
      return fail2(new NoSuchElementException());
  }
});
var once = (self) => map14(make37(true), (ref) => asVoid2(whenEffect(self, getAndSet3(ref, false))));
var option2 = (self) => matchEffect(self, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some3(a))
});
var orElseFail = dual(2, (self, evaluate4) => orElse3(self, () => failSync(evaluate4)));
var orElseSucceed = dual(2, (self, evaluate4) => orElse3(self, () => sync(evaluate4)));
var parallelErrors = (self) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const errors2 = fromIterable2(failures(cause3));
    return errors2.length === 0 ? failCause(cause3) : fail2(errors2);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch14) => updateFiberRefs((fiberId5, fiberRefs4) => pipe(patch14, patch9(fiberId5, fiberRefs4)));
var promise = (evaluate4) => evaluate4.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate4(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
}) : async_((resolve) => {
  try {
    ;
    evaluate4().then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
});
var provideService = dual(3, (self, tag5, service4) => contextWithEffect((env) => provideContext(self, add3(env, tag5, service4))));
var provideServiceEffect = dual(3, (self, tag5, effect4) => contextWithEffect((env) => flatMap12(effect4, (service4) => provideContext(self, pipe(env, add3(tag5, service4))))));
var random3 = randomWith(succeed);
var reduce12 = dual(3, (elements, zero3, f2) => fromIterable2(elements).reduce((acc, el, i) => flatMap12(acc, (a) => f2(a, el, i)), succeed(zero3)));
var reduceRight4 = dual(3, (elements, zero3, f2) => fromIterable2(elements).reduceRight((acc, el, i) => flatMap12(acc, (a) => f2(el, a, i)), succeed(zero3)));
var reduceWhile = dual(3, (elements, zero3, options) => flatMap12(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop = (iterator, index3, state, predicate, f2) => {
  const next6 = iterator.next();
  if (!next6.done && predicate(state)) {
    return flatMap12(f2(state, next6.value, index3), (nextState) => reduceWhileLoop(iterator, index3 + 1, nextState, predicate, f2));
  }
  return succeed(state);
};
var repeatN = dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = (self, n) => flatMap12(self, (a) => n <= 0 ? succeed(a) : zipRight2(yieldNow(), repeatNLoop(self, n - 1)));
var sandbox = (self) => matchCauseEffect(self, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs4) => suspend(() => setAll2(fiberRefs4));
var sleep3 = sleep2;
var succeedNone = succeed(none2());
var succeedSome = (value10) => succeed(some3(value10));
var summarized = dual(3, (self, summary11, f2) => flatMap12(summary11, (start5) => flatMap12(self, (value10) => map14(summary11, (end7) => [f2(start5, end7), value10]))));
var tagMetrics = dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make39(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make39(k, v)));
});
var labelMetrics = dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union2(old, labels)));
var takeUntil = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let effect4 = succeed(false);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index3 = i++;
    effect4 = flatMap12(effect4, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index3);
    });
  }
  return map14(effect4, () => builder);
}));
var takeWhile4 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let taking = succeed(true);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index3 = i++;
    taking = flatMap12(taking, (taking2) => pipe(taking2 ? predicate(a, index3) : succeed(false), map14((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map14(taking, () => builder);
}));
var tapBoth = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either14 = failureOrCause(cause3);
    switch (either14._tag) {
      case "Left": {
        return zipRight2(onFailure(either14.left), failCause(cause3));
      }
      case "Right": {
        return failCause(cause3);
      }
    }
  },
  onSuccess: (a) => as3(onSuccess(a), a)
}));
var tapDefect = dual(2, (self, f2) => catchAllCause(self, (cause3) => match2(keepDefects(cause3), {
  onNone: () => failCause(cause3),
  onSome: (a) => zipRight2(f2(a), failCause(cause3))
})));
var tapError = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either14 = failureOrCause(cause3);
    switch (either14._tag) {
      case "Left":
        return zipRight2(f2(either14.left), failCause(cause3));
      case "Right":
        return failCause(cause3);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = dual(3, (self, k, f2) => tapError(self, (e) => {
  if (isTagged(e, k)) {
    return f2(e);
  }
  return void_3;
}));
var tapErrorCause = dual(2, (self, f2) => matchCauseEffect(self, {
  onFailure: (cause3) => zipRight2(f2(cause3), failCause(cause3)),
  onSuccess: succeed
}));
var timed = (self) => timedWith(self, currentTimeNanos2);
var timedWith = dual(2, (self, nanos2) => summarized(self, nanos2, (start5, end7) => nanos(end7 - start5)));
var tracerWith3 = tracerWith2;
var tracer = tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate4;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate4 = arg;
  } else {
    evaluate4 = arg.try;
    catcher = arg.catch;
  }
  const fail30 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate4.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate4(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(fail30(e)));
      } catch (e) {
        resolve(fail30(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate4().then((a) => resolve(exitSucceed(a)), (e) => resolve(fail30(e)));
    } catch (e) {
      resolve(fail30(e));
    }
  });
};
var tryMap = dual(2, (self, options) => flatMap12(self, (a) => try_2({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = dual(2, (self, options) => flatMap12(self, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
var unlessEffect = dual(2, (self, condition) => flatMap12(condition, (b) => b ? succeedNone : asSome(self)));
var unsandbox = (self) => mapErrorCause2(self, flatten7);
var updateFiberRefs = (f2) => withFiberRuntime((state) => {
  state.setFiberRefs(f2(state.id(), state.getFiberRefs()));
  return void_3;
});
var updateService = dual(3, (self, tag5, f2) => mapInputContext(self, (context15) => add3(context15, tag5, f2(unsafeGet3(context15, tag5)))));
var when = dual(2, (self, condition) => suspend(() => condition() ? map14(self, some3) : succeed(none2())));
var whenFiberRef = dual(3, (self, fiberRef, predicate) => flatMap12(fiberRefGet(fiberRef), (s) => predicate(s) ? map14(self, (a) => [s, some3(a)]) : succeed([s, none2()])));
var whenRef = dual(3, (self, ref, predicate) => flatMap12(get13(ref), (s) => predicate(s) ? map14(self, (a) => [s, some3(a)]) : succeed([s, none2()])));
var withMetric = dual(2, (self, metric) => metric(self));
var serviceFunctionEffect = (getService, f2) => (...args2) => flatMap12(getService, (a) => f2(a)(...args2));
var serviceFunction = (getService, f2) => (...args2) => map14(getService, (a) => f2(a)(...args2));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap12(getService, (s) => s[prop](...args2));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap12(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag5) => map14(context2(), getOption2(tag5));
var serviceOptional = (tag5) => flatMap12(context2(), getOption2(tag5));
var annotateCurrentSpan = function() {
  const args2 = arguments;
  return ignore(flatMap12(currentSpan, (span4) => sync(() => {
    if (typeof args2[0] === "string") {
      span4.attribute(args2[0], args2[1]);
    } else {
      for (const key in args2[0]) {
        span4.attribute(key, args2[0][key]);
      }
    }
  })));
};
var linkSpanCurrent = function() {
  const args2 = arguments;
  const links = Array.isArray(args2[0]) ? args2[0] : [{
    _tag: "SpanLink",
    span: args2[0],
    attributes: args2[1] ?? {}
  }];
  return ignore(flatMap12(currentSpan, (span4) => sync(() => span4.addLinks(links))));
};
var annotateSpans = dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations4) => Object.entries(args2[1]).reduce((acc, [key, value10]) => set4(acc, key, value10), annotations4));
});
var currentParentSpan = serviceOptional(spanTag);
var currentSpan = flatMap12(context2(), (context15) => {
  const span4 = context15.unsafeMap.get(spanTag.key);
  return span4 !== void 0 && span4._tag === "Span" ? succeed(span4) : fail2(new NoSuchElementException());
});
var linkSpans = dual((args2) => isEffect(args2[0]), (self, span4, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append3({
  _tag: "SpanLink",
  span: span4,
  attributes: attributes ?? {}
})));
var bigint04 = BigInt(0);
var filterDisablePropagation = flatMap2((span4) => get4(span4.context, DisablePropagation) ? span4._tag === "Span" ? filterDisablePropagation(span4.parent) : none2() : some3(span4));
var unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get4(options.context, DisablePropagation);
  const context15 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some3(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context15, spanTag));
  let span4;
  if (disablePropagation) {
    span4 = noopSpan({
      name,
      parent,
      context: add3(options.context ?? empty6(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer3 = get4(services, tracerTag);
    const clock3 = get4(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs4 = fiber.getFiberRefs();
    const annotationsFromEnv = get11(fiberRefs4, currentTracerSpanAnnotations);
    const linksFromEnv = get11(fiberRefs4, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty4();
    span4 = tracer3.span(name, parent, options.context ?? empty6(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint04, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach7(annotationsFromEnv.value, (value10, key) => span4.attribute(key, value10));
    }
    if (options.attributes !== void 0) {
      Object.entries(options.attributes).forEach(([k, v]) => span4.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span4, options.captureStackTrace);
  }
  return span4;
};
var makeSpan = (name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
};
var spanAnnotations = fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = fiberRefGet(currentTracerSpanLinks);
var endSpan = (span4, exit4, clock3, timingEnabled) => sync(() => {
  if (span4.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit4) && spanToTrace.has(span4)) {
    span4.attribute("code.stacktrace", spanToTrace.get(span4)());
  }
  span4.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint04, exit4);
});
var useSpan = (name, ...args2) => {
  const options = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
  const evaluate4 = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get4(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate4(span4), (exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  });
};
var withParentSpan = dual(2, (self, span4) => provideService(self, spanTag, span4));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan(name, options, (span4) => withParentSpan(self, span4));
  }
  return (self) => useSpan(name, options, (span4) => withParentSpan(self, span4));
};
var functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit2 = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error4 = new Error();
    Error.stackTraceLimit = limit2;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error4.stack) {
        const stack = error4.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
var fromNullable4 = (value10) => value10 == null ? fail2(new NoSuchElementException()) : succeed(value10);
var optionFromOptional = (self) => catchAll(map14(self, some3), (error4) => isNoSuchElementException(error4) ? succeedNone : fail2(error4));

// node_modules/effect/dist/esm/ExecutionStrategy.js
var ExecutionStrategy_exports = {};
__export(ExecutionStrategy_exports, {
  isParallel: () => isParallel2,
  isParallelN: () => isParallelN2,
  isSequential: () => isSequential2,
  match: () => match10,
  parallel: () => parallel3,
  parallelN: () => parallelN2,
  sequential: () => sequential3
});

// node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
var isParallel = (self) => self._tag === OP_PARALLEL2;
var isParallelN = (self) => self._tag === OP_PARALLEL_N;
var match9 = dual(2, (self, options) => {
  switch (self._tag) {
    case OP_SEQUENTIAL2: {
      return options.onSequential();
    }
    case OP_PARALLEL2: {
      return options.onParallel();
    }
    case OP_PARALLEL_N: {
      return options.onParallelN(self.parallelism);
    }
  }
});

// node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;
var isSequential2 = isSequential;
var isParallel2 = isParallel;
var isParallelN2 = isParallelN;
var match10 = match9;

// node_modules/effect/dist/esm/FiberRefsPatch.js
var FiberRefsPatch_exports = {};
__export(FiberRefsPatch_exports, {
  combine: () => combine13,
  diff: () => diff9,
  empty: () => empty29,
  patch: () => patch10
});
var empty29 = empty28;
var diff9 = diff8;
var combine13 = combine12;
var patch10 = patch9;

// node_modules/effect/dist/esm/FiberStatus.js
var FiberStatus_exports = {};
__export(FiberStatus_exports, {
  FiberStatusTypeId: () => FiberStatusTypeId2,
  done: () => done4,
  isDone: () => isDone3,
  isFiberStatus: () => isFiberStatus2,
  isRunning: () => isRunning2,
  isSuspended: () => isSuspended2,
  running: () => running2,
  suspended: () => suspended2
});

// node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = string2(`${FiberStatusSymbolKey}-${OP_DONE}`);
var _a18;
var Done = class {
  constructor() {
    __publicField(this, _a18, FiberStatusTypeId);
    __publicField(this, "_tag", OP_DONE);
  }
  [(_a18 = FiberStatusTypeId, symbol2)]() {
    return DoneHash;
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var _a19;
var Running = class {
  constructor(runtimeFlags2) {
    __publicField(this, "runtimeFlags");
    __publicField(this, _a19, FiberStatusTypeId);
    __publicField(this, "_tag", OP_RUNNING);
    this.runtimeFlags = runtimeFlags2;
  }
  [(_a19 = FiberStatusTypeId, symbol2)]() {
    return pipe(hash(FiberStatusSymbolKey), combine2(hash(this._tag)), combine2(hash(this.runtimeFlags)), cached(this));
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var _a20;
var Suspended = class {
  constructor(runtimeFlags2, blockingOn) {
    __publicField(this, "runtimeFlags");
    __publicField(this, "blockingOn");
    __publicField(this, _a20, FiberStatusTypeId);
    __publicField(this, "_tag", OP_SUSPENDED);
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [(_a20 = FiberStatusTypeId, symbol2)]() {
    return pipe(hash(FiberStatusSymbolKey), combine2(hash(this._tag)), combine2(hash(this.runtimeFlags)), combine2(hash(this.blockingOn)), cached(this));
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done3 = new Done();
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self) => self._tag === OP_DONE;
var isRunning = (self) => self._tag === OP_RUNNING;
var isSuspended = (self) => self._tag === OP_SUSPENDED;

// node_modules/effect/dist/esm/FiberStatus.js
var FiberStatusTypeId2 = FiberStatusTypeId;
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isFiberStatus2 = isFiberStatus;
var isDone3 = isDone2;
var isRunning2 = isRunning;
var isSuspended2 = isSuspended;

// node_modules/effect/dist/esm/Micro.js
var Micro_exports = {};
__export(Micro_exports, {
  CurrentConcurrency: () => CurrentConcurrency,
  CurrentScheduler: () => CurrentScheduler,
  Do: () => Do5,
  Error: () => Error3,
  MaxOpsBeforeYield: () => MaxOpsBeforeYield,
  MicroCauseTypeId: () => MicroCauseTypeId,
  MicroExitTypeId: () => MicroExitTypeId,
  MicroFiberTypeId: () => MicroFiberTypeId,
  MicroSchedulerDefault: () => MicroSchedulerDefault,
  MicroScope: () => MicroScope,
  MicroScopeTypeId: () => MicroScopeTypeId,
  NoSuchElementException: () => NoSuchElementException2,
  TaggedError: () => TaggedError,
  TimeoutException: () => TimeoutException2,
  TypeId: () => TypeId16,
  acquireRelease: () => acquireRelease,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer,
  all: () => all8,
  andThen: () => andThen8,
  as: () => as5,
  asSome: () => asSome2,
  asVoid: () => asVoid4,
  async: () => async,
  bind: () => bind6,
  bindTo: () => bindTo6,
  catchAll: () => catchAll2,
  catchAllCause: () => catchAllCause2,
  catchAllDefect: () => catchAllDefect2,
  catchCauseIf: () => catchCauseIf,
  catchIf: () => catchIf2,
  catchTag: () => catchTag2,
  causeDie: () => causeDie,
  causeFail: () => causeFail,
  causeInterrupt: () => causeInterrupt,
  causeIsDie: () => causeIsDie,
  causeIsFail: () => causeIsFail,
  causeIsInterrupt: () => causeIsInterrupt,
  causeSquash: () => causeSquash2,
  causeWithTrace: () => causeWithTrace,
  context: () => context3,
  delay: () => delay2,
  die: () => die5,
  either: () => either4,
  ensuring: () => ensuring,
  exit: () => exit2,
  exitDie: () => exitDie2,
  exitFail: () => exitFail2,
  exitFailCause: () => exitFailCause2,
  exitInterrupt: () => exitInterrupt2,
  exitIsDie: () => exitIsDie,
  exitIsFail: () => exitIsFail,
  exitIsFailure: () => exitIsFailure2,
  exitIsInterrupt: () => exitIsInterrupt,
  exitIsSuccess: () => exitIsSuccess2,
  exitSucceed: () => exitSucceed2,
  exitVoid: () => exitVoid2,
  exitVoidAll: () => exitVoidAll,
  fail: () => fail5,
  failCause: () => failCause4,
  failCauseSync: () => failCauseSync3,
  failSync: () => failSync3,
  fiberAwait: () => fiberAwait,
  fiberInterrupt: () => fiberInterrupt,
  fiberInterruptAll: () => fiberInterruptAll,
  fiberJoin: () => fiberJoin,
  filter: () => filter12,
  filterMap: () => filterMap10,
  filterOrFail: () => filterOrFail2,
  filterOrFailCause: () => filterOrFailCause,
  flatMap: () => flatMap14,
  flatten: () => flatten10,
  flip: () => flip4,
  forEach: () => forEach11,
  forever: () => forever2,
  fork: () => fork,
  forkDaemon: () => forkDaemon,
  forkIn: () => forkIn,
  forkScoped: () => forkScoped,
  fromEither: () => fromEither2,
  fromOption: () => fromOption5,
  gen: () => gen5,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  interrupt: () => interrupt5,
  interruptible: () => interruptible3,
  isMicro: () => isMicro,
  isMicroCause: () => isMicroCause,
  isMicroExit: () => isMicroExit,
  let: () => let_6,
  map: () => map17,
  mapError: () => mapError3,
  mapErrorCause: () => mapErrorCause3,
  match: () => match11,
  matchCause: () => matchCause2,
  matchCauseEffect: () => matchCauseEffect2,
  matchEffect: () => matchEffect3,
  never: () => never2,
  onError: () => onError2,
  onExit: () => onExit2,
  onExitIf: () => onExitIf,
  onInterrupt: () => onInterrupt2,
  option: () => option3,
  orDie: () => orDie2,
  orElseSucceed: () => orElseSucceed2,
  promise: () => promise2,
  provideContext: () => provideContext2,
  provideScope: () => provideScope,
  provideService: () => provideService2,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race,
  raceAll: () => raceAll,
  raceAllFirst: () => raceAllFirst,
  raceFirst: () => raceFirst,
  repeat: () => repeat,
  repeatExit: () => repeatExit,
  replicate: () => replicate3,
  replicateEffect: () => replicateEffect,
  retry: () => retry,
  runFork: () => runFork,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  sandbox: () => sandbox2,
  scheduleAddDelay: () => scheduleAddDelay,
  scheduleExponential: () => scheduleExponential,
  scheduleIntersect: () => scheduleIntersect,
  scheduleRecurs: () => scheduleRecurs,
  scheduleSpaced: () => scheduleSpaced,
  scheduleUnion: () => scheduleUnion,
  scheduleWithMaxDelay: () => scheduleWithMaxDelay,
  scheduleWithMaxElapsed: () => scheduleWithMaxElapsed,
  scope: () => scope,
  scopeMake: () => scopeMake,
  scopeUnsafeMake: () => scopeUnsafeMake,
  scoped: () => scoped,
  service: () => service,
  serviceOption: () => serviceOption2,
  sleep: () => sleep4,
  succeed: () => succeed4,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  suspend: () => suspend2,
  sync: () => sync3,
  tap: () => tap3,
  tapDefect: () => tapDefect2,
  tapError: () => tapError2,
  tapErrorCause: () => tapErrorCause2,
  tapErrorCauseIf: () => tapErrorCauseIf,
  timeout: () => timeout,
  timeoutOption: () => timeoutOption,
  timeoutOrElse: () => timeoutOrElse,
  try: () => try_3,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask2,
  updateContext: () => updateContext,
  updateService: () => updateService2,
  void: () => void_5,
  when: () => when2,
  whileLoop: () => whileLoop2,
  withConcurrency: () => withConcurrency2,
  withMicroFiber: () => withMicroFiber,
  withTrace: () => withTrace,
  yieldFlush: () => yieldFlush,
  yieldNow: () => yieldNow2,
  yieldNowWith: () => yieldNowWith,
  zip: () => zip7,
  zipWith: () => zipWith8
});
var TypeId16 = Symbol.for("effect/Micro");
var MicroExitTypeId = Symbol.for("effect/Micro/MicroExit");
var isMicro = (u) => typeof u === "object" && u !== null && TypeId16 in u;
var MicroCauseTypeId = Symbol.for("effect/Micro/MicroCause");
var isMicroCause = (self) => hasProperty(self, MicroCauseTypeId);
var microCauseVariance = {
  _E: identity
};
var _a21;
var MicroCauseImpl = class extends globalThis.Error {
  constructor(_tag, originalError2, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError2 instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError2.name}`;
      message = originalError2.message;
      const messageLines = message.split("\n").length;
      stack = originalError2.stack ? `(${causeName}) ${originalError2.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError2, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    __publicField(this, "_tag");
    __publicField(this, "traces");
    __publicField(this, _a21);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [(_a21 = MicroCauseTypeId, NodeInspectSymbol)]() {
    return this.stack;
  }
};
var Fail = class extends MicroCauseImpl {
  constructor(error4, traces = []) {
    super("Fail", error4, traces);
    __publicField(this, "error");
    this.error = error4;
  }
};
var causeFail = (error4, traces = []) => new Fail(error4, traces);
var Die = class extends MicroCauseImpl {
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    __publicField(this, "defect");
    this.defect = defect;
  }
};
var causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsFail = (self) => self._tag === "Fail";
var causeIsDie = (self) => self._tag === "Die";
var causeIsInterrupt = (self) => self._tag === "Interrupt";
var causeSquash2 = (self) => self._tag === "Fail" ? self.error : self._tag === "Die" ? self.defect : self;
var causeWithTrace = dual(2, (self, trace3) => {
  const traces = [...self.traces, trace3];
  switch (self._tag) {
    case "Die":
      return causeDie(self.defect, traces);
    case "Interrupt":
      return causeInterrupt(traces);
    case "Fail":
      return causeFail(self.error, traces);
  }
});
var MicroFiberTypeId = Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var _a22;
_a22 = MicroFiberTypeId;
var MicroFiberImpl = class {
  constructor(context15, interruptible6 = true) {
    __publicField(this, "context");
    __publicField(this, "interruptible");
    __publicField(this, _a22);
    __publicField(this, "_stack", []);
    __publicField(this, "_observers", []);
    __publicField(this, "_exit");
    __publicField(this, "_children");
    __publicField(this, "currentOpCount", 0);
    __publicField(this, "_interrupted", false);
    // cancel the yielded operation, or for the yielded exit value
    __publicField(this, "_yielded");
    this.context = context15;
    this.interruptible = interruptible6;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index3 = this._observers.indexOf(cb);
      if (index3 >= 0) {
        this._observers.splice(index3, 1);
      }
    };
  }
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect4) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit4 = this.runLoop(effect4);
    if (exit4 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap14(interruptChildren, () => exit4));
    }
    this._exit = exit4;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit4);
    }
    this._observers.length = 0;
  }
  runLoop(effect4) {
    let yielding = false;
    let current2 = effect4;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current2;
          current2 = flatMap14(yieldNow2, () => prev);
        }
        current2 = current2[evaluate](this);
        if (current2 === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error4) {
      if (!hasProperty(current2, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current2)}`);
      }
      return exitDie2(error4);
    }
  }
  getCont(symbol6) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol6]: cont
      };
      if (op[symbol6]) return op;
    }
  }
  yieldWith(value10) {
    this._yielded = value10;
    return Yield;
  }
  children() {
    return this._children ?? (this._children = /* @__PURE__ */ new Set());
  }
};
var fiberMiddleware = globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberInterruptChildren = (fiber) => {
  if (fiber._children === void 0 || fiber._children.size === 0) {
    return void 0;
  }
  return fiberInterruptAll(fiber._children);
};
var fiberAwait = (self) => async((resume2) => sync3(self.addObserver((exit4) => resume2(succeed4(exit4)))));
var fiberJoin = (self) => flatten10(fiberAwait(self));
var fiberInterrupt = (self) => suspend2(() => {
  self.unsafeInterrupt();
  return asVoid4(fiberAwait(self));
});
var fiberInterruptAll = (fibers2) => suspend2(() => {
  for (const fiber of fibers2) fiber.unsafeInterrupt();
  const iter = fibers2[Symbol.iterator]();
  const wait2 = suspend2(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async((resume2) => {
        fiber.addObserver((_) => {
          resume2(wait2);
        });
      });
    }
    return exitVoid2;
  });
  return wait2;
});
var identifier = Symbol.for("effect/Micro/identifier");
var args = Symbol.for("effect/Micro/args");
var evaluate = Symbol.for("effect/Micro/evaluate");
var successCont = Symbol.for("effect/Micro/successCont");
var failureCont = Symbol.for("effect/Micro/failureCont");
var ensureCont = Symbol.for("effect/Micro/ensureCont");
var Yield = Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId16]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto8 = makePrimitiveProto(options);
  return function() {
    const self = Object.create(Proto8);
    self[args] = options.single === false ? arguments : arguments[0];
    return self;
  };
};
var makeExit = (options) => {
  const Proto8 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol3](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol2]() {
      return cached(this, combine2(string2(options.op))(hash(this[args])));
    }
  };
  return function(value10) {
    const self = Object.create(Proto8);
    self[args] = value10;
    self[successCont] = void 0;
    self[failureCont] = void 0;
    self[ensureCont] = void 0;
    return self;
  };
};
var succeed4 = makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause4 = makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var fail5 = (error4) => failCause4(causeFail(error4));
var sync3 = makePrimitive({
  op: "Sync",
  eval(fiber) {
    const value10 = this[args]();
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](value10, fiber) : fiber.yieldWith(exitSucceed2(value10));
  }
});
var suspend2 = makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
var yieldNowWith = makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = yieldNowWith(0);
var succeedSome2 = (a) => succeed4(some3(a));
var succeedNone2 = succeed4(none2());
var failCauseSync3 = (evaluate4) => suspend2(() => failCause4(evaluate4()));
var die5 = (defect) => exitDie2(defect);
var failSync3 = (error4) => suspend2(() => fail5(error4()));
var fromOption5 = (option11) => option11._tag === "Some" ? succeed4(option11.value) : fail5(new NoSuchElementException2({}));
var fromEither2 = (either14) => either14._tag === "Right" ? succeed4(either14.right) : fail5(either14.left);
var void_5 = succeed4(void 0);
var try_3 = (options) => suspend2(() => {
  try {
    return succeed4(options.try());
  } catch (err2) {
    return fail5(options.catch(err2));
  }
});
var promise2 = (evaluate4) => asyncOptions(function(resume2, signal) {
  evaluate4(signal).then((a) => resume2(succeed4(a)), (e) => resume2(die5(e)));
}, evaluate4.length !== 0);
var tryPromise2 = (options) => asyncOptions(function(resume2, signal) {
  try {
    options.try(signal).then((a) => resume2(succeed4(a)), (e) => resume2(fail5(options.catch(e))));
  } catch (err2) {
    resume2(fail5(options.catch(err2)));
  }
}, options.try.length !== 0);
var withMicroFiber = makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var yieldFlush = withMicroFiber((fiber) => {
  fiber.getRef(CurrentScheduler).flush();
  return exitVoid2;
});
var asyncOptions = makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : void 0;
    const onCancel = register((effect4) => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect4);
      } else {
        yielded = effect4;
      }
    }, controller == null ? void 0 : controller.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller == null ? void 0 : controller.abort();
      return onCancel ?? exitVoid2;
    }));
    return Yield;
  }
});
var asyncFinalizer = makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause3, _fiber) {
    return causeIsInterrupt(cause3) ? flatMap14(this[args](), () => failCause4(cause3)) : failCause4(cause3);
  }
});
var async = (register) => asyncOptions(register, register.length >= 2);
var never2 = async(function() {
  const interval = setInterval(constVoid, 2147483646);
  return sync3(() => clearInterval(interval));
});
var gen5 = (...args2) => suspend2(() => fromIterator2(args2.length === 1 ? args2[0]() : args2[1].call(args2[0])));
var fromIterator2 = makePrimitive({
  op: "Iterator",
  contA(value10, fiber) {
    const state = this[args].next(value10);
    if (state.done) return succeed4(state.value);
    fiber._stack.push(this);
    return yieldWrapGet(state.value);
  },
  eval(fiber) {
    return this[successCont](void 0, fiber);
  }
});
var as5 = dual(2, (self, value10) => map17(self, (_) => value10));
var asSome2 = (self) => map17(self, some3);
var flip4 = (self) => matchEffect3(self, {
  onFailure: succeed4,
  onSuccess: fail5
});
var andThen8 = dual(2, (self, f2) => flatMap14(self, (a) => {
  const value10 = isMicro(f2) ? f2 : typeof f2 === "function" ? f2(a) : f2;
  return isMicro(value10) ? value10 : succeed4(value10);
}));
var tap3 = dual(2, (self, f2) => flatMap14(self, (a) => {
  const value10 = isMicro(f2) ? f2 : typeof f2 === "function" ? f2(a) : f2;
  return isMicro(value10) ? as5(value10, a) : succeed4(a);
}));
var asVoid4 = (self) => flatMap14(self, (_) => exitVoid2);
var exit2 = (self) => matchCause2(self, {
  onFailure: exitFailCause2,
  onSuccess: exitSucceed2
});
var sandbox2 = (self) => catchAllCause2(self, fail5);
var raceAll = (all16) => withMicroFiber((parent) => async((resume2) => {
  const effects = fromIterable2(all16);
  const len = effects.length;
  let doneCount = 0;
  let done17 = false;
  const fibers2 = /* @__PURE__ */ new Set();
  const causes = [];
  const onExit4 = (exit4) => {
    doneCount++;
    if (exit4._tag === "Failure") {
      causes.push(exit4.cause);
      if (doneCount >= len) {
        resume2(failCause4(causes[0]));
      }
      return;
    }
    done17 = true;
    resume2(fibers2.size === 0 ? exit4 : flatMap14(uninterruptible2(fiberInterruptAll(fibers2)), () => exit4));
  };
  for (let i = 0; i < len; i++) {
    if (done17) break;
    const fiber = unsafeFork(parent, interruptible3(effects[i]), true, true);
    fibers2.add(fiber);
    fiber.addObserver((exit4) => {
      fibers2.delete(fiber);
      onExit4(exit4);
    });
  }
  return fiberInterruptAll(fibers2);
}));
var raceAllFirst = (all16) => withMicroFiber((parent) => async((resume2) => {
  let done17 = false;
  const fibers2 = /* @__PURE__ */ new Set();
  const onExit4 = (exit4) => {
    done17 = true;
    resume2(fibers2.size === 0 ? exit4 : flatMap14(fiberInterruptAll(fibers2), () => exit4));
  };
  for (const effect4 of all16) {
    if (done17) break;
    const fiber = unsafeFork(parent, interruptible3(effect4), true, true);
    fibers2.add(fiber);
    fiber.addObserver((exit4) => {
      fibers2.delete(fiber);
      onExit4(exit4);
    });
  }
  return fiberInterruptAll(fibers2);
}));
var race = dual(2, (self, that) => raceAll([self, that]));
var raceFirst = dual(2, (self, that) => raceAllFirst([self, that]));
var flatMap14 = dual(2, (self, f2) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f2;
  return onSuccess;
});
var OnSuccessProto = makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var flatten10 = (self) => flatMap14(self, identity);
var map17 = dual(2, (self, f2) => flatMap14(self, (a) => succeed4(f2(a))));
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed4;
var exitFailCause2 = failCause4;
var exitInterrupt2 = exitFailCause2(causeInterrupt());
var exitFail2 = (e) => exitFailCause2(causeFail(e));
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitIsSuccess2 = (self) => self._tag === "Success";
var exitIsFailure2 = (self) => self._tag === "Failure";
var exitIsInterrupt = (self) => exitIsFailure2(self) && self.cause._tag === "Interrupt";
var exitIsFail = (self) => exitIsFailure2(self) && self.cause._tag === "Fail";
var exitIsDie = (self) => exitIsFailure2(self) && self.cause._tag === "Die";
var exitVoid2 = exitSucceed2(void 0);
var exitVoidAll = (exits) => {
  for (const exit4 of exits) {
    if (exit4._tag === "Failure") {
      return exit4;
    }
  }
  return exitVoid2;
};
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f2) => setTimeout(f2, 0);
var MicroSchedulerDefault = class {
  constructor() {
    __publicField(this, "tasks", []);
    __publicField(this, "running", false);
    /**
     * @since 3.5.9
     */
    __publicField(this, "afterScheduled", () => {
      this.running = false;
      this.runTasks();
    });
  }
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var service = (tag5) => withMicroFiber((fiber) => succeed4(unsafeGet3(fiber.context, tag5)));
var serviceOption2 = (tag5) => withMicroFiber((fiber) => succeed4(getOption2(fiber.context, tag5)));
var updateContext = dual(2, (self, f2) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f2(prev);
  return onExit2(self, () => {
    fiber.context = prev;
    return void_5;
  });
}));
var updateService2 = dual(3, (self, tag5, f2) => withMicroFiber((fiber) => {
  const prev = unsafeGet3(fiber.context, tag5);
  fiber.context = add3(fiber.context, tag5, f2(prev));
  return onExit2(self, () => {
    fiber.context = add3(fiber.context, tag5, prev);
    return void_5;
  });
}));
var context3 = () => getContext;
var getContext = withMicroFiber((fiber) => succeed4(fiber.context));
var provideContext2 = dual(2, (self, provided) => updateContext(self, merge3(provided)));
var provideService2 = dual(3, (self, tag5, service4) => updateContext(self, add3(tag5, service4)));
var provideServiceEffect2 = dual(3, (self, tag5, acquire4) => flatMap14(acquire4, (service4) => provideService2(self, tag5, service4)));
var MaxOpsBeforeYield = class extends Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
}) {
};
var CurrentConcurrency = class extends Reference2()("effect/Micro/currentConcurrency", {
  defaultValue: () => "unbounded"
}) {
};
var CurrentScheduler = class extends Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
}) {
};
var withConcurrency2 = dual(2, (self, concurrency) => provideService2(self, CurrentConcurrency, concurrency));
var zip7 = dual((args2) => isMicro(args2[1]), (self, that, options) => zipWith8(self, that, (a, a2) => [a, a2], options));
var zipWith8 = dual((args2) => isMicro(args2[1]), (self, that, f2, options) => (options == null ? void 0 : options.concurrent) ? map17(all8([self, that], {
  concurrency: 2
}), ([a, a2]) => f2(a, a2)) : flatMap14(self, (a) => map17(that, (a2) => f2(a, a2))));
var filterOrFailCause = dual((args2) => isMicro(args2[0]), (self, refinement, orFailWith) => flatMap14(self, (a) => refinement(a) ? succeed4(a) : failCause4(orFailWith(a))));
var filterOrFail2 = dual((args2) => isMicro(args2[0]), (self, refinement, orFailWith) => flatMap14(self, (a) => refinement(a) ? succeed4(a) : fail5(orFailWith(a))));
var when2 = dual(2, (self, condition) => flatMap14(isMicro(condition) ? condition : sync3(condition), (pass) => pass ? asSome2(self) : succeedNone2));
var repeatExit = dual(2, (self, options) => suspend2(() => {
  const startedAt = options.schedule ? Date.now() : 0;
  let attempt3 = 0;
  const loop5 = flatMap14(exit2(self), (exit4) => {
    if (options.while !== void 0 && !options.while(exit4)) {
      return exit4;
    } else if (options.times !== void 0 && attempt3 >= options.times) {
      return exit4;
    }
    attempt3++;
    let delayEffect = yieldNow2;
    if (options.schedule !== void 0) {
      const elapsed3 = Date.now() - startedAt;
      const duration5 = options.schedule(attempt3, elapsed3);
      if (isNone2(duration5)) {
        return exit4;
      }
      delayEffect = sleep4(duration5.value);
    }
    return flatMap14(delayEffect, () => loop5);
  });
  return loop5;
}));
var repeat = dual((args2) => isMicro(args2[0]), (self, options) => repeatExit(self, {
  ...options,
  while: (exit4) => exit4._tag === "Success" && ((options == null ? void 0 : options.while) === void 0 || options.while(exit4.value))
}));
var replicate3 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect = dual((args2) => isMicro(args2[0]), (self, n, options) => all8(replicate3(self, n), options));
var forever2 = (self) => repeat(self);
var scheduleRecurs = (n) => (attempt3) => attempt3 <= n ? some3(0) : none2();
var scheduleSpaced = (millis2) => () => some3(millis2);
var scheduleExponential = (baseMillis, factor = 2) => (attempt3) => some3(Math.pow(factor, attempt3) * baseMillis);
var scheduleAddDelay = dual(2, (self, f2) => (attempt3, elapsed3) => map2(self(attempt3, elapsed3), (duration5) => duration5 + f2()));
var scheduleWithMaxDelay = dual(2, (self, max14) => (attempt3, elapsed3) => map2(self(attempt3, elapsed3), (duration5) => Math.min(duration5, max14)));
var scheduleWithMaxElapsed = dual(2, (self, max14) => (attempt3, elapsed3) => elapsed3 < max14 ? self(attempt3, elapsed3) : none2());
var scheduleUnion = dual(2, (self, that) => (attempt3, elapsed3) => zipWith2(self(attempt3, elapsed3), that(attempt3, elapsed3), (d1, d2) => Math.min(d1, d2)));
var scheduleIntersect = dual(2, (self, that) => (attempt3, elapsed3) => zipWith2(self(attempt3, elapsed3), that(attempt3, elapsed3), (d1, d2) => Math.max(d1, d2)));
var catchAllCause2 = dual(2, (self, f2) => {
  const onFailure = Object.create(OnFailureProto);
  onFailure[args] = self;
  onFailure[failureCont] = f2;
  return onFailure;
});
var OnFailureProto = makePrimitiveProto({
  op: "OnFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var catchCauseIf = dual(3, (self, predicate, f2) => catchAllCause2(self, (cause3) => predicate(cause3) ? f2(cause3) : failCause4(cause3)));
var catchAll2 = dual(2, (self, f2) => catchCauseIf(self, causeIsFail, (cause3) => f2(cause3.error)));
var catchAllDefect2 = dual(2, (self, f2) => catchCauseIf(self, causeIsDie, (die19) => f2(die19.defect)));
var tapErrorCause2 = dual(2, (self, f2) => tapErrorCauseIf(self, constTrue, f2));
var tapErrorCauseIf = dual(3, (self, refinement, f2) => catchCauseIf(self, refinement, (cause3) => andThen8(f2(cause3), failCause4(cause3))));
var tapError2 = dual(2, (self, f2) => tapErrorCauseIf(self, causeIsFail, (fail30) => f2(fail30.error)));
var tapDefect2 = dual(2, (self, f2) => tapErrorCauseIf(self, causeIsDie, (die19) => f2(die19.defect)));
var catchIf2 = dual(3, (self, predicate, f2) => catchCauseIf(self, (f3) => causeIsFail(f3) && predicate(f3.error), (fail30) => f2(fail30.error)));
var catchTag2 = dual(3, (self, k, f2) => catchIf2(self, isTagged(k), f2));
var mapErrorCause3 = dual(2, (self, f2) => catchAllCause2(self, (cause3) => failCause4(f2(cause3))));
var mapError3 = dual(2, (self, f2) => catchAll2(self, (error4) => fail5(f2(error4))));
var orDie2 = (self) => catchAll2(self, die5);
var orElseSucceed2 = dual(2, (self, f2) => catchAll2(self, (_) => sync3(f2)));
var ignore2 = (self) => matchEffect3(self, {
  onFailure: (_) => void_5,
  onSuccess: (_) => void_5
});
var ignoreLogged2 = (self) => matchEffect3(self, {
  // eslint-disable-next-line no-console
  onFailure: (error4) => sync3(() => console.error(error4)),
  onSuccess: (_) => void_5
});
var option3 = (self) => match11(self, {
  onFailure: none2,
  onSuccess: some3
});
var either4 = (self) => match11(self, {
  onFailure: left2,
  onSuccess: right2
});
var retry = dual((args2) => isMicro(args2[0]), (self, options) => repeatExit(self, {
  ...options,
  while: (exit4) => exit4._tag === "Failure" && exit4.cause._tag === "Fail" && ((options == null ? void 0 : options.while) === void 0 || options.while(exit4.cause.error))
}));
var withTrace = function() {
  const prevLimit = globalThis.Error.stackTraceLimit;
  globalThis.Error.stackTraceLimit = 2;
  const error4 = new globalThis.Error();
  globalThis.Error.stackTraceLimit = prevLimit;
  function generate3(name, cause3) {
    var _a106;
    const stack = error4.stack;
    if (!stack) {
      return cause3;
    }
    const line = (_a106 = stack.split("\n")[2]) == null ? void 0 : _a106.trim().replace(/^at /, "");
    if (!line) {
      return cause3;
    }
    const lineMatch = line.match(/\((.*)\)$/);
    return causeWithTrace(cause3, `at ${name} (${lineMatch ? lineMatch[1] : line})`);
  }
  const f2 = (name) => (self) => onError2(self, (cause3) => failCause4(generate3(name, cause3)));
  if (arguments.length === 2) {
    return f2(arguments[1])(arguments[0]);
  }
  return f2(arguments[0]);
};
var matchCauseEffect2 = dual(2, (self, options) => {
  const primitive3 = Object.create(OnSuccessAndFailureProto);
  primitive3[args] = self;
  primitive3[successCont] = options.onSuccess;
  primitive3[failureCont] = options.onFailure;
  return primitive3;
});
var OnSuccessAndFailureProto = makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var matchCause2 = dual(2, (self, options) => matchCauseEffect2(self, {
  onFailure: (cause3) => sync3(() => options.onFailure(cause3)),
  onSuccess: (value10) => sync3(() => options.onSuccess(value10))
}));
var matchEffect3 = dual(2, (self, options) => matchCauseEffect2(self, {
  onFailure: (cause3) => cause3._tag === "Fail" ? options.onFailure(cause3.error) : failCause4(cause3),
  onSuccess: options.onSuccess
}));
var match11 = dual(2, (self, options) => matchEffect3(self, {
  onFailure: (error4) => sync3(() => options.onFailure(error4)),
  onSuccess: (value10) => sync3(() => options.onSuccess(value10))
}));
var sleep4 = (millis2) => async((resume2) => {
  const timeout6 = setTimeout(() => {
    resume2(void_5);
  }, millis2);
  return sync3(() => {
    clearTimeout(timeout6);
  });
});
var delay2 = dual(2, (self, millis2) => andThen8(sleep4(millis2), self));
var timeoutOrElse = dual(2, (self, options) => raceFirst(self, andThen8(interruptible3(sleep4(options.duration)), options.onTimeout)));
var timeout = dual(2, (self, millis2) => timeoutOrElse(self, {
  duration: millis2,
  onTimeout: () => fail5(new TimeoutException2())
}));
var timeoutOption = dual(2, (self, millis2) => raceFirst(asSome2(self), as5(interruptible3(sleep4(millis2)), none2())));
var MicroScopeTypeId = Symbol.for("effect/Micro/MicroScope");
var MicroScope = GenericTag("effect/Micro/MicroScope");
var _a23;
_a23 = MicroScopeTypeId;
var _MicroScopeImpl = class _MicroScopeImpl {
  constructor() {
    __publicField(this, _a23);
    __publicField(this, "state", {
      _tag: "Open",
      finalizers: /* @__PURE__ */ new Set()
    });
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer3);
    }
  }
  addFinalizer(finalizer3) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer3);
        return void_5;
      }
      return finalizer3(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer3);
    }
  }
  close(microExit) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap14(forEach11(finalizers, (finalizer3) => exit2(finalizer3(microExit))), exitVoidAll);
      }
      return void_5;
    });
  }
  get fork() {
    return sync3(() => {
      const newScope = new _MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit4) {
        return newScope.close(exit4);
      }
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_) => sync3(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
var MicroScopeImpl = _MicroScopeImpl;
var scopeMake = sync3(() => new MicroScopeImpl());
var scopeUnsafeMake = () => new MicroScopeImpl();
var scope = service(MicroScope);
var provideScope = dual(2, (self, scope6) => provideService2(self, MicroScope, scope6));
var scoped = (self) => suspend2(() => {
  const scope6 = new MicroScopeImpl();
  return onExit2(provideService2(self, MicroScope, scope6), (exit4) => scope6.close(exit4));
});
var acquireRelease = (acquire4, release4) => uninterruptible2(flatMap14(scope, (scope6) => tap3(acquire4, (a) => scope6.addFinalizer((exit4) => release4(a, exit4)))));
var addFinalizer = (finalizer3) => flatMap14(scope, (scope6) => scope6.addFinalizer(finalizer3));
var onExit2 = dual(2, (self, f2) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
  onFailure: (cause3) => flatMap14(f2(exitFailCause2(cause3)), () => failCause4(cause3)),
  onSuccess: (a) => flatMap14(f2(exitSucceed2(a)), () => succeed4(a))
})));
var ensuring = dual(2, (self, finalizer3) => onExit2(self, (_) => finalizer3));
var onExitIf = dual(3, (self, refinement, f2) => onExit2(self, (exit4) => refinement(exit4) ? f2(exit4) : exitVoid2));
var onError2 = dual(2, (self, f2) => onExitIf(self, exitIsFailure2, (exit4) => f2(exit4.cause)));
var onInterrupt2 = dual(2, (self, finalizer3) => onExitIf(self, exitIsInterrupt, (_) => finalizer3));
var acquireUseRelease2 = (acquire4, use2, release4) => uninterruptibleMask2((restore) => flatMap14(acquire4, (a) => flatMap14(exit2(restore(use2(a))), (exit4) => andThen8(release4(a, exit4), exit4))));
var interrupt5 = failCause4(causeInterrupt());
var uninterruptible2 = (self) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return self;
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return self;
});
var setInterruptible = makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self;
});
var uninterruptibleMask2 = (f2) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f2(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f2(interruptible3);
});
var all8 = (arg, options) => {
  if (Array.isArray(arg) || isIterable(arg)) {
    return forEach11(arg, identity, options);
  } else if (options == null ? void 0 : options.discard) {
    return forEach11(Object.values(arg), identity, options);
  }
  return suspend2(() => {
    const out = {};
    return as5(forEach11(Object.entries(arg), ([key, effect4]) => map17(effect4, (value10) => {
      out[key] = value10;
    }), {
      discard: true,
      concurrency: options == null ? void 0 : options.concurrency
    }), out);
  });
};
var whileLoop2 = makePrimitive({
  op: "While",
  contA(value10, fiber) {
    this[args].step(value10);
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  },
  eval(fiber) {
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  }
});
var forEach11 = (iterable, f2, options) => withMicroFiber((parent) => {
  const concurrencyOption = (options == null ? void 0 : options.concurrency) === "inherit" ? parent.getRef(CurrentConcurrency) : (options == null ? void 0 : options.concurrency) ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable2(iterable);
  let length6 = items.length;
  if (length6 === 0) {
    return (options == null ? void 0 : options.discard) ? void_5 : succeed4([]);
  }
  const out = (options == null ? void 0 : options.discard) ? void 0 : new Array(length6);
  let index3 = 0;
  if (concurrency === 1) {
    return as5(whileLoop2({
      while: () => index3 < items.length,
      body: () => f2(items[index3], index3),
      step: out ? (b) => out[index3++] = b : (_) => index3++
    }), out);
  }
  return async((resume2) => {
    const fibers2 = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted4 = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index3 < length6) {
        const currentIndex = index3;
        const item = items[currentIndex];
        index3++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f2(item, currentIndex), true, true);
          fibers2.add(child);
          child.addObserver((exit4) => {
            fibers2.delete(child);
            if (interrupted4) {
              return;
            } else if (exit4._tag === "Failure") {
              if (result === void 0) {
                result = exit4;
                length6 = index3;
                fibers2.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit4.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length6) {
              resume2(result ?? succeed4(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err2) {
          result = exitDie2(err2);
          length6 = index3;
          fibers2.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    pump();
    return suspend2(() => {
      interrupted4 = true;
      index3 = length6;
      return fiberInterruptAll(fibers2);
    });
  });
});
var filter12 = (iterable, f2, options) => filterMap10(iterable, (a) => map17(f2(a), (pass) => {
  pass = (options == null ? void 0 : options.negate) ? !pass : pass;
  return pass ? some3(a) : none2();
}), options);
var filterMap10 = (iterable, f2, options) => suspend2(() => {
  const out = [];
  return as5(forEach11(iterable, (a) => map17(f2(a), (o) => {
    if (o._tag === "Some") {
      out.push(o.value);
    }
  }), {
    discard: true,
    concurrency: options == null ? void 0 : options.concurrency
  }), out);
});
var Do5 = succeed4({});
var bindTo6 = bindTo(map17);
var bind6 = bind(map17, flatMap14);
var let_6 = let_(map17);
var fork = (self) => withMicroFiber((fiber) => {
  fiberMiddleware.interruptChildren ?? (fiberMiddleware.interruptChildren = fiberInterruptChildren);
  return succeed4(unsafeFork(fiber, self));
});
var unsafeFork = (parent, effect4, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect4);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect4), 0);
  }
  return child;
};
var forkDaemon = (self) => withMicroFiber((fiber) => succeed4(unsafeFork(fiber, self, false, true)));
var forkIn = dual(2, (self, scope6) => uninterruptibleMask2((restore) => flatMap14(scope6.fork, (scope7) => tap3(restore(forkDaemon(onExit2(self, (exit4) => scope7.close(exit4)))), (fiber) => scope7.addFinalizer((_) => fiberInterrupt(fiber))))));
var forkScoped = (self) => flatMap14(scope, (scope6) => forkIn(self, scope6));
var runFork = (effect4, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context((options == null ? void 0 : options.scheduler) ?? new MicroSchedulerDefault()));
  fiber.evaluate(effect4);
  if (options == null ? void 0 : options.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};
var runPromiseExit = (effect4, options) => new Promise((resolve, _reject) => {
  const handle = runFork(effect4, options);
  handle.addObserver(resolve);
});
var runPromise = (effect4, options) => runPromiseExit(effect4, options).then((exit4) => {
  if (exit4._tag === "Failure") {
    throw exit4.cause;
  }
  return exit4.value;
});
var runSyncExit = (effect4) => {
  const scheduler2 = new MicroSchedulerDefault();
  const fiber = runFork(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  return fiber._exit ?? exitDie2(fiber);
};
var runSync = (effect4) => {
  const exit4 = runSyncExit(effect4);
  if (exit4._tag === "Failure") throw exit4.cause;
  return exit4.value;
};
var YieldableError2 = function() {
  class YieldableError4 extends globalThis.Error {
  }
  Object.assign(YieldableError4.prototype, MicroProto, StructuralPrototype, {
    [identifier]: "Failure",
    [evaluate]() {
      return fail5(this);
    },
    toString() {
      return this.message ? `${this.name}: ${this.message}` : this.name;
    },
    toJSON() {
      return {
        ...this
      };
    },
    [NodeInspectSymbol]() {
      const stack = this.stack;
      if (stack) {
        return `${this.toString()}
${stack.split("\n").slice(1).join("\n")}`;
      }
      return this.toString();
    }
  });
  return YieldableError4;
}();
var Error3 = /* @__PURE__ */ function() {
  return class extends YieldableError2 {
    constructor(args2) {
      super();
      if (args2) {
        Object.assign(this, args2);
      }
    }
  };
}();
var TaggedError = (tag5) => {
  class Base4 extends Error3 {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag5);
    }
  }
  ;
  Base4.prototype.name = tag5;
  return Base4;
};
var NoSuchElementException2 = class extends TaggedError("NoSuchElementException") {
};
var TimeoutException2 = class extends TaggedError("TimeoutException") {
};

// node_modules/effect/dist/esm/Scheduler.js
var Scheduler_exports = {};
__export(Scheduler_exports, {
  ControlledScheduler: () => ControlledScheduler,
  MixedScheduler: () => MixedScheduler,
  PriorityBuckets: () => PriorityBuckets,
  SyncScheduler: () => SyncScheduler,
  currentScheduler: () => currentScheduler,
  defaultScheduler: () => defaultScheduler,
  defaultShouldYield: () => defaultShouldYield,
  make: () => make40,
  makeBatched: () => makeBatched,
  makeMatrix: () => makeMatrix,
  timer: () => timer,
  timerBatched: () => timerBatched,
  withScheduler: () => withScheduler
});
var PriorityBuckets = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, "buckets", []);
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length6 = this.buckets.length;
    let bucket = void 0;
    let index3 = 0;
    for (; index3 < length6; index3++) {
      if (this.buckets[index3][0] <= priority) {
        bucket = this.buckets[index3];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index3 === length6) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index3, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  constructor(maxNextTickBeforeTimer) {
    __publicField(this, "maxNextTickBeforeTimer");
    /**
     * @since 2.0.0
     */
    __publicField(this, "running", false);
    /**
     * @since 2.0.0
     */
    __publicField(this, "tasks", new PriorityBuckets());
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = globalValue(Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, "tasks", new PriorityBuckets());
    /**
     * @since 2.0.0
     */
    __publicField(this, "deferred", false);
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var ControlledScheduler = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, "tasks", new PriorityBuckets());
    /**
     * @since 2.0.0
     */
    __publicField(this, "deferred", false);
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  step() {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
  }
};
var makeMatrix = (...record4) => {
  const index3 = record4.sort(([p0], [p1]) => p0 < p1 ? -1 : p0 > p1 ? 1 : 0);
  return {
    shouldYield(fiber) {
      for (const scheduler2 of record4) {
        const priority = scheduler2[1].shouldYield(fiber);
        if (priority !== false) {
          return priority;
        }
      }
      return false;
    },
    scheduleTask(task, priority) {
      let scheduler2 = void 0;
      for (const i of index3) {
        if (priority >= i[0]) {
          scheduler2 = i[1];
        } else {
          return (scheduler2 ?? defaultScheduler).scheduleTask(task, priority);
        }
      }
      return (scheduler2 ?? defaultScheduler).scheduleTask(task, priority);
    }
  };
};
var defaultShouldYield = (fiber) => {
  return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
};
var make40 = (scheduleTask, shouldYield = defaultShouldYield) => ({
  scheduleTask,
  shouldYield
});
var makeBatched = (callback, shouldYield = defaultShouldYield) => {
  let running4 = false;
  const tasks = new PriorityBuckets();
  const starveInternal = () => {
    const tasksToRun = tasks.buckets;
    tasks.buckets = [];
    for (const [_, toRun] of tasksToRun) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (tasks.buckets.length === 0) {
      running4 = false;
    } else {
      starve();
    }
  };
  const starve = () => callback(starveInternal);
  return make40((task, priority) => {
    tasks.scheduleTask(task, priority);
    if (!running4) {
      running4 = true;
      starve();
    }
  }, shouldYield);
};
var timer = (ms, shouldYield = defaultShouldYield) => make40((task) => setTimeout(task, ms), shouldYield);
var timerBatched = (ms, shouldYield = defaultShouldYield) => makeBatched((task) => setTimeout(task, ms), shouldYield);
var currentScheduler = globalValue(Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = dual(2, (self, scheduler2) => fiberRefLocally(self, currentScheduler, scheduler2));

// node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = globalValue(Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// node_modules/effect/dist/esm/internal/concurrency.js
var match12 = (concurrency, sequential6, unbounded10, bounded10) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return unbounded10();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded10() : concurrency2 > 1 ? bounded10(concurrency2) : sequential6());
    default:
      return concurrency > 1 ? bounded10(concurrency) : sequential6();
  }
};
var matchSimple = (concurrency, sequential6, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential6());
    default:
      return concurrency > 1 ? concurrent() : sequential6();
  }
};

// node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause3) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause3
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect4) => ({
  _tag: OP_RESUME,
  effect: effect4
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = Symbol.for(FiberScopeSymbolKey);
var _a24;
_a24 = FiberScopeTypeId;
var Global = class {
  constructor() {
    __publicField(this, _a24, FiberScopeTypeId);
    __publicField(this, "fiberId", none4);
    __publicField(this, "roots", /* @__PURE__ */ new Set());
  }
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var _a25;
_a25 = FiberScopeTypeId;
var Local = class {
  constructor(fiberId5, parent) {
    __publicField(this, "fiberId");
    __publicField(this, "parent");
    __publicField(this, _a25, FiberScopeTypeId);
    this.fiberId = fiberId5;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake9 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = globalValue(Symbol.for("effect/FiberScope/Global"), () => new Global());

// node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = Symbol.for(RuntimeFiberSymbolKey);
var Order7 = pipe(tuple3(Order, Order), mapInput3((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
var isFiber = (u) => hasProperty(u, FiberTypeId);
var isRuntimeFiber = (self) => RuntimeFiberTypeId in self;
var _await2 = (self) => self.await;
var children = (self) => self.children;
var done5 = (exit4) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => none4,
    await: succeed(exit4),
    children: succeed([]),
    inheritAll: void_3,
    poll: succeed(some3(exit4)),
    interruptAsFork: () => void_3
  };
  return _fiber;
};
var dump = (self) => map14(self.status, (status3) => ({
  id: self.id(),
  status: status3
}));
var dumpAll = (fibers2) => forEachSequential(fibers2, dump);
var fail6 = (error4) => done5(fail4(error4));
var failCause5 = (cause3) => done5(failCause3(cause3));
var fromEffect = (effect4) => map14(exit(effect4), done5);
var id = (self) => self.id();
var inheritAll = (self) => self.inheritAll;
var interrupted = (fiberId5) => done5(interrupt4(fiberId5));
var interruptAll = (fibers2) => flatMap12(fiberId, (fiberId5) => pipe(fibers2, interruptAllAs(fiberId5)));
var interruptAllAs = dual(2, (fibers2, fiberId5) => pipe(forEachSequentialDiscard(fibers2, interruptAsFork(fiberId5)), zipRight2(pipe(fibers2, forEachSequentialDiscard(_await2)))));
var interruptAsFork = dual(2, (self, fiberId5) => self.interruptAsFork(fiberId5));
var join3 = (self) => zipLeft2(flatten8(self.await), self.inheritAll);
var map18 = dual(2, (self, f2) => mapEffect2(self, (a) => sync(() => f2(a))));
var mapEffect2 = dual(2, (self, f2) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => self.id(),
    await: flatMap12(self.await, forEachEffect(f2)),
    children: self.children,
    inheritAll: self.inheritAll,
    poll: flatMap12(self.poll, (result) => {
      switch (result._tag) {
        case "None":
          return succeed(none2());
        case "Some":
          return pipe(forEachEffect(result.value, f2), map14(some3));
      }
    }),
    interruptAsFork: (id3) => self.interruptAsFork(id3)
  };
  return _fiber;
});
var mapFiber = dual(2, (self, f2) => map14(self.await, match7({
  onFailure: (cause3) => failCause5(cause3),
  onSuccess: (a) => f2(a)
})));
var match13 = dual(2, (self, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self)) {
    return onRuntimeFiber(self);
  }
  return onFiber(self);
});
var _never = {
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: succeed([]),
  inheritAll: never,
  poll: succeed(none2()),
  interruptAsFork: () => never
};
var never3 = _never;
var orElse5 = dual(2, (self, that) => ({
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: () => getOrElse6(self.id(), that.id()),
  await: zipWith6(self.await, that.await, (exit1, exit22) => isSuccess(exit1) ? exit1 : exit22),
  children: self.children,
  inheritAll: zipRight2(that.inheritAll, self.inheritAll),
  poll: zipWith6(self.poll, that.poll, (option1, option22) => {
    switch (option1._tag) {
      case "None": {
        return none2();
      }
      case "Some": {
        return isSuccess(option1.value) ? option1 : option22;
      }
    }
  }),
  interruptAsFork: (id3) => pipe(interruptAsFiber(self, id3), zipRight2(pipe(that, interruptAsFiber(id3))), asVoid2)
}));
var orElseEither3 = dual(2, (self, that) => orElse5(map18(self, left2), map18(that, right2)));
var poll3 = (self) => self.poll;
var parseMs = (milliseconds) => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 864e5),
    hours: roundTowardsZero(milliseconds / 36e5) % 24,
    minutes: roundTowardsZero(milliseconds / 6e4) % 60,
    seconds: roundTowardsZero(milliseconds / 1e3) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1e3,
    microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
  };
};
var renderStatus = (status3) => {
  if (isDone3(status3)) {
    return "Done";
  }
  if (isRunning2(status3)) {
    return "Running";
  }
  const isInterruptible = interruptible(status3.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
};
var pretty2 = (self) => flatMap12(currentTimeMillis2, (now3) => map14(dump(self), (dump3) => {
  const time3 = now3 - dump3.id.startTimeMillis;
  const {
    days: days2,
    hours: hours2,
    milliseconds,
    minutes: minutes2,
    seconds: seconds2
  } = parseMs(time3);
  const lifeMsg = (days2 === 0 ? "" : `${days2}d`) + (days2 === 0 && hours2 === 0 ? "" : `${hours2}h`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 ? "" : `${minutes2}m`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 && seconds2 === 0 ? "" : `${seconds2}s`) + `${milliseconds}ms`;
  const waitMsg = isSuspended2(dump3.status) ? (() => {
    const ids3 = ids2(dump3.status.blockingOn);
    return size9(ids3) > 0 ? `waiting on ` + Array.from(ids3).map((id3) => `${id3}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump3.status);
  return `[Fiber](#${dump3.id.id}) (${lifeMsg}) ${waitMsg}
   Status: ${statusMsg}`;
}));
var unsafeRoots = () => Array.from(globalScope.roots);
var roots = sync(unsafeRoots);
var status = (self) => self.status;
var succeed5 = (value10) => done5(succeed3(value10));
var void_6 = succeed5(void 0);
var currentFiberURI = "effect/FiberCurrent";
var getCurrentFiber = () => fromNullable2(globalThis[currentFiberURI]);

// node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_) => _,
  /* c8 ignore next */
  _Output: (_) => _
};
var makeLogger = (log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: log5,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var mapInput4 = dual(2, (self, f2) => makeLogger((options) => self.log({
  ...options,
  message: f2(options.message)
})));
var mapInputOptions = dual(2, (self, f2) => makeLogger((options) => self.log(f2(options))));
var filterLogLevel = dual(2, (self, f2) => makeLogger((options) => f2(options.logLevel) ? some3(self.log(options)) : none2()));
var map19 = dual(2, (self, f2) => makeLogger((options) => f2(self.log(options))));
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var simple = (log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: ({
    message
  }) => log5(message),
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var succeed6 = (value10) => {
  return simple(() => value10);
};
var sync4 = (evaluate4) => {
  return simple(evaluate4);
};
var zip8 = dual(2, (self, that) => makeLogger((options) => [self.log(options), that.log(options)]));
var zipLeft4 = dual(2, (self, that) => map19(zip8(self, that), (tuple7) => tuple7[0]));
var zipRight4 = dual(2, (self, that) => map19(zip8(self, that), (tuple7) => tuple7[1]));
var textOnly = /^[^\s"=]*$/;
var format4 = (quoteValue, whitespace) => ({
  annotations: annotations4,
  cause: cause3,
  date: date5,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message,
  spans
}) => {
  const formatValue = (value10) => value10.match(textOnly) ? value10 : quoteValue(value10);
  const format16 = (label, value10) => `${formatLabel(label)}=${formatValue(value10)}`;
  const append6 = (label, value10) => " " + format16(label, value10);
  let out = format16("timestamp", date5.toISOString());
  out += append6("level", logLevel3.label);
  out += append6("fiber", threadName(fiberId5));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append6("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause3)) {
    out += append6("cause", pretty(cause3, {
      renderErrorCause: true
    }));
  }
  for (const span4 of spans) {
    out += " " + render3(date5.getTime())(span4);
  }
  for (const [label, value10] of annotations4) {
    out += append6(label, toStringUnknown(value10, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = makeLogger(format4(escapeDoubleQuotes));
var logfmtLogger = makeLogger(format4(JSON.stringify, 0));
var structuredLogger = makeLogger(({
  annotations: annotations4,
  cause: cause3,
  date: date5,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message,
  spans
}) => {
  const now3 = date5.getTime();
  const annotationsObj = {};
  const spansObj = {};
  if (size10(annotations4) > 0) {
    for (const [k, v] of annotations4) {
      annotationsObj[k] = structuredMessage(v);
    }
  }
  if (isCons(spans)) {
    for (const span4 of spans) {
      spansObj[span4.label] = now3 - span4.startTime;
    }
  }
  const messageArr = ensure(message);
  return {
    message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
    logLevel: logLevel3.label,
    timestamp: date5.toISOString(),
    cause: isEmpty7(cause3) ? void 0 : pretty(cause3, {
      renderErrorCause: true
    }),
    annotations: annotationsObj,
    spans: spansObj,
    fiberId: threadName(fiberId5)
  };
});
var structuredMessage = (u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
};
var jsonLogger = map19(structuredLogger, stringifyCircular);
var isLogger = (u) => {
  return typeof u === "object" && u != null && LoggerTypeId in u;
};
var withColor = (text, ...colors2) => {
  let out = "";
  for (let i = 0; i < colors2.length; i++) {
    out += `\x1B[${colors2[i]}m`;
  }
  return out + text + "\x1B[0m";
};
var withColorNoop = (text, ..._colors) => text;
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = (date5) => `${date5.getHours().toString().padStart(2, "0")}:${date5.getMinutes().toString().padStart(2, "0")}:${date5.getSeconds().toString().padStart(2, "0")}.${date5.getMilliseconds().toString().padStart(3, "0")}`;
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = (options) => {
  const mode_ = (options == null ? void 0 : options.mode) ?? "auto";
  const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
  const isBrowser = mode === "browser";
  const showColors = typeof (options == null ? void 0 : options.colors) === "boolean" ? options.colors : processStdoutIsTTY || isBrowser;
  const formatDate2 = (options == null ? void 0 : options.formatDate) ?? defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate: formatDate2
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate: formatDate2,
    stderr: (options == null ? void 0 : options.stderr) === true
  });
};
var prettyLoggerTty = (options) => {
  const processIsBun = typeof process === "object" && "isBun" in process && process.isBun === true;
  const color = options.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations: annotations4,
    cause: cause3,
    context: context15,
    date: date5,
    fiberId: fiberId5,
    logLevel: logLevel3,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context15, currentServices);
    const console4 = get4(services, consoleTag).unsafe;
    const log5 = options.stderr === true ? console4.error : console4.log;
    const message = ensure(message_);
    let firstLine = color(`[${options.formatDate(date5)}]`, colors.white) + ` ${color(logLevel3.label, ...logLevelColors[logLevel3._tag])} (${threadName(fiberId5)})`;
    if (isCons(spans)) {
      const now3 = date5.getTime();
      const render6 = render3(now3);
      for (const span4 of spans) {
        firstLine += " " + render6(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log5(firstLine);
    if (!processIsBun) console4.group();
    if (!isEmpty7(cause3)) {
      log5(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        log5(redact(message[messageIndex]));
      }
    }
    if (size10(annotations4) > 0) {
      for (const [key, value10] of annotations4) {
        log5(color(`${key}:`, colors.bold, colors.white), redact(value10));
      }
    }
    if (!processIsBun) console4.groupEnd();
  });
};
var prettyLoggerBrowser = (options) => {
  const color = options.colors ? "%c" : "";
  return makeLogger(({
    annotations: annotations4,
    cause: cause3,
    context: context15,
    date: date5,
    fiberId: fiberId5,
    logLevel: logLevel3,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context15, currentServices);
    const console4 = get4(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color}[${options.formatDate(date5)}]`;
    const firstParams = [];
    if (options.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color}${logLevel3.label}${color} (${threadName(fiberId5)})`;
    if (options.colors) {
      firstParams.push(logLevelStyle[logLevel3._tag], "");
    }
    if (isCons(spans)) {
      const now3 = date5.getTime();
      const render6 = render3(now3);
      for (const span4 of spans) {
        firstLine += " " + render6(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color}${firstMaybeString}`;
        if (options.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console4.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty7(cause3)) {
      console4.error(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        console4.log(redact(message[messageIndex]));
      }
    }
    if (size10(annotations4) > 0) {
      for (const [key, value10] of annotations4) {
        const redacted3 = redact(value10);
        if (options.colors) {
          console4.log(`%c${key}:`, "color:gray", redacted3);
        } else {
          console4.log(`${key}:`, redacted3);
        }
      }
    }
    console4.groupEnd();
  });
};
var prettyLoggerDefault = globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = Symbol.for(MetricBoundariesSymbolKey);
var _a26;
var MetricBoundariesImpl = class {
  constructor(values15) {
    __publicField(this, "values");
    __publicField(this, _a26, MetricBoundariesTypeId);
    __publicField(this, "_hash");
    this.values = values15;
    this._hash = pipe(string2(MetricBoundariesSymbolKey), combine2(array2(this.values)));
  }
  [(_a26 = MetricBoundariesTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable11 = (iterable) => {
  const values15 = pipe(iterable, appendAll2(of3(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values15);
};
var linear = (options) => pipe(makeBy2(options.count - 1, (i) => options.start + i * options.width), unsafeFromArray, fromIterable11);
var exponential = (options) => pipe(makeBy2(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable11);

// node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var _a27, _b2;
var CounterKeyType = class {
  constructor(incremental, bigint4) {
    __publicField(this, "incremental");
    __publicField(this, "bigint");
    __publicField(this, _b2, metricKeyTypeVariance);
    __publicField(this, _a27, CounterKeyTypeTypeId);
    __publicField(this, "_hash");
    this.incremental = incremental;
    this.bigint = bigint4;
    this._hash = string2(CounterKeyTypeSymbolKey);
  }
  [(_b2 = MetricKeyTypeTypeId, _a27 = CounterKeyTypeTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FrequencyKeyTypeHash = string2(FrequencyKeyTypeSymbolKey);
var _a28, _b3;
var FrequencyKeyType = class {
  constructor(preregisteredWords) {
    __publicField(this, "preregisteredWords");
    __publicField(this, _b3, metricKeyTypeVariance);
    __publicField(this, _a28, FrequencyKeyTypeTypeId);
    this.preregisteredWords = preregisteredWords;
  }
  [(_b3 = MetricKeyTypeTypeId, _a28 = FrequencyKeyTypeTypeId, symbol2)]() {
    return FrequencyKeyTypeHash;
  }
  [symbol3](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeKeyTypeHash = string2(GaugeKeyTypeSymbolKey);
var _a29, _b4;
var GaugeKeyType = class {
  constructor(bigint4) {
    __publicField(this, "bigint");
    __publicField(this, _b4, metricKeyTypeVariance);
    __publicField(this, _a29, GaugeKeyTypeTypeId);
    this.bigint = bigint4;
  }
  [(_b4 = MetricKeyTypeTypeId, _a29 = GaugeKeyTypeTypeId, symbol2)]() {
    return GaugeKeyTypeHash;
  }
  [symbol3](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a30, _b5;
var HistogramKeyType = class {
  constructor(boundaries) {
    __publicField(this, "boundaries");
    __publicField(this, _b5, metricKeyTypeVariance);
    __publicField(this, _a30, HistogramKeyTypeTypeId);
    __publicField(this, "_hash");
    this.boundaries = boundaries;
    this._hash = pipe(string2(HistogramKeyTypeSymbolKey), combine2(hash(this.boundaries)));
  }
  [(_b5 = MetricKeyTypeTypeId, _a30 = HistogramKeyTypeTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a31, _b6;
var SummaryKeyType = class {
  constructor(maxAge, maxSize, error4, quantiles) {
    __publicField(this, "maxAge");
    __publicField(this, "maxSize");
    __publicField(this, "error");
    __publicField(this, "quantiles");
    __publicField(this, _b6, metricKeyTypeVariance);
    __publicField(this, _a31, SummaryKeyTypeTypeId);
    __publicField(this, "_hash");
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error4;
    this.quantiles = quantiles;
    this._hash = pipe(string2(SummaryKeyTypeSymbolKey), combine2(hash(this.maxAge)), combine2(hash(this.maxSize)), combine2(hash(this.error)), combine2(array2(this.quantiles)));
  }
  [(_b6 = MetricKeyTypeTypeId, _a31 = SummaryKeyTypeTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter2 = (options) => new CounterKeyType((options == null ? void 0 : options.incremental) ?? false, (options == null ? void 0 : options.bigint) ?? false);
var frequency = (options) => new FrequencyKeyType((options == null ? void 0 : options.preregisteredWords) ?? []);
var gauge = (options) => new GaugeKeyType((options == null ? void 0 : options.bigint) ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var summary = (options) => {
  return new SummaryKeyType(decode(options.maxAge), options.maxSize, options.error, options.quantiles);
};
var isMetricKeyType = (u) => hasProperty(u, MetricKeyTypeTypeId);
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var arrayEquivilence = getEquivalence5(equals);
var _a32;
var MetricKeyImpl = class {
  constructor(name, keyType, description, tags3 = []) {
    __publicField(this, "name");
    __publicField(this, "keyType");
    __publicField(this, "description");
    __publicField(this, "tags");
    __publicField(this, _a32, metricKeyVariance);
    __publicField(this, "_hash");
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags3;
    this._hash = pipe(string2(this.name + this.description), combine2(hash(this.keyType)), combine2(array2(this.tags)));
  }
  [(_a32 = MetricKeyTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter3 = (name, options) => new MetricKeyImpl(name, counter2(options), fromNullable2(options == null ? void 0 : options.description));
var frequency2 = (name, options) => new MetricKeyImpl(name, frequency(options), fromNullable2(options == null ? void 0 : options.description));
var gauge2 = (name, options) => new MetricKeyImpl(name, gauge(options), fromNullable2(options == null ? void 0 : options.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable2(description));
var summary2 = (options) => new MetricKeyImpl(options.name, summary(options), fromNullable2(options.description));
var tagged = dual(3, (self, key, value10) => taggedWithLabels(self, [make39(key, value10)]));
var taggedWithLabels = dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union2(self.tags, extraTags)));

// node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a33, _b7;
var CounterState = class {
  constructor(count9) {
    __publicField(this, "count");
    __publicField(this, _b7, metricStateVariance);
    __publicField(this, _a33, CounterStateTypeId);
    this.count = count9;
  }
  [(_b7 = MetricStateTypeId, _a33 = CounterStateTypeId, symbol2)]() {
    return pipe(hash(CounterStateSymbolKey), combine2(hash(this.count)), cached(this));
  }
  [symbol3](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = getEquivalence5(equals);
var _a34, _b8;
var FrequencyState = class {
  constructor(occurrences) {
    __publicField(this, "occurrences");
    __publicField(this, _b8, metricStateVariance);
    __publicField(this, _a34, FrequencyStateTypeId);
    __publicField(this, "_hash");
    this.occurrences = occurrences;
  }
  [(_b8 = MetricStateTypeId, _a34 = FrequencyStateTypeId, symbol2)]() {
    return pipe(string2(FrequencyStateSymbolKey), combine2(array2(fromIterable2(this.occurrences.entries()))), cached(this));
  }
  [symbol3](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable2(this.occurrences.entries()), fromIterable2(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a35, _b9;
var GaugeState = class {
  constructor(value10) {
    __publicField(this, "value");
    __publicField(this, _b9, metricStateVariance);
    __publicField(this, _a35, GaugeStateTypeId);
    this.value = value10;
  }
  [(_b9 = MetricStateTypeId, _a35 = GaugeStateTypeId, symbol2)]() {
    return pipe(hash(GaugeStateSymbolKey), combine2(hash(this.value)), cached(this));
  }
  [symbol3](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a36, _b10;
var HistogramState = class {
  constructor(buckets, count9, min11, max14, sum7) {
    __publicField(this, "buckets");
    __publicField(this, "count");
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "sum");
    __publicField(this, _b10, metricStateVariance);
    __publicField(this, _a36, HistogramStateTypeId);
    this.buckets = buckets;
    this.count = count9;
    this.min = min11;
    this.max = max14;
    this.sum = sum7;
  }
  [(_b10 = MetricStateTypeId, _a36 = HistogramStateTypeId, symbol2)]() {
    return pipe(hash(HistogramStateSymbolKey), combine2(hash(this.buckets)), combine2(hash(this.count)), combine2(hash(this.min)), combine2(hash(this.max)), combine2(hash(this.sum)), cached(this));
  }
  [symbol3](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a37, _b11;
var SummaryState = class {
  constructor(error4, quantiles, count9, min11, max14, sum7) {
    __publicField(this, "error");
    __publicField(this, "quantiles");
    __publicField(this, "count");
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "sum");
    __publicField(this, _b11, metricStateVariance);
    __publicField(this, _a37, SummaryStateTypeId);
    this.error = error4;
    this.quantiles = quantiles;
    this.count = count9;
    this.min = min11;
    this.max = max14;
    this.sum = sum7;
  }
  [(_b11 = MetricStateTypeId, _a37 = SummaryStateTypeId, symbol2)]() {
    return pipe(hash(SummaryStateSymbolKey), combine2(hash(this.error)), combine2(hash(this.quantiles)), combine2(hash(this.count)), combine2(hash(this.min)), combine2(hash(this.max)), combine2(hash(this.sum)), cached(this));
  }
  [symbol3](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter4 = (count9) => new CounterState(count9);
var frequency3 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge3 = (count9) => new GaugeState(count9);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary3 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isMetricState = (u) => hasProperty(u, MetricStateTypeId);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var make41 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var onModify = dual(2, (self, f2) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  get: self.get,
  update: self.update,
  modify: (input) => {
    self.modify(input);
    return f2(input);
  }
}));
var onUpdate = dual(2, (self, f2) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  get: self.get,
  update: (input) => {
    self.update(input);
    return f2(input);
  },
  modify: self.modify
}));
var bigint05 = BigInt(0);
var counter5 = (key) => {
  let sum7 = key.keyType.bigint ? bigint05 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value10) => value10 >= bigint05 : (value10) => value10 >= 0 : (_value2) => true;
  const update18 = (value10) => {
    if (canUpdate(value10)) {
      sum7 = sum7 + value10;
    }
  };
  return make41({
    get: () => counter4(sum7),
    update: update18,
    modify: update18
  });
};
var frequency4 = (key) => {
  const values15 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values15.set(word, 0);
  }
  const update18 = (word) => {
    const slotCount = values15.get(word) ?? 0;
    values15.set(word, slotCount + 1);
  };
  return make41({
    get: () => frequency3(values15),
    update: update18,
    modify: update18
  });
};
var gauge4 = (_key, startAt) => {
  let value10 = startAt;
  return make41({
    get: () => gauge3(value10),
    update: (v) => {
      value10 = v;
    },
    modify: (v) => {
      value10 = value10 + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size45 = bounds.length;
  const values15 = new Uint32Array(size45 + 1);
  const boundaries = new Float32Array(size45);
  let count9 = 0;
  let sum7 = 0;
  let min11 = Number.MAX_VALUE;
  let max14 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map6((n, i) => {
    boundaries[i] = n;
  }));
  const update18 = (value10) => {
    let from29 = 0;
    let to3 = size45;
    while (from29 !== to3) {
      const mid = Math.floor(from29 + (to3 - from29) / 2);
      const boundary = boundaries[mid];
      if (value10 <= boundary) {
        to3 = mid;
      } else {
        from29 = mid;
      }
      if (to3 === from29 + 1) {
        if (value10 <= boundaries[from29]) {
          to3 = from29;
        } else {
          from29 = to3;
        }
      }
    }
    values15[from29] = values15[from29] + 1;
    count9 = count9 + 1;
    sum7 = sum7 + value10;
    if (value10 < min11) {
      min11 = value10;
    }
    if (value10 > max14) {
      max14 = value10;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size45);
    let cumulated = 0;
    for (let i = 0; i < size45; i++) {
      const boundary = boundaries[i];
      const value10 = values15[i];
      cumulated = cumulated + value10;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make41({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count9,
      min: min11,
      max: max14,
      sum: sum7
    }),
    update: update18,
    modify: update18
  });
};
var summary4 = (key) => {
  const {
    error: error4,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values15 = allocate(maxSize);
  let head13 = 0;
  let count9 = 0;
  let sum7 = 0;
  let min11 = 0;
  let max14 = 0;
  const snapshot4 = (now3) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values15[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now3 - t);
        if (greaterThanOrEqualTo5(age, zero2) && lessThanOrEqualTo5(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error4, sortedQuantiles, sort(builder, Order));
  };
  const observe2 = (value10, timestamp) => {
    if (maxSize > 0) {
      head13 = head13 + 1;
      const target = head13 % maxSize;
      values15[target] = [timestamp, value10];
    }
    min11 = count9 === 0 ? value10 : Math.min(min11, value10);
    max14 = count9 === 0 ? value10 : Math.max(max14, value10);
    count9 = count9 + 1;
    sum7 = sum7 + value10;
  };
  return make41({
    get: () => summary3({
      error: error4,
      quantiles: snapshot4(Date.now()),
      count: count9,
      min: min11,
      max: max14,
      sum: sum7
    }),
    update: ([value10, timestamp]) => observe2(value10, timestamp),
    modify: ([value10, timestamp]) => observe2(value10, timestamp)
  });
};
var calculateQuantiles = (error4, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty4();
  }
  const head13 = sortedQuantiles[0];
  const tail5 = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error4, sampleCount, none2(), 0, head13, sortedSamples);
  const resolved = of2(resolvedHead);
  tail5.forEach((quantile) => {
    resolved.push(resolveQuantile(error4, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map6(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error4, sampleCount, current2, consumed, quantile, rest) => {
  let error_1 = error4;
  let sampleCount_1 = sampleCount;
  let current_1 = current2;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error4;
  let sampleCount_2 = sampleCount;
  let current_2 = current2;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some3(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head2(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some3(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head2(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head2(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some3(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var make42 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};
var unsafeMake10 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = Symbol.for(MetricRegistrySymbolKey);
var _a38;
_a38 = MetricRegistryTypeId;
var MetricRegistryImpl = class {
  constructor() {
    __publicField(this, _a38, MetricRegistryTypeId);
    __publicField(this, "map", empty23());
  }
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake10(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get9(key), getOrUndefined2);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const counter12 = counter5(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, counter12));
      }
      value10 = counter12;
    }
    return value10;
  }
  getFrequency(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const frequency11 = frequency4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, frequency11));
      }
      value10 = frequency11;
    }
    return value10;
  }
  getGauge(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const gauge11 = gauge4(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, gauge11));
      }
      value10 = gauge11;
    }
    return value10;
  }
  getHistogram(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const histogram11 = histogram4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, histogram11));
      }
      value10 = histogram11;
    }
    return value10;
  }
  getSummary(key) {
    let value10 = pipe(this.map, get9(key), getOrUndefined2);
    if (value10 == null) {
      const summary11 = summary4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set5(key, summary11));
      }
      value10 = summary11;
    }
    return value10;
  }
};
var make43 = () => {
  return new MetricRegistryImpl();
};

// node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var globalMetricRegistry = globalValue(Symbol.for("effect/Metric/globalMetricRegistry"), () => make43());
var make44 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect4) => tap2(effect4, (a) => update5(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var mapInput5 = dual(2, (self, f2) => make44(self.keyType, (input, extraTags) => self.unsafeUpdate(f2(input), extraTags), self.unsafeValue, (input, extraTags) => self.unsafeModify(f2(input), extraTags)));
var counter6 = (name, options) => fromMetricKey(counter3(name, options));
var frequency5 = (name, options) => fromMetricKey(frequency2(name, options));
var withConstantInput = dual(2, (self, input) => mapInput5(self, () => input));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make44(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var gauge5 = (name, options) => fromMetricKey(gauge2(name, options));
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var increment4 = (self) => isCounterKey(self.keyType) ? update5(self, self.keyType.bigint ? BigInt(1) : 1) : modify9(self, self.keyType.bigint ? BigInt(1) : 1);
var incrementBy = dual(2, (self, amount) => isCounterKey(self.keyType) ? update5(self, amount) : modify9(self, amount));
var map20 = dual(2, (self, f2) => make44(self.keyType, self.unsafeUpdate, (extraTags) => f2(self.unsafeValue(extraTags)), self.unsafeModify));
var mapType = dual(2, (self, f2) => make44(f2(self.keyType), self.unsafeUpdate, self.unsafeValue, self.unsafeModify));
var modify9 = dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self.unsafeModify(input, tags3))));
var set8 = dual(2, (self, value10) => update5(self, value10));
var succeed7 = (out) => make44(void 0, constVoid, () => out, constVoid);
var sync5 = (evaluate4) => make44(void 0, constVoid, evaluate4, constVoid);
var summary5 = (options) => withNow(summaryTimestamp(options));
var summaryTimestamp = (options) => fromMetricKey(summary2(options));
var tagged2 = dual(3, (self, key, value10) => taggedWithLabels2(self, [make39(key, value10)]));
var taggedWithLabelsInput = dual(2, (self, f2) => map20(make44(self.keyType, (input, extraTags) => self.unsafeUpdate(input, union2(f2(input), extraTags)), self.unsafeValue, (input, extraTags) => self.unsafeModify(input, union2(f2(input), extraTags))), constVoid));
var taggedWithLabels2 = dual(2, (self, extraTags) => {
  return make44(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union2(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union2(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union2(extraTags, extraTags1)));
});
var timer2 = (name, description) => {
  const boundaries = exponential({
    start: 0.5,
    factor: 2,
    count: 35
  });
  const base = pipe(histogram5(name, boundaries, description), tagged2("time_unit", "milliseconds"));
  return mapInput5(base, toMillis);
};
var timerWithBoundaries = (name, boundaries, description) => {
  const base = pipe(histogram5(name, fromIterable11(boundaries), description), tagged2("time_unit", "milliseconds"));
  return mapInput5(base, toMillis);
};
var trackAll = dual(2, (self, input) => (effect4) => matchCauseEffect(effect4, {
  onFailure: (cause3) => zipRight2(update5(self, input), failCause(cause3)),
  onSuccess: (value10) => zipRight2(update5(self, input), succeed(value10))
}));
var trackDefect = dual(2, (self, metric) => trackDefectWith(self, metric, identity));
var trackDefectWith = dual(3, (self, metric, f2) => {
  const updater = (defect) => update5(metric, f2(defect));
  return tapDefect(self, (cause3) => forEachSequentialDiscard(defects(cause3), updater));
});
var trackDuration = dual(2, (self, metric) => trackDurationWith(self, metric, identity));
var trackDurationWith = dual(3, (self, metric, f2) => clockWith2((clock3) => {
  const startTime = clock3.unsafeCurrentTimeNanos();
  return tap2(self, (_) => {
    const endTime = clock3.unsafeCurrentTimeNanos();
    const duration5 = nanos(endTime - startTime);
    return update5(metric, f2(duration5));
  });
}));
var trackError = dual(2, (self, metric) => trackErrorWith(self, metric, (a) => a));
var trackErrorWith = dual(3, (self, metric, f2) => {
  const updater = (error4) => update5(metric, f2(error4));
  return tapError(self, updater);
});
var trackSuccess = dual(2, (self, metric) => trackSuccessWith(self, metric, (a) => a));
var trackSuccessWith = dual(3, (self, metric, f2) => {
  const updater = (value10) => update5(metric, f2(value10));
  return tap2(self, updater);
});
var update5 = dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self.unsafeUpdate(input, tags3))));
var value = (self) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self.unsafeValue(tags3)));
var withNow = (self) => mapInput5(self, (input) => [input, Date.now()]);
var zip9 = dual(2, (self, that) => make44([self.keyType, that.keyType], (input, extraTags) => {
  const [l, r] = input;
  self.unsafeUpdate(l, extraTags);
  that.unsafeUpdate(r, extraTags);
}, (extraTags) => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)], (input, extraTags) => {
  const [l, r] = input;
  self.unsafeModify(l, extraTags);
  that.unsafeModify(r, extraTags);
}));
var unsafeSnapshot = () => globalMetricRegistry.snapshot();
var snapshot = sync(unsafeSnapshot);

// node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u) => hasProperty(u, RequestTypeId);
var of5 = () => (args2) => Object.assign(Object.create(RequestPrototype), args2);
var tagged3 = (tag5) => (args2) => {
  const request2 = Object.assign(Object.create(RequestPrototype), args2);
  request2._tag = tag5;
  return request2;
};
var Class4 = function() {
  function Class9(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Class9.prototype = RequestPrototype;
  return Class9;
}();
var TaggedClass = (tag5) => {
  return class TaggedClass extends Class4 {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag5);
    }
  };
};
var complete2 = dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map49) => sync(() => {
  if (map49.has(self)) {
    const entry = map49.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var completeEffect = dual(2, (self, effect4) => matchEffect(effect4, {
  onFailure: (error4) => complete2(self, exitFail(error4)),
  onSuccess: (value10) => complete2(self, exitSucceed(value10))
}));
var fail7 = dual(2, (self, error4) => complete2(self, exitFail(error4)));
var failCause6 = dual(2, (self, cause3) => complete2(self, exitFailCause(cause3)));
var succeed8 = dual(2, (self, value10) => complete2(self, exitSucceed(value10)));
var Listeners = class {
  constructor() {
    __publicField(this, "count", 0);
    __publicField(this, "observers", /* @__PURE__ */ new Set());
    __publicField(this, "interrupted", false);
  }
  addObserver(f2) {
    this.observers.add(f2);
  }
  removeObserver(f2) {
    this.observers.delete(f2);
  }
  increment() {
    this.count++;
    this.observers.forEach((f2) => f2(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f2) => f2(this.count));
  }
};

// node_modules/effect/dist/esm/SortedSet.js
var SortedSet_exports = {};
__export(SortedSet_exports, {
  add: () => add6,
  difference: () => difference6,
  empty: () => empty32,
  every: () => every12,
  filter: () => filter13,
  flatMap: () => flatMap15,
  forEach: () => forEach14,
  fromIterable: () => fromIterable14,
  getEquivalence: () => getEquivalence8,
  has: () => has9,
  intersection: () => intersection7,
  isSortedSet: () => isSortedSet,
  isSubset: () => isSubset3,
  make: () => make47,
  map: () => map21,
  partition: () => partition7,
  remove: () => remove10,
  size: () => size16,
  some: () => some14,
  toggle: () => toggle4,
  union: () => union8,
  values: () => values9
});

// node_modules/effect/dist/esm/RedBlackTree.js
var RedBlackTree_exports = {};
__export(RedBlackTree_exports, {
  Direction: () => Direction2,
  at: () => at3,
  atReversed: () => atReversed,
  empty: () => empty31,
  findAll: () => findAll2,
  findFirst: () => findFirst10,
  first: () => first2,
  forEach: () => forEach13,
  forEachBetween: () => forEachBetween2,
  forEachGreaterThanEqual: () => forEachGreaterThanEqual2,
  forEachLessThan: () => forEachLessThan2,
  fromIterable: () => fromIterable13,
  getAt: () => getAt2,
  getOrder: () => getOrder5,
  greaterThan: () => greaterThan8,
  greaterThanEqual: () => greaterThanEqual3,
  greaterThanEqualReversed: () => greaterThanEqualReversed,
  greaterThanReversed: () => greaterThanReversed,
  has: () => has8,
  insert: () => insert2,
  isRedBlackTree: () => isRedBlackTree2,
  keys: () => keys6,
  keysReversed: () => keysReversed,
  last: () => last5,
  lessThan: () => lessThan8,
  lessThanEqual: () => lessThanEqual3,
  lessThanEqualReversed: () => lessThanEqualReversed,
  lessThanReversed: () => lessThanReversed,
  make: () => make46,
  reduce: () => reduce14,
  removeFirst: () => removeFirst2,
  reversed: () => reversed2,
  size: () => size15,
  values: () => values8,
  valuesReversed: () => valuesReversed
});

// node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  constructor(self, stack, direction) {
    __publicField(this, "self");
    __publicField(this, "stack");
    __publicField(this, "direction");
    __publicField(this, "count", 0);
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some3(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some3(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ;
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone2 = ({
  color,
  count: count9,
  key,
  left: left3,
  right: right3,
  value: value10
}) => ({
  color,
  key,
  value: value10,
  left: left3,
  right: right3,
  count: count9
});
function swap3(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
var repaint = ({
  count: count9,
  key,
  left: left3,
  right: right3,
  value: value10
}, color) => ({
  color,
  key,
  value: value10,
  left: left3,
  right: right3,
  count: count9
});
var recount = (node) => {
  var _a106, _b32;
  node.count = 1 + (((_a106 = node.left) == null ? void 0 : _a106.count) ?? 0) + (((_b32 = node.right) == null ? void 0 : _b32.count) ?? 0);
};

// node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol2]() {
    let hash11 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash11 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash11);
  },
  [symbol3](that) {
    var _a106, _b32;
    if (isRedBlackTree(that)) {
      if ((((_a106 = this._root) == null ? void 0 : _a106.count) ?? 0) !== (((_b32 = that._root) == null ? void 0 : _b32.count) ?? 0)) {
        return false;
      }
      const entries6 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries6[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var empty30 = (ord) => makeImpl3(ord, void 0);
var fromIterable12 = dual(2, (entries6, ord) => {
  let tree = empty30(ord);
  for (const [key, value10] of entries6) {
    tree = insert(tree, key, value10);
  }
  return tree;
});
var make45 = (ord) => (...entries6) => {
  return fromIterable12(entries6, ord);
};
var atBackwards = dual(2, (self, index3) => at2(self, index3, Direction.Backward));
var atForwards = dual(2, (self, index3) => at2(self, index3, Direction.Forward));
var at2 = (self, index3, direction) => {
  return {
    [Symbol.iterator]: () => {
      if (index3 < 0) {
        return new RedBlackTreeIterator(self, [], direction);
      }
      let node = self._root;
      const stack = [];
      while (node !== void 0) {
        stack.push(node);
        if (node.left !== void 0) {
          if (index3 < node.left.count) {
            node = node.left;
            continue;
          }
          index3 -= node.left.count;
        }
        if (!index3) {
          return new RedBlackTreeIterator(self, stack, direction);
        }
        index3 -= 1;
        if (node.right !== void 0) {
          if (index3 >= node.right.count) {
            break;
          }
          node = node.right;
        } else {
          break;
        }
      }
      return new RedBlackTreeIterator(self, [], direction);
    }
  };
};
var findAll = dual(2, (self, key) => {
  const stack = [];
  let node = self._root;
  let result = empty7();
  while (node !== void 0 || stack.length > 0) {
    if (node) {
      stack.push(node);
      node = node.left;
    } else {
      const current2 = stack.pop();
      if (equals(key, current2.key)) {
        result = prepend3(current2.value)(result);
      }
      node = current2.right;
    }
  }
  return result;
});
var findFirst9 = dual(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some3(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var first = (self) => {
  let node = self._root;
  let current2 = self._root;
  while (node !== void 0) {
    current2 = node;
    node = node.left;
  }
  return current2 ? some3([current2.key, current2.value]) : none2();
};
var getAt = dual(2, (self, index3) => {
  if (index3 < 0) {
    return none2();
  }
  let root = self._root;
  let node = void 0;
  while (root !== void 0) {
    node = root;
    if (root.left) {
      if (index3 < root.left.count) {
        root = root.left;
        continue;
      }
      index3 -= root.left.count;
    }
    if (!index3) {
      return some3([node.key, node.value]);
    }
    index3 -= 1;
    if (root.right) {
      if (index3 >= root.right.count) {
        break;
      }
      root = root.right;
    } else {
      break;
    }
  }
  return none2();
});
var getOrder4 = (tree) => tree._ord;
var has7 = dual(2, (self, key) => isSome2(findFirst9(self, key)));
var insert = dual(3, (self, key, value10) => {
  const cmp = self._ord;
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value: value10,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self._ord, n_stack[0]);
});
var keysForward = (self) => keys5(self, Direction.Forward);
var keysBackward = (self) => keys5(self, Direction.Backward);
var keys5 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count9 = 0;
  return {
    [Symbol.iterator]: () => keys5(self, direction),
    next: () => {
      count9++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count9
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var last4 = (self) => {
  let node = self._root;
  let current2 = self._root;
  while (node !== void 0) {
    current2 = node;
    node = node.right;
  }
  return current2 ? some3([current2.key, current2.value]) : none2();
};
var reversed = (self) => {
  return {
    [Symbol.iterator]: () => {
      const stack = [];
      let node = self._root;
      while (node !== void 0) {
        stack.push(node);
        node = node.right;
      }
      return new RedBlackTreeIterator(self, stack, Direction.Backward);
    }
  };
};
var greaterThanBackwards = dual(2, (self, key) => greaterThan7(self, key, Direction.Backward));
var greaterThanForwards = dual(2, (self, key) => greaterThan7(self, key, Direction.Forward));
var greaterThan7 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d < 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var greaterThanEqualBackwards = dual(2, (self, key) => greaterThanEqual2(self, key, Direction.Backward));
var greaterThanEqualForwards = dual(2, (self, key) => greaterThanEqual2(self, key, Direction.Forward));
var greaterThanEqual2 = (self, key, direction = Direction.Forward) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d <= 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var lessThanBackwards = dual(2, (self, key) => lessThan7(self, key, Direction.Backward));
var lessThanForwards = dual(2, (self, key) => lessThan7(self, key, Direction.Forward));
var lessThan7 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d > 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var lessThanEqualBackwards = dual(2, (self, key) => lessThanEqual2(self, key, Direction.Backward));
var lessThanEqualForwards = dual(2, (self, key) => lessThanEqual2(self, key, Direction.Forward));
var lessThanEqual2 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d >= 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var forEach12 = dual(2, (self, f2) => {
  const root = self._root;
  if (root !== void 0) {
    visitFull(root, (key, value10) => {
      f2(key, value10);
      return none2();
    });
  }
});
var forEachGreaterThanEqual = dual(3, (self, min11, f2) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== void 0) {
    visitGreaterThanEqual(root, min11, ord, (key, value10) => {
      f2(key, value10);
      return none2();
    });
  }
});
var forEachLessThan = dual(3, (self, max14, f2) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== void 0) {
    visitLessThan(root, max14, ord, (key, value10) => {
      f2(key, value10);
      return none2();
    });
  }
});
var forEachBetween = dual(2, (self, {
  body,
  max: max14,
  min: min11
}) => {
  const root = self._root;
  const ord = self._ord;
  if (root) {
    visitBetween(root, min11, max14, ord, (key, value10) => {
      body(key, value10);
      return none2();
    });
  }
});
var reduce13 = dual(3, (self, zero3, f2) => {
  let accumulator = zero3;
  for (const entry of self) {
    accumulator = f2(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var removeFirst = dual(2, (self, key) => {
  if (!has7(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split8 = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split8 - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split8 - 1].key = n.key;
    cstack[split8 - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split8; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split8 - 1].left = cstack[split8];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap3(n, n.left);
      } else if (n.right !== void 0) {
        swap3(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var size14 = (self) => {
  var _a106;
  return ((_a106 = self._root) == null ? void 0 : _a106.count) ?? 0;
};
var valuesForward = (self) => values7(self, Direction.Forward);
var valuesBackward = (self) => values7(self, Direction.Backward);
var values7 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count9 = 0;
  return {
    [Symbol.iterator]: () => values7(self, direction),
    next: () => {
      count9++;
      const entry = begin.value;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count9
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var visitFull = (node, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 != null) {
      stack = make11(current2, stack);
      current2 = current2.left;
    } else if (stack != null) {
      const value10 = visit(stack.value.key, stack.value.value);
      if (isSome2(value10)) {
        return value10;
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitGreaterThanEqual = (node, min11, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make11(current2, stack);
      if (ord(min11, current2.key) <= 0) {
        current2 = current2.left;
      } else {
        current2 = void 0;
      }
    } else if (stack !== void 0) {
      if (ord(min11, stack.value.key) <= 0) {
        const value10 = visit(stack.value.key, stack.value.value);
        if (isSome2(value10)) {
          return value10;
        }
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitLessThan = (node, max14, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make11(current2, stack);
      current2 = current2.left;
    } else if (stack !== void 0 && ord(max14, stack.value.key) > 0) {
      const value10 = visit(stack.value.key, stack.value.value);
      if (isSome2(value10)) {
        return value10;
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitBetween = (node, min11, max14, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make11(current2, stack);
      if (ord(min11, current2.key) <= 0) {
        current2 = current2.left;
      } else {
        current2 = void 0;
      }
    } else if (stack !== void 0 && ord(max14, stack.value.key) > 0) {
      if (ord(min11, stack.value.key) <= 0) {
        const value10 = visit(stack.value.key, stack.value.value);
        if (isSome2(value10)) {
          return value10;
        }
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var fixDoubleBlack = (stack) => {
  let n, p, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.right = clone2(s);
        z = s.right = clone2(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.right = clone2(s);
        z = s.left = clone2(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.right = repaint(s, Color.Red);
          return;
        } else {
          p.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone2(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.left = clone2(s);
        z = s.left = clone2(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.left = clone2(s);
        z = s.right = clone2(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.left = repaint(s, Color.Red);
          return;
        } else {
          p.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone2(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
};

// node_modules/effect/dist/esm/RedBlackTree.js
var Direction2 = Direction;
var isRedBlackTree2 = isRedBlackTree;
var empty31 = empty30;
var fromIterable13 = fromIterable12;
var make46 = make45;
var at3 = atForwards;
var atReversed = atBackwards;
var findAll2 = findAll;
var findFirst10 = findFirst9;
var first2 = first;
var getAt2 = getAt;
var getOrder5 = getOrder4;
var greaterThan8 = greaterThanForwards;
var greaterThanReversed = greaterThanBackwards;
var greaterThanEqual3 = greaterThanEqualForwards;
var greaterThanEqualReversed = greaterThanEqualBackwards;
var has8 = has7;
var insert2 = insert;
var keys6 = keysForward;
var keysReversed = keysBackward;
var last5 = last4;
var lessThan8 = lessThanForwards;
var lessThanReversed = lessThanBackwards;
var lessThanEqual3 = lessThanEqualForwards;
var lessThanEqualReversed = lessThanEqualBackwards;
var forEach13 = forEach12;
var forEachGreaterThanEqual2 = forEachGreaterThanEqual;
var forEachLessThan2 = forEachLessThan;
var forEachBetween2 = forEachBetween;
var reduce14 = reduce13;
var removeFirst2 = removeFirst;
var reversed2 = reversed;
var size15 = size14;
var values8 = valuesForward;
var valuesReversed = valuesBackward;

// node_modules/effect/dist/esm/SortedSet.js
var TypeId17 = Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId17]: {
    _A: (_) => _
  },
  [symbol2]() {
    return pipe(hash(this.keyTree), combine2(hash(TypeId17)), cached(this));
  },
  [symbol3](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys6(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = (keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
var isSortedSet = (u) => hasProperty(u, TypeId17);
var empty32 = (O) => fromTree(empty31(O));
var fromIterable14 = dual(2, (iterable, ord) => fromTree(fromIterable13(Array.from(iterable).map((k) => [k, true]), ord)));
var make47 = (ord) => (...entries6) => fromIterable14(entries6, ord);
var add6 = dual(2, (self, value10) => has8(self.keyTree, value10) ? self : fromTree(insert2(self.keyTree, value10, true)));
var difference6 = dual(2, (self, that) => {
  let out = self;
  for (const value10 of that) {
    out = remove10(out, value10);
  }
  return out;
});
var every12 = dual(2, (self, predicate) => {
  for (const value10 of self) {
    if (!predicate(value10)) {
      return false;
    }
  }
  return true;
});
var filter13 = dual(2, (self, predicate) => {
  const ord = getOrder5(self.keyTree);
  let out = empty32(ord);
  for (const value10 of self) {
    if (predicate(value10)) {
      out = add6(out, value10);
    }
  }
  return out;
});
var flatMap15 = dual(3, (self, O, f2) => {
  let out = empty32(O);
  forEach14(self, (a) => {
    for (const b of f2(a)) {
      out = add6(out, b);
    }
  });
  return out;
});
var forEach14 = dual(2, (self, f2) => forEach13(self.keyTree, f2));
var has9 = dual(2, (self, value10) => has8(self.keyTree, value10));
var intersection7 = dual(2, (self, that) => {
  const ord = getOrder5(self.keyTree);
  let out = empty32(ord);
  for (const value10 of that) {
    if (has9(self, value10)) {
      out = add6(out, value10);
    }
  }
  return out;
});
var isSubset3 = dual(2, (self, that) => every12(self, (a) => has9(that, a)));
var map21 = dual(3, (self, O, f2) => {
  let out = empty32(O);
  forEach14(self, (a) => {
    const b = f2(a);
    if (!has9(out, b)) {
      out = add6(out, b);
    }
  });
  return out;
});
var partition7 = dual(2, (self, predicate) => {
  const ord = getOrder5(self.keyTree);
  let right3 = empty32(ord);
  let left3 = empty32(ord);
  for (const value10 of self) {
    if (predicate(value10)) {
      right3 = add6(right3, value10);
    } else {
      left3 = add6(left3, value10);
    }
  }
  return [left3, right3];
});
var remove10 = dual(2, (self, value10) => fromTree(removeFirst2(self.keyTree, value10)));
var size16 = (self) => size15(self.keyTree);
var some14 = dual(2, (self, predicate) => {
  for (const value10 of self) {
    if (predicate(value10)) {
      return true;
    }
  }
  return false;
});
var toggle4 = dual(2, (self, value10) => has9(self, value10) ? remove10(self, value10) : add6(self, value10));
var union8 = dual(2, (self, that) => {
  const ord = getOrder5(self.keyTree);
  let out = empty32(ord);
  for (const value10 of self) {
    out = add6(value10)(out);
  }
  for (const value10 of that) {
    out = add6(value10)(out);
  }
  return out;
});
var values9 = (self) => keys6(self.keyTree);
var getEquivalence8 = () => (a, b) => isSubset3(a, b) && isSubset3(b, a);

// node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_) => _
};
var _a39;
_a39 = SupervisorTypeId;
var _ProxySupervisor = class _ProxySupervisor {
  constructor(underlying, value0) {
    __publicField(this, "underlying");
    __publicField(this, "value0");
    __publicField(this, _a39, supervisorVariance);
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context15, effect4, parent, fiber) {
    this.underlying.onStart(context15, effect4, parent, fiber);
  }
  onEnd(value10, fiber) {
    this.underlying.onEnd(value10, fiber);
  }
  onEffect(fiber, effect4) {
    this.underlying.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f2) {
    return new _ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
var ProxySupervisor = _ProxySupervisor;
var _a40;
_a40 = SupervisorTypeId;
var _Zip = class _Zip {
  constructor(left3, right3) {
    __publicField(this, "left");
    __publicField(this, "right");
    __publicField(this, "_tag", "Zip");
    __publicField(this, _a40, supervisorVariance);
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip5(this.left.value, this.right.value);
  }
  onStart(context15, effect4, parent, fiber) {
    this.left.onStart(context15, effect4, parent, fiber);
    this.right.onStart(context15, effect4, parent, fiber);
  }
  onEnd(value10, fiber) {
    this.left.onEnd(value10, fiber);
    this.right.onEnd(value10, fiber);
  }
  onEffect(fiber, effect4) {
    this.left.onEffect(fiber, effect4);
    this.right.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new _Zip(this, right3);
  }
};
var Zip = _Zip;
var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
var _a41;
_a41 = SupervisorTypeId;
var Track = class {
  constructor() {
    __publicField(this, _a41, supervisorVariance);
    __publicField(this, "fibers", /* @__PURE__ */ new Set());
  }
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value2, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var _a42;
_a42 = SupervisorTypeId;
var Const = class {
  constructor(effect4) {
    __publicField(this, "effect");
    __publicField(this, _a42, supervisorVariance);
    this.effect = effect4;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value2, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var _a43;
_a43 = SupervisorTypeId;
var FibersIn = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a43, supervisorVariance);
    this.ref = ref;
  }
  get value() {
    return sync(() => get7(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set3(pipe(get7(this.ref), add6(fiber))));
  }
  onEnd(_value2, fiber) {
    pipe(this.ref, set3(pipe(get7(this.ref), remove10(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f2) {
    return new ProxySupervisor(this, pipe(this.value, map14(f2)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var unsafeTrack = () => {
  return new Track();
};
var track = sync(unsafeTrack);
var fromEffect2 = (effect4) => {
  return new Const(effect4);
};
var none8 = globalValue("effect/Supervisor/none", () => fromEffect2(void_3));
var fibersIn = (ref) => sync(() => new FibersIn(ref));

// node_modules/effect/dist/esm/Differ.js
var Differ_exports = {};
__export(Differ_exports, {
  TypeId: () => TypeId18,
  chunk: () => chunk2,
  combine: () => combine14,
  diff: () => diff10,
  empty: () => empty33,
  environment: () => environment2,
  hashMap: () => hashMap2,
  hashSet: () => hashSet2,
  make: () => make48,
  orElseEither: () => orElseEither4,
  patch: () => patch11,
  readonlyArray: () => readonlyArray2,
  transform: () => transform2,
  update: () => update6,
  updateWith: () => updateWith2,
  zip: () => zip10
});
var TypeId18 = DifferTypeId;
var empty33 = (self) => self.empty;
var diff10 = dual(3, (self, oldValue, newValue) => self.diff(oldValue, newValue));
var combine14 = dual(3, (self, first5, second) => self.combine(first5, second));
var patch11 = dual(3, (self, patch14, oldValue) => self.patch(patch14, oldValue));
var make48 = make20;
var environment2 = environment;
var chunk2 = chunk;
var hashMap2 = hashMap;
var hashSet2 = hashSet;
var orElseEither4 = orElseEither2;
var readonlyArray2 = readonlyArray;
var transform2 = transform;
var update6 = update2;
var updateWith2 = updateWith;
var zip10 = zip4;

// node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty34 = {
  _tag: OP_EMPTY3
};
var combine15 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
};
var patch12 = (self, supervisor) => {
  return patchLoop(supervisor, of3(self));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty2(patches)) {
    const head13 = headNonEmpty2(patches);
    switch (head13._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head13.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head13.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend3(head13.first)(prepend3(head13.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none8;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
var toSet4 = (self) => {
  if (equals(self, none8)) {
    return empty10();
  } else {
    if (isZip(self)) {
      return pipe(toSet4(self.left), union6(toSet4(self.right)));
    } else {
      return make14(self);
    }
  }
};
var diff11 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty34;
  }
  const oldSupervisors = toSet4(oldValue);
  const newSupervisors = toSet4(newValue);
  const added = pipe(newSupervisors, difference5(oldSupervisors), reduce7(empty34, (patch14, supervisor) => combine15(patch14, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference5(newSupervisors), reduce7(empty34, (patch14, supervisor) => combine15(patch14, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine15(added, removed);
};
var differ2 = make48({
  empty: empty34,
  patch: patch12,
  combine: combine15,
  diff: diff11
});

// node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = counter6("effect_fiber_started", {
  incremental: true
});
var fiberActive = counter6("effect_fiber_active");
var fiberSuccesses = counter6("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = counter6("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = tagged2(histogram5("effect_fiber_lifetimes", exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var absurd3 = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value10) => {
    return internalCall(() => cont.effect_instruction_i1(value10));
  },
  ["OnStep"]: (_, _cont, value10) => {
    return exitSucceed(exitSucceed(value10));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value10) => {
    return internalCall(() => cont.effect_instruction_i2(value10));
  },
  [OP_REVERT_FLAGS]: (self, cont, value10) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value10);
    }
  },
  [OP_WHILE]: (self, cont, value10) => {
    internalCall(() => cont.effect_instruction_i2(value10));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_3;
    }
  },
  [OP_ITERATOR]: (self, cont, value10) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value10));
    if (state.done) return exitSucceed(state.value);
    self.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
    message.onFiber(self, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap12(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten6(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential6]) => {
  const map49 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential6) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map49.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map49);
}, false, false));
var _version = getCurrentVersion();
var _a44, _b12;
var FiberRuntime = class extends Class3 {
  constructor(fiberId5, fiberRefs0, runtimeFlags0) {
    super();
    __publicField(this, _b12, fiberVariance2);
    __publicField(this, _a44, runtimeFiberVariance);
    __publicField(this, "_fiberRefs");
    __publicField(this, "_fiberId");
    __publicField(this, "_queue", new Array());
    __publicField(this, "_children", null);
    __publicField(this, "_observers", new Array());
    __publicField(this, "_running", false);
    __publicField(this, "_stack", []);
    __publicField(this, "_asyncInterruptor", null);
    __publicField(this, "_asyncBlockingOn", null);
    __publicField(this, "_exitValue", null);
    __publicField(this, "_steps", []);
    __publicField(this, "_isYielding", false);
    __publicField(this, "currentRuntimeFlags");
    __publicField(this, "currentOpCount", 0);
    __publicField(this, "currentSupervisor");
    __publicField(this, "currentScheduler");
    __publicField(this, "currentTracer");
    __publicField(this, "currentSpan");
    __publicField(this, "currentContext");
    __publicField(this, "currentDefaultServices");
    __publicField(this, "run", () => {
      this.drainQueueOnCurrentThread();
    });
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId5;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags3);
      fiberActive.unsafeUpdate(1, tags3);
    }
    this.refreshRefCache();
  }
  commit() {
    return join3(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status3) => status3);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status3) => {
      if (isDone3(status3)) {
        return state.currentRuntimeFlags;
      }
      return status3.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake9(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f2) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status3) => {
        deferredUnsafeDone(deferred, sync(() => f2(fiber, status3)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit4) => resume2(succeed(exit4));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch14 = pipe(
        diff7(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch14);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable2(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId5) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId5))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId5) {
    this.tell(interruptSignal(interrupt(fiberId5)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value10) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value10
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs4) {
    this._fiberRefs = fiberRefs4;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope6) {
    const children3 = this._children;
    this._children = null;
    if (children3 !== null && children3.size > 0) {
      for (const child of children3) {
        if (child._exitValue === null) {
          scope6.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty7(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause3) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause3));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause3) {
    this.addInterruptedCause(cause3);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone9 = false;
      const body = () => {
        const next6 = it.next();
        if (!next6.done) {
          return asVoid2(next6.value.await);
        } else {
          return sync(() => {
            isDone9 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone9,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit4) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags3);
      fiberActive.unsafeUpdate(-1, tags3);
      switch (exit4._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags3);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags3);
          break;
        }
      }
    }
    if (exit4._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit4.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit4.cause, level);
      }
    }
  }
  setExitValue(exit4) {
    this._exitValue = exit4;
    this.reportExitValue(exit4);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit4);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause3, overrideLogLevel) {
    const logLevel3 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel3 = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan6(minimumLogLevel3, logLevel3)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations4 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size9(loggers) > 0) {
      const clockService = get4(this.getFiberRef(currentServices), clockTag);
      const date5 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel: logLevel3,
            message,
            cause: cause3,
            context: contextMap,
            spans,
            annotations: annotations4,
            date: date5
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd3(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect4 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect4 !== null) {
        const eff = effect4;
        const exit4 = this.runLoop(eff);
        if (exit4 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect4 = null;
            } else {
              effect4 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect4 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption3 = this.interruptAllChildren();
          if (interruption3 !== null) {
            effect4 = flatMap12(interruption3, () => exit4);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit4);
            } else {
              this.tell(resume(exit4));
            }
            effect4 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect4) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect4);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect4));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch14) {
    const newRuntimeFlags = patch7(oldRuntimeFlags, patch14);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect4) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect4));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [(_b12 = FiberTypeId, _a44 = RuntimeFiberTypeId, OP_TAG)](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Success") {
          return resume2(exitSucceed(exit4.value));
        }
        switch (exit4.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit4.cause.error));
          }
          case "Die": {
            return resume2(die2(exit4.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_3);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value10 = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd3(cont);
      }
      return contOpSuccess[cont._op](this, cont, value10);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value10);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd3(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause3 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause3, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause3);
          }
        }
        default: {
          absurd3(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause3);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff9(snap.refs, refs);
      const patchFlags = diff7(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch7(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap12(forkDaemon2(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check6 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check6()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap12(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId2]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
};
var currentMinimumLogLevel = globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get4(services, consoleTag).unsafe.log(self.log(opts));
});
var loggerWithLeveledLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  const unsafeLogger = get4(services, consoleTag).unsafe;
  switch (opts.logLevel._tag) {
    case "Debug":
      return unsafeLogger.debug(self.log(opts));
    case "Info":
      return unsafeLogger.info(self.log(opts));
    case "Trace":
      return unsafeLogger.trace(self.log(opts));
    case "Warning":
      return unsafeLogger.warn(self.log(opts));
    case "Error":
    case "Fatal":
      return unsafeLogger.error(self.log(opts));
    default:
      return unsafeLogger.log(self.log(opts));
  }
});
var loggerWithConsoleError = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get4(services, consoleTag).unsafe.error(self.log(opts));
});
var defaultLogger = globalValue(Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var jsonLogger2 = globalValue(Symbol.for("effect/Logger/jsonLogger"), () => loggerWithConsoleLog(jsonLogger));
var logFmtLogger = globalValue(Symbol.for("effect/Logger/logFmtLogger"), () => loggerWithConsoleLog(logfmtLogger));
var prettyLogger2 = globalValue(Symbol.for("effect/Logger/prettyLogger"), () => prettyLoggerDefault);
var structuredLogger2 = globalValue(Symbol.for("effect/Logger/structuredLogger"), () => loggerWithConsoleLog(structuredLogger));
var tracerLogger = globalValue(Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations4,
  cause: cause3,
  context: context15,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message
}) => {
  const span4 = getOption2(getOrDefault(context15, currentContext), spanTag);
  if (span4._tag === "None" || span4.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context15, currentServices), clockTag);
  const attributes = {};
  for (const [key, value10] of annotations4) {
    attributes[key] = value10;
  }
  attributes["effect.fiberId"] = threadName2(fiberId5);
  attributes["effect.logLevel"] = logLevel3.label;
  if (cause3 !== null && cause3._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause3, {
      renderErrorCause: true
    });
  }
  span4.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var loggerWithSpanAnnotations = (self) => mapInputOptions(self, (options) => {
  const span4 = flatMap2(get10(options.context, currentContext), getOption2(spanTag));
  if (span4._tag === "None") {
    return options;
  }
  return {
    ...options,
    annotations: pipe(options.annotations, set4("effect.traceId", span4.value.traceId), set4("effect.spanId", span4.value.spanId), span4.value._tag === "Span" ? set4("effect.spanName", span4.value.name) : identity)
  };
});
var currentLoggers = globalValue(Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make14(defaultLogger, tracerLogger)));
var batchedLogger = dual(3, (self, window3, f2) => flatMap12(scope2, (scope6) => {
  let buffer7 = [];
  const flush = suspend(() => {
    if (buffer7.length === 0) {
      return void_3;
    }
    const arr = buffer7;
    buffer7 = [];
    return f2(arr);
  });
  return uninterruptibleMask((restore) => pipe(sleep3(window3), zipRight2(flush), forever, restore, forkDaemon2, flatMap12((fiber) => scopeAddFinalizer(scope6, interruptFiber(fiber))), zipRight2(addFinalizer2(() => flush)), as3(makeLogger((options) => {
    buffer7.push(self.log(options));
  }))));
}));
var annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set4(arguments[0], arguments[1]));
  }
  const entries6 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate4((annotations4) => {
    for (let i = 0; i < entries6.length; i++) {
      const [key, value10] = entries6[i];
      set4(annotations4, key, value10);
    }
    return annotations4;
  }));
};
var whenLogLevel = dual(2, (effect4, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel3 = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan6(minimumLogLevel3, requiredLogLevel)) {
      return succeed(none2());
    }
    return map14(effect4, some3);
  });
});
var acquireRelease2 = dual((args2) => isEffect(args2[0]), (acquire4, release4) => uninterruptible(tap2(acquire4, (a) => addFinalizer2((exit4) => release4(a, exit4)))));
var acquireReleaseInterruptible = dual((args2) => isEffect(args2[0]), (acquire4, release4) => ensuring2(acquire4, addFinalizer2((exit4) => release4(exit4))));
var addFinalizer2 = (finalizer3) => withFiberRuntime((runtime8) => {
  const acquireRefs = runtime8.getFiberRefs();
  const acquireFlags = disable2(runtime8.currentRuntimeFlags, Interruption);
  return flatMap12(scope2, (scope6) => scopeAddFinalizerExit(scope6, (exit4) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring2(withRuntimeFlags(finalizer3(exit4), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some3(globalScope));
  return forkScope(self);
};
var _existsParFound = Symbol.for("effect/Effect/existsPar/found");
var exists3 = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options == null ? void 0 : options.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach15(elements, (a, i) => if_(predicate(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_3
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index3, f2) => {
  const next6 = iterator.next();
  if (next6.done) {
    return succeed(false);
  }
  return pipe(flatMap12(f2(next6.value, index3), (b) => b ? succeed(b) : existsLoop(iterator, index3 + 1, f2)));
};
var filter14 = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = (options == null ? void 0 : options.negate) ? (a, i) => map14(predicate(a, i), not2) : predicate;
  return matchSimple(options == null ? void 0 : options.concurrency, () => suspend(() => fromIterable2(elements).reduceRight((effect4, a, i) => zipWith6(effect4, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map14(forEach15(elements, (a, i) => map14(predicate_(a, i), (b) => b ? some3(a) : none2()), options), getSomes3));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys15 = Object.keys(input);
  const size45 = keys15.length;
  return [keys15.map((k) => input[k]), some3((values15) => {
    const res = {};
    for (let i = 0; i < size45; i++) {
      ;
      res[keys15[i]] = values15[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either3(effect4));
  }
  return flatMap12(forEach15(eitherEffects, identity, {
    concurrency: options == null ? void 0 : options.concurrency,
    batching: options == null ? void 0 : options.batching,
    concurrentFinalizers: options == null ? void 0 : options.concurrentFinalizers
  }), (eithers) => {
    const none15 = none2();
    const size45 = eithers.length;
    const errors2 = new Array(size45);
    const successes = new Array(size45);
    let errored = false;
    for (let i = 0; i < size45; i++) {
      const either14 = eithers[i];
      if (either14._tag === "Left") {
        errors2[i] = some3(either14.left);
        errored = true;
      } else {
        successes[i] = either14.right;
        errors2[i] = none15;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors2)) : fail2(errors2);
    } else if (options == null ? void 0 : options.discard) {
      return void_3;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either3(effect4));
  }
  if (options == null ? void 0 : options.discard) {
    return forEach15(eitherEffects, identity, {
      concurrency: options == null ? void 0 : options.concurrency,
      batching: options == null ? void 0 : options.batching,
      discard: true,
      concurrentFinalizers: options == null ? void 0 : options.concurrentFinalizers
    });
  }
  return map14(forEach15(eitherEffects, identity, {
    concurrency: options == null ? void 0 : options.concurrency,
    batching: options == null ? void 0 : options.batching,
    concurrentFinalizers: options == null ? void 0 : options.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all9 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if ((options == null ? void 0 : options.mode) === "validate") {
    return allValidate(effects, reconcile, options);
  } else if ((options == null ? void 0 : options.mode) === "either") {
    return allEither(effects, reconcile, options);
  }
  return (options == null ? void 0 : options.discard) !== true && reconcile._tag === "Some" ? map14(forEach15(effects, identity, options), reconcile.value) : forEach15(effects, identity, options);
};
var allWith = (options) => (arg) => all9(arg, options);
var allSuccesses = (elements, options) => map14(all9(fromIterable2(elements).map(exit), options), filterMap4((exit4) => exitIsSuccess(exit4) ? some3(exit4.effect_instruction_i0) : none2()));
var replicate4 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect2 = dual((args2) => isEffect(args2[0]), (self, n, options) => all9(replicate4(self, n), options));
var forEach15 = dual((args2) => isIterable(args2[0]), (self, f2, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = (options == null ? void 0 : options.batching) === true || (options == null ? void 0 : options.batching) === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options == null ? void 0 : options.discard) {
    return match12(options.concurrency, () => finalizersMaskInternal(sequential3, options == null ? void 0 : options.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f2(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f2(a, i)))), () => finalizersMaskInternal(parallel3, options == null ? void 0 : options.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f2(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options == null ? void 0 : options.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f2(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match12(options == null ? void 0 : options.concurrency, () => finalizersMaskInternal(sequential3, options == null ? void 0 : options.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f2(a, i)), true) : forEachSequential(self, (a, i) => restore(f2(a, i)))), () => finalizersMaskInternal(parallel3, options == null ? void 0 : options.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f2(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options == null ? void 0 : options.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f2(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self, f2, batching) => suspend(() => {
  const as18 = fromIterable2(self);
  const array8 = new Array(as18.length);
  const fn2 = (a, i) => flatMap12(f2(a, i), (b) => sync(() => array8[i] = b));
  return zipRight2(forEachConcurrentDiscard(as18, fn2, batching, false), succeed(array8));
});
var forEachConcurrentDiscard = (self, f2, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_3;
  }
  let counter12 = 0;
  let interrupted4 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers2 = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll3 = () => fibers2.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit4
    }) => exit4._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit4
    }) => exit4);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted4 = true;
    interruptAll3();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index3) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index: index3,
          exit: res
        });
        if (res._op === "Failure" && !interrupted4) {
          onInterruptSignal();
        }
      }
    };
    const next6 = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index3 = counter12++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index3 = counter12++;
          return flatMap12(yieldNow(), () => flatMap12(stepOrExit(restore(f2(a2, index3))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index3);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap12(stepOrExit(restore(f2(a, index3))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers2.add(fiber);
        if (interrupted4) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit4;
          if (wrapped._op === "Failure") {
            exit4 = wrapped;
          } else {
            exit4 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers2.delete(fiber);
          pushResult(exit4, index3);
          if (results.length === target) {
            resume2(succeed(getOrElse2(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked3) => blocked3.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse2(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked3) => blocked3.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next6();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next6();
    }
  }));
  return asVoid2(onExit(flatten8(restore(join3(processingFiber))), exitMatch({
    onFailure: (cause3) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count9 = 0;
        let index3 = 0;
        const check6 = (index4, hitNext) => (exit4) => {
          exits[index4] = exit4;
          count9++;
          if (count9 === target2) {
            cb(exitSucceed(exitFailCause(cause3)));
          }
          if (toPop.length > 0 && hitNext) {
            next6();
          }
        };
        const next6 = () => {
          runFiber(toPop.pop(), true).addObserver(check6(index3, true));
          index3++;
        };
        processingFiber.addObserver(check6(index3, false));
        index3++;
        for (let i = 0; i < concurrency; i++) {
          next6();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f3) => f3.inheritAll)
  })));
})));
var forEachParN = (self, n, f2, batching) => suspend(() => {
  const as18 = fromIterable2(self);
  const array8 = new Array(as18.length);
  const fn2 = (a, i) => map14(f2(a, i), (b) => array8[i] = b);
  return zipRight2(forEachConcurrentDiscard(as18, fn2, batching, false, n), succeed(array8));
});
var fork2 = (self) => withFiberRuntime((state, status3) => succeed(unsafeFork2(self, state, status3.runtimeFlags)));
var forkDaemon2 = (self) => forkWithScopeOverride(self, globalScope);
var forkWithErrorHandler = dual(2, (self, handler) => fork2(onError(self, (cause3) => {
  const either14 = failureOrCause(cause3);
  switch (either14._tag) {
    case "Left":
      return handler(either14.left);
    case "Right":
      return failCause(either14.right);
  }
})));
var unsafeFork2 = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect4);
  return childFiber;
};
var unsafeForkUnstarted = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect4, some3(parentFiber), childFiber);
  childFiber.addObserver((exit4) => supervisor.onEnd(exit4, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse2(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll3 = dual((args2) => isFunction2(args2[2]), (elements, zero3, f2, options) => matchSimple(options == null ? void 0 : options.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith6(acc, a, (acc2, a2) => f2(acc2, a2, i)), succeed(zero3)), () => flatMap12(make37(zero3), (acc) => flatMap12(forEach15(elements, (effect4, i) => flatMap12(effect4, (a) => update4(acc, (b) => f2(b, a, i))), options), () => get13(acc)))));
var partition8 = dual((args2) => isIterable(args2[0]), (elements, f2, options) => pipe(forEach15(elements, (a, i) => either3(f2(a, i)), options), map14((chunk7) => partitionMap6(chunk7, identity))));
var validateAll = dual((args2) => isIterable(args2[0]), (elements, f2, options) => flatMap12(partition8(elements, f2, {
  concurrency: options == null ? void 0 : options.concurrency,
  batching: options == null ? void 0 : options.batching,
  concurrentFinalizers: options == null ? void 0 : options.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : (options == null ? void 0 : options.discard) ? void_3 : succeed(bs)));
var raceAll2 = (all16) => {
  const list = fromIterable3(all16);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self = headNonEmpty2(list);
  const effects = tailNonEmpty2(list);
  const inheritAll3 = (res) => pipe(inheritAll(res[1]), as3(res[0]));
  return pipe(deferredMake(), flatMap12((done17) => pipe(make37(effects.length), flatMap12((fails) => uninterruptibleMask((restore) => pipe(fork2(interruptible2(self)), flatMap12((head13) => pipe(effects, forEachSequential((effect4) => fork2(interruptible2(effect4))), map14((fibers2) => unsafeFromArray(fibers2)), map14((tail5) => pipe(tail5, prepend3(head13))), tap2((fibers2) => pipe(fibers2, reduce3(void_3, (effect4, fiber) => pipe(effect4, zipRight2(pipe(_await2(fiber), flatMap12(raceAllArbiter(fibers2, fiber, done17, fails)), fork2, asVoid2)))))), flatMap12((fibers2) => pipe(restore(pipe(_await(done17), flatMap12(inheritAll3))), onInterrupt(() => pipe(fibers2, reduce3(void_3, (effect4, fiber) => pipe(effect4, zipLeft2(interruptFiber(fiber))))))))))))))));
};
var raceAllArbiter = (fibers2, winner, deferred, fails) => (exit4) => exitMatchEffect(exit4, {
  onFailure: (cause3) => pipe(modify8(fails, (fails2) => [fails2 === 0 ? pipe(deferredFailCause(deferred, cause3), asVoid2) : void_3, fails2 - 1]), flatten8),
  onSuccess: (value10) => pipe(deferredSucceed(deferred, [value10, winner]), flatMap12((set26) => set26 ? pipe(fromIterable3(fibers2), reduce3(void_3, (effect4, fiber) => fiber === winner ? effect4 : pipe(effect4, zipLeft2(interruptFiber(fiber))))) : void_3))
});
var reduceEffect = dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f2, options) => matchSimple(options == null ? void 0 : options.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith6(acc, a, (acc2, a2) => f2(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some3(elem);
    }
    case "Some": {
      return some3(f2(acc.value, elem, i));
    }
  }
}, options), map14((option11) => {
  switch (option11._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option11.value;
    }
  }
})))));
var parallelFinalizers = (self) => contextWithEffect((context15) => match2(getOption2(context15, scopeTag), {
  onNone: () => self,
  onSome: (scope6) => {
    switch (scope6.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap12(scopeFork(scope6, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context15) => match2(getOption2(context15, scopeTag), {
  onNone: () => self,
  onSome: (scope6) => {
    if (scope6.strategy._tag === "ParallelN" && scope6.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap12(scopeFork(scope6, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
}));
var finalizersMask = (strategy) => (self) => finalizersMaskInternal(strategy, true)(self);
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context15) => match2(getOption2(context15, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope6) => {
    if (concurrentFinalizers === true) {
      const patch14 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope6.strategy._tag) {
        case "Parallel":
          return patch14(self(parallelFinalizers));
        case "Sequential":
          return patch14(self(sequentialFinalizers));
        case "ParallelN":
          return patch14(self(parallelNFinalizers(scope6.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
}));
var scopeWith = (f2) => flatMap12(scopeTag, f2);
var scopedWith = (f2) => flatMap12(scopeMake2(), (scope6) => onExit(f2(scope6), (exit4) => scope6.close(exit4)));
var scopedEffect = (effect4) => flatMap12(scopeMake2(), (scope6) => scopeUse(effect4, scope6));
var sequentialFinalizers = (self) => contextWithEffect((context15) => match2(getOption2(context15, scopeTag), {
  onNone: () => self,
  onSome: (scope6) => {
    switch (scope6.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap12(scopeFork(scope6, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var tagMetricsScoped = (key, value10) => labelMetricsScoped([make39(key, value10)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union2(old, labels));
var using = dual(2, (self, use2) => scopedWith((scope6) => flatMap12(scopeExtend(self, scope6), use2)));
var validate3 = dual((args2) => isEffect(args2[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
var validateWith = dual((args2) => isEffect(args2[1]), (self, that, f2, options) => flatten8(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f2,
  onFailure: (ca, cb) => (options == null ? void 0 : options.concurrent) ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateAllPar = dual(2, (elements, f2) => flatMap12(partition8(elements, f2), ([es, bs]) => es.length === 0 ? succeed(bs) : fail2(es)));
var validateAllParDiscard = dual(2, (elements, f2) => flatMap12(partition8(elements, f2), ([es, _]) => es.length === 0 ? void_3 : fail2(es)));
var validateFirst = dual((args2) => isIterable(args2[0]), (elements, f2, options) => flip3(forEach15(elements, (a, i) => flip3(f2(a, i)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add3(clockTag, c));
var withRandomScoped = (value10) => fiberRefLocallyScopedWith(currentServices, add3(randomTag, value10));
var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add3(configProviderTag, provider));
var withEarlyRelease = (self) => scopeWith((parent) => flatMap12(scopeFork(parent, sequential2), (child) => pipe(self, scopeExtend(child), map14((value10) => [fiberIdWith((fiberId5) => scopeClose(child, exitInterrupt(fiberId5))), value10]))));
var zipOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
var zipLeftOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if ((options == null ? void 0 : options.concurrent) !== true && ((options == null ? void 0 : options.batching) === void 0 || options.batching === false)) {
    return zipLeft2(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options);
});
var zipRightOptions = dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if ((options == null ? void 0 : options.concurrent) !== true && ((options == null ? void 0 : options.batching) === void 0 || options.batching === false)) {
    return zipRight2(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options);
});
var zipWithOptions = dual((args2) => isEffect(args2[1]), (self, that, f2, options) => map14(all9([self, that], {
  concurrency: (options == null ? void 0 : options.concurrent) ? 2 : 1,
  batching: options == null ? void 0 : options.batching,
  concurrentFinalizers: options == null ? void 0 : options.concurrentFinalizers
}), ([a, a2]) => f2(a, a2)));
var withRuntimeFlagsScoped = (update18) => {
  if (update18 === empty20) {
    return void_3;
  }
  return pipe(runtimeFlags, flatMap12((runtimeFlags2) => {
    const updatedRuntimeFlags = patch7(runtimeFlags2, update18);
    const revertRuntimeFlags = diff7(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update18), zipRight2(addFinalizer2(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid2);
  }), uninterruptible);
};
var scopeTag = GenericTag("effect/Scope");
var scope2 = scopeTag;
var scopeUnsafeAddFinalizer = (scope6, fin) => {
  if (scope6.state._tag === "Open") {
    scope6.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake2(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit4) => newScope.close(exit4);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit4) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_3;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit4
      };
      if (finalizers.length === 0) {
        return void_3;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit4))), flatMap12((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit4)), false), flatMap12((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit4)), false), flatMap12((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_3;
    });
  }
};
var scopeUnsafeMake2 = (strategy = sequential2) => {
  const scope6 = Object.create(ScopeImplProto);
  scope6.strategy = strategy;
  scope6.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope6;
};
var scopeMake2 = (strategy = sequential2) => sync(() => scopeUnsafeMake2(strategy));
var scopeExtend = dual(2, (effect4, scope6) => mapInputContext(
  effect4,
  // @ts-expect-error
  merge3(make8(scopeTag, scope6))
));
var scopeUse = dual(2, (effect4, scope6) => pipe(effect4, scopeExtend(scope6), onExit((exit4) => scope6.close(exit4))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty34
});
var fiberRefLocallyScoped = dual(2, (self, value10) => asVoid2(acquireRelease2(flatMap12(fiberRefGet(self), (oldValue) => as3(fiberRefSet(self, value10), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
var fiberRefLocallyScopedWith = dual(2, (self, f2) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f2(a))));
var fiberRefMake = (initial, options) => fiberRefMakeWith(() => fiberRefUnsafeMake(initial, options));
var fiberRefMakeWith = (ref) => acquireRelease2(tap2(sync(ref), (ref2) => fiberRefUpdate(ref2, identity)), (fiberRef) => fiberRefDelete(fiberRef));
var fiberRefMakeContext = (initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeContext(initial));
var fiberRefMakeRuntimeFlags = (initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeRuntimeFlags(initial));
var currentRuntimeFlags = fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers2) => forEach15(fibers2, _await2);
var fiberAll = (fibers2) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join3(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable2(fibers2).reduce((id3, fiber) => combine5(id3, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers2, (fiber) => flatten8(fiber.await), false)),
    children: map14(forEachParUnbounded(fibers2, (fiber) => fiber.children, false), flatten3),
    inheritAll: forEachSequentialDiscard(fibers2, (fiber) => fiber.inheritAll),
    poll: map14(forEachSequential(fibers2, (fiber) => fiber.poll), reduceRight(some3(exitSucceed(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some3(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk7) => [a, ...chunk7],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId5) => forEachSequentialDiscard(fibers2, (fiber) => fiber.interruptAsFork(fiberId5))
  };
  return _fiberAll;
};
var fiberInterruptFork = (self) => asVoid2(forkDaemon2(interruptFiber(self)));
var fiberJoinAll = (fibers2) => join3(fiberAll(fibers2));
var fiberScoped = (self) => acquireRelease2(succeed(self), interruptFiber);
var raceWith = dual(3, (self, other, options) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => flatMap12(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap12(winner.inheritAll, () => options.onSelfDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit4, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap12(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap12(winner.inheritAll, () => options.onOtherDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit4, loser);
      }
    }
  })
}));
var disconnect = (self) => uninterruptibleMask((restore) => fiberIdWith((fiberId5) => flatMap12(forkDaemon2(restore(self)), (fiber) => pipe(restore(join3(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId5)))))));
var race2 = dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: (exit4, right3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join3(right3), mapErrorCause2((cause22) => parallel(cause3, cause22))),
    onSuccess: (value10) => pipe(right3, interruptAsFiber(parentFiberId), as3(value10))
  }),
  onOtherDone: (exit4, left3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join3(left3), mapErrorCause2((cause22) => parallel(cause22, cause3))),
    onSuccess: (value10) => pipe(left3, interruptAsFiber(parentFiberId), as3(value10))
  })
})));
var raceFibersWith = dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make15(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine5(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring2 = dual(2, (self, finalizer3) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => matchCauseEffect(finalizer3, {
    onFailure: (cause22) => failCause(sequential(cause1, cause22)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as3(finalizer3, a)
})));
var invokeWithInterrupt = (self, entries6, onInterrupt4) => fiberIdWith((id3) => flatMap12(flatMap12(forkDaemon2(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries6.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count9) => count9 === 0)) {
      if (entries6.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f2) => f2());
        onInterrupt4 == null ? void 0 : onInterrupt4();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit4) => {
    cleanup.forEach((f2) => f2());
    cb(exit4);
  });
  const cleanup = entries6.map((r, i) => {
    const observer = (count9) => {
      counts[i] = count9;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f2) => f2());
  });
})), () => suspend(() => {
  const residual = entries6.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete2(entry.request, exitInterrupt(id3)));
})));
var interruptWhenPossible = dual(2, (self, all16) => fiberRefGetWith(currentRequestMap, (map49) => suspend(() => {
  const entries6 = fromIterable2(all16).flatMap((_) => map49.has(_) ? [map49.get(_)] : []);
  return invokeWithInterrupt(self, entries6);
})));
var makeSpanScoped = (name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope6 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get4(fiber.getFiberRef(currentServices), clockTag);
    return as3(scopeAddFinalizerExit(scope6, (exit4) => endSpan(span4, exit4, clock_, timingEnabled)), span4);
  }));
};
var withTracerScoped = (value10) => fiberRefLocallyScopedWith(currentServices, add3(tracerTag, value10));
var withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return flatMap12(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self, spanTag, span4));
  }
  return (self) => flatMap12(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self, spanTag, span4));
};

// node_modules/effect/dist/esm/internal/cache.js
var complete3 = (key, exit4, entryStats, timeToLiveMillis) => struct4({
  _tag: "Complete",
  key,
  exit: exit4,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct4({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete6) => struct4({
  _tag: "Refreshing",
  deferred,
  complete: complete6
});
var MapKeyTypeId = Symbol.for("effect/Cache/MapKey");
var _a45;
var MapKeyImpl = class {
  constructor(current2) {
    __publicField(this, "current");
    __publicField(this, _a45, MapKeyTypeId);
    __publicField(this, "previous");
    __publicField(this, "next");
    this.current = current2;
  }
  [(_a45 = MapKeyTypeId, symbol2)]() {
    return pipe(hash(this.current), combine2(hash(this.previous)), combine2(hash(this.next)), cached(this));
  }
  [symbol3](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
var makeMapKey = (current2) => new MapKeyImpl(current2);
var isMapKey = (u) => hasProperty(u, MapKeyTypeId);
var KeySetImpl = class {
  constructor() {
    __publicField(this, "head");
    __publicField(this, "tail");
  }
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous2 = key.previous;
        const next6 = key.next;
        if (next6 !== void 0) {
          key.next = void 0;
          if (previous2 !== void 0) {
            previous2.next = next6;
            next6.previous = previous2;
          } else {
            this.head = next6;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next6 = key.next;
      if (next6 !== void 0) {
        key.next = void 0;
        this.head = next6;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet = () => new KeySetImpl();
var makeCacheState = (map49, keys15, accesses, updating, hits, misses) => ({
  map: map49,
  keys: keys15,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty23(), makeKeySet(), unbounded(), make15(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});
var _a46, _b13;
_b13 = CacheTypeId, _a46 = ConsumerCacheTypeId;
var CacheImpl = class {
  constructor(capacity10, context15, fiberId5, lookup, timeToLive) {
    __publicField(this, "capacity");
    __publicField(this, "context");
    __publicField(this, "fiberId");
    __publicField(this, "lookup");
    __publicField(this, "timeToLive");
    __publicField(this, _b13, cacheVariance);
    __publicField(this, _a46, consumerCacheVariance);
    __publicField(this, "cacheState");
    this.capacity = capacity10;
    this.context = context15;
    this.fiberId = fiberId5;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map14(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size13(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value10) => this.resolveMapValue(value10)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value10) => this.resolveMapValue(value10, true)
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option11 = get9(this.cacheState.map, key);
      if (isSome2(option11)) {
        switch (option11.value._tag) {
          case "Complete": {
            const loaded = option11.value.entryStats.loadedMillis;
            return some3(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option11.value.complete.entryStats.loadedMillis;
            return some3(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value10 = getOrUndefined2(get9(this.cacheState.map, k));
      if (value10 === void 0) {
        deferred = unsafeMake4(this.fiberId);
        mapKey = makeMapKey(k);
        if (has6(this.cacheState.map, k)) {
          value10 = getOrUndefined2(get9(this.cacheState.map, k));
        } else {
          set5(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value10 === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map14(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap12(this.resolveMapValue(value10), match2({
          onNone: () => this.getEither(key),
          onSome: (value11) => succeed(left2(value11))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove8(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when10) {
    return sync(() => {
      const value10 = get9(this.cacheState.map, key);
      if (isSome2(value10) && value10.value._tag === "Complete") {
        if (value10.value.exit._tag === "Success") {
          if (when10(value10.value.exit.value)) {
            remove8(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty23();
    });
  }
  refresh(key) {
    return clockWith3((clock3) => suspend(() => {
      const k = key;
      const deferred = unsafeMake4(this.fiberId);
      let value10 = getOrUndefined2(get9(this.cacheState.map, k));
      if (value10 === void 0) {
        if (has6(this.cacheState.map, k)) {
          value10 = getOrUndefined2(get9(this.cacheState.map, k));
        } else {
          set5(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value10 === void 0) {
        return asVoid2(this.lookupValueOf(key, deferred));
      } else {
        switch (value10._tag) {
          case "Complete": {
            if (this.hasExpired(clock3, value10.timeToLiveMillis)) {
              const found = getOrUndefined2(get9(this.cacheState.map, k));
              if (equals(found, value10)) {
                remove8(this.cacheState.map, k);
              }
              return asVoid2(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current2 = getOrUndefined2(get9(this.cacheState.map, k));
              if (equals(current2, value10)) {
                const mapValue = refreshing(deferred, value10);
                set5(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid2);
          }
          case "Pending": {
            return _await(value10.deferred);
          }
          case "Refreshing": {
            return _await(value10.deferred);
          }
        }
      }
    }));
  }
  set(key, value10) {
    return clockWith3((clock3) => sync(() => {
      const now3 = clock3.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed3(value10);
      const mapValue = complete3(makeMapKey(k), lookupResult, makeEntryStats(now3), now3 + toMillis(decode(this.timeToLive(lookupResult))));
      set5(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size13(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values15 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values15.push(entry[1].exit.value);
        }
      }
      return values15;
    });
  }
  get entries() {
    return sync(() => {
      const values15 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values15.push([entry[0], entry[1].exit.value]);
        }
      }
      return values15;
    });
  }
  get keys() {
    return sync(() => {
      const keys15 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys15.push(entry[0]);
        }
      }
      return keys15;
    });
  }
  resolveMapValue(value10, ignorePending = false) {
    return clockWith3((clock3) => {
      switch (value10._tag) {
        case "Complete": {
          this.trackAccess(value10.key);
          if (this.hasExpired(clock3, value10.timeToLiveMillis)) {
            remove8(this.cacheState.map, value10.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map14(value10.exit, some3);
        }
        case "Pending": {
          this.trackAccess(value10.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map14(_await(value10.deferred), some3);
        }
        case "Refreshing": {
          this.trackAccess(value10.complete.key);
          this.trackHit();
          if (this.hasExpired(clock3, value10.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map14(_await(value10.deferred), some3);
          }
          return map14(value10.complete.exit, some3);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size45 = size13(this.cacheState.map);
      loop5 = size45 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has6(this.cacheState.map, key2.current)) {
            remove8(this.cacheState.map, key2.current);
            size45 = size45 - 1;
            loop5 = size45 > this.capacity;
          }
        } else {
          loop5 = false;
        }
      }
      set3(this.cacheState.updating, false);
    }
  }
  hasExpired(clock3, timeToLiveMillis) {
    return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock3) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap12((exit4) => {
        const now3 = clock3.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now3);
        const value10 = complete3(makeMapKey(key), exit4, stats, now3 + toMillis(decode(this.timeToLive(exit4))));
        set5(this.cacheState.map, key, value10);
        return zipRight2(done2(deferred, exit4), exit4);
      }), onInterrupt(() => zipRight2(interrupt3(deferred), sync(() => {
        remove8(this.cacheState.map, key);
      }))));
    }));
  }
};
var make49 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeWith({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
var makeWith = (options) => map14(all9([context2(), fiberId]), ([context15, fiberId5]) => new CacheImpl(options.capacity, context15, fiberId5, options.lookup, (exit4) => decode(options.timeToLive(exit4))));
var unsafeMakeWith = (capacity10, lookup, timeToLive) => new CacheImpl(capacity10, empty6(), none3, lookup, (exit4) => decode(timeToLive(exit4)));

// node_modules/effect/dist/esm/Cache.js
var CacheTypeId2 = CacheTypeId;
var ConsumerCacheTypeId2 = ConsumerCacheTypeId;
var make50 = make49;
var makeWith2 = makeWith;
var makeCacheStats2 = makeCacheStats;
var makeEntryStats2 = makeEntryStats;

// node_modules/effect/dist/esm/Cause.js
var Cause_exports = {};
__export(Cause_exports, {
  CauseTypeId: () => CauseTypeId2,
  ExceededCapacityException: () => ExceededCapacityException2,
  ExceededCapacityExceptionTypeId: () => ExceededCapacityExceptionTypeId2,
  IllegalArgumentException: () => IllegalArgumentException2,
  IllegalArgumentExceptionTypeId: () => IllegalArgumentExceptionTypeId2,
  InterruptedException: () => InterruptedException2,
  InterruptedExceptionTypeId: () => InterruptedExceptionTypeId2,
  InvalidPubSubCapacityExceptionTypeId: () => InvalidPubSubCapacityExceptionTypeId2,
  NoSuchElementException: () => NoSuchElementException3,
  NoSuchElementExceptionTypeId: () => NoSuchElementExceptionTypeId2,
  RuntimeException: () => RuntimeException2,
  RuntimeExceptionTypeId: () => RuntimeExceptionTypeId2,
  TimeoutException: () => TimeoutException3,
  TimeoutExceptionTypeId: () => TimeoutExceptionTypeId2,
  UnknownException: () => UnknownException2,
  UnknownExceptionTypeId: () => UnknownExceptionTypeId2,
  YieldableError: () => YieldableError3,
  andThen: () => andThen9,
  as: () => as6,
  contains: () => contains6,
  defects: () => defects2,
  die: () => die6,
  dieOption: () => dieOption2,
  empty: () => empty35,
  fail: () => fail8,
  failureOption: () => failureOption2,
  failureOrCause: () => failureOrCause2,
  failures: () => failures2,
  filter: () => filter15,
  find: () => find2,
  flatMap: () => flatMap16,
  flatten: () => flatten11,
  flipCauseOption: () => flipCauseOption2,
  interrupt: () => interrupt6,
  interruptOption: () => interruptOption2,
  interruptors: () => interruptors2,
  isCause: () => isCause2,
  isDie: () => isDie2,
  isDieType: () => isDieType2,
  isEmpty: () => isEmpty11,
  isEmptyType: () => isEmptyType2,
  isExceededCapacityException: () => isExceededCapacityException2,
  isFailType: () => isFailType2,
  isFailure: () => isFailure4,
  isIllegalArgumentException: () => isIllegalArgumentException2,
  isInterruptType: () => isInterruptType2,
  isInterrupted: () => isInterrupted3,
  isInterruptedException: () => isInterruptedException2,
  isInterruptedOnly: () => isInterruptedOnly2,
  isNoSuchElementException: () => isNoSuchElementException2,
  isParallelType: () => isParallelType2,
  isRuntimeException: () => isRuntimeException2,
  isSequentialType: () => isSequentialType2,
  isTimeoutException: () => isTimeoutException2,
  isUnknownException: () => isUnknownException2,
  keepDefects: () => keepDefects2,
  linearize: () => linearize2,
  map: () => map22,
  match: () => match14,
  originalError: () => originalError,
  parallel: () => parallel4,
  pretty: () => pretty3,
  prettyErrors: () => prettyErrors2,
  reduce: () => reduce15,
  reduceWithContext: () => reduceWithContext3,
  sequential: () => sequential4,
  size: () => size17,
  squash: () => squash,
  squashWith: () => squashWith,
  stripFailures: () => stripFailures2,
  stripSomeDefects: () => stripSomeDefects2
});
var CauseTypeId2 = CauseTypeId;
var RuntimeExceptionTypeId2 = RuntimeExceptionTypeId;
var InterruptedExceptionTypeId2 = InterruptedExceptionTypeId;
var IllegalArgumentExceptionTypeId2 = IllegalArgumentExceptionTypeId;
var NoSuchElementExceptionTypeId2 = NoSuchElementExceptionTypeId;
var InvalidPubSubCapacityExceptionTypeId2 = InvalidPubSubCapacityExceptionTypeId;
var ExceededCapacityExceptionTypeId2 = ExceededCapacityExceptionTypeId;
var TimeoutExceptionTypeId2 = TimeoutExceptionTypeId;
var UnknownExceptionTypeId2 = UnknownExceptionTypeId;
var YieldableError3 = YieldableError;
var empty35 = empty22;
var fail8 = fail;
var die6 = die;
var interrupt6 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isEmptyType2 = isEmptyType;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterruptType2 = isInterruptType;
var isSequentialType2 = isSequentialType;
var isParallelType2 = isParallelType;
var size17 = size12;
var isEmpty11 = isEmpty7;
var isFailure4 = isFailure;
var isDie2 = isDie;
var isInterrupted3 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var failures2 = failures;
var defects2 = defects;
var interruptors2 = interruptors;
var failureOption2 = failureOption;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var dieOption2 = dieOption;
var interruptOption2 = interruptOption;
var keepDefects2 = keepDefects;
var linearize2 = linearize;
var stripFailures2 = stripFailures;
var stripSomeDefects2 = stripSomeDefects;
var as6 = as2;
var map22 = map13;
var flatMap16 = flatMap11;
var andThen9 = andThen5;
var flatten11 = flatten7;
var contains6 = contains5;
var squash = causeSquash;
var squashWith = causeSquashWith;
var find2 = find;
var filter15 = filter11;
var match14 = match6;
var reduce15 = reduce11;
var reduceWithContext3 = reduceWithContext;
var InterruptedException2 = InterruptedException;
var isInterruptedException2 = isInterruptedException;
var IllegalArgumentException2 = IllegalArgumentException;
var isIllegalArgumentException2 = isIllegalArgumentException;
var NoSuchElementException3 = NoSuchElementException;
var isNoSuchElementException2 = isNoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var TimeoutException3 = TimeoutException;
var isTimeoutException2 = isTimeoutException;
var UnknownException2 = UnknownException;
var isUnknownException2 = isUnknownException;
var ExceededCapacityException2 = ExceededCapacityException;
var isExceededCapacityException2 = isExceededCapacityException;
var pretty3 = pretty;
var prettyErrors2 = prettyErrors;
var originalError = originalInstance;

// node_modules/effect/dist/esm/Channel.js
var Channel_exports = {};
__export(Channel_exports, {
  ChannelException: () => ChannelException2,
  ChannelExceptionTypeId: () => ChannelExceptionTypeId2,
  ChannelTypeId: () => ChannelTypeId4,
  acquireReleaseOut: () => acquireReleaseOut2,
  acquireUseRelease: () => acquireUseRelease6,
  as: () => as14,
  asVoid: () => asVoid10,
  buffer: () => buffer3,
  bufferChunk: () => bufferChunk2,
  catchAll: () => catchAll9,
  catchAllCause: () => catchAllCause8,
  collect: () => collect4,
  concatAll: () => concatAll3,
  concatAllWith: () => concatAllWith2,
  concatMap: () => concatMap2,
  concatMapWith: () => concatMapWith2,
  concatMapWithCustom: () => concatMapWithCustom2,
  concatOut: () => concatOut2,
  context: () => context11,
  contextWith: () => contextWith7,
  contextWithChannel: () => contextWithChannel2,
  contextWithEffect: () => contextWithEffect6,
  doneCollect: () => doneCollect2,
  drain: () => drain4,
  embedInput: () => embedInput2,
  emitCollect: () => emitCollect2,
  ensuring: () => ensuring10,
  ensuringWith: () => ensuringWith4,
  fail: () => fail20,
  failCause: () => failCause17,
  failCauseSync: () => failCauseSync10,
  failSync: () => failSync11,
  flatMap: () => flatMap24,
  flatten: () => flatten18,
  foldCauseChannel: () => foldCauseChannel2,
  foldChannel: () => foldChannel2,
  fromEffect: () => fromEffect10,
  fromEither: () => fromEither5,
  fromInput: () => fromInput4,
  fromOption: () => fromOption8,
  fromPubSub: () => fromPubSub4,
  fromPubSubScoped: () => fromPubSubScoped2,
  fromQueue: () => fromQueue4,
  identity: () => identity5,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  isChannel: () => isChannel2,
  isChannelException: () => isChannelException2,
  map: () => map34,
  mapEffect: () => mapEffect8,
  mapError: () => mapError11,
  mapErrorCause: () => mapErrorCause7,
  mapInput: () => mapInput10,
  mapInputContext: () => mapInputContext8,
  mapInputEffect: () => mapInputEffect5,
  mapInputError: () => mapInputError2,
  mapInputErrorEffect: () => mapInputErrorEffect2,
  mapInputIn: () => mapInputIn2,
  mapInputInEffect: () => mapInputInEffect2,
  mapOut: () => mapOut2,
  mapOutEffect: () => mapOutEffect2,
  mapOutEffectPar: () => mapOutEffectPar2,
  mergeAll: () => mergeAll10,
  mergeAllUnbounded: () => mergeAllUnbounded2,
  mergeAllUnboundedWith: () => mergeAllUnboundedWith2,
  mergeAllWith: () => mergeAllWith2,
  mergeMap: () => mergeMap2,
  mergeOut: () => mergeOut2,
  mergeOutWith: () => mergeOutWith2,
  mergeWith: () => mergeWith4,
  never: () => never9,
  orDie: () => orDie9,
  orDieWith: () => orDieWith6,
  orElse: () => orElse14,
  pipeTo: () => pipeTo2,
  pipeToOrFail: () => pipeToOrFail2,
  provideContext: () => provideContext9,
  provideLayer: () => provideLayer3,
  provideService: () => provideService11,
  provideSomeLayer: () => provideSomeLayer4,
  read: () => read2,
  readOrFail: () => readOrFail2,
  readWith: () => readWith2,
  readWithCause: () => readWithCause2,
  repeated: () => repeated2,
  run: () => run5,
  runCollect: () => runCollect3,
  runDrain: () => runDrain3,
  runScoped: () => runScoped3,
  scoped: () => scoped8,
  scopedWith: () => scopedWith5,
  splitLines: () => splitLines3,
  succeed: () => succeed21,
  suspend: () => suspend11,
  sync: () => sync15,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toPullIn: () => toPullIn2,
  toQueue: () => toQueue3,
  toSink: () => toSink,
  toStream: () => toStream,
  unwrap: () => unwrap5,
  unwrapScoped: () => unwrapScoped6,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService7,
  void: () => void_12,
  withSpan: () => withSpan7,
  write: () => write2,
  writeAll: () => writeAll2,
  writeChunk: () => writeChunk2,
  zip: () => zip17,
  zipLeft: () => zipLeft13,
  zipRight: () => zipRight13
});

// node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do6,
  EffectTypeId: () => EffectTypeId4,
  Service: () => Service,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease3,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease3,
  addFinalizer: () => addFinalizer4,
  all: () => all11,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen11,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap3,
  as: () => as8,
  asSome: () => asSome3,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid6,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind7,
  bindAll: () => bindAll2,
  bindTo: () => bindTo7,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  catchAllDefect: () => catchAllDefect3,
  catchIf: () => catchIf3,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag3,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context5,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay3,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die8,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync4,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect2,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile4,
  either: () => either6,
  ensuring: () => ensuring4,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every13,
  exists: () => exists4,
  exit: () => exit3,
  fail: () => fail12,
  failCause: () => failCause10,
  failCauseSync: () => failCauseSync5,
  failSync: () => failSync5,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter16,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap11,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail3,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst11,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap18,
  flatten: () => flatten13,
  flip: () => flip5,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach16,
  forever: () => forever4,
  fork: () => fork4,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon3,
  forkIn: () => forkIn3,
  forkScoped: () => forkScoped3,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable5,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen6,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head7,
  if: () => if_2,
  ignore: () => ignore3,
  ignoreLogged: () => ignoreLogged3,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt8,
  interruptWith: () => interruptWith3,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure5,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_7,
  liftPredicate: () => liftPredicate5,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally2,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log3,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map26,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth6,
  mapError: () => mapError5,
  mapErrorCause: () => mapErrorCause4,
  mapInputContext: () => mapInputContext3,
  match: () => match20,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect4,
  merge: () => merge7,
  mergeAll: () => mergeAll5,
  metricLabels: () => metricLabels2,
  negate: () => negate4,
  never: () => never5,
  none: () => none9,
  onError: () => onError3,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt3,
  once: () => once3,
  option: () => option4,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie4,
  orDieWith: () => orDieWith2,
  orElse: () => orElse8,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed3,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition9,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise3,
  provide: () => provide2,
  provideService: () => provideService5,
  provideServiceEffect: () => provideServiceEffect3,
  race: () => race3,
  raceAll: () => raceAll3,
  raceFirst: () => raceFirst3,
  raceWith: () => raceWith2,
  random: () => random4,
  randomWith: () => randomWith3,
  reduce: () => reduce17,
  reduceEffect: () => reduceEffect3,
  reduceRight: () => reduceRight5,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat3,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate5,
  replicateEffect: () => replicateEffect3,
  request: () => request,
  retry: () => retry3,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise2,
  runPromiseExit: () => runPromiseExit2,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync2,
  runSyncExit: () => runSyncExit2,
  runtime: () => runtime4,
  sandbox: () => sandbox3,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope4,
  scopeWith: () => scopeWith2,
  scoped: () => scoped4,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption3,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep5,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed13,
  succeedNone: () => succeedNone3,
  succeedSome: () => succeedSome3,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync8,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile5,
  tap: () => tap5,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect3,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout3,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption3,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption2,
  transposeOption: () => transposeOption2,
  try: () => try_4,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise3,
  uninterruptible: () => uninterruptible3,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs3,
  updateService: () => updateService3,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate4,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when3,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency3,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withRandom: () => withRandom2,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip12,
  zipLeft: () => zipLeft7,
  zipRight: () => zipRight7,
  zipWith: () => zipWith12
});

// node_modules/effect/dist/esm/ScheduleDecision.js
var ScheduleDecision_exports = {};
__export(ScheduleDecision_exports, {
  continue: () => _continue2,
  continueWith: () => continueWith2,
  done: () => done7,
  isContinue: () => isContinue2,
  isDone: () => isDone5
});

// node_modules/effect/dist/esm/ScheduleIntervals.js
var ScheduleIntervals_exports = {};
__export(ScheduleIntervals_exports, {
  IntervalsTypeId: () => IntervalsTypeId2,
  empty: () => empty39,
  end: () => end2,
  fromIterable: () => fromIterable16,
  intersect: () => intersect4,
  isNonEmpty: () => isNonEmpty6,
  lessThan: () => lessThan12,
  make: () => make54,
  max: () => max10,
  start: () => start2,
  union: () => union12
});

// node_modules/effect/dist/esm/ScheduleInterval.js
var ScheduleInterval_exports = {};
__export(ScheduleInterval_exports, {
  IntervalTypeId: () => IntervalTypeId2,
  after: () => after2,
  before: () => before2,
  empty: () => empty37,
  intersect: () => intersect2,
  isEmpty: () => isEmpty13,
  isNonEmpty: () => isNonEmpty4,
  lessThan: () => lessThan10,
  make: () => make52,
  max: () => max8,
  min: () => min8,
  size: () => size19,
  union: () => union10
});

// node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = Symbol.for(IntervalSymbolKey);
var empty36 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make51 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty36;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan9 = dual(2, (self, that) => min7(self, that) === self);
var min7 = dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
var max7 = dual(2, (self, that) => min7(self, that) === self ? that : self);
var isEmpty12 = (self) => {
  return self.startMillis >= self.endMillis;
};
var isNonEmpty3 = (self) => {
  return !isEmpty12(self);
};
var intersect = dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end7 = Math.min(self.endMillis, that.endMillis);
  return make51(start5, end7);
});
var size18 = (self) => {
  return millis(self.endMillis - self.startMillis);
};
var union9 = dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end7 = Math.min(self.endMillis, that.endMillis);
  return start5 < end7 ? none2() : some3(make51(start5, end7));
});
var after = (startMilliseconds) => {
  return make51(startMilliseconds, Number.POSITIVE_INFINITY);
};
var before = (endMilliseconds) => {
  return make51(Number.NEGATIVE_INFINITY, endMilliseconds);
};

// node_modules/effect/dist/esm/ScheduleInterval.js
var IntervalTypeId2 = IntervalTypeId;
var make52 = make51;
var empty37 = empty36;
var lessThan10 = lessThan9;
var min8 = min7;
var max8 = max7;
var isEmpty13 = isEmpty12;
var isNonEmpty4 = isNonEmpty3;
var intersect2 = intersect;
var size19 = size18;
var union10 = union9;
var after2 = after;
var before2 = before;

// node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = Symbol.for(IntervalsSymbolKey);
var make53 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var empty38 = make53(empty7());
var fromIterable15 = (intervals) => Array.from(intervals).reduce((intervals2, interval) => pipe(intervals2, union11(make53(of3(interval)))), empty38);
var union11 = dual(2, (self, that) => {
  if (!isNonEmpty2(that.intervals)) {
    return self;
  }
  if (!isNonEmpty2(self.intervals)) {
    return that;
  }
  if (headNonEmpty2(self.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
    return unionLoop(tailNonEmpty2(self.intervals), that.intervals, headNonEmpty2(self.intervals), empty7());
  }
  return unionLoop(self.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty7());
});
var unionLoop = (_self, _that, _interval, _acc) => {
  let self = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty2(self) || isNonEmpty2(that)) {
    if (!isNonEmpty2(self) && isNonEmpty2(that)) {
      if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
        self = empty7();
      } else {
        interval = make52(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
        self = empty7();
      }
    } else if (isNonEmpty2(self) && isEmpty2(that)) {
      if (interval.endMillis < headNonEmpty2(self).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(self);
        that = empty7();
        self = tailNonEmpty2(self);
      } else {
        interval = make52(interval.startMillis, headNonEmpty2(self).endMillis);
        that = empty7();
        self = tailNonEmpty2(self);
      }
    } else if (isNonEmpty2(self) && isNonEmpty2(that)) {
      if (headNonEmpty2(self).startMillis < headNonEmpty2(that).startMillis) {
        if (interval.endMillis < headNonEmpty2(self).startMillis) {
          acc = pipe(acc, prepend3(interval));
          interval = headNonEmpty2(self);
          self = tailNonEmpty2(self);
        } else {
          interval = make52(interval.startMillis, headNonEmpty2(self).endMillis);
          self = tailNonEmpty2(self);
        }
      } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend3(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
      } else {
        interval = make52(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return make53(pipe(acc, prepend3(interval), reverse3));
};
var intersect3 = dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty7()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty13(interval) ? acc : pipe(acc, prepend3(interval));
    if (pipe(headNonEmpty2(left3), lessThan10(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make53(reverse3(acc));
};
var start = (self) => {
  return pipe(self.intervals, head3, getOrElse2(() => empty37)).startMillis;
};
var end = (self) => {
  return pipe(self.intervals, head3, getOrElse2(() => empty37)).endMillis;
};
var lessThan11 = dual(2, (self, that) => start(self) < start(that));
var isNonEmpty5 = (self) => {
  return isNonEmpty2(self.intervals);
};
var max9 = dual(2, (self, that) => lessThan11(self, that) ? that : self);

// node_modules/effect/dist/esm/ScheduleIntervals.js
var IntervalsTypeId2 = IntervalsTypeId;
var make54 = make53;
var empty39 = empty38;
var fromIterable16 = fromIterable15;
var union12 = union11;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan12 = lessThan11;
var isNonEmpty6 = isNonEmpty5;
var max10 = max9;

// node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make54(of3(interval))
  };
};
var done6 = {
  _tag: OP_DONE2
};
var isContinue = (self) => {
  return self._tag === OP_CONTINUE;
};
var isDone4 = (self) => {
  return self._tag === OP_DONE2;
};

// node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done7 = done6;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// node_modules/effect/dist/esm/Scope.js
var Scope_exports = {};
__export(Scope_exports, {
  CloseableScopeTypeId: () => CloseableScopeTypeId2,
  Scope: () => Scope,
  ScopeTypeId: () => ScopeTypeId2,
  addFinalizer: () => addFinalizer3,
  addFinalizerExit: () => addFinalizerExit,
  close: () => close,
  extend: () => extend3,
  fork: () => fork3,
  make: () => make55,
  use: () => use
});
var ScopeTypeId2 = ScopeTypeId;
var CloseableScopeTypeId2 = CloseableScopeTypeId;
var Scope = scopeTag;
var addFinalizer3 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend3 = scopeExtend;
var fork3 = scopeFork;
var use = scopeUse;
var make55 = scopeMake2;

// node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  constructor(permits) {
    __publicField(this, "permits");
    __publicField(this, "waiters", /* @__PURE__ */ new Set());
    __publicField(this, "taken", 0);
    __publicField(this, "take", (n) => asyncInterrupt((resume2) => {
      if (this.free < n) {
        const observer = () => {
          if (this.free < n) {
            return;
          }
          this.waiters.delete(observer);
          this.taken += n;
          resume2(succeed(n));
        };
        this.waiters.add(observer);
        return sync(() => {
          this.waiters.delete(observer);
        });
      }
      this.taken += n;
      return resume2(succeed(n));
    }));
    __publicField(this, "updateTaken", (f2) => withFiberRuntime((fiber) => {
      this.taken = f2(this.taken);
      if (this.waiters.size > 0) {
        fiber.getFiberRef(currentScheduler).scheduleTask(() => {
          const iter = this.waiters.values();
          let item = iter.next();
          while (item.done === false && this.free > 0) {
            item.value();
            item = iter.next();
          }
        }, fiber.getFiberRef(currentSchedulingPriority));
      }
      return succeed(this.free);
    }));
    __publicField(this, "release", (n) => this.updateTaken((taken) => taken - n));
    __publicField(this, "releaseAll", this.updateTaken((_) => 0));
    __publicField(this, "withPermits", (n) => (self) => uninterruptibleMask((restore) => flatMap12(restore(this.take(n)), (permits) => ensuring2(restore(self), this.release(permits)))));
    __publicField(this, "withPermitsIfAvailable", (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
      if (this.free < n) {
        return succeedNone;
      }
      this.taken += n;
      return ensuring2(restore(asSome(self)), this.release(n));
    })));
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
};
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));
var Latch = class extends Class3 {
  constructor(isOpen) {
    super();
    __publicField(this, "isOpen");
    __publicField(this, "waiters", []);
    __publicField(this, "scheduled", false);
    __publicField(this, "flushWaiters", () => {
      this.scheduled = false;
      const waiters = this.waiters;
      this.waiters = [];
      for (let i = 0; i < waiters.length; i++) {
        waiters[i](exitVoid);
      }
    });
    __publicField(this, "open", withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_3;
      }
      this.isOpen = true;
      return this.unsafeSchedule(fiber);
    }));
    __publicField(this, "release", withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_3;
      }
      return this.unsafeSchedule(fiber);
    }));
    __publicField(this, "await", asyncInterrupt((resume2) => {
      if (this.isOpen) {
        return resume2(void_3);
      }
      this.waiters.push(resume2);
      return sync(() => {
        const index3 = this.waiters.indexOf(resume2);
        if (index3 !== -1) {
          this.waiters.splice(index3, 1);
        }
      });
    }));
    __publicField(this, "close", sync(() => {
      this.isOpen = false;
    }));
    __publicField(this, "whenOpen", (self) => {
      return zipRight2(this.await, self);
    });
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_3;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_3;
  }
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  unsafeClose() {
    this.isOpen = false;
  }
};
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
var awaitAllChildren = (self) => ensuringChildren(self, fiberAwaitAll);
var cached2 = dual(2, (self, timeToLive) => map14(cachedInvalidateWithTTL(self, timeToLive), (tuple7) => tuple7[0]));
var cachedInvalidateWithTTL = dual(2, (self, timeToLive) => {
  const duration5 = decode(timeToLive);
  return flatMap12(context2(), (env) => map14(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self, duration5, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = (self, timeToLive, start5) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap2((deferred) => intoDeferred(self, deferred)), map14((deferred) => some3([start5 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap12((time3) => updateSomeAndGetEffectSynchronized(cache, (option11) => {
  switch (option11._tag) {
    case "None": {
      return some3(computeCachedValue(self, timeToLive, time3));
    }
    case "Some": {
      const [end7] = option11.value;
      return end7 - time3 <= 0 ? some3(computeCachedValue(self, timeToLive, time3)) : none2();
    }
  }
})), flatMap12((option11) => isNone2(option11) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option11.value[1])))));
var invalidateCache = (cache) => set6(cache, none2());
var ensuringChild = dual(2, (self, f2) => ensuringChildren(self, (children3) => f2(fiberAll(children3))));
var ensuringChildren = dual(2, (self, children3) => flatMap12(track, (supervisor) => pipe(supervised(self, supervisor), ensuring2(flatMap12(supervisor.value, children3)))));
var forkAll = dual((args2) => isIterable(args2[0]), (effects, options) => (options == null ? void 0 : options.discard) ? forEachSequentialDiscard(effects, fork2) : map14(forEachSequential(effects, fork2), fiberAll));
var forkIn2 = dual(2, (self, scope6) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope6;
  const fiber = unsafeFork2(self, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer3 = () => fiberIdWith((fiberId5) => equals(fiberId5, fiber.id()) ? void_3 : asVoid2(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer3);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped2 = (self) => scopeWith((scope6) => forkIn2(self, scope6));
var fromFiber = (fiber) => join3(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap12(fiber, join3));
var memoKeySymbol = Symbol.for("effect/Effect/memoizeFunction.key");
var _a47;
var Key = class {
  constructor(a, eq) {
    __publicField(this, "a");
    __publicField(this, "eq");
    __publicField(this, _a47, memoKeySymbol);
    this.a = a;
    this.eq = eq;
  }
  [(_a47 = memoKeySymbol, symbol3)](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol2]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var cachedFunction = (f2, eq) => {
  return pipe(sync(() => empty23()), flatMap12(makeSynchronized), map14((ref) => (a) => pipe(ref.modifyEffect((map49) => {
    const result = pipe(map49, get9(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap2((deferred) => pipe(diffFiberRefs(f2(a)), intoDeferred(deferred), fork2)), map14((deferred) => [deferred, pipe(map49, set5(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map49]);
  }), flatMap12(deferredAwait), flatMap12(([patch14, b]) => pipe(patchFiberRefs(patch14), as3(b))))));
};
var raceFirst2 = dual(2, (self, that) => pipe(exit(self), race2(exit(that)), (effect4) => flatten8(effect4)));
var supervised = dual(2, (self, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self);
});
var timeout2 = dual(2, (self, duration5) => timeoutFail(self, {
  onTimeout: () => timeoutExceptionFromDuration(duration5),
  duration: duration5
}));
var timeoutFail = dual(2, (self, {
  duration: duration5,
  onTimeout
}) => flatten8(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration5
})));
var timeoutFailCause = dual(2, (self, {
  duration: duration5,
  onTimeout
}) => flatten8(timeoutTo(self, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration: duration5
})));
var timeoutOption2 = dual(2, (self, duration5) => timeoutTo(self, {
  duration: duration5,
  onSuccess: some3,
  onTimeout: none2
}));
var timeoutTo = dual(2, (self, {
  duration: duration5,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration5)), {
  onSelfWin: (winner, loser) => flatMap12(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap12(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onSuccess(exit4.value)));
    } else {
      return flatMap12(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap12(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap12(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap12(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a48, _b14, _c2, _d;
var SynchronizedImpl = class extends (_d = Class3, _c2 = SynchronizedTypeId, _b14 = RefTypeId, _a48 = TypeId15, _d) {
  constructor(ref, withLock3) {
    super();
    __publicField(this, "ref");
    __publicField(this, "withLock");
    __publicField(this, _c2, synchronizedVariance);
    __publicField(this, _b14, refVariance);
    __publicField(this, _a48, TypeId15);
    __publicField(this, "get");
    this.ref = ref;
    this.withLock = withLock3;
    this.get = get12(this.ref);
  }
  commit() {
    return this.get;
  }
  modify(f2) {
    return this.modifyEffect((a) => succeed(f2(a)));
  }
  modifyEffect(f2) {
    return this.withLock(pipe(flatMap12(get12(this.ref), f2), flatMap12(([b, a]) => as3(set6(this.ref, a), b))));
  }
};
var makeSynchronized = (value10) => sync(() => unsafeMakeSynchronized(value10));
var unsafeMakeSynchronized = (value10) => {
  const ref = unsafeMake7(value10);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = dual(2, (self, pf) => self.modifyEffect((value10) => {
  const result = pf(value10);
  switch (result._tag) {
    case "None": {
      return succeed([value10, value10]);
    }
    case "Some": {
      return map14(result.value, (a) => [a, a]);
    }
  }
}));
var zipFiber = dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));
var zipLeftFiber = dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));
var zipRightFiber = dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));
var zipWithFiber = dual(3, (self, that, f2) => ({
  ...CommitPrototype2,
  commit() {
    return join3(this);
  },
  [FiberTypeId]: fiberVariance2,
  id: () => pipe(self.id(), getOrElse6(that.id())),
  await: pipe(self.await, flatten8, zipWithOptions(flatten8(that.await), f2, {
    concurrent: true
  }), exit),
  children: self.children,
  inheritAll: zipRight2(that.inheritAll, self.inheritAll),
  poll: zipWith6(self.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap2((exitA) => pipe(optionB, map2((exitB) => zipWith7(exitA, exitB, {
    onSuccess: f2,
    onFailure: parallel
  })))))),
  interruptAsFork: (id3) => zipRight2(self.interruptAsFork(id3), that.interruptAsFork(id3)),
  pipe() {
    return pipeArguments(this, arguments);
  }
}));
var bindAll = dual((args2) => isEffect(args2[0]), (self, f2, options) => flatMap12(self, (a) => all9(f2(a), options).pipe(map14((record4) => Object.assign({}, a, record4)))));

// node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId19 = Symbol.for("effect/ManagedRuntime");

// node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/effect/dist/esm/Fiber.js
var Fiber_exports = {};
__export(Fiber_exports, {
  FiberTypeId: () => FiberTypeId2,
  Order: () => Order8,
  RuntimeFiberTypeId: () => RuntimeFiberTypeId2,
  all: () => all10,
  await: () => _await3,
  awaitAll: () => awaitAll,
  children: () => children2,
  done: () => done8,
  dump: () => dump2,
  dumpAll: () => dumpAll2,
  fail: () => fail9,
  failCause: () => failCause7,
  fromEffect: () => fromEffect3,
  getCurrentFiber: () => getCurrentFiber2,
  id: () => id2,
  inheritAll: () => inheritAll2,
  interrupt: () => interrupt7,
  interruptAll: () => interruptAll2,
  interruptAllAs: () => interruptAllAs2,
  interruptAs: () => interruptAs,
  interruptAsFork: () => interruptAsFork2,
  interruptFork: () => interruptFork,
  interrupted: () => interrupted2,
  isFiber: () => isFiber2,
  isRuntimeFiber: () => isRuntimeFiber2,
  join: () => join4,
  joinAll: () => joinAll,
  map: () => map23,
  mapEffect: () => mapEffect3,
  mapFiber: () => mapFiber2,
  match: () => match15,
  never: () => never4,
  orElse: () => orElse6,
  orElseEither: () => orElseEither5,
  poll: () => poll4,
  pretty: () => pretty4,
  roots: () => roots2,
  scoped: () => scoped2,
  status: () => status2,
  succeed: () => succeed9,
  unsafeRoots: () => unsafeRoots2,
  void: () => void_7,
  zip: () => zip11,
  zipLeft: () => zipLeft5,
  zipRight: () => zipRight5,
  zipWith: () => zipWith9
});
var FiberTypeId2 = FiberTypeId;
var RuntimeFiberTypeId2 = RuntimeFiberTypeId;
var Order8 = Order7;
var isFiber2 = isFiber;
var isRuntimeFiber2 = isRuntimeFiber;
var id2 = id;
var _await3 = _await2;
var awaitAll = fiberAwaitAll;
var children2 = children;
var all10 = fiberAll;
var done8 = done5;
var dump2 = dump;
var dumpAll2 = dumpAll;
var fail9 = fail6;
var failCause7 = failCause5;
var fromEffect3 = fromEffect;
var getCurrentFiber2 = getCurrentFiber;
var inheritAll2 = inheritAll;
var interrupt7 = interruptFiber;
var interrupted2 = interrupted;
var interruptAs = interruptAsFiber;
var interruptAsFork2 = interruptAsFork;
var interruptAll2 = interruptAll;
var interruptAllAs2 = interruptAllAs;
var interruptFork = fiberInterruptFork;
var join4 = join3;
var joinAll = fiberJoinAll;
var map23 = map18;
var mapEffect3 = mapEffect2;
var mapFiber2 = mapFiber;
var match15 = match13;
var never4 = never3;
var orElse6 = orElse5;
var orElseEither5 = orElseEither3;
var poll4 = poll3;
var pretty4 = pretty2;
var roots2 = roots;
var unsafeRoots2 = unsafeRoots;
var scoped2 = fiberScoped;
var status2 = status;
var succeed9 = succeed5;
var void_7 = void_6;
var zip11 = zipFiber;
var zipLeft5 = zipLeftFiber;
var zipRight5 = zipRightFiber;
var zipWith9 = zipWithFiber;

// node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f2) => function() {
  if (arguments.length === 1) {
    const runtime8 = arguments[0];
    return (effect4, ...args2) => f2(runtime8, effect4, ...args2);
  }
  return f2.apply(this, arguments);
};
var unsafeFork3 = makeDual((runtime8, self, options) => {
  const fiberId5 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId5, runtime8.context]]]];
  if (options == null ? void 0 : options.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId5, options.scheduler]]]);
  }
  let fiberRefs4 = updateManyAs2(runtime8.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId5
  });
  if (options == null ? void 0 : options.updateRefs) {
    fiberRefs4 = options.updateRefs(fiberRefs4, fiberId5);
  }
  const fiberRuntime = new FiberRuntime(fiberId5, fiberRefs4, runtime8.runtimeFlags);
  let effect4 = self;
  if (options == null ? void 0 : options.scope) {
    effect4 = flatMap12(fork3(options.scope, sequential2), (closeableScope) => zipRight2(scopeAddFinalizer(closeableScope, fiberIdWith((id3) => equals(id3, fiberRuntime.id()) ? void_3 : interruptAsFiber(fiberRuntime, id3))), onExit(self, (exit4) => close(closeableScope, exit4))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime8.context, effect4, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit4) => supervisor.onEnd(exit4, fiberRuntime));
  }
  globalScope.add(runtime8.runtimeFlags, fiberRuntime);
  if ((options == null ? void 0 : options.immediate) === false) {
    fiberRuntime.resume(effect4);
  } else {
    fiberRuntime.start(effect4);
  }
  return fiberRuntime;
});
var unsafeRunCallback = makeDual((runtime8, effect4, options = {}) => {
  const fiberRuntime = unsafeFork3(runtime8, effect4, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit4) => {
      options.onExit(exit4);
    });
  }
  return (id3, cancelOptions) => unsafeRunCallback(runtime8)(pipe(fiberRuntime, interruptAs(id3 ?? none4)), {
    ...cancelOptions,
    onExit: (cancelOptions == null ? void 0 : cancelOptions.onExit) ? (exit4) => cancelOptions.onExit(flatten9(exit4)) : void 0
  });
});
var unsafeRunSync = makeDual((runtime8, effect4) => {
  const result = unsafeRunSyncExit(runtime8)(effect4);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    __publicField(this, "fiber");
    __publicField(this, "_tag", "AsyncFiberException");
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = (fiber) => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit2;
  return error4;
};
var isAsyncFiberException = (u) => isTagged(u, "AsyncFiberException") && "fiber" in u;
var FiberFailureId = Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = Symbol.for("effect/Runtime/FiberFailure/Cause");
var _a49, _b15;
var FiberFailureImpl = class extends Error {
  constructor(cause3) {
    const head13 = prettyErrors(cause3)[0];
    super((head13 == null ? void 0 : head13.message) || "An error has occurred");
    __publicField(this, _b15);
    __publicField(this, _a49);
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause3;
    this.name = head13 ? `(FiberFailure) ${head13.name}` : "FiberFailure";
    if (head13 == null ? void 0 : head13.stack) {
      this.stack = head13.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [(_b15 = FiberFailureId, _a49 = FiberFailureCauseId, NodeInspectSymbol)]() {
    return this.toString();
  }
};
var fiberFailure = (cause3) => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new FiberFailureImpl(cause3);
  Error.stackTraceLimit = limit2;
  return error4;
};
var isFiberFailure = (u) => hasProperty(u, FiberFailureId);
var fastPath = (effect4) => {
  const op = effect4;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = makeDual((runtime8, effect4) => {
  const op = fastPath(effect4);
  if (op) {
    return op;
  }
  const scheduler2 = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime8)(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = makeDual((runtime8, effect4, options) => unsafeRunPromiseExit(runtime8, effect4, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = makeDual((runtime8, effect4, options) => new Promise((resolve) => {
  const op = fastPath(effect4);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork3(runtime8)(effect4);
  fiber.addObserver((exit4) => {
    resolve(exit4);
  });
  if ((options == null ? void 0 : options.signal) !== void 0) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  constructor(context15, runtimeFlags2, fiberRefs4) {
    __publicField(this, "context");
    __publicField(this, "runtimeFlags");
    __publicField(this, "fiberRefs");
    this.context = context15;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make56 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status3) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status3.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = make22(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = make56({
  context: empty6(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: empty27()
});
var updateRuntimeFlags2 = dual(2, (self, f2) => make56({
  context: self.context,
  runtimeFlags: f2(self.runtimeFlags),
  fiberRefs: self.fiberRefs
}));
var disableRuntimeFlag = dual(2, (self, flag) => updateRuntimeFlags2(self, disable2(flag)));
var enableRuntimeFlag = dual(2, (self, flag) => updateRuntimeFlags2(self, enable2(flag)));
var updateContext2 = dual(2, (self, f2) => make56({
  context: f2(self.context),
  runtimeFlags: self.runtimeFlags,
  fiberRefs: self.fiberRefs
}));
var provideService3 = dual(3, (self, tag5, service4) => updateContext2(self, add3(tag5, service4)));
var updateFiberRefs2 = dual(2, (self, f2) => make56({
  context: self.context,
  runtimeFlags: self.runtimeFlags,
  fiberRefs: f2(self.fiberRefs)
}));
var setFiberRef = dual(3, (self, fiberRef, value10) => updateFiberRefs2(self, updateAs2({
  fiberId: none4,
  fiberRef,
  value: value10
})));
var deleteFiberRef = dual(2, (self, fiberRef) => updateFiberRefs2(self, delete_2(fiberRef)));
var unsafeRunEffect = unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = unsafeFork3(defaultRuntime);
var unsafeRunPromiseEffect = unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = void 0;
  return flatMap12(deferredMake(), (deferred) => flatMap12(runtime3(), (runtime8) => uninterruptibleMask((restore) => zipRight2(fork2(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime8)(intoDeferred(cb, deferred))), {
    onFailure: (cause3) => deferredFailCause(deferred, cause3),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_3;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_3))))));
});

// node_modules/effect/dist/esm/internal/synchronizedRef.js
var getAndUpdateEffect = dual(2, (self, f2) => self.modifyEffect((value10) => map14(f2(value10), (result) => [value10, result])));
var getAndUpdateSomeEffect = dual(2, (self, pf) => self.modifyEffect((value10) => {
  const result = pf(value10);
  switch (result._tag) {
    case "None": {
      return succeed([value10, value10]);
    }
    case "Some": {
      return map14(result.value, (newValue) => [value10, newValue]);
    }
  }
}));
var modify10 = dual(2, (self, f2) => self.modify(f2));
var modifyEffect = dual(2, (self, f2) => self.modifyEffect(f2));
var modifySomeEffect = dual(3, (self, fallback3, pf) => self.modifyEffect((value10) => pipe(pf(value10), getOrElse2(() => succeed([fallback3, value10])))));
var updateEffect = dual(2, (self, f2) => self.modifyEffect((value10) => map14(f2(value10), (result) => [void 0, result])));
var updateAndGetEffect = dual(2, (self, f2) => self.modifyEffect((value10) => map14(f2(value10), (result) => [result, result])));
var updateSomeEffect = dual(2, (self, pf) => self.modifyEffect((value10) => {
  const result = pf(value10);
  switch (result._tag) {
    case "None": {
      return succeed([void 0, value10]);
    }
    case "Some": {
      return map14(result.value, (a) => [void 0, a]);
    }
  }
}));

// node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self) => {
  return self._op_layer === OP_FRESH;
};
var _a50;
_a50 = MemoMapTypeId;
var MemoMapImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a50);
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer, scope6) {
    return pipe(modifyEffect(this.ref, (map49) => {
      const inMap = map49.get(layer);
      if (inMap !== void 0) {
        const [acquire4, release4] = inMap;
        const cached4 = pipe(acquire4, flatMap12(([patch14, b]) => pipe(patchFiberRefs(patch14), as3(b))), onExit(exitMatch({
          onFailure: () => void_3,
          onSuccess: () => scopeAddFinalizerExit(scope6, release4)
        })));
        return succeed([cached4, map49]);
      }
      return pipe(make36(0), flatMap12((observers) => pipe(deferredMake(), flatMap12((deferred) => pipe(make36(() => void_3), map14((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake2(), flatMap12((innerScope) => pipe(restore(flatMap12(makeBuilder(layer, innerScope, true), (f2) => diffFiberRefs(f2(this)))), exit, flatMap12((exit4) => {
          switch (exit4._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit4.effect_instruction_i0), zipRight2(scopeClose(innerScope, exit4)), zipRight2(failCause(exit4.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set6(finalizerRef, (exit5) => pipe(scopeClose(innerScope, exit5), whenEffect(modify7(observers, (n) => [n === 1, n - 1])), asVoid2)), zipRight2(update3(observers, (n) => n + 1)), zipRight2(scopeAddFinalizerExit(scope6, (exit5) => pipe(sync(() => map49.delete(layer)), zipRight2(get12(finalizerRef)), flatMap12((finalizer3) => finalizer3(exit5))))), zipRight2(deferredSucceed(deferred, exit4.effect_instruction_i0)), as3(exit4.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized2 = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_3,
          onSuccess: () => update3(observers, (n) => n + 1)
        }))), (exit4) => pipe(get12(finalizerRef), flatMap12((finalizer3) => finalizer3(exit4)))];
        return [resource, isFresh(layer) ? map49 : map49.set(layer, memoized2)];
      }))))));
    }), flatten8);
  }
};
var makeMemoMap = suspend(() => map14(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
var build = (self) => scopeWith((scope6) => buildWithScope(self, scope6));
var buildWithScope = dual(2, (self, scope6) => flatMap12(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope6)));
var buildWithMemoMap = dual(3, (self, memoMap, scope6) => flatMap12(makeBuilder(self, scope6), (run10) => provideService(run10(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self, scope6, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope6)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope7) => memoMap.getOrElseMemoize(op.layer, scope7)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope6), matchCauseEffect({
        onFailure: (cause3) => memoMap.getOrElseMemoize(op.failureK(cause3), scope6),
        onSuccess: (value10) => memoMap.getOrElseMemoize(op.successK(value10), scope6)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope6)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope6));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope6), flatMap12((env) => pipe(memoMap.getOrElseMemoize(op.second, scope6), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope6)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope6));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope6));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope6), zipWith6(memoMap.getOrElseMemoize(op.second, scope6), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope6), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope6), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var catchAll3 = dual(2, (self, onFailure) => match16(self, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause3 = dual(2, (self, onFailure) => matchCause3(self, {
  onFailure,
  onSuccess: succeedContext
}));
var die7 = (defect) => failCause8(die6(defect));
var dieSync3 = (evaluate4) => failCauseSync4(() => die6(evaluate4()));
var discard = (self) => map24(self, () => empty6());
var context4 = () => fromEffectContext(context2());
var extendScope = (self) => {
  const extendScope3 = Object.create(proto3);
  extendScope3._op_layer = OP_EXTEND_SCOPE;
  extendScope3.layer = self;
  return extendScope3;
};
var fail10 = (error4) => failCause8(fail8(error4));
var failSync4 = (evaluate4) => failCauseSync4(() => fail8(evaluate4()));
var failCause8 = (cause3) => fromEffectContext(failCause(cause3));
var failCauseSync4 = (evaluate4) => fromEffectContext(failCauseSync(evaluate4));
var flatMap17 = dual(2, (self, f2) => match16(self, {
  onFailure: fail10,
  onSuccess: f2
}));
var flatten12 = dual(2, (self, tag5) => flatMap17(self, get4(tag5)));
var fresh = (self) => {
  const fresh3 = Object.create(proto3);
  fresh3._op_layer = OP_FRESH;
  fresh3.layer = self;
  return fresh3;
};
var fromEffect4 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag5 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return fromEffectContext(map14(effect4, (service4) => make8(tag5, service4)));
});
var fromEffectDiscard = (effect4) => fromEffectContext(map14(effect4, () => empty6()));
function fromEffectContext(effect4) {
  const fromEffect17 = Object.create(proto3);
  fromEffect17._op_layer = OP_FROM_EFFECT;
  fromEffect17.effect = effect4;
  return fromEffect17;
}
var fiberRefLocally2 = dual(3, (self, ref, value10) => locallyEffect(self, fiberRefLocally(ref, value10)));
var locallyEffect = dual(2, (self, f2) => {
  const locally5 = Object.create(proto3);
  locally5._op_layer = "Locally";
  locally5.self = self;
  locally5.f = f2;
  return locally5;
});
var fiberRefLocallyWith2 = dual(3, (self, ref, value10) => locallyEffect(self, fiberRefLocallyWith(ref, value10)));
var fiberRefLocallyScoped2 = (self, value10) => scopedDiscard(fiberRefLocallyScoped(self, value10));
var fiberRefLocallyScopedWith2 = (self, value10) => scopedDiscard(fiberRefLocallyScopedWith(self, value10));
var fromFunction = (tagA, tagB, f2) => fromEffectContext(map14(tagA, (a) => make8(tagB, f2(a))));
var launch = (self) => scopedEffect(zipRight2(scopeWith((scope6) => pipe(self, buildWithScope(scope6))), never));
var map24 = dual(2, (self, f2) => flatMap17(self, (context15) => succeedContext(f2(context15))));
var mapError4 = dual(2, (self, f2) => catchAll3(self, (error4) => failSync4(() => f2(error4))));
var matchCause3 = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  const fold3 = Object.create(proto3);
  fold3._op_layer = OP_FOLD;
  fold3.layer = self;
  fold3.failureK = onFailure;
  fold3.successK = onSuccess;
  return fold3;
});
var match16 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCause3(self, {
  onFailure: (cause3) => {
    const failureOrCause3 = failureOrCause2(cause3);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause8(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = (self) => scopeWith((scope6) => map14(memoize(buildWithScope(self, scope6)), fromEffectContext));
var merge6 = dual(2, (self, that) => zipWith10(self, that, (a, b) => merge3(a, b)));
var mergeAll4 = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
};
var orDie3 = (self) => catchAll3(self, (defect) => die7(defect));
var orElse7 = dual(2, (self, that) => catchAll3(self, that));
var passthrough = (self) => merge6(context4(), self);
var project = dual(4, (self, tagA, tagB, f2) => map24(self, (context15) => make8(tagB, f2(unsafeGet3(context15, tagA)))));
var retry2 = dual(2, (self, schedule4) => suspend3(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed10(stateTag, {
    state: schedule4.initial
  }), flatMap17((env) => retryLoop(self, schedule4, stateTag, pipe(env, get4(stateTag)).state)));
}));
var retryLoop = (self, schedule4, stateTag, state) => {
  return pipe(self, catchAll3((error4) => pipe(retryUpdate(schedule4, stateTag, error4, state), flatMap17((env) => fresh(retryLoop(self, schedule4, stateTag, pipe(env, get4(stateTag)).state))))));
};
var retryUpdate = (schedule4, stateTag, error4, state) => {
  return fromEffect4(stateTag, pipe(currentTimeMillis2, flatMap12((now3) => pipe(schedule4.step(now3, error4, state), flatMap12(([state2, _, decision]) => isDone5(decision) ? fail2(error4) : pipe(sleep2(millis(start2(decision.intervals) - now3)), as3({
    state: state2
  })))))));
};
var scoped3 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag5 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return scopedContext(map14(effect4, (service4) => make8(tag5, service4)));
});
var scopedDiscard = (effect4) => scopedContext(pipe(effect4, as3(empty6())));
var scopedContext = (effect4) => {
  const scoped10 = Object.create(proto3);
  scoped10._op_layer = OP_SCOPED;
  scoped10.effect = effect4;
  return scoped10;
};
var scope3 = scopedContext(map14(acquireRelease2(scopeMake2(), (scope6, exit4) => scope6.close(exit4)), (scope6) => make8(Scope, scope6)));
var service2 = (tag5) => fromEffect4(tag5, tag5);
var succeed10 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag5 = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make8(tag5, resource)));
});
var succeedContext = (context15) => {
  return fromEffectContext(succeed(context15));
};
var empty40 = succeedContext(empty6());
var suspend3 = (evaluate4) => {
  const suspend18 = Object.create(proto3);
  suspend18._op_layer = OP_SUSPEND;
  suspend18.evaluate = evaluate4;
  return suspend18;
};
var sync6 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag5 = tagFirst ? a : b;
  const evaluate4 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make8(tag5, evaluate4())));
});
var syncContext = (evaluate4) => {
  return fromEffectContext(sync(evaluate4));
};
var tap4 = dual(2, (self, f2) => flatMap17(self, (context15) => fromEffectContext(as3(f2(context15), context15))));
var tapError3 = dual(2, (self, f2) => catchAll3(self, (e) => fromEffectContext(flatMap12(f2(e), () => fail2(e)))));
var tapErrorCause3 = dual(2, (self, f2) => catchAllCause3(self, (cause3) => fromEffectContext(flatMap12(f2(cause3), () => failCause(cause3)))));
var toRuntime = (self) => pipe(scopeWith((scope6) => buildWithScope(self, scope6)), flatMap12((context15) => pipe(runtime3(), provideContext(context15))));
var toRuntimeWithMemoMap = dual(2, (self, memoMap) => flatMap12(scopeWith((scope6) => buildWithMemoMap(self, memoMap, scope6)), (context15) => pipe(runtime3(), provideContext(context15))));
var provide = dual(2, (self, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context4(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll4(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideMerge = dual(2, (that, self) => {
  const zipWith23 = Object.create(proto3);
  zipWith23._op_layer = OP_PROVIDE_MERGE;
  zipWith23.first = self;
  zipWith23.second = provide(that, self);
  zipWith23.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith23;
});
var zipWith10 = dual(3, (self, that, f2) => suspend3(() => {
  const zipWith23 = Object.create(proto3);
  zipWith23._op_layer = OP_ZIP_WITH2;
  zipWith23.first = self;
  zipWith23.second = that;
  zipWith23.zipK = f2;
  return zipWith23;
}));
var unwrapEffect = (self) => {
  const tag5 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap17(fromEffect4(tag5, self), (context15) => get4(context15, tag5));
};
var unwrapScoped = (self) => {
  const tag5 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap17(scoped3(tag5, self), (context15) => get4(context15, tag5));
};
var annotateLogs2 = dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations4) => Object.entries(args2[1]).reduce((acc, [key, value10]) => set4(acc, key, value10), annotations4));
});
var annotateSpans2 = dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations4) => Object.entries(args2[1]).reduce((acc, [key, value10]) => set4(acc, key, value10), annotations4));
});
var withSpan2 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return unwrapScoped(map14((options == null ? void 0 : options.onEnd) ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer2((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self, span4)));
  }
  return (self) => unwrapScoped(map14((options == null ? void 0 : options.onEnd) ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer2((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self, span4)));
};
var withParentSpan2 = dual(2, (self, span4) => provide(self, succeedContext(make8(spanTag, span4))));
var provideSomeLayer = dual(2, (self, layer) => scopedWith((scope6) => flatMap12(buildWithScope(layer, scope6), (context15) => provideSomeContext(self, context15))));
var provideSomeRuntime = dual(2, (self, rt) => {
  const patchRefs = diff9(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff7(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch7(patchFlags)(oldFlags);
    const rollbackRefs = diff9(newRefs, oldRefs);
    const rollbackFlags = diff7(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring2(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch7(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_3;
    }));
  }));
});
var effect_provide = dual(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self, mergeAll4(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self, source);
  } else if (TypeId19 in source) {
    return flatMap12(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
  } else {
    return provideSomeRuntime(self, source);
  }
});

// node_modules/effect/dist/esm/internal/console.js
var console2 = map14(fiberRefGet(currentServices), get4(consoleTag));
var consoleWith = (f2) => fiberRefGetWith(currentServices, (services) => f2(get4(services, consoleTag)));
var withConsole = dual(2, (effect4, value10) => fiberRefLocallyWith(effect4, currentServices, add3(consoleTag, value10)));
var withConsoleScoped = (console4) => fiberRefLocallyScopedWith(currentServices, add3(consoleTag, console4));
var setConsole = (console4) => scopedDiscard(fiberRefLocallyScopedWith(currentServices, add3(consoleTag, console4)));
var assert2 = (condition, ...args2) => consoleWith((_) => _.assert(condition, ...args2));
var clear2 = consoleWith((_) => _.clear);
var count = (label) => consoleWith((_) => _.count(label));
var countReset = (label) => consoleWith((_) => _.countReset(label));
var debug = (...args2) => consoleWith((_) => _.debug(...args2));
var dir = (item, options) => consoleWith((_) => _.dir(item, options));
var dirxml = (...args2) => consoleWith((_) => _.dirxml(...args2));
var error2 = (...args2) => consoleWith((_) => _.error(...args2));
var group3 = (options) => consoleWith((_) => acquireRelease2(_.group(options), () => _.groupEnd));
var info = (...args2) => consoleWith((_) => _.info(...args2));
var log2 = (...args2) => consoleWith((_) => _.log(...args2));
var table = (tabularData, properties) => consoleWith((_) => _.table(tabularData, properties));
var time = (label) => consoleWith((_) => acquireRelease2(_.time(label), () => _.timeEnd(label)));
var timeLog = (label, ...args2) => consoleWith((_) => _.timeLog(label, ...args2));
var trace = (...args2) => consoleWith((_) => _.trace(...args2));
var warn = (...args2) => consoleWith((_) => _.warn(...args2));
var withGroup = dual((args2) => isEffect(args2[0]), (self, options) => consoleWith((_) => acquireUseRelease(_.group(options), () => self, () => _.groupEnd)));
var withTime = dual((args2) => isEffect(args2[0]), (self, label) => consoleWith((_) => acquireUseRelease(_.time(label), () => self, () => _.timeEnd(label))));

// node_modules/effect/dist/esm/Cron.js
var Cron_exports = {};
__export(Cron_exports, {
  Equivalence: () => Equivalence8,
  ParseError: () => ParseError,
  ParseErrorTypeId: () => ParseErrorTypeId,
  TypeId: () => TypeId21,
  equals: () => equals5,
  isCron: () => isCron,
  isParseError: () => isParseError,
  make: () => make58,
  match: () => match19,
  next: () => next2,
  parse: () => parse2,
  sequence: () => sequence,
  unsafeParse: () => unsafeParse
});

// node_modules/effect/dist/esm/Data.js
var Data_exports = {};
__export(Data_exports, {
  Class: () => Class5,
  Error: () => Error4,
  Structural: () => Structural2,
  TaggedClass: () => TaggedClass2,
  TaggedError: () => TaggedError2,
  array: () => array5,
  case: () => _case,
  struct: () => struct5,
  tagged: () => tagged4,
  taggedEnum: () => taggedEnum,
  tuple: () => tuple5,
  unsafeArray: () => unsafeArray,
  unsafeStruct: () => unsafeStruct
});
var struct5 = struct4;
var unsafeStruct = (as18) => Object.setPrototypeOf(as18, StructuralPrototype);
var tuple5 = (...as18) => unsafeArray(as18);
var array5 = (as18) => unsafeArray(as18.slice(0));
var unsafeArray = (as18) => Object.setPrototypeOf(as18, ArrayProto);
var _case = () => (args2) => args2 === void 0 ? Object.create(StructuralPrototype) : struct5(args2);
var tagged4 = (tag5) => (args2) => {
  const value10 = args2 === void 0 ? Object.create(StructuralPrototype) : struct5(args2);
  value10._tag = tag5;
  return value10;
};
var Class5 = Structural;
var TaggedClass2 = (tag5) => {
  class Base4 extends Class5 {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag5);
    }
  }
  return Base4;
};
var Structural2 = Structural;
var taggedEnum = () => new Proxy({}, {
  get(_target, tag5, _receiver) {
    if (tag5 === "$is") {
      return isTagged;
    } else if (tag5 === "$match") {
      return taggedMatch;
    }
    return tagged4(tag5);
  }
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value11) {
      return cases2[value11._tag](value11);
    };
  }
  const value10 = arguments[0];
  const cases = arguments[1];
  return cases[value10._tag](value10);
}
var Error4 = function() {
  const plainArgsSymbol = Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2 == null ? void 0 : args2.message, (args2 == null ? void 0 : args2.cause) ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError2 = (tag5) => {
  const O = {
    BaseEffectError: class extends Error4 {
      constructor() {
        super(...arguments);
        __publicField(this, "_tag", tag5);
      }
    }
  };
  O.BaseEffectError.prototype.name = tag5;
  return O.BaseEffectError;
};

// node_modules/effect/dist/esm/internal/dateTime.js
var TypeId20 = Symbol.for("effect/DateTime");
var TimeZoneTypeId = Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId20]: TypeId20,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol2]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol3](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol2]() {
    return pipe(number2(this.epochMillis), combine2(hash(this.zone)), cached(this));
  },
  [symbol3](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol2]() {
    return cached(this, string2(`Named:${this.id}`));
  },
  [symbol3](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol2]() {
    return cached(this, string2(`Offset:${this.offset}`));
  },
  [symbol3](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var makeZonedProto = (epochMillis, zone, partsUtc) => {
  const self = Object.create(ProtoZoned);
  self.epochMillis = epochMillis;
  self.zone = zone;
  Object.defineProperty(self, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "adjustedEpochMillis", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "partsAdjusted", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self;
};
var isDateTime = (u) => hasProperty(u, TypeId20);
var isDateTimeArgs = (args2) => isDateTime(args2[0]);
var isTimeZone = (u) => hasProperty(u, TimeZoneTypeId);
var isTimeZoneOffset = (u) => isTimeZone(u) && u._tag === "Offset";
var isTimeZoneNamed = (u) => isTimeZone(u) && u._tag === "Named";
var isUtc = (self) => self._tag === "Utc";
var isZoned = (self) => self._tag === "Zoned";
var Equivalence6 = make((a, b) => a.epochMillis === b.epochMillis);
var Order9 = make2((self, that) => self.epochMillis < that.epochMillis ? -1 : self.epochMillis > that.epochMillis ? 1 : 0);
var clamp7 = clamp(Order9);
var makeUtc = (epochMillis) => {
  const self = Object.create(ProtoUtc);
  self.epochMillis = epochMillis;
  Object.defineProperty(self, "partsUtc", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self;
};
var unsafeFromDate = (date5) => {
  const epochMillis = date5.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new IllegalArgumentException2("Invalid date");
  }
  return makeUtc(epochMillis);
};
var unsafeMake11 = (input) => {
  if (isDateTime(input)) {
    return input;
  } else if (input instanceof Date) {
    return unsafeFromDate(input);
  } else if (typeof input === "object") {
    const date5 = /* @__PURE__ */ new Date(0);
    setPartsDate(date5, input);
    return unsafeFromDate(date5);
  } else if (typeof input === "string" && !hasZone(input)) {
    return unsafeFromDate(/* @__PURE__ */ new Date(input + "Z"));
  }
  return unsafeFromDate(new Date(input));
};
var hasZone = (input) => /Z|[+-]\d{2}$|[+-]\d{2}:?\d{2}$|\]$/.test(input);
var minEpochMillis = -864e13 + 12 * 60 * 60 * 1e3;
var maxEpochMillis = 864e13 - 14 * 60 * 60 * 1e3;
var unsafeMakeZoned = (input, options) => {
  if ((options == null ? void 0 : options.timeZone) === void 0 && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self = unsafeMake11(input);
  if (self.epochMillis < minEpochMillis || self.epochMillis > maxEpochMillis) {
    throw new IllegalArgumentException2(`Epoch millis out of range: ${self.epochMillis}`);
  }
  let zone;
  if ((options == null ? void 0 : options.timeZone) === void 0) {
    const offset = new Date(self.epochMillis).getTimezoneOffset() * -60 * 1e3;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options == null ? void 0 : options.timeZone)) {
    zone = options.timeZone;
  } else if (typeof (options == null ? void 0 : options.timeZone) === "number") {
    zone = zoneMakeOffset(options.timeZone);
  } else {
    const parsedZone = zoneFromString(options.timeZone);
    if (isNone2(parsedZone)) {
      throw new IllegalArgumentException2(`Invalid time zone: ${options.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if ((options == null ? void 0 : options.adjustForTimeZone) !== true) {
    return makeZonedProto(self.epochMillis, zone, self.partsUtc);
  }
  return makeZonedFromAdjusted(self.epochMillis, zone);
};
var makeZoned = liftThrowable(unsafeMakeZoned);
var make57 = liftThrowable(unsafeMake11);
var zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
var makeZonedFromString = (input) => {
  const match43 = zonedStringRegex.exec(input);
  if (match43 === null) {
    const offset = parseOffset(input);
    return offset !== null ? makeZoned(input, {
      timeZone: offset
    }) : none2();
  }
  const [, isoString, timeZone] = match43;
  return makeZoned(isoString, {
    timeZone
  });
};
var now = map14(currentTimeMillis2, makeUtc);
var nowAsDate = map14(currentTimeMillis2, (millis2) => new Date(millis2));
var unsafeNow = () => makeUtc(Date.now());
var toUtc = (self) => makeUtc(self.epochMillis);
var setZone = dual(isDateTimeArgs, (self, zone, options) => (options == null ? void 0 : options.adjustForTimeZone) === true ? makeZonedFromAdjusted(self.epochMillis, zone) : makeZonedProto(self.epochMillis, zone, self.partsUtc));
var setZoneOffset = dual(isDateTimeArgs, (self, offset, options) => setZone(self, zoneMakeOffset(offset), options));
var validZoneCache = globalValue("effect/DateTime/validZoneCache", () => /* @__PURE__ */ new Map());
var formatOptions = {
  day: "numeric",
  month: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZoneName: "longOffset",
  fractionalSecondDigits: 3,
  hourCycle: "h23"
};
var zoneMakeIntl = (format16) => {
  const zoneId = format16.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format16;
  validZoneCache.set(zoneId, zone);
  return zone;
};
var zoneUnsafeMakeNamed = (zoneId) => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
  }
};
var zoneMakeOffset = (offset) => {
  const zone = Object.create(ProtoTimeZoneOffset);
  zone.offset = offset;
  return zone;
};
var zoneMakeNamed = liftThrowable(zoneUnsafeMakeNamed);
var zoneMakeNamedEffect = (zoneId) => try_2({
  try: () => zoneUnsafeMakeNamed(zoneId),
  catch: (e) => e
});
var zoneMakeLocal = () => zoneMakeIntl(new Intl.DateTimeFormat("en-US", formatOptions));
var offsetZoneRegex = /^(?:GMT|[+-])/;
var zoneFromString = (zone) => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? none2() : some3(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
};
var zoneToString = (self) => {
  if (self._tag === "Offset") {
    return offsetToString(self.offset);
  }
  return self.id;
};
var setZoneNamed = dual(isDateTimeArgs, (self, zoneId, options) => map2(zoneMakeNamed(zoneId), (zone) => setZone(self, zone, options)));
var unsafeSetZoneNamed = dual(isDateTimeArgs, (self, zoneId, options) => setZone(self, zoneUnsafeMakeNamed(zoneId), options));
var distance = dual(2, (self, other) => toEpochMillis(other) - toEpochMillis(self));
var distanceDurationEither = dual(2, (self, other) => {
  const diffMillis = distance(self, other);
  return diffMillis > 0 ? right2(millis(diffMillis)) : left2(millis(-diffMillis));
});
var distanceDuration = dual(2, (self, other) => millis(Math.abs(distance(self, other))));
var min9 = min(Order9);
var max11 = max(Order9);
var greaterThan9 = greaterThan(Order9);
var greaterThanOrEqualTo6 = greaterThanOrEqualTo(Order9);
var lessThan13 = lessThan(Order9);
var lessThanOrEqualTo6 = lessThanOrEqualTo(Order9);
var between6 = between(Order9);
var isFuture = (self) => map14(now, lessThan13(self));
var unsafeIsFuture = (self) => lessThan13(unsafeNow(), self);
var isPast = (self) => map14(now, greaterThan9(self));
var unsafeIsPast = (self) => greaterThan9(unsafeNow(), self);
var toDateUtc = (self) => new Date(self.epochMillis);
var toDate = (self) => {
  if (self._tag === "Utc") {
    return new Date(self.epochMillis);
  } else if (self.zone._tag === "Offset") {
    return new Date(self.epochMillis + self.zone.offset);
  } else if (self.adjustedEpochMillis !== void 0) {
    return new Date(self.adjustedEpochMillis);
  }
  const parts2 = self.zone.format.formatToParts(self.epochMillis).filter((_) => _.type !== "literal");
  const date5 = /* @__PURE__ */ new Date(0);
  date5.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date5.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self.adjustedEpochMillis = date5.getTime();
  return date5;
};
var zonedOffset = (self) => {
  const date5 = toDate(self);
  return date5.getTime() - toEpochMillis(self);
};
var offsetToString = (offset) => {
  const abs3 = Math.abs(offset);
  let hours2 = Math.floor(abs3 / (60 * 60 * 1e3));
  let minutes2 = Math.round(abs3 % (60 * 60 * 1e3) / (60 * 1e3));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
};
var zonedOffsetIso = (self) => offsetToString(zonedOffset(self));
var toEpochMillis = (self) => self.epochMillis;
var removeTime = (self) => withDate(self, (date5) => {
  date5.setUTCHours(0, 0, 0, 0);
  return makeUtc(date5.getTime());
});
var dateToParts = (date5) => ({
  millis: date5.getUTCMilliseconds(),
  seconds: date5.getUTCSeconds(),
  minutes: date5.getUTCMinutes(),
  hours: date5.getUTCHours(),
  day: date5.getUTCDate(),
  weekDay: date5.getUTCDay(),
  month: date5.getUTCMonth() + 1,
  year: date5.getUTCFullYear()
});
var toParts = (self) => {
  if (self._tag === "Utc") {
    return toPartsUtc(self);
  } else if (self.partsAdjusted !== void 0) {
    return self.partsAdjusted;
  }
  self.partsAdjusted = withDate(self, dateToParts);
  return self.partsAdjusted;
};
var toPartsUtc = (self) => {
  if (self.partsUtc !== void 0) {
    return self.partsUtc;
  }
  self.partsUtc = withDateUtc(self, dateToParts);
  return self.partsUtc;
};
var getPartUtc = dual(2, (self, part) => toPartsUtc(self)[part]);
var getPart = dual(2, (self, part) => toParts(self)[part]);
var setPartsDate = (date5, parts2) => {
  if (parts2.year !== void 0) {
    date5.setUTCFullYear(parts2.year);
  }
  if (parts2.month !== void 0) {
    date5.setUTCMonth(parts2.month - 1);
  }
  if (parts2.day !== void 0) {
    date5.setUTCDate(parts2.day);
  }
  if (parts2.weekDay !== void 0) {
    const diff13 = parts2.weekDay - date5.getUTCDay();
    date5.setUTCDate(date5.getUTCDate() + diff13);
  }
  if (parts2.hours !== void 0) {
    date5.setUTCHours(parts2.hours);
  }
  if (parts2.minutes !== void 0) {
    date5.setUTCMinutes(parts2.minutes);
  }
  if (parts2.seconds !== void 0) {
    date5.setUTCSeconds(parts2.seconds);
  }
  if (parts2.millis !== void 0) {
    date5.setUTCMilliseconds(parts2.millis);
  }
};
var setParts = dual(2, (self, parts2) => mutate5(self, (date5) => setPartsDate(date5, parts2)));
var setPartsUtc = dual(2, (self, parts2) => mutateUtc(self, (date5) => setPartsDate(date5, parts2)));
var makeZonedFromAdjusted = (adjustedMillis, zone) => {
  const offset = zone._tag === "Offset" ? zone.offset : calculateNamedOffset(adjustedMillis, zone);
  return makeZonedProto(adjustedMillis - offset, zone);
};
var offsetRegex = /([+-])(\d{2}):(\d{2})$/;
var parseOffset = (offset) => {
  const match43 = offsetRegex.exec(offset);
  if (match43 === null) {
    return null;
  }
  const [, sign10, hours2, minutes2] = match43;
  return (sign10 === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1e3;
};
var calculateNamedOffset = (adjustedMillis, zone) => {
  var _a106;
  const offset = ((_a106 = zone.format.formatToParts(adjustedMillis).find((_) => _.type === "timeZoneName")) == null ? void 0 : _a106.value) ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
};
var mutate5 = dual(2, (self, f2) => {
  if (self._tag === "Utc") {
    const date5 = toDateUtc(self);
    f2(date5);
    return makeUtc(date5.getTime());
  }
  const adjustedDate = toDate(self);
  const newAdjustedDate = new Date(adjustedDate.getTime());
  f2(newAdjustedDate);
  return makeZonedFromAdjusted(newAdjustedDate.getTime(), self.zone);
});
var mutateUtc = dual(2, (self, f2) => mapEpochMillis(self, (millis2) => {
  const date5 = new Date(millis2);
  f2(date5);
  return date5.getTime();
}));
var mapEpochMillis = dual(2, (self, f2) => {
  const millis2 = f2(toEpochMillis(self));
  return self._tag === "Utc" ? makeUtc(millis2) : makeZonedProto(millis2, self.zone);
});
var withDate = dual(2, (self, f2) => f2(toDate(self)));
var withDateUtc = dual(2, (self, f2) => f2(toDateUtc(self)));
var match17 = dual(2, (self, options) => self._tag === "Utc" ? options.onUtc(self) : options.onZoned(self));
var addDuration = dual(2, (self, duration5) => mapEpochMillis(self, (millis2) => millis2 + toMillis(duration5)));
var subtractDuration = dual(2, (self, duration5) => mapEpochMillis(self, (millis2) => millis2 - toMillis(duration5)));
var addMillis = (date5, amount) => {
  date5.setTime(date5.getTime() + amount);
};
var add7 = dual(2, (self, parts2) => mutate5(self, (date5) => {
  if (parts2.millis) {
    addMillis(date5, parts2.millis);
  }
  if (parts2.seconds) {
    addMillis(date5, parts2.seconds * 1e3);
  }
  if (parts2.minutes) {
    addMillis(date5, parts2.minutes * 60 * 1e3);
  }
  if (parts2.hours) {
    addMillis(date5, parts2.hours * 60 * 60 * 1e3);
  }
  if (parts2.days) {
    date5.setUTCDate(date5.getUTCDate() + parts2.days);
  }
  if (parts2.weeks) {
    date5.setUTCDate(date5.getUTCDate() + parts2.weeks * 7);
  }
  if (parts2.months) {
    const day = date5.getUTCDate();
    date5.setUTCMonth(date5.getUTCMonth() + parts2.months + 1, 0);
    if (day < date5.getUTCDate()) {
      date5.setUTCDate(day);
    }
  }
  if (parts2.years) {
    const day = date5.getUTCDate();
    const month = date5.getUTCMonth();
    date5.setUTCFullYear(date5.getUTCFullYear() + parts2.years, month + 1, 0);
    if (day < date5.getUTCDate()) {
      date5.setUTCDate(day);
    }
  }
}));
var subtract5 = dual(2, (self, parts2) => {
  const newParts = {};
  for (const key in parts2) {
    newParts[key] = -1 * parts2[key];
  }
  return add7(self, newParts);
});
var startOfDate = (date5, part, options) => {
  switch (part) {
    case "second": {
      date5.setUTCMilliseconds(0);
      break;
    }
    case "minute": {
      date5.setUTCSeconds(0, 0);
      break;
    }
    case "hour": {
      date5.setUTCMinutes(0, 0, 0);
      break;
    }
    case "day": {
      date5.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "week": {
      const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? 0;
      const day = date5.getUTCDay();
      const diff13 = (day - weekStartsOn + 7) % 7;
      date5.setUTCDate(date5.getUTCDate() - diff13);
      date5.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "month": {
      date5.setUTCDate(1);
      date5.setUTCHours(0, 0, 0, 0);
      break;
    }
    case "year": {
      date5.setUTCMonth(0, 1);
      date5.setUTCHours(0, 0, 0, 0);
      break;
    }
  }
};
var startOf = dual(isDateTimeArgs, (self, part, options) => mutate5(self, (date5) => startOfDate(date5, part, options)));
var endOfDate = (date5, part, options) => {
  switch (part) {
    case "second": {
      date5.setUTCMilliseconds(999);
      break;
    }
    case "minute": {
      date5.setUTCSeconds(59, 999);
      break;
    }
    case "hour": {
      date5.setUTCMinutes(59, 59, 999);
      break;
    }
    case "day": {
      date5.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "week": {
      const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? 0;
      const day = date5.getUTCDay();
      const diff13 = (day - weekStartsOn + 7) % 7;
      date5.setUTCDate(date5.getUTCDate() - diff13 + 6);
      date5.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "month": {
      date5.setUTCMonth(date5.getUTCMonth() + 1, 0);
      date5.setUTCHours(23, 59, 59, 999);
      break;
    }
    case "year": {
      date5.setUTCMonth(11, 31);
      date5.setUTCHours(23, 59, 59, 999);
      break;
    }
  }
};
var endOf = dual(isDateTimeArgs, (self, part, options) => mutate5(self, (date5) => endOfDate(date5, part, options)));
var nearest = dual(isDateTimeArgs, (self, part, options) => mutate5(self, (date5) => {
  if (part === "milli") return;
  const millis2 = date5.getTime();
  const start5 = new Date(millis2);
  startOfDate(start5, part, options);
  const startMillis = start5.getTime();
  const end7 = new Date(millis2);
  endOfDate(end7, part, options);
  const endMillis = end7.getTime() + 1;
  const diffStart = millis2 - startMillis;
  const diffEnd = endMillis - millis2;
  if (diffStart < diffEnd) {
    date5.setTime(startMillis);
  } else {
    date5.setTime(endMillis);
  }
}));
var intlTimeZone = (self) => {
  if (self._tag === "Named") {
    return self.id;
  }
  return offsetToString(self.offset);
};
var format5 = dual(isDateTimeArgs, (self, options) => {
  try {
    return new Intl.DateTimeFormat(options == null ? void 0 : options.locale, {
      timeZone: self._tag === "Utc" ? "UTC" : intlTimeZone(self.zone),
      ...options
    }).format(self.epochMillis);
  } catch {
    return new Intl.DateTimeFormat(options == null ? void 0 : options.locale, {
      timeZone: "UTC",
      ...options
    }).format(toDate(self));
  }
});
var formatLocal = dual(isDateTimeArgs, (self, options) => new Intl.DateTimeFormat(options == null ? void 0 : options.locale, options).format(self.epochMillis));
var formatUtc = dual(isDateTimeArgs, (self, options) => new Intl.DateTimeFormat(options == null ? void 0 : options.locale, {
  ...options,
  timeZone: "UTC"
}).format(self.epochMillis));
var formatIntl = dual(2, (self, format16) => format16.format(self.epochMillis));
var formatIso2 = (self) => toDateUtc(self).toISOString();
var formatIsoDate = (self) => toDate(self).toISOString().slice(0, 10);
var formatIsoDateUtc = (self) => toDateUtc(self).toISOString().slice(0, 10);
var formatIsoOffset = (self) => {
  const date5 = toDate(self);
  return self._tag === "Utc" ? date5.toISOString() : `${date5.toISOString().slice(0, -1)}${zonedOffsetIso(self)}`;
};
var formatIsoZoned = (self) => self.zone._tag === "Offset" ? formatIsoOffset(self) : `${formatIsoOffset(self)}[${self.zone.id}]`;

// node_modules/effect/dist/esm/String.js
var String_exports = {};
__export(String_exports, {
  Equivalence: () => Equivalence7,
  Order: () => Order10,
  at: () => at4,
  camelToSnake: () => camelToSnake,
  capitalize: () => capitalize,
  charAt: () => charAt,
  charCodeAt: () => charCodeAt,
  codePointAt: () => codePointAt,
  concat: () => concat5,
  empty: () => empty41,
  endsWith: () => endsWith,
  includes: () => includes2,
  indexOf: () => indexOf,
  isEmpty: () => isEmpty14,
  isNonEmpty: () => isNonEmpty7,
  isString: () => isString2,
  kebabToSnake: () => kebabToSnake,
  lastIndexOf: () => lastIndexOf,
  length: () => length4,
  linesIterator: () => linesIterator,
  linesWithSeparators: () => linesWithSeparators,
  localeCompare: () => localeCompare,
  match: () => match18,
  matchAll: () => matchAll,
  normalize: () => normalize2,
  padEnd: () => padEnd,
  padStart: () => padStart,
  pascalToSnake: () => pascalToSnake,
  repeat: () => repeat2,
  replace: () => replace5,
  replaceAll: () => replaceAll,
  search: () => search,
  slice: () => slice4,
  snakeToCamel: () => snakeToCamel,
  snakeToKebab: () => snakeToKebab,
  snakeToPascal: () => snakeToPascal,
  split: () => split3,
  startsWith: () => startsWith,
  stripMargin: () => stripMargin,
  stripMarginWith: () => stripMarginWith,
  substring: () => substring,
  takeLeft: () => takeLeft,
  takeRight: () => takeRight3,
  toLocaleLowerCase: () => toLocaleLowerCase,
  toLocaleUpperCase: () => toLocaleUpperCase,
  toLowerCase: () => toLowerCase,
  toUpperCase: () => toUpperCase,
  trim: () => trim2,
  trimEnd: () => trimEnd,
  trimStart: () => trimStart,
  uncapitalize: () => uncapitalize
});
var isString2 = isString;
var Equivalence7 = string;
var Order10 = string3;
var empty41 = "";
var concat5 = dual(2, (self, that) => self + that);
var toUpperCase = (self) => self.toUpperCase();
var toLowerCase = (self) => self.toLowerCase();
var capitalize = (self) => {
  if (self.length === 0) return self;
  return toUpperCase(self[0]) + self.slice(1);
};
var uncapitalize = (self) => {
  if (self.length === 0) return self;
  return toLowerCase(self[0]) + self.slice(1);
};
var replace5 = (searchValue, replaceValue) => (self) => self.replace(searchValue, replaceValue);
var trim2 = (self) => self.trim();
var trimStart = (self) => self.trimStart();
var trimEnd = (self) => self.trimEnd();
var slice4 = (start5, end7) => (self) => self.slice(start5, end7);
var isEmpty14 = (self) => self.length === 0;
var isNonEmpty7 = (self) => self.length > 0;
var length4 = (self) => self.length;
var split3 = dual(2, (self, separator) => {
  const out = self.split(separator);
  return isNonEmptyArray(out) ? out : [self];
});
var includes2 = (searchString, position) => (self) => self.includes(searchString, position);
var startsWith = (searchString, position) => (self) => self.startsWith(searchString, position);
var endsWith = (searchString, position) => (self) => self.endsWith(searchString, position);
var charCodeAt = dual(2, (self, index3) => filter(some3(self.charCodeAt(index3)), (charCode) => !isNaN(charCode)));
var substring = (start5, end7) => (self) => self.substring(start5, end7);
var at4 = dual(2, (self, index3) => fromNullable2(self.at(index3)));
var charAt = dual(2, (self, index3) => filter(some3(self.charAt(index3)), isNonEmpty7));
var codePointAt = dual(2, (self, index3) => fromNullable2(self.codePointAt(index3)));
var indexOf = (searchString) => (self) => filter(some3(self.indexOf(searchString)), greaterThanOrEqualTo2(0));
var lastIndexOf = (searchString) => (self) => filter(some3(self.lastIndexOf(searchString)), greaterThanOrEqualTo2(0));
var localeCompare = (that, locales, options) => (self) => sign(self.localeCompare(that, locales, options));
var match18 = (regexp) => (self) => fromNullable2(self.match(regexp));
var matchAll = (regexp) => (self) => self.matchAll(regexp);
var normalize2 = (form) => (self) => self.normalize(form);
var padEnd = (maxLength2, fillString) => (self) => self.padEnd(maxLength2, fillString);
var padStart = (maxLength2, fillString) => (self) => self.padStart(maxLength2, fillString);
var repeat2 = (count9) => (self) => self.repeat(count9);
var replaceAll = (searchValue, replaceValue) => (self) => self.replaceAll(searchValue, replaceValue);
var search = dual(2, (self, regexp) => filter(some3(self.search(regexp)), greaterThanOrEqualTo2(0)));
var toLocaleLowerCase = (locale) => (self) => self.toLocaleLowerCase(locale);
var toLocaleUpperCase = (locale) => (self) => self.toLocaleUpperCase(locale);
var takeLeft = dual(2, (self, n) => self.slice(0, Math.max(n, 0)));
var takeRight3 = dual(2, (self, n) => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));
var CR = 13;
var LF = 10;
var linesIterator = (self) => linesSeparated(self, true);
var linesWithSeparators = (s) => linesSeparated(s, false);
var stripMarginWith = dual(2, (self, marginChar) => {
  let out = "";
  for (const line of linesWithSeparators(self)) {
    let index3 = 0;
    while (index3 < line.length && line.charAt(index3) <= " ") {
      index3 = index3 + 1;
    }
    const stripped = index3 < line.length && line.charAt(index3) === marginChar ? line.substring(index3 + 1) : line;
    out = out + stripped;
  }
  return out;
});
var stripMargin = (self) => stripMarginWith(self, "|");
var snakeToCamel = (self) => {
  let str = self[0];
  for (let i = 1; i < self.length; i++) {
    str += self[i] === "_" ? self[++i].toUpperCase() : self[i];
  }
  return str;
};
var snakeToPascal = (self) => {
  let str = self[0].toUpperCase();
  for (let i = 1; i < self.length; i++) {
    str += self[i] === "_" ? self[++i].toUpperCase() : self[i];
  }
  return str;
};
var snakeToKebab = (self) => self.replace(/_/g, "-");
var camelToSnake = (self) => self.replace(/([A-Z])/g, "_$1").toLowerCase();
var pascalToSnake = (self) => (self.slice(0, 1) + self.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var kebabToSnake = (self) => self.replace(/-/g, "_");
var LinesIterator = class _LinesIterator {
  constructor(s, stripped = false) {
    __publicField(this, "s");
    __publicField(this, "stripped");
    __publicField(this, "index");
    __publicField(this, "length");
    this.s = s;
    this.stripped = stripped;
    this.index = 0;
    this.length = s.length;
  }
  next() {
    if (this.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const start5 = this.index;
    while (!this.done && !isLineBreak(this.s[this.index])) {
      this.index = this.index + 1;
    }
    let end7 = this.index;
    if (!this.done) {
      const char2 = this.s[this.index];
      this.index = this.index + 1;
      if (!this.done && isLineBreak2(char2, this.s[this.index])) {
        this.index = this.index + 1;
      }
      if (!this.stripped) {
        end7 = this.index;
      }
    }
    return {
      done: false,
      value: this.s.substring(start5, end7)
    };
  }
  [Symbol.iterator]() {
    return new _LinesIterator(this.s, this.stripped);
  }
  get done() {
    return this.index >= this.length;
  }
};
var isLineBreak = (char2) => {
  const code = char2.charCodeAt(0);
  return code === CR || code === LF;
};
var isLineBreak2 = (char0, char1) => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF;
var linesSeparated = (self, stripped) => new LinesIterator(self, stripped);

// node_modules/effect/dist/esm/Cron.js
var TypeId21 = Symbol.for("effect/Cron");
var CronProto = {
  [TypeId21]: TypeId21,
  [symbol3](that) {
    return isCron(that) && equals5(this, that);
  },
  [symbol2]() {
    return pipe(hash(this.tz), combine2(array2(fromIterable2(this.seconds))), combine2(array2(fromIterable2(this.minutes))), combine2(array2(fromIterable2(this.hours))), combine2(array2(fromIterable2(this.days))), combine2(array2(fromIterable2(this.months))), combine2(array2(fromIterable2(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable2(this.seconds),
      minutes: fromIterable2(this.minutes),
      hours: fromIterable2(this.hours),
      days: fromIterable2(this.days),
      months: fromIterable2(this.months),
      weekdays: fromIterable2(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u) => hasProperty(u, TypeId21);
var make58 = (values15) => {
  const o = Object.create(CronProto);
  o.seconds = new Set(sort(values15.seconds ?? [0], Order));
  o.minutes = new Set(sort(values15.minutes, Order));
  o.hours = new Set(sort(values15.hours, Order));
  o.days = new Set(sort(values15.days, Order));
  o.months = new Set(sort(values15.months, Order));
  o.weekdays = new Set(sort(values15.weekdays, Order));
  o.tz = fromNullable2(values15.tz);
  const seconds2 = Array.from(o.seconds);
  const minutes2 = Array.from(o.minutes);
  const hours2 = Array.from(o.hours);
  const days2 = Array.from(o.days);
  const months = Array.from(o.months);
  const weekdays = Array.from(o.weekdays);
  o.first = {
    second: seconds2[0] ?? 0,
    minute: minutes2[0] ?? 0,
    hour: hours2[0] ?? 0,
    day: days2[0] ?? 1,
    month: (months[0] ?? 1) - 1,
    weekday: weekdays[0] ?? 0
  };
  o.next = {
    second: nextLookupTable(seconds2, 60),
    minute: nextLookupTable(minutes2, 60),
    hour: nextLookupTable(hours2, 24),
    day: nextLookupTable(days2, 32),
    month: nextLookupTable(months, 13),
    weekday: nextLookupTable(weekdays, 7)
  };
  return o;
};
var nextLookupTable = (values15, size45) => {
  const result = new Array(size45).fill(void 0);
  if (values15.length === 0) {
    return result;
  }
  let current2 = void 0;
  let index3 = values15.length - 1;
  for (let i = size45 - 1; i >= 0; i--) {
    while (index3 >= 0 && values15[index3] >= i) {
      current2 = values15[index3--];
    }
    result[i] = current2;
  }
  return result;
};
var ParseErrorTypeId = Symbol.for("effect/Cron/errors/ParseError");
var _a51, _b16;
var ParseError = class extends (_b16 = TaggedError2("CronParseError"), _a51 = ParseErrorTypeId, _b16) {
  constructor() {
    super(...arguments);
    /**
     * @since 2.0.0
     */
    __publicField(this, _a51, ParseErrorTypeId);
  }
};
var isParseError = (u) => hasProperty(u, ParseErrorTypeId);
var parse2 = (cron3, tz) => {
  const segments = cron3.split(" ").filter(isNonEmpty7);
  if (segments.length !== 5 && segments.length !== 6) {
    return left2(new ParseError({
      message: `Invalid number of segments in cron expression`,
      input: cron3
    }));
  }
  if (segments.length === 5) {
    segments.unshift("0");
  }
  const [seconds2, minutes2, hours2, days2, months, weekdays] = segments;
  const zone = tz === void 0 || isTimeZone(tz) ? right2(tz) : fromOption2(zoneFromString(tz), () => new ParseError({
    message: `Invalid time zone in cron expression`,
    input: tz
  }));
  return all3({
    tz: zone,
    seconds: parseSegment(seconds2, secondOptions),
    minutes: parseSegment(minutes2, minuteOptions),
    hours: parseSegment(hours2, hourOptions),
    days: parseSegment(days2, dayOptions),
    months: parseSegment(months, monthOptions),
    weekdays: parseSegment(weekdays, weekdayOptions)
  }).pipe(map(make58));
};
var unsafeParse = (cron3, tz) => getOrThrowWith(parse2(cron3, tz), identity);
var match19 = (cron3, date5) => {
  const parts2 = unsafeMakeZoned(date5, {
    timeZone: getOrUndefined2(cron3.tz)
  }).pipe(toParts);
  if (cron3.seconds.size !== 0 && !cron3.seconds.has(parts2.seconds)) {
    return false;
  }
  if (cron3.minutes.size !== 0 && !cron3.minutes.has(parts2.minutes)) {
    return false;
  }
  if (cron3.hours.size !== 0 && !cron3.hours.has(parts2.hours)) {
    return false;
  }
  if (cron3.months.size !== 0 && !cron3.months.has(parts2.month)) {
    return false;
  }
  if (cron3.days.size === 0 && cron3.weekdays.size === 0) {
    return true;
  }
  if (cron3.weekdays.size === 0) {
    return cron3.days.has(parts2.day);
  }
  if (cron3.days.size === 0) {
    return cron3.weekdays.has(parts2.weekDay);
  }
  return cron3.days.has(parts2.day) || cron3.weekdays.has(parts2.weekDay);
};
var daysInMonth = (date5) => new Date(Date.UTC(date5.getUTCFullYear(), date5.getUTCMonth() + 1, 0)).getUTCDate();
var next2 = (cron3, startFrom) => {
  const tz = getOrUndefined2(cron3.tz);
  const zoned = unsafeMakeZoned(startFrom ?? /* @__PURE__ */ new Date(), {
    timeZone: tz
  });
  const utc = tz !== void 0 && isTimeZoneNamed(tz) && tz.id === "UTC";
  const adjustDst = utc ? constVoid : (current2) => {
    const adjusted = unsafeMakeZoned(current2, {
      timeZone: zoned.zone,
      adjustForTimeZone: true
    }).pipe(toDate);
    const drift = current2.getTime() - adjusted.getTime();
    if (drift > 0) {
      current2.setTime(current2.getTime() + drift);
    }
  };
  const result = mutate5(zoned, (current2) => {
    current2.setUTCSeconds(current2.getUTCSeconds() + 1, 0);
    for (let i = 0; i < 1e4; i++) {
      if (cron3.seconds.size !== 0) {
        const currentSecond = current2.getUTCSeconds();
        const nextSecond2 = cron3.next.second[currentSecond];
        if (nextSecond2 === void 0) {
          current2.setUTCMinutes(current2.getUTCMinutes() + 1, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextSecond2 > currentSecond) {
          current2.setUTCSeconds(nextSecond2);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.minutes.size !== 0) {
        const currentMinute = current2.getUTCMinutes();
        const nextMinute2 = cron3.next.minute[currentMinute];
        if (nextMinute2 === void 0) {
          current2.setUTCHours(current2.getUTCHours() + 1, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextMinute2 > currentMinute) {
          current2.setUTCMinutes(nextMinute2, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.hours.size !== 0) {
        const currentHour = current2.getUTCHours();
        const nextHour2 = cron3.next.hour[currentHour];
        if (nextHour2 === void 0) {
          current2.setUTCDate(current2.getUTCDate() + 1);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextHour2 > currentHour) {
          current2.setUTCHours(nextHour2, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.weekdays.size !== 0 || cron3.days.size !== 0) {
        let a = Infinity;
        let b = Infinity;
        if (cron3.weekdays.size !== 0) {
          const currentWeekday = current2.getUTCDay();
          const nextWeekday = cron3.next.weekday[currentWeekday];
          a = nextWeekday === void 0 ? 7 - currentWeekday + cron3.first.weekday : nextWeekday - currentWeekday;
        }
        if (cron3.days.size !== 0 && a !== 0) {
          const currentDay = current2.getUTCDate();
          const nextDay2 = cron3.next.day[currentDay];
          b = nextDay2 === void 0 ? daysInMonth(current2) - currentDay + cron3.first.day : nextDay2 - currentDay;
        }
        const addDays = Math.min(a, b);
        if (addDays !== 0) {
          current2.setUTCDate(current2.getUTCDate() + addDays);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.months.size !== 0) {
        const currentMonth = current2.getUTCMonth() + 1;
        const nextMonth = cron3.next.month[currentMonth];
        if (nextMonth === void 0) {
          current2.setUTCFullYear(current2.getUTCFullYear() + 1);
          current2.setUTCMonth(cron3.first.month, cron3.first.day);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextMonth > currentMonth) {
          current2.setUTCMonth(nextMonth - 1, cron3.first.day);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      return;
    }
    throw new Error("Unable to find next cron date");
  });
  return toDateUtc(result);
};
var sequence = function* (cron3, startFrom) {
  while (true) {
    yield startFrom = next2(cron3, startFrom);
  }
};
var Equivalence8 = make((self, that) => restrictionsEquals(self.seconds, that.seconds) && restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));
var restrictionsArrayEquals = array(number);
var restrictionsEquals = (self, that) => restrictionsArrayEquals(fromIterable2(self), fromIterable2(that));
var equals5 = dual(2, (self, that) => Equivalence8(self, that));
var secondOptions = {
  min: 0,
  max: 59
};
var minuteOptions = {
  min: 0,
  max: 59
};
var hourOptions = {
  min: 0,
  max: 23
};
var dayOptions = {
  min: 1,
  max: 31
};
var monthOptions = {
  min: 1,
  max: 12,
  aliases: {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12
  }
};
var weekdayOptions = {
  min: 0,
  max: 6,
  aliases: {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  }
};
var parseSegment = (input, options) => {
  const capacity10 = options.max - options.min + 1;
  const values15 = /* @__PURE__ */ new Set();
  const fields = input.split(",");
  for (const field of fields) {
    const [raw, step4] = splitStep(field);
    if (raw === "*" && step4 === void 0) {
      return right2(/* @__PURE__ */ new Set());
    }
    if (step4 !== void 0) {
      if (!Number.isInteger(step4)) {
        return left2(new ParseError({
          message: `Expected step value to be a positive integer`,
          input
        }));
      }
      if (step4 < 1) {
        return left2(new ParseError({
          message: `Expected step value to be greater than 0`,
          input
        }));
      }
      if (step4 > options.max) {
        return left2(new ParseError({
          message: `Expected step value to be less than ${options.max}`,
          input
        }));
      }
    }
    if (raw === "*") {
      for (let i = options.min; i <= options.max; i += step4 ?? 1) {
        values15.add(i);
      }
    } else {
      const [left3, right3] = splitRange(raw, options.aliases);
      if (!Number.isInteger(left3)) {
        return left2(new ParseError({
          message: `Expected a positive integer`,
          input
        }));
      }
      if (left3 < options.min || left3 > options.max) {
        return left2(new ParseError({
          message: `Expected a value between ${options.min} and ${options.max}`,
          input
        }));
      }
      if (right3 === void 0) {
        values15.add(left3);
      } else {
        if (!Number.isInteger(right3)) {
          return left2(new ParseError({
            message: `Expected a positive integer`,
            input
          }));
        }
        if (right3 < options.min || right3 > options.max) {
          return left2(new ParseError({
            message: `Expected a value between ${options.min} and ${options.max}`,
            input
          }));
        }
        if (left3 > right3) {
          return left2(new ParseError({
            message: `Invalid value range`,
            input
          }));
        }
        for (let i = left3; i <= right3; i += step4 ?? 1) {
          values15.add(i);
        }
      }
    }
    if (values15.size >= capacity10) {
      return right2(/* @__PURE__ */ new Set());
    }
  }
  return right2(values15);
};
var splitStep = (input) => {
  const seperator = input.indexOf("/");
  if (seperator !== -1) {
    return [input.slice(0, seperator), Number(input.slice(seperator + 1))];
  }
  return [input, void 0];
};
var splitRange = (input, aliases) => {
  const seperator = input.indexOf("-");
  if (seperator !== -1) {
    return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)];
  }
  return [aliasOrValue(input, aliases), void 0];
};
function aliasOrValue(field, aliases) {
  return (aliases == null ? void 0 : aliases[field.toLocaleLowerCase()]) ?? Number(field);
}

// node_modules/effect/dist/esm/Random.js
var Random_exports = {};
__export(Random_exports, {
  Random: () => Random2,
  RandomTypeId: () => RandomTypeId2,
  choice: () => choice2,
  make: () => make59,
  next: () => next3,
  nextBoolean: () => nextBoolean2,
  nextInt: () => nextInt2,
  nextIntBetween: () => nextIntBetween2,
  nextRange: () => nextRange2,
  randomWith: () => randomWith2,
  shuffle: () => shuffle2
});
var RandomTypeId2 = RandomTypeId;
var next3 = next;
var nextInt2 = nextInt;
var nextBoolean2 = nextBoolean;
var nextRange2 = nextRange;
var nextIntBetween2 = nextIntBetween;
var shuffle2 = shuffle;
var choice2 = choice;
var randomWith2 = randomWith;
var Random2 = randomTag;
var make59 = make30;

// node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: void 0,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  recurrence: 0
};
var CurrentIterationMetadata = Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a52;
_a52 = ScheduleTypeId;
var ScheduleImpl = class {
  constructor(initial, step4) {
    __publicField(this, "initial");
    __publicField(this, "step");
    __publicField(this, _a52, scheduleVariance);
    this.initial = initial;
    this.step = step4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var updateInfo = (iterationMetaRef, now3, input) => update3(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now: now3,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  start: now3
} : {
  now: now3,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now3 - prev.start),
  elapsedSincePrevious: millis(now3 - prev.now),
  start: prev.start
});
var _a53;
_a53 = ScheduleDriverTypeId;
var ScheduleDriverImpl = class {
  constructor(schedule4, ref) {
    __publicField(this, "schedule");
    __publicField(this, "ref");
    __publicField(this, _a53, scheduleDriverVariance);
    __publicField(this, "iterationMeta", unsafeMake7(defaultIterationMetadata));
    this.schedule = schedule4;
    this.ref = ref;
  }
  get state() {
    return map14(get12(this.ref), (tuple7) => tuple7[1]);
  }
  get last() {
    return flatMap12(get12(this.ref), ([element2, _]) => {
      switch (element2._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element2.value);
        }
      }
    });
  }
  get reset() {
    return set6(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft2(set6(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map14(get12(this.ref), (tuple7) => tuple7[1]), flatMap12((state) => pipe(currentTimeMillis2, flatMap12((now3) => pipe(suspend(() => this.schedule.step(now3, input, state)), flatMap12(([state2, out, decision]) => {
      const setState = set6(this.ref, [some3(out), state2]);
      if (isDone5(decision)) {
        return setState.pipe(zipRight2(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now3;
      if (millis2 <= 0) {
        return setState.pipe(zipRight2(updateInfo(this.iterationMeta, now3, input)), as3(out));
      }
      const duration5 = millis(millis2);
      return pipe(setState, zipRight2(updateInfo(this.iterationMeta, now3, input)), zipRight2(sleep3(duration5)), as3(out));
    }))))));
  }
};
var makeWithState = (initial, step4) => new ScheduleImpl(initial, step4);
var addDelay = dual(2, (self, f2) => addDelayEffect(self, (out) => sync(() => f2(out))));
var addDelayEffect = dual(2, (self, f2) => modifyDelayEffect(self, (out, duration5) => map14(f2(out), (delay4) => sum4(duration5, decode(delay4)))));
var andThen10 = dual(2, (self, that) => map25(andThenEither(self, that), merge));
var andThenEither = dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now3, input, state) => state[2] ? flatMap12(self.step(now3, input, state[0]), ([lState, out, decision]) => {
  if (isDone5(decision)) {
    return map14(that.step(now3, input, state[1]), ([rState, out2, decision2]) => [[lState, rState, false], right2(out2), decision2]);
  }
  return succeed([[lState, state[1], true], left2(out), decision]);
}) : map14(that.step(now3, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], right2(out), decision])));
var as7 = dual(2, (self, out) => map25(self, () => out));
var asVoid5 = (self) => map25(self, constVoid);
var bothInOut = dual(2, (self, that) => makeWithState([self.initial, that.initial], (now3, [in1, in2], state) => zipWith6(self.step(now3, in1, state[0]), that.step(now3, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const interval = pipe(lDecision.intervals, union12(rDecision.intervals));
    return [[lState, rState], [out, out2], _continue2(interval)];
  }
  return [[lState, rState], [out, out2], done7];
})));
var check2 = dual(2, (self, test3) => checkEffect(self, (input, out) => sync(() => test3(input, out))));
var checkEffect = dual(2, (self, test3) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done7]);
  }
  return map14(test3(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done7]);
})));
var collectAllInputs = () => collectAllOutputs(identity3());
var collectAllOutputs = (self) => reduce16(self, empty7(), (outs, out) => pipe(outs, append3(out)));
var collectUntil = (f2) => collectAllOutputs(recurUntil(f2));
var collectUntilEffect = (f2) => collectAllOutputs(recurUntilEffect(f2));
var collectWhile = (f2) => collectAllOutputs(recurWhile(f2));
var collectWhileEffect = (f2) => collectAllOutputs(recurWhileEffect(f2));
var compose4 = dual(2, (self, that) => makeWithState([self.initial, that.initial], (now3, input, state) => flatMap12(self.step(now3, input, state[0]), ([lState, out, lDecision]) => map14(that.step(now3, out, state[1]), ([rState, out2, rDecision]) => isDone5(lDecision) ? [[lState, rState], out2, done7] : isDone5(rDecision) ? [[lState, rState], out2, done7] : [[lState, rState], out2, _continue2(pipe(lDecision.intervals, max10(rDecision.intervals)))]))));
var mapInput6 = dual(2, (self, f2) => mapInputEffect(self, (input2) => sync(() => f2(input2))));
var mapInputContext2 = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => mapInputContext(self.step(now3, input, state), f2)));
var mapInputEffect = dual(2, (self, f2) => makeWithState(self.initial, (now3, input2, state) => flatMap12(f2(input2), (input) => self.step(now3, input, state))));
var cron = (expression, tz) => {
  const parsed = isCron(expression) ? right2(expression) : parse2(expression, tz);
  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now3, _, [initial, previous2]) => {
    if (now3 < previous2[0]) {
      return succeed([[false, previous2], [previous2[1], previous2[2]], continueWith2(make52(previous2[1], previous2[2]))]);
    }
    if (isLeft2(parsed)) {
      return die2(parsed.left);
    }
    const cron3 = parsed.right;
    const date5 = new Date(now3);
    let next6;
    if (initial && match19(cron3, date5)) {
      next6 = now3;
    }
    next6 = next2(cron3, date5).getTime();
    const start5 = beginningOfSecond(next6);
    const end7 = endOfSecond(next6);
    return succeed([[false, [next6, start5, end7]], [start5, end7], continueWith2(make52(start5, end7))]);
  });
};
var dayOfMonth = (day) => {
  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now3, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 31 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDayOfMonth(now3, day, initial);
    const start5 = beginningOfDay(day0);
    const end7 = endOfDay(day0);
    const interval = make52(start5, end7);
    return succeed([[end7, n + 1], n, continueWith2(interval)]);
  });
};
var dayOfWeek = (day) => {
  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now3, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 7 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDay(now3, day, initial);
    const start5 = beginningOfDay(day0);
    const end7 = endOfDay(day0);
    const interval = make52(start5, end7);
    return succeed([[end7, n + 1], n, continueWith2(interval)]);
  });
};
var delayed = dual(2, (self, f2) => delayedEffect(self, (duration5) => sync(() => f2(duration5))));
var delayedEffect = dual(2, (self, f2) => modifyDelayEffect(self, (_, delay4) => f2(delay4)));
var delayedSchedule = (schedule4) => addDelay(schedule4, (x) => x);
var delays = (self) => makeWithState(self.initial, (now3, input, state) => pipe(self.step(now3, input, state), flatMap12(([state2, _, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, zero2, decision]);
  }
  return succeed([state2, millis(start2(decision.intervals) - now3), decision]);
})));
var mapBoth5 = dual(2, (self, {
  onInput,
  onOutput
}) => map25(mapInput6(self, onInput), onOutput));
var mapBothEffect = dual(2, (self, {
  onInput,
  onOutput
}) => mapEffect4(mapInputEffect(self, onInput), onOutput));
var driver = (self) => pipe(make36([none2(), self.initial]), map14((ref) => new ScheduleDriverImpl(self, ref)));
var duration = (durationInput) => {
  const duration5 = decode(durationInput);
  const durationMillis = toMillis(duration5);
  return makeWithState(true, (now3, _, state) => succeed(state ? [false, duration5, continueWith2(after2(now3 + durationMillis))] : [false, zero2, done7]));
};
var either5 = dual(2, (self, that) => union13(self, that));
var eitherWith = dual(3, (self, that, f2) => unionWith2(self, that, f2));
var ensuring3 = dual(2, (self, finalizer3) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => isDone5(decision) ? as3(finalizer3, [state2, out, decision]) : succeed([state2, out, decision]))));
var exponential2 = (baseInput, factor = 2) => {
  const base = decode(baseInput);
  return delayedSchedule(map25(forever3, (i) => times(base, Math.pow(factor, i))));
};
var fibonacci = (oneInput) => {
  const one = decode(oneInput);
  return delayedSchedule(pipe(unfold3([one, one], ([a, b]) => [b, sum4(a, b)]), map25((out) => out[0])));
};
var fixed = (intervalInput) => {
  const interval = decode(intervalInput);
  const intervalMillis = toMillis(interval);
  return makeWithState([none2(), 0], (now3, _, [option11, n]) => sync(() => {
    switch (option11._tag) {
      case "None": {
        return [[some3([now3, now3 + intervalMillis]), n + 1], n, continueWith2(after2(now3 + intervalMillis))];
      }
      case "Some": {
        const [startMillis, lastRun] = option11.value;
        const runningBehind = now3 > lastRun + intervalMillis;
        const boundary = equals(interval, zero2) ? interval : millis(intervalMillis - (now3 - startMillis) % intervalMillis);
        const sleepTime = equals(boundary, zero2) ? interval : boundary;
        const nextRun = runningBehind ? now3 : now3 + toMillis(sleepTime);
        return [[some3([startMillis, nextRun]), n + 1], n, continueWith2(after2(nextRun))];
      }
    }
  }));
};
var fromDelay = (delay4) => duration(delay4);
var fromDelays = (delay4, ...delays3) => makeWithState([[delay4, ...delays3].map((_) => decode(_)), true], (now3, _, [durations, cont]) => sync(() => {
  if (cont) {
    const x = durations[0];
    const interval = after2(now3 + toMillis(x));
    if (durations.length >= 2) {
      return [[durations.slice(1), true], x, continueWith2(interval)];
    }
    const y = durations.slice(1);
    return [[[x, ...y], false], x, continueWith2(interval)];
  }
  return [[durations, false], zero2, done7];
}));
var fromFunction2 = (f2) => map25(identity3(), f2);
var hourOfDay = (hour) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now3, _, state) => {
  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
  }
  const n = state[1];
  const initial = n === 0;
  const hour0 = nextHour(now3, hour, initial);
  const start5 = beginningOfHour(hour0);
  const end7 = endOfHour(hour0);
  const interval = make52(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var identity3 = () => makeWithState(void 0, (now3, input, state) => succeed([state, input, continueWith2(after2(now3))]));
var intersect5 = dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = dual(3, (self, that, f2) => makeWithState([self.initial, that.initial], (now3, input, state) => pipe(zipWith6(self.step(now3, input, state[0]), that.step(now3, input, state[1]), (a, b) => [a, b]), flatMap12(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f2);
  }
  return succeed([[lState, rState], [out, out2], done7]);
}))));
var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f2) => {
  const combined = f2(lInterval, rInterval);
  if (isNonEmpty6(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan12(rInterval))) {
    return flatMap12(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done7]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f2);
    });
  }
  return flatMap12(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done7]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f2);
  });
};
var jittered = (self) => jitteredWith(self, {
  min: 0.8,
  max: 1.2
});
var jitteredWith = dual(2, (self, options) => {
  const {
    max: max14,
    min: min11
  } = Object.assign({
    min: 0.8,
    max: 1.2
  }, options);
  return delayedEffect(self, (duration5) => map14(next3, (random6) => {
    const d = toMillis(duration5);
    const jittered3 = d * min11 * (1 - random6) + d * max14 * random6;
    return millis(jittered3);
  }));
});
var linear2 = (baseInput) => {
  const base = decode(baseInput);
  return delayedSchedule(map25(forever3, (i) => times(base, i + 1)));
};
var map25 = dual(2, (self, f2) => mapEffect4(self, (out) => sync(() => f2(out))));
var mapEffect4 = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => map14(f2(out), (out2) => [state2, out2, decision]))));
var minuteOfHour = (minute) => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now3, _, state) => {
  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const minute0 = nextMinute(now3, minute, initial);
  const start5 = beginningOfMinute(minute0);
  const end7 = endOfMinute(minute0);
  const interval = make52(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var modifyDelay = dual(2, (self, f2) => modifyDelayEffect(self, (out, duration5) => sync(() => f2(out, duration5))));
var modifyDelayEffect = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay4 = size19(make52(now3, start2(intervals)));
  return map14(f2(out, delay4), (durationInput) => {
    const duration5 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now3 + toMillis(duration5);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make52(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var onDecision = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => as3(f2(out, decision), [state2, out, decision]))));
var passthrough2 = (self) => makeWithState(self.initial, (now3, input, state) => pipe(self.step(now3, input, state), map14(([state2, _, decision]) => [state2, input, decision])));
var provideContext3 = dual(2, (self, context15) => makeWithState(self.initial, (now3, input, state) => provideContext(self.step(now3, input, state), context15)));
var provideService4 = dual(3, (self, tag5, service4) => makeWithState(self.initial, (now3, input, state) => contextWithEffect((env) => provideContext(
  // @ts-expect-error
  self.step(now3, input, state),
  add3(env, tag5, service4)
))));
var recurUntil = (f2) => untilInput(identity3(), f2);
var recurUntilEffect = (f2) => untilInputEffect(identity3(), f2);
var recurUntilOption = (pf) => untilOutput(map25(identity3(), pf), isSome2);
var recurUpTo = (durationInput) => {
  const duration5 = decode(durationInput);
  return whileOutput(elapsed, (elapsed3) => lessThan5(elapsed3, duration5));
};
var recurWhile = (f2) => whileInput(identity3(), f2);
var recurWhileEffect = (f2) => whileInputEffect(identity3(), f2);
var recurs = (n) => whileOutput(forever3, (out) => out < n);
var reduce16 = dual(3, (self, zero3, f2) => reduceEffect2(self, zero3, (z, out) => sync(() => f2(z, out))));
var reduceEffect2 = dual(3, (self, zero3, f2) => makeWithState([self.initial, zero3], (now3, input, [s, z]) => flatMap12(self.step(now3, input, s), ([s2, out, decision]) => isDone5(decision) ? succeed([[s2, z], z, decision]) : map14(f2(z, out), (z2) => [[s2, z2], z, decision]))));
var repetitions = (self) => reduce16(self, 0, (n, _) => n + 1);
var resetAfter = dual(2, (self, durationInput) => {
  const duration5 = decode(durationInput);
  return pipe(self, intersect5(elapsed), resetWhen(([, time3]) => greaterThanOrEqualTo5(time3, duration5)), map25((out) => out[0]));
});
var resetWhen = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => flatMap12(self.step(now3, input, state), ([state2, out, decision]) => f2(out) ? self.step(now3, input, self.initial) : succeed([state2, out, decision]))));
var run = dual(3, (self, now3, input) => pipe(runLoop(self, now3, fromIterable3(input), self.initial, empty7()), map14((list) => reverse3(list))));
var runLoop = (self, now3, inputs, state, acc) => {
  if (!isNonEmpty2(inputs)) {
    return succeed(acc);
  }
  const input = headNonEmpty2(inputs);
  const nextInputs = tailNonEmpty2(inputs);
  return flatMap12(self.step(now3, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return sync(() => pipe(acc, prepend3(out)));
    }
    return runLoop(self, start2(decision.intervals), nextInputs, state2, prepend3(acc, out));
  });
};
var secondOfMinute = (second) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now3, _, state) => {
  if (!Number.isInteger(second) || second < 0 || 59 < second) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const second0 = nextSecond(now3, second, initial);
  const start5 = beginningOfSecond(second0);
  const end7 = endOfSecond(second0);
  const interval = make52(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var spaced = (duration5) => addDelay(forever3, () => duration5);
var succeed11 = (value10) => map25(forever3, () => value10);
var sync7 = (evaluate4) => map25(forever3, evaluate4);
var tapInput = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => zipRight2(f2(input), self.step(now3, input, state))));
var tapOutput = dual(2, (self, f2) => makeWithState(self.initial, (now3, input, state) => tap2(self.step(now3, input, state), ([, out]) => f2(out))));
var unfold3 = (initial, f2) => makeWithState(initial, (now3, _, state) => sync(() => [f2(state), state, continueWith2(after2(now3))]));
var union13 = dual(2, (self, that) => unionWith2(self, that, union12));
var unionWith2 = dual(3, (self, that, f2) => makeWithState([self.initial, that.initial], (now3, input, state) => zipWith6(self.step(now3, input, state[0]), that.step(now3, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
  if (isDone5(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], done7];
  }
  if (isDone5(lDecision) && isContinue2(rDecision)) {
    return [[lState, rState], [l, r], _continue2(rDecision.intervals)];
  }
  if (isContinue2(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], _continue2(lDecision.intervals)];
  }
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const combined = f2(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l, r], _continue2(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})));
var untilInput = dual(2, (self, f2) => check2(self, (input, _) => !f2(input)));
var untilInputEffect = dual(2, (self, f2) => checkEffect(self, (input, _) => negate3(f2(input))));
var untilOutput = dual(2, (self, f2) => check2(self, (_, out) => !f2(out)));
var untilOutputEffect = dual(2, (self, f2) => checkEffect(self, (_, out) => negate3(f2(out))));
var upTo = dual(2, (self, duration5) => zipLeft6(self, recurUpTo(duration5)));
var whileInput = dual(2, (self, f2) => check2(self, (input, _) => f2(input)));
var whileInputEffect = dual(2, (self, f2) => checkEffect(self, (input, _) => f2(input)));
var whileOutput = dual(2, (self, f2) => check2(self, (_, out) => f2(out)));
var whileOutputEffect = dual(2, (self, f2) => checkEffect(self, (_, out) => f2(out)));
var windowed = (intervalInput) => {
  const interval = decode(intervalInput);
  const millis2 = toMillis(interval);
  return makeWithState([none2(), 0], (now3, _, [option11, n]) => {
    switch (option11._tag) {
      case "None": {
        return succeed([[some3(now3), n + 1], n, continueWith2(after2(now3 + millis2))]);
      }
      case "Some": {
        return succeed([[some3(option11.value), n + 1], n, continueWith2(after2(now3 + (millis2 - (now3 - option11.value) % millis2)))]);
      }
    }
  });
};
var zipLeft6 = dual(2, (self, that) => map25(intersect5(self, that), (out) => out[0]));
var zipRight6 = dual(2, (self, that) => map25(intersect5(self, that), (out) => out[1]));
var zipWith11 = dual(3, (self, that, f2) => map25(intersect5(self, that), ([out, out2]) => f2(out, out2)));
var beginningOfSecond = (now3) => {
  const date5 = new Date(now3);
  return new Date(date5.getFullYear(), date5.getMonth(), date5.getDate(), date5.getHours(), date5.getMinutes(), date5.getSeconds(), 0).getTime();
};
var endOfSecond = (now3) => {
  const date5 = new Date(beginningOfSecond(now3));
  return date5.setSeconds(date5.getSeconds() + 1);
};
var nextSecond = (now3, second, initial) => {
  const date5 = new Date(now3);
  if (date5.getSeconds() === second && initial) {
    return now3;
  }
  if (date5.getSeconds() < second) {
    return date5.setSeconds(second);
  }
  const newDate = new Date(date5.setSeconds(second));
  return newDate.setTime(newDate.getTime() + 1e3 * 60);
};
var beginningOfMinute = (now3) => {
  const date5 = new Date(now3);
  return new Date(date5.getFullYear(), date5.getMonth(), date5.getDate(), date5.getHours(), date5.getMinutes(), 0, 0).getTime();
};
var endOfMinute = (now3) => {
  const date5 = new Date(beginningOfMinute(now3));
  return date5.setMinutes(date5.getMinutes() + 1);
};
var nextMinute = (now3, minute, initial) => {
  const date5 = new Date(now3);
  if (date5.getMinutes() === minute && initial) {
    return now3;
  }
  if (date5.getMinutes() < minute) {
    return date5.setMinutes(minute);
  }
  const newDate = new Date(date5.setMinutes(minute));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60);
};
var beginningOfHour = (now3) => {
  const date5 = new Date(now3);
  return new Date(date5.getFullYear(), date5.getMonth(), date5.getDate(), date5.getHours(), 0, 0, 0).getTime();
};
var endOfHour = (now3) => {
  const date5 = new Date(beginningOfHour(now3));
  return date5.setHours(date5.getHours() + 1);
};
var nextHour = (now3, hour, initial) => {
  const date5 = new Date(now3);
  if (date5.getHours() === hour && initial) {
    return now3;
  }
  if (date5.getHours() < hour) {
    return date5.setHours(hour);
  }
  const newDate = new Date(date5.setHours(hour));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60 * 24);
};
var beginningOfDay = (now3) => {
  const date5 = new Date(now3);
  return new Date(date5.getFullYear(), date5.getMonth(), date5.getDate(), 0, 0, 0, 0).getTime();
};
var endOfDay = (now3) => {
  const date5 = new Date(beginningOfDay(now3));
  return date5.setDate(date5.getDate() + 1);
};
var nextDay = (now3, dayOfWeek3, initial) => {
  const date5 = new Date(now3);
  if (date5.getDay() === dayOfWeek3 && initial) {
    return now3;
  }
  const nextDayOfWeek = (7 + dayOfWeek3 - date5.getDay()) % 7;
  return date5.setDate(date5.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
};
var nextDayOfMonth = (now3, day, initial) => {
  const date5 = new Date(now3);
  if (date5.getDate() === day && initial) {
    return now3;
  }
  if (date5.getDate() < day) {
    return date5.setDate(day);
  }
  return findNextMonth(now3, day, 1);
};
var findNextMonth = (now3, day, months) => {
  const d = new Date(now3);
  const tmp1 = new Date(d.setDate(day));
  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
  if (tmp2.getDate() === day) {
    const d2 = new Date(now3);
    const tmp3 = new Date(d2.setDate(day));
    return tmp3.setMonth(tmp3.getMonth() + months);
  }
  return findNextMonth(now3, day, months + 1);
};
var ScheduleDefectTypeId = Symbol.for("effect/Schedule/ScheduleDefect");
var _a54;
_a54 = ScheduleDefectTypeId;
var ScheduleDefect = class {
  constructor(error4) {
    __publicField(this, "error");
    __publicField(this, _a54);
    this.error = error4;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause3) => match2(find(cause3, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some3(_.defect) : none2()), {
  onNone: () => cause3,
  onSome: (error4) => fail(error4.error)
});
var scheduleDefectRefail = (effect4) => catchAllCause(effect4, (cause3) => failCause(scheduleDefectRefailCause(cause3)));
var repeat_Effect = dual(2, (self, schedule4) => repeatOrElse_Effect(self, schedule4, (e, _) => fail2(e)));
var repeat_combined = dual(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough2(forever3);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map25((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = dual(3, (self, schedule4, orElse24) => flatMap12(driver(schedule4), (driver3) => matchEffect(self, {
  onFailure: (error4) => orElse24(error4, none2()),
  onSuccess: (value10) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get12(driver3.iterationMeta)), driver3, (error4, option11) => provideServiceEffect(orElse24(error4, option11), CurrentIterationMetadata, get12(driver3.iterationMeta)), value10)
})));
var repeatOrElseEffectLoop = (self, driver3, orElse24, value10) => matchEffect(driver3.next(value10), {
  onFailure: () => orDie(driver3.last),
  onSuccess: (b) => matchEffect(self, {
    onFailure: (error4) => orElse24(error4, some3(b)),
    onSuccess: (value11) => repeatOrElseEffectLoop(self, driver3, orElse24, value11)
  })
});
var retry_Effect = dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
var retry_combined = dual(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever3;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = dual(3, (self, policy, orElse24) => flatMap12(driver(policy), (driver3) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get12(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect(orElse24(e, out), CurrentIterationMetadata, get12(driver3.iterationMeta)))));
var retryOrElse_EffectLoop = (self, driver3, orElse24) => {
  return catchAll(self, (e) => matchEffect(driver3.next(e), {
    onFailure: () => pipe(driver3.last, orDie, flatMap12((out) => orElse24(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver3, orElse24)
  }));
};
var schedule_Effect = dual(2, (self, schedule4) => scheduleFrom_Effect(self, void 0, schedule4));
var scheduleFrom_Effect = dual(3, (self, initial, schedule4) => flatMap12(driver(schedule4), (driver3) => scheduleFrom_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get12(driver3.iterationMeta)), initial, driver3)));
var scheduleFrom_EffectLoop = (self, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: () => orDie(driver3.last),
  onSuccess: () => flatMap12(self, (a) => scheduleFrom_EffectLoop(self, a, driver3))
});
var count2 = unfold3(0, (n) => n + 1);
var elapsed = makeWithState(none2(), (now3, _, state) => {
  switch (state._tag) {
    case "None": {
      return succeed([some3(now3), zero2, continueWith2(after2(now3))]);
    }
    case "Some": {
      return succeed([some3(state.value), millis(now3 - state.value), continueWith2(after2(now3))]);
    }
  }
});
var forever3 = unfold3(0, (n) => n + 1);
var once2 = asVoid5(recurs(1));
var stop = asVoid5(recurs(0));
var scheduleForked = dual(2, (self, schedule4) => forkScoped2(schedule_Effect(self, schedule4)));

// node_modules/effect/dist/esm/internal/executionPlan.js
var TypeId22 = Symbol.for("effect/ExecutionPlan");
var isExecutionPlan = (u) => hasProperty(u, TypeId22);
var withExecutionPlan = dual(2, (effect4, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap12(whileLoop({
    while: () => i < plan.steps.length && (result === void 0 || isLeft2(result)),
    body: () => {
      const step4 = plan.steps[i];
      let nextEffect = effect_provide(effect4, step4.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted) return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step4, false)));
      } else {
        const schedule4 = scheduleFromStep(step4, true);
        nextEffect = schedule4 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule4)) : nextEffect;
      }
      return either3(nextEffect);
    },
    step: (either14) => {
      result = either14;
      i++;
    }
  }), () => result);
}));
var scheduleFromStep = (step4, first5) => {
  if (!first5) {
    return fromRetryOptions({
      schedule: step4.schedule ? step4.schedule : step4.attempts ? void 0 : once2,
      times: step4.attempts,
      while: step4.while
    });
  } else if (step4.attempts === 1 || !(step4.schedule || step4.attempts)) {
    return void 0;
  }
  return fromRetryOptions({
    schedule: step4.schedule,
    while: step4.while,
    times: step4.attempts ? step4.attempts - 1 : void 0
  });
};

// node_modules/effect/dist/esm/internal/query.js
var currentCache = globalValue(Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map14(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = globalValue(Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request2, dataSource) => flatMap12(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id3) => {
  const proxy = new Proxy(request2, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached4 = fiberRefGetWith(currentCache, (cache) => flatMap12(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap12(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached4);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap12(exit(blocked(empty21, restore(deferredAwait(orNew.left.handle)))), (exit4) => {
              orNew.left.listeners.decrement();
              return exit4;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap12(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id3,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached4;
    }
    const listeners = new Listeners();
    listeners.increment();
    return flatMap12(deferredMake(), (ref) => ensuring2(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id3,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request2, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap12(cache.getEither(request2), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_3;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_3;
  });
};
var withRequestCaching = dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
var withRequestCache = dual(
  2,
  // @ts-expect-error
  (self, cache) => fiberRefLocally(self, currentCache, cache)
);

// node_modules/effect/dist/esm/Request.js
var Request_exports = {};
__export(Request_exports, {
  Class: () => Class6,
  EntryTypeId: () => EntryTypeId2,
  RequestTypeId: () => RequestTypeId2,
  TaggedClass: () => TaggedClass3,
  complete: () => complete4,
  completeEffect: () => completeEffect2,
  fail: () => fail11,
  failCause: () => failCause9,
  interruptWhenPossible: () => interruptWhenPossible2,
  isEntry: () => isEntry2,
  isRequest: () => isRequest2,
  makeCache: () => makeCache,
  makeEntry: () => makeEntry2,
  of: () => of6,
  succeed: () => succeed12,
  tagged: () => tagged5
});
var RequestTypeId2 = RequestTypeId;
var isRequest2 = isRequest;
var of6 = of5;
var tagged5 = tagged3;
var Class6 = Class4;
var TaggedClass3 = TaggedClass;
var complete4 = complete2;
var interruptWhenPossible2 = interruptWhenPossible;
var completeEffect2 = completeEffect;
var fail11 = fail7;
var failCause9 = failCause6;
var succeed12 = succeed8;
var makeCache = (options) => make49({
  ...options,
  lookup: () => map14(deferredMake(), (handle) => ({
    listeners: new Listeners(),
    handle
  }))
});
var EntryTypeId2 = Symbol.for("effect/RequestBlock.Entry");
var isEntry2 = isEntry;
var makeEntry2 = makeEntry;

// node_modules/effect/dist/esm/Effect.js
var EffectTypeId4 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all11 = all9;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile4 = dropWhile3;
var takeUntil2 = takeUntil;
var takeWhile5 = takeWhile4;
var every13 = every11;
var exists4 = exists3;
var filter16 = filter14;
var filterMap11 = filterMap9;
var findFirst11 = findFirst8;
var forEach16 = forEach15;
var head7 = head6;
var mergeAll5 = mergeAll3;
var partition9 = partition8;
var reduce17 = reduce12;
var reduceWhile2 = reduceWhile;
var reduceRight5 = reduceRight4;
var reduceEffect3 = reduceEffect;
var replicate5 = replicate4;
var replicateEffect3 = replicateEffect2;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async2 = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail12 = fail2;
var failSync5 = failSync;
var failCause10 = failCause;
var failCauseSync5 = failCauseSync;
var die8 = die2;
var dieMessage2 = dieMessage;
var dieSync4 = dieSync;
var gen6 = gen4;
var never5 = never;
var none9 = none6;
var promise3 = promise;
var succeed13 = succeed;
var succeedNone3 = succeedNone;
var succeedSome3 = succeedSome;
var suspend4 = suspend;
var sync8 = sync;
var _void = void_3;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll4 = catchAll;
var catchAllCause4 = catchAllCause;
var catchAllDefect3 = catchAllDefect;
var catchIf3 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag3 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore3 = ignore;
var ignoreLogged3 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox3 = sandbox;
var retry3 = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_4 = try_2;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise3 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt8 = interrupt2;
var interruptWith3 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt3 = onInterrupt;
var uninterruptible3 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate5 = liftPredicate4;
var as8 = as3;
var asSome3 = asSome;
var asSomeError2 = asSomeError;
var asVoid6 = asVoid2;
var flip5 = flip3;
var flipWith2 = flipWith;
var map26 = map14;
var mapAccum4 = mapAccum3;
var mapBoth6 = mapBoth3;
var mapError5 = mapError;
var mapErrorCause4 = mapErrorCause2;
var merge7 = merge5;
var negate4 = negate3;
var acquireRelease3 = acquireRelease2;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease3 = acquireUseRelease;
var addFinalizer4 = addFinalizer2;
var ensuring4 = ensuring2;
var onError3 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope4 = scope2;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped4 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork4 = fork2;
var forkDaemon3 = forkDaemon2;
var forkAll2 = forkAll;
var forkIn3 = forkIn2;
var forkScoped3 = forkScoped2;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency3 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay3 = delay;
var sleep5 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout3 = timeout2;
var timeoutOption3 = timeoutOption2;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context5 = context2;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext3 = mapInputContext;
var provide2 = effect_provide;
var provideService5 = provideService;
var provideServiceEffect3 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption3 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService3 = updateService;
var Do6 = Do4;
var bind7 = bind5;
var bindAll2 = bindAll;
var bindTo7 = bindTo5;
var let_7 = let_5;
var option4 = option2;
var either6 = either3;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail3 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when3 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap18 = flatMap12;
var andThen11 = andThen6;
var flatten13 = flatten8;
var race3 = race2;
var raceAll3 = raceAll2;
var raceFirst3 = raceFirst2;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap5 = tap2;
var tapBoth2 = tapBoth;
var tapDefect3 = tapDefect;
var tapError4 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause4 = tapErrorCause;
var forever4 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat3 = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop3 = whileLoop;
var getFiberRefs = fiberRefs3;
var inheritFiberRefs2 = inheritFiberRefs;
var locally2 = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs3 = updateFiberRefs;
var isFailure5 = isFailure3;
var isSuccess3 = isSuccess2;
var match20 = match8;
var matchCause4 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect4 = matchEffect;
var log3 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie4 = orDie;
var orDieWith2 = orDieWith;
var orElse8 = orElse3;
var orElseFail2 = orElseFail;
var orElseSucceed3 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random4 = random3;
var randomWith3 = randomWith;
var withRandom2 = withRandom;
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise2 = unsafeRunPromiseEffect;
var runPromiseExit2 = unsafeRunPromiseExitEffect;
var runSync2 = unsafeRunSyncEffect;
var runSyncExit2 = unsafeRunSyncExitEffect;
var validate4 = validate3;
var validateWith2 = validateWith;
var zip12 = zipOptions;
var zipLeft7 = zipLeftOptions;
var zipRight7 = zipRightOptions;
var zipWith12 = zipWithOptions;
var ap3 = dual(2, (self, that) => zipWith12(self, that, (f2, a) => f2(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable5 = fromNullable4;
var optionFromOptional2 = optionFromOptional;
var transposeOption2 = (self) => {
  return isNone(self) ? succeedNone3 : map26(self.value, some2);
};
var transposeMapOption2 = dual(2, (self, f2) => isNone(self) ? succeedNone3 : map26(f2(self.value), some2));
var makeTagProxy = (TagClass) => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn2 = (...args2) => andThen6(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen6(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen6(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen6(target, (s) => s[prop]);
      Object.assign(fn2, cn);
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(cn));
      cache.set(prop, fn2);
      return fn2;
    }
  });
};
var Tag3 = (id3) => () => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit2;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen6(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var Service = function() {
  return function() {
    const [id3, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit2 = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit2;
    let patchState = "unchecked";
    const TagClass = function(service4) {
      if (patchState === "unchecked") {
        const proto16 = Object.getPrototypeOf(service4);
        if (proto16 === Object.prototype || proto16 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto16);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service4);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service4, Object.getPrototypeOf(this));
        return service4;
      }
    };
    TagClass.prototype._tag = id3;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service4) => new this(service4);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen6(this, body);
      }
    });
    TagClass.key = id3;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return (function() {
              return fromEffect4(TagClass, map26(maker.effect.apply(null, arguments), (_) => new this(_)));
            }).bind(this);
          }
          return layerCache ?? (layerCache = fromEffect4(TagClass, map26(maker.effect, (_) => new this(_))));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return (function() {
              return scoped3(TagClass, map26(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }).bind(this);
          }
          return layerCache ?? (layerCache = scoped3(TagClass, map26(maker.scoped, (_) => new this(_))));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ?? (layerCache = sync6(TagClass, () => new this(maker.sync())));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ?? (layerCache = succeed10(TagClass, new this(maker.succeed)));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ?? (layerWithDepsCache = provide(this.DefaultWithoutDependencies, maker.dependencies));
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
};
var fn = function(nameOrBody, ...pipeables) {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit2;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit3 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit3;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit3 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit3;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
};
function defineLength(length6, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length6,
    configurable: true
  });
}
function fnApply(options) {
  let effect4;
  let fnError = void 0;
  if (isGeneratorFunction(options.body)) {
    effect4 = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect4 = options.body.apply(options.self, options.args);
    } catch (error4) {
      fnError = error4;
      effect4 = die8(error4);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect4 = x(effect4, ...options.args);
      }
    } catch (error4) {
      effect4 = fnError ? failCause10(sequential(die(fnError), die(error4))) : die8(error4);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split("\n");
      const stackCall = options.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan3(effect4, options.spanName, opts);
}
var fnUntraced2 = fnUntraced;

// node_modules/effect/dist/esm/FiberRef.js
var FiberRef_exports = {};
__export(FiberRef_exports, {
  FiberRefTypeId: () => FiberRefTypeId2,
  currentConcurrency: () => currentConcurrency2,
  currentContext: () => currentContext2,
  currentLogAnnotations: () => currentLogAnnotations2,
  currentLogLevel: () => currentLogLevel2,
  currentLogSpan: () => currentLogSpan2,
  currentLoggers: () => currentLoggers2,
  currentMaxOpsBeforeYield: () => currentMaxOpsBeforeYield2,
  currentMetricLabels: () => currentMetricLabels2,
  currentMinimumLogLevel: () => currentMinimumLogLevel2,
  currentRequestBatchingEnabled: () => currentRequestBatchingEnabled,
  currentRequestCache: () => currentRequestCache,
  currentRequestCacheEnabled: () => currentRequestCacheEnabled,
  currentRuntimeFlags: () => currentRuntimeFlags2,
  currentScheduler: () => currentScheduler2,
  currentSchedulingPriority: () => currentSchedulingPriority2,
  currentSupervisor: () => currentSupervisor2,
  currentTracerEnabled: () => currentTracerEnabled2,
  currentTracerSpanAnnotations: () => currentTracerSpanAnnotations2,
  currentTracerSpanLinks: () => currentTracerSpanLinks2,
  currentTracerTimingEnabled: () => currentTracerTimingEnabled2,
  delete: () => _delete,
  get: () => get14,
  getAndSet: () => getAndSet4,
  getAndUpdate: () => getAndUpdate4,
  getAndUpdateSome: () => getAndUpdateSome3,
  getWith: () => getWith,
  interruptedCause: () => interruptedCause,
  make: () => make60,
  makeContext: () => makeContext2,
  makeRuntimeFlags: () => makeRuntimeFlags,
  makeWith: () => makeWith3,
  modify: () => modify11,
  modifySome: () => modifySome3,
  reset: () => reset2,
  set: () => set9,
  unhandledErrorLogLevel: () => unhandledErrorLogLevel,
  unsafeMake: () => unsafeMake12,
  unsafeMakeContext: () => unsafeMakeContext,
  unsafeMakeHashSet: () => unsafeMakeHashSet,
  unsafeMakePatch: () => unsafeMakePatch,
  unsafeMakeSupervisor: () => unsafeMakeSupervisor,
  update: () => update7,
  updateAndGet: () => updateAndGet4,
  updateSome: () => updateSome3,
  updateSomeAndGet: () => updateSomeAndGet3
});
var FiberRefTypeId2 = FiberRefTypeId;
var make60 = fiberRefMake;
var makeWith3 = fiberRefMakeWith;
var makeContext2 = fiberRefMakeContext;
var makeRuntimeFlags = fiberRefMakeRuntimeFlags;
var unsafeMake12 = fiberRefUnsafeMake;
var unsafeMakeHashSet = fiberRefUnsafeMakeHashSet;
var unsafeMakeContext = fiberRefUnsafeMakeContext;
var unsafeMakeSupervisor = fiberRefUnsafeMakeSupervisor;
var unsafeMakePatch = fiberRefUnsafeMakePatch;
var get14 = fiberRefGet;
var getAndSet4 = fiberRefGetAndSet;
var getAndUpdate4 = fiberRefGetAndUpdate;
var getAndUpdateSome3 = fiberRefGetAndUpdateSome;
var getWith = fiberRefGetWith;
var set9 = fiberRefSet;
var _delete = fiberRefDelete;
var reset2 = fiberRefReset;
var modify11 = fiberRefModify;
var modifySome3 = fiberRefModifySome;
var update7 = fiberRefUpdate;
var updateSome3 = fiberRefUpdateSome;
var updateAndGet4 = fiberRefUpdateAndGet;
var updateSomeAndGet3 = fiberRefUpdateSomeAndGet;
var currentConcurrency2 = currentConcurrency;
var currentRequestBatchingEnabled = currentRequestBatching;
var currentRequestCache = currentCache;
var currentRequestCacheEnabled = currentCacheEnabled;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentMaxOpsBeforeYield2 = currentMaxOpsBeforeYield;
var unhandledErrorLogLevel = currentUnhandledErrorLogLevel;
var currentLogAnnotations2 = currentLogAnnotations;
var currentLoggers2 = currentLoggers;
var currentLogLevel2 = currentLogLevel;
var currentMinimumLogLevel2 = currentMinimumLogLevel;
var currentLogSpan2 = currentLogSpan;
var currentRuntimeFlags2 = currentRuntimeFlags;
var currentScheduler2 = currentScheduler;
var currentSupervisor2 = currentSupervisor;
var currentMetricLabels2 = currentMetricLabels;
var currentTracerEnabled2 = currentTracerEnabled;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;
var currentTracerSpanAnnotations2 = currentTracerSpanAnnotations;
var currentTracerSpanLinks2 = currentTracerSpanLinks;
var interruptedCause = currentInterruptedCause;

// node_modules/effect/dist/esm/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  CurrentMemoMap: () => CurrentMemoMap2,
  LayerTypeId: () => LayerTypeId2,
  MemoMapTypeId: () => MemoMapTypeId2,
  annotateLogs: () => annotateLogs4,
  annotateSpans: () => annotateSpans4,
  build: () => build2,
  buildWithMemoMap: () => buildWithMemoMap2,
  buildWithScope: () => buildWithScope2,
  catchAll: () => catchAll5,
  catchAllCause: () => catchAllCause5,
  context: () => context6,
  die: () => die9,
  dieSync: () => dieSync5,
  discard: () => discard2,
  effect: () => effect,
  effectContext: () => effectContext,
  effectDiscard: () => effectDiscard,
  empty: () => empty42,
  extendScope: () => extendScope2,
  fail: () => fail13,
  failCause: () => failCause11,
  failCauseSync: () => failCauseSync6,
  failSync: () => failSync6,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  flatMap: () => flatMap19,
  flatten: () => flatten14,
  fresh: () => fresh2,
  function: () => fromFunction3,
  isFresh: () => isFresh2,
  isLayer: () => isLayer2,
  launch: () => launch2,
  locally: () => locally3,
  locallyEffect: () => locallyEffect2,
  locallyScoped: () => locallyScoped2,
  locallyWith: () => locallyWith2,
  makeMemoMap: () => makeMemoMap2,
  map: () => map27,
  mapError: () => mapError6,
  match: () => match21,
  matchCause: () => matchCause5,
  memoize: () => memoize3,
  merge: () => merge8,
  mergeAll: () => mergeAll6,
  orDie: () => orDie5,
  orElse: () => orElse9,
  parentSpan: () => parentSpan2,
  passthrough: () => passthrough3,
  project: () => project2,
  provide: () => provide3,
  provideMerge: () => provideMerge2,
  retry: () => retry4,
  scope: () => scope5,
  scoped: () => scoped5,
  scopedContext: () => scopedContext2,
  scopedDiscard: () => scopedDiscard2,
  service: () => service3,
  setClock: () => setClock,
  setConfigProvider: () => setConfigProvider2,
  setRandom: () => setRandom,
  setRequestBatching: () => setRequestBatching,
  setRequestCache: () => setRequestCache,
  setRequestCaching: () => setRequestCaching,
  setScheduler: () => setScheduler,
  setTracer: () => setTracer2,
  setTracerEnabled: () => setTracerEnabled,
  setTracerTiming: () => setTracerTiming,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  span: () => span3,
  succeed: () => succeed14,
  succeedContext: () => succeedContext2,
  suspend: () => suspend5,
  sync: () => sync9,
  syncContext: () => syncContext2,
  tap: () => tap6,
  tapError: () => tapError5,
  tapErrorCause: () => tapErrorCause5,
  toRuntime: () => toRuntime2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  unwrapEffect: () => unwrapEffect2,
  unwrapScoped: () => unwrapScoped2,
  updateService: () => updateService4,
  withParentSpan: () => withParentSpan4,
  withSpan: () => withSpan4,
  zipWith: () => zipWith13
});

// node_modules/effect/dist/esm/internal/layer/circular.js
var minimumLogLevel = (level) => scopedDiscard(fiberRefLocallyScoped(currentMinimumLogLevel, level));
var withMinimumLogLevel = dual(2, (self, level) => fiberRefLocally(currentMinimumLogLevel, level)(self));
var addLogger = (logger) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, add5(logger)));
var addLoggerEffect = (effect4) => unwrapEffect(map14(effect4, addLogger));
var addLoggerScoped = (effect4) => unwrapScoped(map14(effect4, addLogger));
var removeLogger = (logger) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, remove6(logger)));
var replaceLogger = dual(2, (self, that) => flatMap17(removeLogger(self), () => addLogger(that)));
var replaceLoggerEffect = dual(2, (self, that) => flatMap17(removeLogger(self), () => addLoggerEffect(that)));
var replaceLoggerScoped = dual(2, (self, that) => flatMap17(removeLogger(self), () => addLoggerScoped(that)));
var addSupervisor = (supervisor) => scopedDiscard(fiberRefLocallyScopedWith(currentSupervisor, (current2) => new Zip(current2, supervisor)));
var enableCooperativeYielding = scopedDiscard(withRuntimeFlagsScoped(enable(CooperativeYielding)));
var enableInterruption = scopedDiscard(withRuntimeFlagsScoped(enable(Interruption)));
var enableOpSupervision = scopedDiscard(withRuntimeFlagsScoped(enable(OpSupervision)));
var enableRuntimeMetrics = scopedDiscard(withRuntimeFlagsScoped(enable(RuntimeMetrics)));
var enableWindDown = scopedDiscard(withRuntimeFlagsScoped(enable(WindDown)));
var disableCooperativeYielding = scopedDiscard(withRuntimeFlagsScoped(disable(CooperativeYielding)));
var disableInterruption = scopedDiscard(withRuntimeFlagsScoped(disable(Interruption)));
var disableOpSupervision = scopedDiscard(withRuntimeFlagsScoped(disable(OpSupervision)));
var disableRuntimeMetrics = scopedDiscard(withRuntimeFlagsScoped(disable(RuntimeMetrics)));
var disableWindDown = scopedDiscard(withRuntimeFlagsScoped(disable(WindDown)));
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
var parentSpan = (span4) => succeedContext(make8(spanTag, span4));
var span2 = (name, options) => {
  options = addSpanStackTrace(options);
  return scoped3(spanTag, (options == null ? void 0 : options.onEnd) ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer2((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options));
};
var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

// node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll5 = catchAll3;
var catchAllCause5 = catchAllCause3;
var context6 = context4;
var die9 = die7;
var dieSync5 = dieSync3;
var discard2 = discard;
var effect = fromEffect4;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty42 = empty40;
var extendScope2 = extendScope;
var fail13 = fail10;
var failSync6 = failSync4;
var failCause11 = failCause8;
var failCauseSync6 = failCauseSync4;
var flatMap19 = flatMap17;
var flatten14 = flatten12;
var fresh2 = fresh;
var fromFunction3 = fromFunction;
var launch2 = launch;
var map27 = map24;
var mapError6 = mapError4;
var match21 = match16;
var matchCause5 = matchCause3;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll6 = mergeAll4;
var orDie5 = orDie3;
var orElse9 = orElse7;
var passthrough3 = passthrough;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally3 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry4 = retry2;
var scope5 = scope3;
var scoped5 = scoped3;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service3 = service2;
var succeed14 = succeed10;
var succeedContext2 = succeedContext;
var suspend5 = suspend3;
var sync9 = sync6;
var syncContext2 = syncContext;
var tap6 = tap4;
var tapError5 = tapError3;
var tapErrorCause5 = tapErrorCause3;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith13 = zipWith10;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add3(clockTag, clock3)));
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRandom = (random6) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add3(randomTag, random6)));
var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap12(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache));
var setScheduler = (scheduler2) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler2));
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService4 = dual(3, (layer, tag5, f2) => provide3(layer, map27(context6(), (c) => add3(c, tag5, f2(unsafeGet3(c, tag5))))));

// node_modules/effect/dist/esm/PubSub.js
var PubSub_exports = {};
__export(PubSub_exports, {
  awaitShutdown: () => awaitShutdown3,
  bounded: () => bounded4,
  capacity: () => capacity4,
  dropping: () => dropping3,
  isEmpty: () => isEmpty17,
  isFull: () => isFull4,
  isShutdown: () => isShutdown3,
  publish: () => publish2,
  publishAll: () => publishAll2,
  shutdown: () => shutdown3,
  size: () => size22,
  sliding: () => sliding3,
  subscribe: () => subscribe2,
  unbounded: () => unbounded4
});

// node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var _a55, _b17, _c3;
var QueueImpl = class extends (_c3 = Class3, _b17 = EnqueueTypeId, _a55 = DequeueTypeId, _c3) {
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    __publicField(this, "queue");
    __publicField(this, "takers");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, _b17, enqueueVariance);
    __publicField(this, _a55, dequeueVariance);
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.queue.length() - length3(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map14(this.size, (size45) => size45 <= 0);
  }
  get isFull() {
    return map14(this.size, (size45) => size45 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set3(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value10) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value10);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value10);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value10) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value10);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value10);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value10], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const values15 = fromIterable2(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable2(unsafePollN(this.takers, values15.length)) : empty4;
      const [forTakers, remaining] = pipe(values15, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty2(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get7(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values15 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable3(values15);
      });
    });
  }
  takeUpTo(max14) {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values15 = this.queue.pollUpTo(max14);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable3(values15);
    }));
  }
  takeBetween(min11, max14) {
    return suspend(() => takeRemainderLoop(this, min11, max14, empty7()));
  }
};
var takeRemainderLoop = (self, min11, max14, acc) => {
  if (max14 < min11) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max14), flatMap12((bs) => {
    const remaining = min11 - bs.length;
    if (remaining === 1) {
      return pipe(take5(self), map14((b) => pipe(acc, appendAll3(bs), append3(b))));
    }
    if (remaining > 1) {
      return pipe(take5(self), flatMap12((b) => takeRemainderLoop(self, remaining - 1, max14 - bs.length - 1, pipe(acc, appendAll3(bs), append3(b)))));
    }
    return succeed(pipe(acc, appendAll3(bs)));
  }));
};
var isQueue = (u) => isEnqueue(u) && isDequeue(u);
var isEnqueue = (u) => hasProperty(u, EnqueueTypeId);
var isDequeue = (u) => hasProperty(u, DequeueTypeId);
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap12((queue) => make61(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap12((queue) => make61(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap12((queue) => make61(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap12((queue) => make61(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake13 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make61 = (queue, strategy) => pipe(deferredMake(), map14((deferred) => unsafeMake13(queue, unbounded(), deferred, make15(false), strategy)));
var _a56;
_a56 = BackingQueueTypeId;
var BackingQueueFromMutableQueue = class {
  constructor(mutable3) {
    __publicField(this, "mutable");
    __publicField(this, _a56, backingQueueVariance);
    this.mutable = mutable3;
  }
  poll(def) {
    return poll2(this.mutable, def);
  }
  pollUpTo(limit2) {
    return pollUpTo(this.mutable, limit2);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element2) {
    return offer(this.mutable, element2);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length3(this.mutable);
  }
};
var backingQueueFromMutableQueue = (mutable3) => new BackingQueueFromMutableQueue(mutable3);
var capacity2 = (self) => self.capacity();
var size20 = (self) => self.size;
var isFull2 = (self) => self.isFull;
var isEmpty15 = (self) => self.isEmpty;
var isShutdown = (self) => self.isShutdown;
var awaitShutdown = (self) => self.awaitShutdown;
var shutdown = (self) => self.shutdown;
var offer2 = dual(2, (self, value10) => self.offer(value10));
var unsafeOffer = dual(2, (self, value10) => self.unsafeOffer(value10));
var offerAll2 = dual(2, (self, iterable) => self.offerAll(iterable));
var poll5 = (self) => map14(self.takeUpTo(1), head3);
var take5 = (self) => self.take;
var takeAll = (self) => self.takeAll;
var takeUpTo = dual(2, (self, max14) => self.takeUpTo(max14));
var takeBetween = dual(3, (self, min11, max14) => self.takeBetween(min11, max14));
var takeN = dual(2, (self, n) => self.takeBetween(n, n));
var backPressureStrategy = () => new BackPressureStrategy();
var droppingStrategy = () => new DroppingStrategy();
var slidingStrategy = () => new SlidingStrategy();
var _a57;
_a57 = QueueStrategyTypeId;
var BackPressureStrategy = class {
  constructor() {
    __publicField(this, _a57, queueStrategyVariance);
    __publicField(this, "putters", unbounded());
  }
  surplusSize() {
    return length3(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty10(this.putters) && !isEmpty10(takers)) {
      const taker = poll2(takers, void 0);
      const putter = poll2(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap12((fiberId5) => pipe(sync(() => unsafePollAll(this.putters)), flatMap12((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId5), asVoid2) : void_3, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown9) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get7(isShutdown9) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll2(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend3(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable2(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value10 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value10, deferred, true]));
      } else {
        pipe(this.putters, offer([value10, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter5(([, _]) => _ !== deferred)));
  }
};
var _a58;
_a58 = QueueStrategyTypeId;
var DroppingStrategy = class {
  constructor() {
    __publicField(this, _a58, queueStrategyVariance);
  }
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_3;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
var _a59;
_a59 = QueueStrategyTypeId;
var SlidingStrategy = class {
  constructor() {
    __publicField(this, _a59, queueStrategyVariance);
  }
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_3;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next6;
    let offering = true;
    while (!(next6 = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next6.value);
    }
  }
};
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as18) => {
  return pipe(queue, offerAll(as18));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max14) => {
  return pipe(queue, pollUpTo(max14));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter5((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element2 = queue.poll(EmptyMutableQueue);
      if (element2 !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element2);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend3(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty10(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, /* @__PURE__ */ new Set());
  }
  const set26 = subscribers.get(subscription);
  set26.add(pollers);
};
var removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set26 = subscribers.get(subscription);
  set26.delete(pollers);
  if (set26.size === 0) {
    subscribers.delete(subscription);
  }
};
var bounded3 = (capacity10) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity10);
  return makePubSub(pubsub, new BackPressureStrategy2());
});
var dropping2 = (capacity10) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity10);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var sliding2 = (capacity10) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity10);
  return makePubSub(pubsub, new SlidingStrategy2());
});
var unbounded3 = (options) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var capacity3 = (self) => self.capacity();
var size21 = (self) => self.size;
var isFull3 = (self) => self.isFull;
var isEmpty16 = (self) => self.isEmpty;
var shutdown2 = (self) => self.shutdown;
var isShutdown2 = (self) => self.isShutdown;
var awaitShutdown2 = (self) => self.awaitShutdown;
var publish = dual(2, (self, value10) => self.publish(value10));
var publishAll = dual(2, (self, elements) => self.publishAll(elements));
var subscribe = (self) => self.subscribe;
var makeBoundedPubSub = (capacity10) => {
  const options = typeof capacity10 === "number" ? {
    capacity: capacity10
  } : capacity10;
  ensureCapacity(options.capacity);
  const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : void 0;
  if (options.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options.capacity) === options.capacity) {
    return new BoundedPubSubPow2(options.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options.capacity, replayBuffer);
  }
};
var makeUnboundedPubSub = (options) => new UnboundedPubSub((options == null ? void 0 : options.replay) ? new ReplayBuffer(options.replay) : void 0);
var makeSubscription = (pubsub, subscribers, strategy) => map14(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make15(false), strategy));
var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());
var BoundedPubSubArb = class {
  constructor(capacity10, replayBuffer) {
    __publicField(this, "capacity");
    __publicField(this, "replayBuffer");
    __publicField(this, "array");
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribers");
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribersIndex", 0);
    this.capacity = capacity10;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity10
    });
    this.subscribers = Array.from({
      length: capacity10
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value10) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index3 = this.publisherIndex % this.capacity;
      this.array[index3] = value10;
      this.subscribers[index3] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value10);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty7();
    }
    const chunk7 = fromIterable3(elements);
    const n = chunk7.length;
    const size45 = this.publisherIndex - this.subscribersIndex;
    const available3 = this.capacity - size45;
    const forPubSub = Math.min(n, available3);
    if (forPubSub === 0) {
      return chunk7;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet4(chunk7, iteratorIndex++);
      const index3 = this.publisherIndex % this.capacity;
      this.array[index3] = a;
      this.subscribers[index3] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop3(chunk7, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index3 = this.subscribersIndex % this.capacity;
      this.array[index3] = AbsentValue;
      this.subscribers[index3] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubArbSubscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index3 = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index3];
      this.self.subscribers[index3] -= 1;
      if (this.self.subscribers[index3] === 0) {
        this.self.array[index3] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty7();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size45 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size45);
    if (toPoll <= 0) {
      return empty7();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index3 = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index3];
      this.self.subscribers[index3] -= 1;
      if (this.self.subscribers[index3] === 0) {
        this.self.array[index3] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index3 = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index3] -= 1;
        if (this.self.subscribers[index3] === 0) {
          this.self.array[index3] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubPow2 = class {
  constructor(capacity10, replayBuffer) {
    __publicField(this, "capacity");
    __publicField(this, "replayBuffer");
    __publicField(this, "array");
    __publicField(this, "mask");
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribers");
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribersIndex", 0);
    this.capacity = capacity10;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity10
    });
    this.mask = capacity10 - 1;
    this.subscribers = Array.from({
      length: capacity10
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value10) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index3 = this.publisherIndex & this.mask;
      this.array[index3] = value10;
      this.subscribers[index3] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value10);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty7();
    }
    const chunk7 = fromIterable3(elements);
    const n = chunk7.length;
    const size45 = this.publisherIndex - this.subscribersIndex;
    const available3 = this.capacity - size45;
    const forPubSub = Math.min(n, available3);
    if (forPubSub === 0) {
      return chunk7;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet4(chunk7, iteratorIndex++);
      const index3 = this.publisherIndex & this.mask;
      this.array[index3] = elem;
      this.subscribers[index3] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop3(chunk7, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index3 = this.subscribersIndex & this.mask;
      this.array[index3] = AbsentValue;
      this.subscribers[index3] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubPow2Subscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index3 = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index3];
      this.self.subscribers[index3] -= 1;
      if (this.self.subscribers[index3] === 0) {
        this.self.array[index3] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty7();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size45 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size45);
    if (toPoll <= 0) {
      return empty7();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index3 = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index3];
      this.self.subscribers[index3] -= 1;
      if (this.self.subscribers[index3] === 0) {
        this.self.array[index3] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index3 = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index3] -= 1;
        if (this.self.subscribers[index3] === 0) {
          this.self.array[index3] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubSingle = class {
  constructor(replayBuffer) {
    __publicField(this, "replayBuffer");
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribers", 0);
    __publicField(this, "value", AbsentValue);
    __publicField(this, "capacity", 1);
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value10) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value10;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value10);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty7();
    }
    const chunk7 = fromIterable3(elements);
    if (isEmpty2(chunk7)) {
      return chunk7;
    }
    if (this.publish(unsafeHead2(chunk7))) {
      return drop3(chunk7, 1);
    } else {
      return chunk7;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubSingleSubscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty7();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of3(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
};
var UnboundedPubSub = class {
  constructor(replayBuffer) {
    __publicField(this, "replayBuffer");
    __publicField(this, "publisherHead", {
      value: AbsentValue,
      subscribers: 0,
      next: null
    });
    __publicField(this, "publisherTail", this.publisherHead);
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribersIndex", 0);
    __publicField(this, "capacity", Number.MAX_SAFE_INTEGER);
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value10) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value: value10,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value10);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty7();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
var UnboundedPubSubSubscription = class {
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberHead");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty61 = true;
    let loop5 = true;
    while (loop5) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop5 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty61 = false;
          loop5 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty61;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop5 = true;
    let polled = default_;
    while (loop5) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop5 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop5 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};
var _a60, _b18;
var SubscriptionImpl = class extends (_b18 = Class3, _a60 = DequeueTypeId, _b18) {
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    __publicField(this, "pubsub");
    __publicField(this, "subscribers");
    __publicField(this, "subscription");
    __publicField(this, "pollers");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, "replayWindow");
    __publicField(this, _a60, dequeueVariance);
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map14(this.size, (size45) => size45 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set3(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight2(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty10(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const as18 = isEmpty10(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty7();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll3(this.replayWindow.takeAll(), as18));
      }
      return succeed(as18);
    });
  }
  takeUpTo(max14) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = void 0;
      if (this.replayWindow.remaining >= max14) {
        const as19 = this.replayWindow.takeN(max14);
        return succeed(as19);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max14 = max14 - replay.length;
      }
      const as18 = isEmpty10(this.pollers) ? unsafePollN2(this.subscription, max14) : empty7();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll3(replay, as18)) : succeed(as18);
    });
  }
  takeBetween(min11, max14) {
    return suspend(() => takeRemainderLoop2(this, min11, max14, empty7()));
  }
};
var takeRemainderLoop2 = (self, min11, max14, acc) => {
  if (max14 < min11) {
    return succeed(acc);
  }
  return pipe(self.takeUpTo(max14), flatMap12((bs) => {
    const remaining = min11 - bs.length;
    if (remaining === 1) {
      return pipe(self.take, map14((b) => pipe(acc, appendAll3(bs), append3(b))));
    }
    if (remaining > 1) {
      return pipe(self.take, flatMap12((b) => takeRemainderLoop2(self, remaining - 1, max14 - bs.length - 1, pipe(acc, appendAll3(bs), append3(b)))));
    }
    return succeed(pipe(acc, appendAll3(bs)));
  }));
};
var _a61, _b19;
_b19 = EnqueueTypeId, _a61 = DequeueTypeId;
var PubSubImpl = class {
  constructor(pubsub, subscribers, scope6, shutdownHook, shutdownFlag, strategy) {
    __publicField(this, "pubsub");
    __publicField(this, "subscribers");
    __publicField(this, "scope");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, _b19, enqueueVariance);
    __publicField(this, _a61, dequeueVariance);
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope6;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.pubsub.size());
  }
  get isFull() {
    return map14(this.size, (size45) => size45 === this.capacity());
  }
  get isEmpty() {
    return map14(this.size, (size45) => size45 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set3(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  publish(value10) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value10)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of3(value10), this.shutdownFlag);
    });
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value10) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value10)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty2(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire4 = tap2(all9([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple7) => tuple7[0].addFinalizer(() => tuple7[1].shutdown));
    return map14(acquireRelease2(acquire4, (tuple7, exit4) => tuple7[0].close(exit4)), (tuple7) => tuple7[1]);
  }
  offer(value10) {
    return this.publish(value10);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makePubSub = (pubsub, strategy) => flatMap12(scopeMake2(), (scope6) => map14(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope6, deferred, make15(false), strategy)));
var unsafeMakePubSub = (pubsub, subscribers, scope6, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope6, shutdownHook, shutdownFlag, strategy);
var ensureCapacity = (capacity10) => {
  if (capacity10 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity10}`);
  }
};
var unsafeCompleteDeferred2 = (deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll2 = (queue, as18) => {
  return pipe(queue, offerAll(as18));
};
var unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
var unsafePollN2 = (subscription, max14) => {
  return subscription.pollUpTo(max14);
};
var unsafePublishAll = (pubsub, as18) => {
  return pubsub.publishAll(as18);
};
var unsafeRemove2 = (queue, value10) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter5((elem) => elem !== value10)));
};
var BackPressureStrategy2 = class {
  constructor() {
    __publicField(this, "publishers", unbounded());
  }
  get shutdown() {
    return flatMap12(fiberId, (fiberId5) => flatMap12(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last8]) => last8 ? pipe(deferredInterruptWith(deferred, fiberId5), asVoid2) : void_3, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown9) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get7(isShutdown9) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend3(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next6 = iterator.next();
    if (!next6.done) {
      while (1) {
        const value10 = next6.value;
        next6 = iterator.next();
        if (next6.done) {
          pipe(this.publishers, offer([value10, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value10, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter5(([_, a]) => a !== deferred)));
  }
};
var DroppingStrategy2 = class {
  get shutdown() {
    return void_3;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
};
var SlidingStrategy2 = class {
  get shutdown() {
    return void_3;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next6 = it.next();
    if (!next6.done && pubsub.capacity > 0) {
      let a = next6.value;
      let loop5 = true;
      while (loop5) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next6 = it.next()) && !next6.done) {
          a = next6.value;
        } else if (pub) {
          loop5 = false;
        }
      }
    }
  }
};
var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll2(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty10(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend3(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
};
var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
};
var ReplayBuffer = class {
  constructor(capacity10) {
    __publicField(this, "capacity");
    __publicField(this, "head", {
      value: AbsentValue,
      next: null
    });
    __publicField(this, "tail", this.head);
    __publicField(this, "size", 0);
    __publicField(this, "index", 0);
    this.capacity = capacity10;
  }
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as18) {
    for (const a of as18) {
      this.offer(a);
    }
  }
};
var ReplayWindowImpl = class {
  constructor(buffer7) {
    __publicField(this, "buffer");
    __publicField(this, "head");
    __publicField(this, "index");
    __publicField(this, "remaining");
    this.buffer = buffer7;
    this.index = buffer7.index;
    this.remaining = buffer7.size;
    this.head = buffer7.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return void 0;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value10 = this.head.value;
    this.head = this.head.next;
    return value10;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty7();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0; i < len; i++) {
      const value10 = this.head.value;
      this.head = this.head.next;
      items[i] = value10;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
};
var emptyReplayWindow = {
  remaining: 0,
  take: () => void 0,
  takeN: () => empty7(),
  takeAll: () => empty7()
};

// node_modules/effect/dist/esm/PubSub.js
var bounded4 = bounded3;
var dropping3 = dropping2;
var sliding3 = sliding2;
var unbounded4 = unbounded3;
var capacity4 = capacity3;
var size22 = size21;
var isFull4 = isFull3;
var isEmpty17 = isEmpty16;
var shutdown3 = shutdown2;
var isShutdown3 = isShutdown2;
var awaitShutdown3 = awaitShutdown2;
var publish2 = publish;
var publishAll2 = publishAll;
var subscribe2 = subscribe;

// node_modules/effect/dist/esm/Queue.js
var Queue_exports = {};
__export(Queue_exports, {
  BackingQueueTypeId: () => BackingQueueTypeId2,
  DequeueTypeId: () => DequeueTypeId2,
  EnqueueTypeId: () => EnqueueTypeId2,
  QueueStrategyTypeId: () => QueueStrategyTypeId2,
  awaitShutdown: () => awaitShutdown4,
  backPressureStrategy: () => backPressureStrategy2,
  bounded: () => bounded5,
  capacity: () => capacity5,
  dropping: () => dropping4,
  droppingStrategy: () => droppingStrategy2,
  isDequeue: () => isDequeue2,
  isEmpty: () => isEmpty18,
  isEnqueue: () => isEnqueue2,
  isFull: () => isFull5,
  isQueue: () => isQueue2,
  isShutdown: () => isShutdown4,
  make: () => make62,
  offer: () => offer3,
  offerAll: () => offerAll3,
  poll: () => poll6,
  shutdown: () => shutdown4,
  size: () => size23,
  sliding: () => sliding4,
  slidingStrategy: () => slidingStrategy2,
  take: () => take6,
  takeAll: () => takeAll2,
  takeBetween: () => takeBetween2,
  takeN: () => takeN2,
  takeUpTo: () => takeUpTo2,
  unbounded: () => unbounded5,
  unsafeOffer: () => unsafeOffer2
});
var EnqueueTypeId2 = EnqueueTypeId;
var DequeueTypeId2 = DequeueTypeId;
var QueueStrategyTypeId2 = QueueStrategyTypeId;
var BackingQueueTypeId2 = BackingQueueTypeId;
var isQueue2 = isQueue;
var isDequeue2 = isDequeue;
var isEnqueue2 = isEnqueue;
var backPressureStrategy2 = backPressureStrategy;
var droppingStrategy2 = droppingStrategy;
var slidingStrategy2 = slidingStrategy;
var make62 = make61;
var bounded5 = bounded2;
var dropping4 = dropping;
var sliding4 = sliding;
var unbounded5 = unbounded2;
var capacity5 = capacity2;
var size23 = size20;
var isEmpty18 = isEmpty15;
var isFull5 = isFull2;
var isShutdown4 = isShutdown;
var awaitShutdown4 = awaitShutdown;
var shutdown4 = shutdown;
var offer3 = offer2;
var unsafeOffer2 = unsafeOffer;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take6 = take5;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_CONTINUE2;
  return op;
};
var Close = (value10) => {
  const op = Object.create(proto4);
  op._tag = OP_CLOSE;
  op.value = value10;
  return op;
};
var Yield2 = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_YIELD2;
  return op;
};
var isChildExecutorDecision = (u) => hasProperty(u, ChildExecutorDecisionTypeId);
var isContinue3 = (self) => self._tag === OP_CONTINUE2;
var isClose = (self) => self._tag === OP_CLOSE;
var isYield = (self) => self._tag === OP_YIELD2;
var match22 = dual(2, (self, {
  onClose,
  onContinue,
  onYield
}) => {
  switch (self._tag) {
    case OP_CONTINUE2: {
      return onContinue();
    }
    case OP_CLOSE: {
      return onClose(self.value);
    }
    case OP_YIELD2: {
      return onYield();
    }
  }
});

// node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _,
  /* c8 ignore next */
  _OutErr2: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone2: (_) => _
};
var _a62;
_a62 = ContinuationTypeId;
var ContinuationKImpl = class {
  constructor(onSuccess, onHalt) {
    __publicField(this, "onSuccess");
    __publicField(this, "onHalt");
    __publicField(this, "_tag", OP_CONTINUATION_K);
    __publicField(this, _a62, continuationVariance);
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit4) {
    return isFailure2(exit4) ? this.onHalt(exit4.cause) : this.onSuccess(exit4.value);
  }
};
var _a63;
_a63 = ContinuationTypeId;
var ContinuationFinalizerImpl = class {
  constructor(finalizer3) {
    __publicField(this, "finalizer");
    __publicField(this, "_tag", OP_CONTINUATION_FINALIZER);
    __publicField(this, _a63, continuationVariance);
    this.finalizer = finalizer3;
  }
};

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};
var PullAfterAllEnqueued = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_ALL_ENQUEUED;
  op.emitSeparator = emitSeparator;
  return op;
};
var isUpstreamPullStrategy = (u) => hasProperty(u, UpstreamPullStrategyTypeId);
var isPullAfterNext = (self) => self._tag === OP_PULL_AFTER_NEXT;
var isPullAfterAllEnqueued = (self) => self._tag === OP_PULL_AFTER_ALL_ENQUEUED;
var match23 = dual(2, (self, {
  onAllEnqueued,
  onNext
}) => {
  switch (self._tag) {
    case OP_PULL_AFTER_NEXT: {
      return onNext(self.emitSeparator);
    }
    case OP_PULL_AFTER_ALL_ENQUEUED: {
      return onAllEnqueued(self.emitSeparator);
    }
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId3 = Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var proto6 = {
  [ChannelTypeId3]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId3) || isEffect2(u);
var acquireReleaseOut = dual(2, (self, release4) => {
  const op = Object.create(proto6);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = release4;
  return op;
});
var catchAllCause6 = dual(2, (self, f2) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(succeed15, f2);
  return op;
});
var collectElements = (self) => {
  return suspend6(() => {
    const builder = [];
    return flatMap20(pipeTo(self, collectElementsReader(builder)), (value10) => sync10(() => [fromIterable3(builder), value10]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap20(sync10(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail14,
  onDone: succeedNow
});
var concatAll = (channels) => concatAllWith(channels, constVoid, constVoid);
var concatAllWith = (channels, f2, g) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f2;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = dual(4, (self, f2, g, h2) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h2;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self;
  op.k = f2;
  return op;
});
var concatMapWithCustom = dual(6, (self, f2, g, h2, onPull, onEmit) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h2;
  op.onPull = onPull;
  op.onEmit = onEmit;
  op.value = () => self;
  op.k = f2;
  return op;
});
var embedInput = dual(2, (self, input) => {
  const op = Object.create(proto6);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
var ensuringWith = dual(2, (self, finalizer3) => {
  const op = Object.create(proto6);
  op._tag = OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer3;
  return op;
});
var fail14 = (error4) => failCause12(fail8(error4));
var failSync7 = (evaluate4) => failCauseSync7(() => fail8(evaluate4()));
var failCause12 = (cause3) => failCauseSync7(() => cause3);
var failCauseSync7 = (evaluate4) => {
  const op = Object.create(proto6);
  op._tag = OP_FAIL3;
  op.error = evaluate4;
  return op;
};
var flatMap20 = dual(2, (self, f2) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(f2, failCause12);
  return op;
});
var foldCauseChannel = dual(2, (self, options) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
var fromEffect5 = (effect4) => {
  const op = Object.create(proto6);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect4;
  return op;
};
var pipeTo = dual(2, (self, that) => {
  const op = Object.create(proto6);
  op._tag = OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op;
});
var provideContext4 = dual(2, (self, env) => {
  const op = Object.create(proto6);
  op._tag = OP_PROVIDE2;
  op.context = () => env;
  op.inner = self;
  return op;
});
var readOrFail = (error4) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = succeed15;
  op.done = new ContinuationKImpl(() => fail14(error4), () => fail14(error4));
  return op;
};
var readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options.onFailure,
    onRight: failCause12
  }),
  onDone: options.onDone
});
var readWithCause = (options) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
};
var succeed15 = (value10) => sync10(() => value10);
var succeedNow = (result) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend6 = (evaluate4) => {
  const op = Object.create(proto6);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate4;
  return op;
};
var sync10 = (evaluate4) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate4;
  return op;
};
var void_8 = succeedNow(void 0);
var write = (out) => {
  const op = Object.create(proto6);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto7);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto7);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect6 = (effect4) => {
  const op = Object.create(proto7);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect4;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone3) => {
  const op = Object.create(proto7);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone3;
  return op;
};
var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore3(self.effect) : void 0;

// node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  constructor(childExecutor, parentSubexecutor, onEmit) {
    __publicField(this, "childExecutor");
    __publicField(this, "parentSubexecutor");
    __publicField(this, "onEmit");
    __publicField(this, "_tag", OP_PULL_FROM_CHILD);
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.childExecutor.close(exit4);
    const fin2 = this.parentSubexecutor.close(exit4);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith12(exit3(fin1), exit3(fin2), (exit1, exit22) => pipe(exit1, zipRight3(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    __publicField(this, "upstreamExecutor");
    __publicField(this, "createChild");
    __publicField(this, "lastDone");
    __publicField(this, "activeChildExecutors");
    __publicField(this, "combineChildResults");
    __publicField(this, "combineWithChildResult");
    __publicField(this, "onPull");
    __publicField(this, "onEmit");
    __publicField(this, "_tag", OP_PULL_FROM_UPSTREAM);
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next6) => {
      if (acc !== void 0 && next6 !== void 0) {
        return zipWith12(acc, exit3(next6), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next6 !== void 0) {
        return exit3(next6);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    __publicField(this, "upstreamExecutor");
    __publicField(this, "lastDone");
    __publicField(this, "activeChildExecutors");
    __publicField(this, "upstreamDone");
    __publicField(this, "combineChildResults");
    __publicField(this, "combineWithChildResult");
    __publicField(this, "onPull");
    __publicField(this, "_tag", OP_DRAIN_CHILD_EXECUTORS);
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next6) => {
      if (acc !== void 0 && next6 !== void 0) {
        return zipWith12(acc, exit3(next6), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next6 !== void 0) {
        return exit3(next6);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  constructor(value10, next6) {
    __publicField(this, "value");
    __publicField(this, "next");
    __publicField(this, "_tag", OP_EMIT3);
    this.value = value10;
    this.next = next6;
  }
  close(exit4) {
    const result = this.next.close(exit4);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value10) => {
  const op = Object.create(proto8);
  op._tag = OP_PULLED;
  op.value = value10;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto8);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};
var isUpstreamPullRequest = (u) => hasProperty(u, UpstreamPullRequestTypeId);
var isPulled = (self) => self._tag === OP_PULLED;
var isNoUpstream = (self) => self._tag === OP_NO_UPSTREAM;
var match24 = dual(2, (self, {
  onNoUpstream,
  onPulled
}) => {
  switch (self._tag) {
    case OP_PULLED: {
      return onPulled(self.value);
    }
    case OP_NO_UPSTREAM: {
      return onNoUpstream(self.activeDownstreamCount);
    }
  }
});

// node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    __publicField(this, "_activeSubexecutor");
    __publicField(this, "_cancelled");
    __publicField(this, "_closeLastSubstream");
    __publicField(this, "_currentChannel");
    __publicField(this, "_done");
    __publicField(this, "_doneStack", []);
    __publicField(this, "_emitted");
    __publicField(this, "_executeCloseLastSubstream");
    __publicField(this, "_input");
    __publicField(this, "_inProgressFinalizer");
    __publicField(this, "_providedEnv");
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect5(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = () => flatMap18(bridgeInput.awaitRead(), () => suspend4(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match7(inputExecutor.getDone(), {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: (value10) => bridgeInput.done(value10)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap18(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  }));
                  result = fromEffect6(flatMap18(forkDaemon3(interruptible4(drainer())), (fiber) => sync8(() => this.addFinalizer((exit4) => flatMap18(interrupt7(fiber), () => suspend4(() => {
                    const effect4 = this.restorePipe(exit4, inputExecutor);
                    return effect4 !== void 0 ? effect4 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync8(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight7(effect4));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value10) => channel.k(value10), void 0, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value10) => channel.onEmit(value10));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_8;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect6(matchCauseEffect3(effect4, {
                  onFailure: (cause3) => {
                    const state = this.doneHalt(cause3);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value10) => {
                    const state = this.doneSucceed(value10);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit4) => {
                  const effect4 = this.restorePipe(exit4, previousInput);
                  return effect4 !== void 0 ? effect4 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync8(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read3 = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read3.more(emitted);
                  } catch (error4) {
                    this._currentChannel = read3.done.onExit(die4(error4));
                  }
                  return void 0;
                }, (exit4) => {
                  const onExit4 = (exit5) => {
                    return read3.done.onExit(exit5);
                  };
                  this._currentChannel = onExit4(exit4);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error4) {
          this._currentChannel = failCause12(die6(error4));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit4) {
    this._cancelled = exit4;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer3) {
    this._inProgressFinalizer = finalizer3;
  }
  popAllFinalizers(exit4) {
    const finalizers = [];
    let next6 = this._doneStack.pop();
    while (next6) {
      if (next6._tag === "ContinuationFinalizer") {
        finalizers.push(next6.finalizer);
      }
      next6 = this._doneStack.pop();
    }
    const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit4);
    this.storeInProgressFinalizer(effect4);
    return effect4;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit4, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect4 = currInput.close(exit4);
      return effect4;
    }
    return _void;
  }
  close(exit4) {
    let runInProgressFinalizers = void 0;
    const finalizer3 = this._inProgressFinalizer;
    if (finalizer3 !== void 0) {
      runInProgressFinalizers = pipe(finalizer3, ensuring4(sync8(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit4);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring4(sync8(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit4);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit3(ifNotNull(closeSubexecutors)),
      zip12(exit3(ifNotNull(runInProgressFinalizers))),
      zip12(exit3(ifNotNull(closeSelf))),
      map26(([[exit1, exit22], exit32]) => pipe(exit1, zipRight3(exit22), zipRight3(exit32))),
      uninterruptible3,
      // TODO: remove
      flatMap18((exit5) => suspend4(() => exit5))
    );
  }
  doneSucceed(value10) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value10);
      this._currentChannel = void 0;
      return Done2();
    }
    const head13 = this._doneStack[this._doneStack.length - 1];
    if (head13._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head13.onSuccess(value10);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value10);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f2) => f2.finalizer), succeed3(value10));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring4(sync8(() => this.clearInProgressFinalizer())), uninterruptible3, flatMap18(() => sync8(() => this.doneSucceed(value10))));
    return fromEffect6(effect4);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const head13 = this._doneStack[this._doneStack.length - 1];
    if (head13._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head13.onHalt(cause3);
      } catch (error4) {
        this._currentChannel = failCause12(die6(error4));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f2) => f2.finalizer), failCause3(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring4(sync8(() => this.clearInProgressFinalizer())), uninterruptible3, flatMap18(() => sync8(() => this.doneHalt(cause3))));
    return fromEffect6(effect4);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect4 = uninterruptible3(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync8(() => {
        this._currentChannel = failCause12(cause3);
      }),
      onSuccess: (out) => sync8(() => {
        this.addFinalizer((exit4) => this.provide(bracketOut.finalizer(out, exit4)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect6(effect4);
  }
  provide(effect4) {
    if (this._providedEnv === void 0) {
      return effect4;
    }
    return pipe(effect4, provide2(this._providedEnv));
  }
  runEnsuring(ensuring14) {
    this.addFinalizer(ensuring14.finalizer);
    this._currentChannel = ensuring14.channel;
  }
  addFinalizer(f2) {
    this._doneStack.push(new ContinuationFinalizerImpl(f2));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit4) {
    const state = match7(exit4, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value10) => this.doneSucceed(value10)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach16((closeFunc) => pipe(sync8(() => closeFunc(subexecutorDone)), flatMap18((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match7({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value10) => this.doneSucceed(value10)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match7({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit4) => parentSubexecutor.close(exit4), (exit4) => childExecutor.close(exit4));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect4) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight7(effect4));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map26(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit4) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain7 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map26(() => this.replaceSubexecutor(drain7)));
        }
        this.replaceSubexecutor(drain7);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit4, map15((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit5) => subexecutor.upstreamExecutor.close(exit5));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed13(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit4) => subexecutor.upstreamExecutor.close(exit4));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = (effect4) => effect4 !== void 0 ? effect4 : _void;
var runFinalizers = (finalizers, exit4) => {
  return pipe(forEach16(finalizers, (fin) => exit3(fin(exit4))), map26((exits) => pipe(all7(exits), getOrElse2(() => void_4))), flatMap18((exit5) => suspend4(() => exit5)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read3 = () => {
    const current2 = readStack.pop();
    if (current2 === void 0 || current2.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current2.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current2.onEmit(current2.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend4(() => read3());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current2.onDone(current2.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend4(() => read3());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current2);
        return pipe(current2.onEffect(state.effect), catchAllCause4((cause3) => suspend4(() => {
          const doneEffect = current2.onDone(failCause3(cause3));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_READ2: {
        readStack.push(current2);
        readStack.push(state);
        return suspend4(() => read3());
      }
    }
  };
  return read3();
};
var runIn = dual(2, (self, scope6) => {
  const run10 = (channelDeferred, scopeDeferred, scope7) => acquireUseRelease3(sync8(() => new ChannelExecutor(self, void 0, identity)), (exec) => suspend4(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight7(_await(channelDeferred)), zipLeft7(_await(scopeDeferred)))), (exec, exit4) => {
    const finalize = exec.close(exit4);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause4(finalize, (cause3) => addFinalizer3(scope7, failCause10(cause3)));
  });
  return uninterruptibleMask3((restore) => all11([fork3(scope6, sequential3), make24(), make24()]).pipe(flatMap18(([child, channelDeferred, scopeDeferred]) => restore(run10(channelDeferred, scopeDeferred, child)).pipe(forkIn3(scope6), flatMap18((fiber) => scope6.addFinalizer((exit4) => {
    const interruptors3 = isFailure2(exit4) ? interruptors2(exit4.cause) : void 0;
    return isDone(channelDeferred).pipe(flatMap18((isDone9) => isDone9 ? succeed2(scopeDeferred, void 0).pipe(zipRight7(_await3(fiber)), zipRight7(inheritAll2(fiber))) : succeed2(scopeDeferred, void 0).pipe(zipRight7(interruptors3 && size9(interruptors3) > 0 ? interruptAs(fiber, combineAll4(interruptors3)) : interrupt7(fiber)), zipRight7(inheritAll2(fiber)))));
  }).pipe(zipRight7(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap18(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend4(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause10);
    }
  }
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Done3 = (effect4) => {
  const op = Object.create(proto9);
  op._tag = OP_DONE4;
  op.effect = effect4;
  return op;
};
var Await = (f2) => {
  const op = Object.create(proto9);
  op._tag = OP_AWAIT;
  op.f = f2;
  return op;
};
var AwaitConst = (effect4) => Await(() => effect4);
var isMergeDecision = (u) => hasProperty(u, MergeDecisionTypeId);
var match25 = dual(2, (self, {
  onAwait,
  onDone: onDone3
}) => {
  const op = self;
  switch (op._tag) {
    case OP_DONE4:
      return onDone3(op.effect);
    case OP_AWAIT:
      return onAwait(op.f);
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto10);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f2) => {
  const op = Object.create(proto10);
  op._tag = OP_LEFT_DONE;
  op.f = f2;
  return op;
};
var RightDone = (f2) => {
  const op = Object.create(proto10);
  op._tag = OP_RIGHT_DONE;
  op.f = f2;
  return op;
};
var isMergeState = (u) => hasProperty(u, MergeStateTypeId);
var isBothRunning = (self) => {
  return self._tag === OP_BOTH_RUNNING;
};
var isLeftDone = (self) => {
  return self._tag === OP_LEFT_DONE;
};
var isRightDone = (self) => {
  return self._tag === OP_RIGHT_DONE;
};
var match26 = dual(2, (self, {
  onBothRunning,
  onLeftDone,
  onRightDone
}) => {
  switch (self._tag) {
    case OP_BOTH_RUNNING: {
      return onBothRunning(self.left, self.right);
    }
    case OP_LEFT_DONE: {
      return onLeftDone(self.f);
    }
    case OP_RIGHT_DONE: {
      return onRightDone(self.f);
    }
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var isMergeStrategy = (u) => hasProperty(u, MergeStrategyTypeId);
var isBackPressure = (self) => self._tag === OP_BACK_PRESSURE;
var isBufferSliding = (self) => self._tag === OP_BUFFER_SLIDING;
var match27 = dual(2, (self, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
});
var stateDone = (done17) => ({
  _tag: OP_STATE_DONE2,
  done: done17
});
var SingleProducerAsyncInputImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    this.ref = ref;
  }
  awaitRead() {
    return flatten13(modify8(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId5) => this.error(interrupt6(fiberId5)));
  }
  done(value10) {
    return flatten13(modify8(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach16(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value10)), {
            discard: true
          }), stateDone(value10)];
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    }));
  }
  emit(element2) {
    return flatMap18(make24(), (deferred) => flatten13(modify8(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed2(notifyConsumer, right2(element2)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten13(modify8(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach16(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt8, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt8, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause3(map22(cause3, left2)), (elem) => succeed3(elem), (done17) => fail4(right2(done17)));
  }
  takeWith(onError6, onElement, onDone3) {
    return flatMap18(make24(), (deferred) => flatten13(modify8(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight7(succeed2(state.notifyProducer, void 0), matchCause4(_await(deferred), {
            onFailure: onError6,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause4(_await(deferred), {
            onFailure: onError6,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed13(onError6(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed13(onDone3(state.done)), state];
        }
      }
    })));
  }
};
var make63 = () => pipe(make24(), flatMap18((deferred) => make37(stateEmpty(deferred))), map26((ref) => new SingleProducerAsyncInputImpl(ref)));

// node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease4 = (acquire4, use2, release4) => flatMap20(fromEffect5(make37(() => _void)), (ref) => pipe(fromEffect5(uninterruptible3(tap5(acquire4, (a) => set7(ref, (exit4) => release4(a, exit4))))), flatMap20(use2), ensuringWith((exit4) => flatMap18(get13(ref), (f2) => f2(exit4)))));
var as9 = dual(2, (self, value10) => map28(self, () => value10));
var asVoid7 = (self) => map28(self, constVoid);
var buffer = (options) => suspend6(() => {
  const doBuffer = (empty61, isEmpty32, ref) => unwrap2(modify8(ref, (inElem) => isEmpty32(inElem) ? [readWith({
    onInput: (input) => flatMap20(write(input), () => doBuffer(empty61, isEmpty32, ref)),
    onFailure: (error4) => fail14(error4),
    onDone: (done17) => succeedNow(done17)
  }), inElem] : [flatMap20(write(inElem), () => doBuffer(empty61, isEmpty32, ref)), empty61]));
  return doBuffer(options.empty, options.isEmpty, options.ref);
});
var bufferChunk = (ref) => buffer({
  empty: empty7(),
  isEmpty: isEmpty2,
  ref
});
var catchAll6 = dual(2, (self, f2) => catchAllCause6(self, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f2,
  onRight: failCause12
})));
var concatMap = dual(2, (self, f2) => concatMapWith(self, f2, () => void 0, () => void 0));
var collect2 = dual(2, (self, pf) => {
  const collector = readWith({
    onInput: (out) => match2(pf(out), {
      onNone: () => collector,
      onSome: (out2) => flatMap20(write(out2), () => collector)
    }),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(self, collector);
});
var concatOut = (self) => concatAll(self);
var mapInput7 = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(inElem), () => reader),
    onFailure: fail14,
    onDone: (done17) => succeedNow(f2(done17))
  });
  return pipeTo(reader, self);
});
var mapInputEffect2 = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(inElem), () => reader),
    onFailure: fail14,
    onDone: (done17) => fromEffect5(f2(done17))
  });
  return pipeTo(reader, self);
});
var mapInputError = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(inElem), () => reader),
    onFailure: (error4) => fail14(f2(error4)),
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputErrorEffect = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(inElem), () => reader),
    onFailure: (error4) => fromEffect5(f2(error4)),
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputIn = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(write(f2(inElem)), () => reader),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputInEffect = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (inElem) => flatMap20(flatMap20(fromEffect5(f2(inElem)), write), () => reader),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var doneCollect = (self) => suspend6(() => {
  const builder = [];
  return pipe(pipeTo(self, doneCollectReader(builder)), flatMap20((outDone) => succeed15([unsafeFromArray(builder), outDone])));
});
var doneCollectReader = (builder) => {
  return readWith({
    onInput: (outElem) => flatMap20(sync10(() => {
      builder.push(outElem);
    }), () => doneCollectReader(builder)),
    onFailure: fail14,
    onDone: succeed15
  });
};
var drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause12,
    onDone: succeed15
  });
  return pipeTo(self, drainer);
};
var emitCollect = (self) => flatMap20(doneCollect(self), write);
var ensuring5 = dual(2, (self, finalizer3) => ensuringWith(self, () => finalizer3));
var context7 = () => fromEffect5(context5());
var contextWith3 = (f2) => map28(context7(), f2);
var contextWithChannel = (f2) => flatMap20(context7(), f2);
var contextWithEffect3 = (f2) => mapEffect5(context7(), f2);
var flatten15 = (self) => flatMap20(self, identity);
var foldChannel = dual(2, (self, options) => foldCauseChannel(self, {
  onFailure: (cause3) => {
    const either14 = failureOrCause2(cause3);
    switch (either14._tag) {
      case "Left": {
        return options.onFailure(either14.left);
      }
      case "Right": {
        return failCause12(either14.right);
      }
    }
  },
  onSuccess: options.onSuccess
}));
var fromEither3 = (either14) => suspend6(() => match(either14, {
  onLeft: fail14,
  onRight: succeed15
}));
var fromInput = (input) => unwrap2(input.takeWith(failCause12, (elem) => flatMap20(write(elem), () => fromInput(input)), succeed15));
var fromPubSub = (pubsub) => unwrapScoped3(map26(subscribe2(pubsub), fromQueue));
var fromPubSubScoped = (pubsub) => map26(subscribe2(pubsub), fromQueue);
var fromOption6 = (option11) => suspend6(() => match2(option11, {
  onNone: () => fail14(none2()),
  onSome: succeed15
}));
var fromQueue = (queue) => suspend6(() => fromQueueInternal(queue));
var fromQueueInternal = (queue) => pipe(fromEffect5(take6(queue)), flatMap20(match({
  onLeft: match7({
    onFailure: failCause12,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap20(write(elem), () => fromQueueInternal(queue))
})));
var identityChannel = () => readWith({
  onInput: (input) => flatMap20(write(input), () => identityChannel()),
  onFailure: fail14,
  onDone: succeedNow
});
var interruptWhen = dual(2, (self, effect4) => mergeWith2(self, {
  other: fromEffect5(effect4),
  onSelfDone: (selfDone) => Done3(suspend4(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend4(() => effectDone))
}));
var interruptWhenDeferred = dual(2, (self, deferred) => interruptWhen(self, _await(deferred)));
var map28 = dual(2, (self, f2) => flatMap20(self, (a) => sync10(() => f2(a))));
var mapEffect5 = dual(2, (self, f2) => flatMap20(self, (z) => fromEffect5(f2(z))));
var mapError7 = dual(2, (self, f2) => mapErrorCause5(self, map22(f2)));
var mapErrorCause5 = dual(2, (self, f2) => catchAllCause6(self, (cause3) => failCause12(f2(cause3))));
var mapOut = dual(2, (self, f2) => {
  const reader = readWith({
    onInput: (outElem) => flatMap20(write(f2(outElem)), () => reader),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffect = dual(2, (self, f2) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect5(f2(outElem)), flatMap20(write), flatMap20(() => reader)),
    onFailure: failCause12,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffectPar = dual(3, (self, f2, n) => unwrapScopedWith((scope6) => gen6(function* () {
  const input = yield* make63();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(n);
  yield* addFinalizer3(scope6, shutdown4(queue));
  const errorSignal = yield* make24();
  const withPermits3 = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self), toPullIn(scope6));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause10(cause3)),
    onSuccess: match({
      onLeft: (outDone) => zipRight7(interruptible4(withPermits3(n)(_void)), asVoid6(offer3(queue, succeed13(left2(outDone))))),
      onRight: (outElem) => gen6(function* () {
        const deferred = yield* make24();
        const latch = yield* make24();
        yield* offer3(queue, map26(_await(deferred), right2));
        yield* succeed2(latch, void 0).pipe(zipRight7(uninterruptibleMask3((restore) => exit3(restore(_await(errorSignal))).pipe(raceFirst3(exit3(restore(f2(outElem)))), flatMap18(identity))).pipe(tapErrorCause4((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits3(1), forkIn3(scope6));
        yield* _await(latch);
      })
    })
  }), forever4, interruptible4, forkIn3(scope6));
  const consumer = unwrap2(matchCause4(flatten13(take6(queue)), {
    onFailure: failCause12,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap20(write(outElem), () => consumer)
    })
  }));
  return embedInput(consumer, input);
})));
var mergeAll7 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
};
var mergeAllUnbounded = (channels) => mergeAllWith({
  concurrency: "unbounded"
})(channels, constVoid);
var mergeAllUnboundedWith = (channels, f2) => mergeAllWith({
  concurrency: "unbounded"
})(channels, f2);
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f2) => unwrapScopedWith((scope6) => gen6(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make63();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(bufferSize);
  yield* addFinalizer3(scope6, shutdown4(queue));
  const cancelers = yield* unbounded5();
  yield* addFinalizer3(scope6, shutdown4(cancelers));
  const lastDone = yield* make37(none2());
  const errorSignal = yield* make24();
  const withPermits3 = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope6);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap18(match({
      onLeft: (done17) => succeed13(some3(done17)),
      onRight: (outElem) => as8(offer3(queue, succeed13(right2(outElem))), none2())
    })), repeat3({
      until: (_) => isSome2(_)
    }), flatMap18((outDone) => update4(lastDone, match2({
      onNone: () => some3(outDone.value),
      onSome: (lastDone2) => some3(f2(lastDone2, outDone.value))
    }))), catchAllCause4((cause3) => isInterrupted3(cause3) ? failCause10(cause3) : offer3(queue, failCause10(cause3)).pipe(zipRight7(succeed2(errorSignal, void 0)), asVoid6)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause10(cause3)).pipe(zipRight7(succeed13(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits3(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as8(interrupt7(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight7(interrupt7(failureAwait), get13(lastDone).pipe(flatMap18(match2({
          onNone: () => offer3(queue, succeed13(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed13(left2(f2(lastDone2, outDone))))
        })), as8(false)))
      }),
      onRight: (channel) => match27(mergeStrategy, {
        onBackPressure: () => gen6(function* () {
          const latch = yield* make24();
          const raceEffects = scopedWith2((scope7) => toPullIn(pipeTo(queueReader, channel), scope7).pipe(flatMap18((pull2) => race3(exit3(evaluatePull(pull2)), exit3(interruptible4(_await(errorSignal))))), flatMap18(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight7(raceEffects), withPermits3(1), forkIn3(scope6));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen6(function* () {
          const canceler = yield* make24();
          const latch = yield* make24();
          const size45 = yield* size23(cancelers);
          yield* take6(cancelers).pipe(flatMap18((canceler2) => succeed2(canceler2, void 0)), when3(() => size45 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope7) => toPullIn(pipeTo(queueReader, channel), scope7).pipe(flatMap18((pull2) => exit3(evaluatePull(pull2)).pipe(race3(exit3(interruptible4(_await(errorSignal)))), race3(exit3(interruptible4(_await(canceler)))))), flatMap18(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight7(raceEffects), withPermits3(1), forkIn3(scope6));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat3({
    while: (_) => _
  }), forkIn3(scope6));
  const consumer = pipe(take6(queue), flatten13, matchCause4({
    onFailure: failCause12,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap20(write(outElem), () => consumer)
    })
  }), unwrap2);
  return embedInput(consumer, input);
}));
var mergeMap = dual(3, (self, f2, options) => mergeAll7(options)(mapOut(self, f2)));
var mergeOut = dual(2, (self, n) => mergeAll7({
  concurrency: n
})(mapOut(self, identity)));
var mergeOutWith = dual(3, (self, n, f2) => mergeAllWith({
  concurrency: n
})(mapOut(self, identity), f2));
var mergeWith2 = dual(2, (self, options) => {
  function merge16(scope6) {
    return gen6(function* () {
      const input = yield* make63();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self), scope6);
      const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope6);
      function handleSide(exit4, fiber, pull) {
        return (done17, both3, single3) => {
          function onDecision3(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed13(fromEffect5(zipRight7(interrupt7(fiber), op.effect)));
            }
            return map26(_await3(fiber), match7({
              onFailure: (cause3) => fromEffect5(op.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done18) => fromEffect5(op.f(succeed3(done18))),
                onRight: (elem) => zipRight8(write(elem), go5(single3(op.f)))
              })
            }));
          }
          return match7(exit4, {
            onFailure: (cause3) => onDecision3(done17(failCause3(cause3))),
            onSuccess: match({
              onLeft: (z) => onDecision3(done17(succeed3(z))),
              onRight: (elem) => succeed13(flatMap20(write(elem), () => flatMap20(fromEffect5(forkIn3(interruptible4(pull), scope6)), (leftFiber) => go5(both3(leftFiber, fiber)))))
            })
          });
        };
      }
      function go5(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join4(state.left));
            const rightJoin = interruptible4(join4(state.right));
            return unwrap2(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight7(interrupt7(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f2) => LeftDone(f2))),
              onOtherDone: (rightExit, lf) => zipRight7(interrupt7(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f2) => RightDone(f2)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap2(map26(exit3(pullR), match7({
              onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done17) => fromEffect5(state.f(succeed3(done17))),
                onRight: (elem) => flatMap20(write(elem), () => go5(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap2(map26(exit3(pullL), match7({
              onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done17) => fromEffect5(state.f(succeed3(done17))),
                onRight: (elem) => flatMap20(write(elem), () => go5(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect5(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          ;
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring4(inherit), forkIn3(scope6));
        const rightFiber = interruptible4(pullR).pipe(ensuring4(inherit), forkIn3(scope6));
        return zipWith12(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap20(go5), embedInput(input));
    });
  }
  return unwrapScopedWith(merge16);
});
var never6 = fromEffect5(never5);
var orDie6 = dual(2, (self, error4) => orDieWith3(self, error4));
var orDieWith3 = dual(2, (self, f2) => catchAll6(self, (e) => failCauseSync7(() => die6(f2(e)))));
var orElse10 = dual(2, (self, that) => catchAll6(self, that));
var pipeToOrFail = dual(2, (self, that) => suspend6(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap20(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause12(die6(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap20(() => writer)),
    onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail14(cause3.defect.error) : failCause12(cause3),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
}));
var provideService6 = dual(3, (self, tag5, service4) => {
  return flatMap20(context7(), (context15) => provideContext4(self, add3(context15, tag5, service4)));
});
var provideLayer = dual(2, (self, layer) => unwrapScopedWith((scope6) => map26(buildWithScope2(layer, scope6), (context15) => provideContext4(self, context15))));
var mapInputContext4 = dual(2, (self, f2) => contextWithChannel((context15) => provideContext4(self, f2(context15))));
var provideSomeLayer2 = dual(2, (self, layer) => (
  // @ts-expect-error
  provideLayer(self, merge8(context6(), layer))
));
var read = () => readOrFail(none2());
var repeated = (self) => flatMap20(self, () => repeated(self));
var run2 = (self) => scopedWith2((scope6) => runIn(self, scope6));
var runCollect = (self) => run2(collectElements(self));
var runDrain = (self) => run2(drain(self));
var runScoped = (self) => scopeWith2((scope6) => runIn(self, scope6));
var scoped6 = (effect4) => unwrap2(uninterruptibleMask3((restore) => map26(make55(), (scope6) => acquireReleaseOut(tapErrorCause4(restore(extend3(effect4, scope6)), (cause3) => close(scope6, failCause3(cause3))), (_, exit4) => close(scope6, exit4)))));
var scopedWith3 = (f2) => unwrapScoped3(map26(scope4, (scope6) => flatMap20(fromEffect5(f2(scope6)), write)));
var splitLines = () => suspend6(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk7) => {
    const chunkBuilder = [];
    map7(chunk7, (str) => {
      if (str.length !== 0) {
        let from29 = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from29 = 1;
            indexOfLF = str.indexOf("\n", from29);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from29, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from29, indexOfLF));
              stringBuilder = "";
            }
            from29 = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from29);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from29, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from29, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from29 = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from29);
                indexOfLF = str.indexOf("\n", from29);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from29, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from29, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop5 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty2(out) ? loop5 : flatMap20(write(out), () => loop5);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause12(cause3) : flatMap20(write(of3(stringBuilder)), () => failCause12(cause3)),
    onDone: (done17) => stringBuilder.length === 0 ? succeed15(done17) : flatMap20(write(of3(stringBuilder)), () => succeed15(done17))
  });
  return loop5;
});
var toPubSub = (pubsub) => toQueue(pubsub);
var toPull = (self) => flatMap18(scope4, (scope6) => toPullIn(self, scope6));
var toPullIn = dual(2, (self, scope6) => zip12(sync8(() => new ChannelExecutor(self, void 0, identity)), runtime4()).pipe(tap5(([executor, runtime8]) => addFinalizerExit(scope6, (exit4) => {
  const finalizer3 = executor.close(exit4);
  return finalizer3 !== void 0 ? provide2(finalizer3, runtime8) : _void;
})), uninterruptible3, map26(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match7(exec.getDone(), {
        onFailure: failCause10,
        onSuccess: (done17) => succeed13(left2(done17))
      });
    }
    case OP_EMIT2: {
      return succeed13(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap18(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause10(cause3));
    }
  }
};
var toQueue = (queue) => suspend6(() => toQueueInternal(queue));
var toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap20(fromEffect5(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect5(pipe(offer3(queue, left2(failCause3(cause3))))),
    onDone: (done17) => fromEffect5(pipe(offer3(queue, left2(succeed3(done17)))))
  });
};
var unwrap2 = (channel) => flatten15(fromEffect5(channel));
var unwrapScoped3 = (self) => concatAllWith(scoped6(self), (d, _) => d, (d, _) => d);
var unwrapScopedWith = (f2) => concatAllWith(scopedWith3(f2), (d, _) => d, (d, _) => d);
var updateService5 = dual(3, (self, tag5, f2) => mapInputContext4(self, (context15) => merge3(context15, make8(tag5, f2(unsafeGet3(context15, tag5))))));
var withSpan5 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire4 = all11([makeSpan2(name, options), context5(), clock2, get14(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self = arguments[0];
    return acquireUseRelease4(acquire4, ([span4, context15]) => provideContext4(self, add3(context15, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  }
  return (self) => acquireUseRelease4(acquire4, ([span4, context15]) => provideContext4(self, add3(context15, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
};
var writeAll = (...outs) => writeChunk(fromIterable3(outs));
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk7) => {
  return idx === len ? void_8 : pipe(write(pipe(chunk7, unsafeGet4(idx))), flatMap20(() => writeChunkWriter(idx + 1, len, chunk7)));
};
var zip13 = dual((args2) => isChannel(args2[1]), (self, that, options) => (options == null ? void 0 : options.concurrent) ? mergeWith2(self, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend4(() => zip6(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend4(() => zip6(exit1, exit22)))
}) : flatMap20(self, (a) => map28(that, (b) => [a, b])));
var zipLeft8 = dual((args2) => isChannel(args2[1]), (self, that, options) => (options == null ? void 0 : options.concurrent) ? map28(zip13(self, that, {
  concurrent: true
}), (tuple7) => tuple7[0]) : flatMap20(self, (z) => as9(that, z)));
var zipRight8 = dual((args2) => isChannel(args2[1]), (self, that, options) => (options == null ? void 0 : options.concurrent) ? map28(zip13(self, that, {
  concurrent: true
}), (tuple7) => tuple7[1]) : flatMap20(self, () => that));
var ChannelExceptionTypeId = Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error4) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error4
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId3 = Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a64;
_a64 = SinkTypeId3;
var SinkImpl = class {
  constructor(channel) {
    __publicField(this, "channel");
    __publicField(this, _a64, sinkVariance2);
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSink = (u) => hasProperty(u, SinkTypeId3);
var suspend7 = (evaluate4) => new SinkImpl(suspend6(() => toChannel(evaluate4())));
var as10 = dual(2, (self, a) => pipe(self, map29(() => a)));
var collectAll = () => new SinkImpl(collectAllLoop(empty7()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk7) => collectAllLoop(pipe(acc, appendAll3(chunk7))),
  onFailure: failCause12,
  onDone: () => succeed15(acc)
});
var collectAllN = (n) => suspend7(() => fromChannel(collectAllNLoop(n, empty7())));
var collectAllNLoop = (n, acc) => readWithCause({
  onInput: (chunk7) => {
    const [collected, leftovers] = splitAt2(chunk7, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll3(acc, collected));
    }
    if (isEmpty2(leftovers)) {
      return succeed15(appendAll3(acc, collected));
    }
    return flatMap20(write(leftovers), () => succeed15(appendAll3(acc, collected)));
  },
  onFailure: failCause12,
  onDone: () => succeed15(acc)
});
var collectAllFrom = (self) => collectAllWhileWith(self, {
  initial: empty7(),
  while: constTrue,
  body: (chunk7, a) => pipe(chunk7, append3(a))
});
var collectAllToMap = (key, merge16) => {
  return pipe(foldLeftChunks(empty11(), (map49, chunk7) => pipe(chunk7, reduce4(map49, (map50, input) => {
    const k = key(input);
    const v = pipe(map50, has5(k)) ? merge16(pipe(map50, unsafeGet6(k)), input) : input;
    return pipe(map50, set4(k, v));
  }))));
};
var collectAllToMapN = (n, key, merge16) => {
  return foldWeighted({
    initial: empty11(),
    maxCost: n,
    cost: (acc, input) => pipe(acc, has5(key(input))) ? 0 : 1,
    body: (acc, input) => {
      const k = key(input);
      const v = pipe(acc, has5(k)) ? merge16(pipe(acc, unsafeGet6(k)), input) : input;
      return pipe(acc, set4(k, v));
    }
  });
};
var collectAllToSet = () => foldLeftChunks(empty10(), (acc, chunk7) => pipe(chunk7, reduce4(acc, (acc2, input) => pipe(acc2, add5(input)))));
var collectAllToSetN = (n) => foldWeighted({
  initial: empty10(),
  maxCost: n,
  cost: (acc, input) => has4(acc, input) ? 0 : 1,
  body: (acc, input) => add5(acc, input)
});
var collectAllUntil = (p) => {
  return pipe(fold([empty7(), true], (tuple7) => tuple7[1], ([chunk7, _], input) => [pipe(chunk7, append3(input)), !p(input)]), map29((tuple7) => tuple7[0]));
};
var collectAllUntilEffect = (p) => {
  return pipe(foldEffect([empty7(), true], (tuple7) => tuple7[1], ([chunk7, _], input) => pipe(p(input), map26((bool) => [pipe(chunk7, append3(input)), !bool]))), map29((tuple7) => tuple7[0]));
};
var collectAllWhile = (predicate) => fromChannel(collectAllWhileReader(predicate, empty7()));
var collectAllWhileReader = (predicate, done17) => readWith({
  onInput: (input) => {
    const [collected, leftovers] = pipe(toReadonlyArray(input), span(predicate));
    if (leftovers.length === 0) {
      return collectAllWhileReader(predicate, pipe(done17, appendAll3(unsafeFromArray(collected))));
    }
    return pipe(write(unsafeFromArray(leftovers)), zipRight8(succeed15(pipe(done17, appendAll3(unsafeFromArray(collected))))));
  },
  onFailure: fail14,
  onDone: () => succeed15(done17)
});
var collectAllWhileEffect = (predicate) => fromChannel(collectAllWhileEffectReader(predicate, empty7()));
var collectAllWhileEffectReader = (predicate, done17) => readWith({
  onInput: (input) => pipe(fromEffect5(pipe(input, takeWhile5(predicate), map26(unsafeFromArray))), flatMap20((collected) => {
    const leftovers = pipe(input, drop3(collected.length));
    if (isEmpty2(leftovers)) {
      return collectAllWhileEffectReader(predicate, pipe(done17, appendAll3(collected)));
    }
    return pipe(write(leftovers), zipRight8(succeed15(pipe(done17, appendAll3(collected)))));
  })),
  onFailure: fail14,
  onDone: () => succeed15(done17)
});
var collectAllWhileWith = dual(2, (self, options) => {
  const refs = pipe(make37(empty7()), zip12(make37(false)));
  const newChannel = pipe(fromEffect5(refs), flatMap20(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = readWith({
      onInput: (input) => pipe(write(input), flatMap20(() => upstreamMarker)),
      onFailure: fail14,
      onDone: (done17) => pipe(fromEffect5(set7(upstreamDoneRef, true)), as9(done17))
    });
    return pipe(upstreamMarker, pipeTo(bufferChunk(leftoversRef)), pipeTo(collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body)));
  }));
  return new SinkImpl(newChannel);
});
var collectAllWhileWithLoop = (self, leftoversRef, upstreamDoneRef, currentResult, p, f2) => {
  return pipe(toChannel(self), doneCollect, foldChannel({
    onFailure: fail14,
    onSuccess: ([leftovers, doneValue]) => p(doneValue) ? pipe(fromEffect5(set7(leftoversRef, flatten5(leftovers))), flatMap20(() => pipe(fromEffect5(get13(upstreamDoneRef)), flatMap20((upstreamDone) => {
      const accumulatedResult = f2(currentResult, doneValue);
      return upstreamDone ? pipe(write(flatten5(leftovers)), as9(accumulatedResult)) : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f2);
    })))) : pipe(write(flatten5(leftovers)), as9(currentResult))
  }));
};
var collectLeftover = (self) => new SinkImpl(pipe(collectElements(toChannel(self)), map28(([chunks3, z]) => [z, flatten5(chunks3)])));
var mapInput8 = dual(2, (self, f2) => pipe(self, mapInputChunks(map7(f2))));
var mapInputEffect3 = dual(2, (self, f2) => mapInputChunksEffect(self, (chunk7) => map26(forEach16(chunk7, (v) => f2(v)), unsafeFromArray)));
var mapInputChunks = dual(2, (self, f2) => {
  const loop5 = readWith({
    onInput: (chunk7) => pipe(write(f2(chunk7)), flatMap20(() => loop5)),
    onFailure: fail14,
    onDone: succeed15
  });
  return new SinkImpl(pipe(loop5, pipeTo(toChannel(self))));
});
var mapInputChunksEffect = dual(2, (self, f2) => {
  const loop5 = readWith({
    onInput: (chunk7) => pipe(fromEffect5(f2(chunk7)), flatMap20(write), flatMap20(() => loop5)),
    onFailure: fail14,
    onDone: succeed15
  });
  return new SinkImpl(pipe(loop5, pipeToOrFail(toChannel(self))));
});
var die10 = (defect) => failCause13(die6(defect));
var dieMessage3 = (message) => failCause13(die6(new RuntimeException2(message)));
var dieSync6 = (evaluate4) => failCauseSync8(() => die6(evaluate4()));
var dimap = dual(2, (self, options) => map29(mapInput8(self, options.onInput), options.onDone));
var dimapEffect = dual(2, (self, options) => mapEffect6(mapInputEffect3(self, options.onInput), options.onDone));
var dimapChunks = dual(2, (self, options) => map29(mapInputChunks(self, options.onInput), options.onDone));
var dimapChunksEffect = dual(2, (self, options) => mapEffect6(mapInputChunksEffect(self, options.onInput), options.onDone));
var drain2 = new SinkImpl(drain(identityChannel()));
var drop5 = (n) => suspend7(() => new SinkImpl(dropLoop(n)));
var dropLoop = (n) => readWith({
  onInput: (input) => {
    const dropped = pipe(input, drop3(n));
    const leftover3 = Math.max(n - input.length, 0);
    const more = isEmpty2(input) || leftover3 > 0;
    if (more) {
      return dropLoop(leftover3);
    }
    return pipe(write(dropped), zipRight8(identityChannel()));
  },
  onFailure: fail14,
  onDone: () => void_8
});
var dropUntil3 = (predicate) => new SinkImpl(pipe(toChannel(dropWhile5((input) => !predicate(input))), pipeToOrFail(toChannel(drop5(1)))));
var dropUntilEffect = (predicate) => suspend7(() => new SinkImpl(dropUntilEffectReader(predicate)));
var dropUntilEffectReader = (predicate) => readWith({
  onInput: (input) => pipe(input, dropUntil2(predicate), map26((leftover3) => {
    const more = leftover3.length === 0;
    return more ? dropUntilEffectReader(predicate) : pipe(write(unsafeFromArray(leftover3)), zipRight8(identityChannel()));
  }), unwrap2),
  onFailure: fail14,
  onDone: () => void_8
});
var dropWhile5 = (predicate) => new SinkImpl(dropWhileReader(predicate));
var dropWhileReader = (predicate) => readWith({
  onInput: (input) => {
    const out = pipe(input, dropWhile2(predicate));
    if (isEmpty2(out)) {
      return dropWhileReader(predicate);
    }
    return pipe(write(out), zipRight8(identityChannel()));
  },
  onFailure: fail14,
  onDone: succeedNow
});
var dropWhileEffect = (predicate) => suspend7(() => new SinkImpl(dropWhileEffectReader(predicate)));
var dropWhileEffectReader = (predicate) => readWith({
  onInput: (input) => pipe(input, dropWhile4(predicate), map26((leftover3) => {
    const more = leftover3.length === 0;
    return more ? dropWhileEffectReader(predicate) : pipe(write(unsafeFromArray(leftover3)), zipRight8(identityChannel()));
  }), unwrap2),
  onFailure: fail14,
  onDone: () => void_8
});
var ensuring6 = dual(2, (self, finalizer3) => new SinkImpl(pipe(self, toChannel, ensuring5(finalizer3))));
var ensuringWith2 = dual(2, (self, finalizer3) => new SinkImpl(pipe(self, toChannel, ensuringWith(finalizer3))));
var context8 = () => fromEffect7(context5());
var contextWith4 = (f2) => pipe(context8(), map29(f2));
var contextWithEffect4 = (f2) => pipe(context8(), mapEffect6(f2));
var contextWithSink = (f2) => new SinkImpl(unwrap2(pipe(contextWith2((context15) => toChannel(f2(context15))))));
var every14 = (predicate) => fold(true, identity, (acc, input) => acc && predicate(input));
var fail15 = (e) => new SinkImpl(fail14(e));
var failSync8 = (evaluate4) => new SinkImpl(failSync7(evaluate4));
var failCause13 = (cause3) => new SinkImpl(failCause12(cause3));
var failCauseSync8 = (evaluate4) => new SinkImpl(failCauseSync7(evaluate4));
var filterInput = (f2) => {
  return (self) => pipe(self, mapInputChunks(filter5(f2)));
};
var filterInputEffect = dual(2, (self, f2) => mapInputChunksEffect(self, (chunk7) => map26(filter16(chunk7, f2), unsafeFromArray)));
var findEffect = dual(2, (self, f2) => {
  const newChannel = pipe(fromEffect5(pipe(make37(empty7()), zip12(make37(false)))), flatMap20(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = readWith({
      onInput: (input) => pipe(write(input), flatMap20(() => upstreamMarker)),
      onFailure: fail14,
      onDone: (done17) => pipe(fromEffect5(set7(upstreamDoneRef, true)), as9(done17))
    });
    const loop5 = foldChannel(collectElements(toChannel(self)), {
      onFailure: fail14,
      onSuccess: ([leftovers, doneValue]) => pipe(fromEffect5(f2(doneValue)), flatMap20((satisfied) => pipe(fromEffect5(set7(leftoversRef, flatten5(leftovers))), zipRight8(pipe(fromEffect5(get13(upstreamDoneRef)), flatMap20((upstreamDone) => {
        if (satisfied) {
          return pipe(write(flatten5(leftovers)), as9(some3(doneValue)));
        }
        if (upstreamDone) {
          return pipe(write(flatten5(leftovers)), as9(none2()));
        }
        return loop5;
      }))))))
    });
    return pipe(upstreamMarker, pipeTo(bufferChunk(leftoversRef)), pipeTo(loop5));
  }));
  return new SinkImpl(newChannel);
});
var fold = (s, contFn, f2) => suspend7(() => new SinkImpl(foldReader(s, contFn, f2)));
var foldReader = (s, contFn, f2) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f2, 0, input.length);
      if (isNonEmpty2(leftovers)) {
        return pipe(write(leftovers), as9(nextS));
      }
      return foldReader(nextS, contFn, f2);
    },
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplit = (s, chunk7, contFn, f2, index3, length6) => {
  if (index3 === length6) {
    return [s, empty7()];
  }
  const s1 = f2(s, pipe(chunk7, unsafeGet4(index3)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk7, contFn, f2, index3 + 1, length6);
  }
  return [s1, pipe(chunk7, drop3(index3 + 1))];
};
var foldSink = dual(2, (self, options) => {
  const newChannel = pipe(toChannel(self), collectElements, foldChannel({
    onFailure: (error4) => toChannel(options.onFailure(error4)),
    onSuccess: ([leftovers, z]) => suspend6(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter5(isNonEmpty2))
      };
      const refReader = pipe(
        sync10(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty7();
          return ref;
        }),
        // This cast is safe because of the L1 >: L <: In1 bound. It follows that
        // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
        flatMap20((chunk7) => writeChunk(chunk7))
      );
      const passthrough5 = identityChannel();
      const continuationSink = pipe(refReader, zipRight8(passthrough5), pipeTo(toChannel(options.onSuccess(z))));
      return flatMap20(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed15(leftoversRef.ref), flatMap20(writeChunk), zipRight8(writeChunk(newLeftovers)), as9(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = (s, contFn, f2) => suspend7(() => new SinkImpl(foldChunksReader(s, contFn, f2)));
var foldChunksReader = (s, contFn, f2) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f2(s, input), contFn, f2),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldChunksEffect = (s, contFn, f2) => suspend7(() => new SinkImpl(foldChunksEffectReader(s, contFn, f2)));
var foldChunksEffectReader = (s, contFn, f2) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(f2(s, input)), flatMap20((s2) => foldChunksEffectReader(s2, contFn, f2))),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldEffect = (s, contFn, f2) => suspend7(() => new SinkImpl(foldEffectReader(s, contFn, f2)));
var foldEffectReader = (s, contFn, f2) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(foldChunkSplitEffect(s, input, contFn, f2)), flatMap20(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f2),
      onSome: (leftover3) => pipe(write(leftover3), as9(nextS))
    })))),
    onFailure: fail14,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplitEffect = (s, chunk7, contFn, f2) => foldChunkSplitEffectInternal(s, chunk7, 0, chunk7.length, contFn, f2);
var foldChunkSplitEffectInternal = (s, chunk7, index3, length6, contFn, f2) => {
  if (index3 === length6) {
    return succeed13([s, none2()]);
  }
  return pipe(f2(s, pipe(chunk7, unsafeGet4(index3))), flatMap18((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk7, index3 + 1, length6, contFn, f2) : succeed13([s1, some3(pipe(chunk7, drop3(index3 + 1)))])));
};
var foldLeft = (s, f2) => ignoreLeftover(fold(s, constTrue, f2));
var foldLeftChunks = (s, f2) => foldChunks(s, constTrue, f2);
var foldLeftChunksEffect = (s, f2) => ignoreLeftover(foldChunksEffect(s, constTrue, f2));
var foldLeftEffect = (s, f2) => foldEffect(s, constTrue, f2);
var foldUntil = (s, max14, f2) => pipe(fold([s, 0], (tuple7) => tuple7[1] < max14, ([output, count9], input) => [f2(output, input), count9 + 1]), map29((tuple7) => tuple7[0]));
var foldUntilEffect = (s, max14, f2) => pipe(foldEffect([s, 0], (tuple7) => tuple7[1] < max14, ([output, count9], input) => pipe(f2(output, input), map26((s2) => [s2, count9 + 1]))), map29((tuple7) => tuple7[0]));
var foldWeighted = (options) => foldWeightedDecompose({
  ...options,
  decompose: of3
});
var foldWeightedDecompose = (options) => suspend7(() => new SinkImpl(foldWeightedDecomposeLoop(options.initial, 0, false, options.maxCost, options.cost, options.decompose, options.body)));
var foldWeightedDecomposeLoop = (s, cost, dirty, max14, costFn, decompose, f2) => readWith({
  onInput: (input) => {
    const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(input, 0, s, cost, dirty, max14, costFn, decompose, f2);
    if (isNonEmpty2(leftovers)) {
      return pipe(write(leftovers), zipRight8(succeedNow(nextS)));
    }
    if (cost > max14) {
      return succeedNow(nextS);
    }
    return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max14, costFn, decompose, f2);
  },
  onFailure: fail14,
  onDone: () => succeedNow(s)
});
var foldWeightedDecomposeFold = (input, index3, s, cost, dirty, max14, costFn, decompose, f2) => {
  if (index3 === input.length) {
    return [s, cost, dirty, empty7()];
  }
  const elem = pipe(input, unsafeGet4(index3));
  const total = cost + costFn(s, elem);
  if (total <= max14) {
    return foldWeightedDecomposeFold(input, index3 + 1, f2(s, elem), total, true, max14, costFn, decompose, f2);
  }
  const decomposed2 = decompose(elem);
  if (decomposed2.length <= 1 && !dirty) {
    return [f2(s, elem), total, true, pipe(input, drop3(index3 + 1))];
  }
  if (decomposed2.length <= 1 && dirty) {
    return [s, cost, dirty, pipe(input, drop3(index3))];
  }
  const next6 = pipe(decomposed2, appendAll3(pipe(input, drop3(index3 + 1))));
  return foldWeightedDecomposeFold(next6, 0, s, cost, dirty, max14, costFn, decompose, f2);
};
var foldWeightedDecomposeEffect = (options) => suspend7(() => new SinkImpl(foldWeightedDecomposeEffectLoop(options.initial, options.maxCost, options.cost, options.decompose, options.body, 0, false)));
var foldWeightedEffect = (options) => foldWeightedDecomposeEffect({
  ...options,
  decompose: (input) => succeed13(of3(input))
});
var foldWeightedDecomposeEffectLoop = (s, max14, costFn, decompose, f2, cost, dirty) => readWith({
  onInput: (input) => pipe(fromEffect5(foldWeightedDecomposeEffectFold(s, max14, costFn, decompose, f2, input, dirty, cost, 0)), flatMap20(([nextS, nextCost, nextDirty, leftovers]) => {
    if (isNonEmpty2(leftovers)) {
      return pipe(write(leftovers), zipRight8(succeedNow(nextS)));
    }
    if (cost > max14) {
      return succeedNow(nextS);
    }
    return foldWeightedDecomposeEffectLoop(nextS, max14, costFn, decompose, f2, nextCost, nextDirty);
  })),
  onFailure: fail14,
  onDone: () => succeedNow(s)
});
var foldWeightedDecomposeEffectFold = (s, max14, costFn, decompose, f2, input, dirty, cost, index3) => {
  if (index3 === input.length) {
    return succeed13([s, cost, dirty, empty7()]);
  }
  const elem = pipe(input, unsafeGet4(index3));
  return pipe(costFn(s, elem), map26((newCost) => cost + newCost), flatMap18((total) => {
    if (total <= max14) {
      return pipe(f2(s, elem), flatMap18((s2) => foldWeightedDecomposeEffectFold(s2, max14, costFn, decompose, f2, input, true, total, index3 + 1)));
    }
    return pipe(decompose(elem), flatMap18((decomposed2) => {
      if (decomposed2.length <= 1 && !dirty) {
        return pipe(f2(s, elem), map26((s2) => [s2, total, true, pipe(input, drop3(index3 + 1))]));
      }
      if (decomposed2.length <= 1 && dirty) {
        return succeed13([s, cost, dirty, pipe(input, drop3(index3))]);
      }
      const next6 = pipe(decomposed2, appendAll3(pipe(input, drop3(index3 + 1))));
      return foldWeightedDecomposeEffectFold(s, max14, costFn, decompose, f2, next6, dirty, cost, 0);
    }));
  }));
};
var flatMap21 = dual(2, (self, f2) => foldSink(self, {
  onFailure: fail15,
  onSuccess: f2
}));
var forEach17 = (f2) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(forEach16(input, (v) => f2(v), {
      discard: true
    })), flatMap20(() => process2)),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new SinkImpl(process2);
};
var forEachChunk = (f2) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(f2(input)), flatMap20(() => process2)),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new SinkImpl(process2);
};
var forEachWhile = (f2) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f2, input, 0, input.length, process2),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new SinkImpl(process2);
};
var forEachWhileReader = (f2, input, index3, length6, cont) => {
  if (index3 === length6) {
    return cont;
  }
  return pipe(fromEffect5(f2(pipe(input, unsafeGet4(index3)))), flatMap20((bool) => bool ? forEachWhileReader(f2, input, index3 + 1, length6, cont) : write(pipe(input, drop3(index3)))), catchAll6((error4) => pipe(write(pipe(input, drop3(index3))), zipRight8(fail14(error4)))));
};
var forEachChunkWhile = (f2) => {
  const reader = readWith({
    onInput: (input) => pipe(fromEffect5(f2(input)), flatMap20((cont) => cont ? reader : void_8)),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new SinkImpl(reader);
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect7 = (effect4) => new SinkImpl(fromEffect5(effect4));
var fromPubSub2 = (pubsub, options) => fromQueue2(pubsub, options);
var fromPush = (push) => new SinkImpl(unwrapScoped3(pipe(push, map26(fromPushPull))));
var fromPushPull = (push) => readWith({
  onInput: (input) => foldChannel(fromEffect5(push(some3(input))), {
    onFailure: ([either14, leftovers]) => match(either14, {
      onLeft: (error4) => pipe(write(leftovers), zipRight8(fail14(error4))),
      onRight: (z) => pipe(write(leftovers), zipRight8(succeedNow(z)))
    }),
    onSuccess: () => fromPushPull(push)
  }),
  onFailure: fail14,
  onDone: () => foldChannel(fromEffect5(push(none2())), {
    onFailure: ([either14, leftovers]) => match(either14, {
      onLeft: (error4) => pipe(write(leftovers), zipRight8(fail14(error4))),
      onRight: (z) => pipe(write(leftovers), zipRight8(succeedNow(z)))
    }),
    onSuccess: () => fromEffect5(dieMessage2("BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/effect/issues"))
  })
});
var fromQueue2 = (queue, options) => (options == null ? void 0 : options.shutdown) ? unwrapScoped4(map26(acquireRelease3(succeed13(queue), shutdown4), fromQueue2)) : forEachChunk((input) => pipe(offerAll3(queue, input)));
var head8 = () => fold(none2(), isNone2, (option11, input) => match2(option11, {
  onNone: () => some3(input),
  onSome: () => option11
}));
var ignoreLeftover = (self) => new SinkImpl(drain(toChannel(self)));
var last6 = () => foldLeftChunks(none2(), (s, input) => orElse2(last2(input), () => s));
var leftover = (chunk7) => new SinkImpl(suspend6(() => write(chunk7)));
var map29 = dual(2, (self, f2) => {
  return new SinkImpl(pipe(toChannel(self), map28(f2)));
});
var mapEffect6 = dual(2, (self, f2) => new SinkImpl(pipe(toChannel(self), mapEffect5(f2))));
var mapError8 = dual(2, (self, f2) => new SinkImpl(pipe(toChannel(self), mapError7(f2))));
var mapLeftover = dual(2, (self, f2) => new SinkImpl(pipe(toChannel(self), mapOut(map7(f2)))));
var never7 = fromEffect7(never5);
var orElse11 = dual(2, (self, that) => new SinkImpl(pipe(toChannel(self), orElse10(() => toChannel(that())))));
var provideContext5 = dual(2, (self, context15) => new SinkImpl(pipe(toChannel(self), provideContext4(context15))));
var race4 = dual(2, (self, that) => pipe(self, raceBoth(that), map29(merge)));
var raceBoth = dual((args2) => isSink(args2[1]), (self, that, options) => raceWith3(self, {
  other: that,
  onSelfDone: (selfDone) => Done3(map26(selfDone, left2)),
  onOtherDone: (thatDone) => Done3(map26(thatDone, right2)),
  capacity: (options == null ? void 0 : options.capacity) ?? 16
}));
var raceWith3 = dual(2, (self, options) => {
  function race10(scope6) {
    return gen6(function* () {
      const pubsub = yield* bounded4((options == null ? void 0 : options.capacity) ?? 16);
      const subscription1 = yield* extend3(subscribe2(pubsub), scope6);
      const subscription2 = yield* extend3(subscribe2(pubsub), scope6);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self)), zipLeft8(fromEffect5(shutdown4(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft8(fromEffect5(shutdown4(subscription2)))),
        onSelfDone: options.onSelfDone,
        onOtherDone: options.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: () => Await(identity),
        onOtherDone: (exit4) => Done3(exit4)
      });
      return new SinkImpl(racedChannel);
    });
  }
  return unwrapScopedWith2(race10);
});
var refineOrDie = dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));
var refineOrDieWith = dual(3, (self, pf, f2) => {
  const newChannel = pipe(self, toChannel, catchAll6((error4) => match2(pf(error4), {
    onNone: () => failCauseSync7(() => die6(f2(error4))),
    onSome: fail14
  })));
  return new SinkImpl(newChannel);
});
var some15 = (predicate) => fold(false, (bool) => !bool, (acc, input) => acc || predicate(input));
var splitWhere3 = dual(2, (self, f2) => {
  const newChannel = pipe(fromEffect5(make37(empty7())), flatMap20((ref) => pipe(splitWhereSplitter(false, ref, f2), pipeToOrFail(toChannel(self)), collectElements, flatMap20(([leftovers, z]) => pipe(fromEffect5(get13(ref)), flatMap20((leftover3) => pipe(write(pipe(leftover3, appendAll3(flatten5(leftovers)))), zipRight8(succeed15(z)))))))));
  return new SinkImpl(newChannel);
});
var splitWhereSplitter = (written, leftovers, f2) => readWithCause({
  onInput: (input) => {
    if (isEmpty2(input)) {
      return splitWhereSplitter(written, leftovers, f2);
    }
    if (written) {
      const index4 = indexWhere(input, f2);
      if (index4 === -1) {
        return zipRight8(write(input), splitWhereSplitter(true, leftovers, f2));
      }
      const [left4, right4] = splitAt2(input, index4);
      return zipRight8(write(left4), fromEffect5(set7(leftovers, right4)));
    }
    const index3 = indexWhere(input, f2, 1);
    if (index3 === -1) {
      return zipRight8(write(input), splitWhereSplitter(true, leftovers, f2));
    }
    const [left3, right3] = pipe(input, splitAt2(Math.max(index3, 1)));
    return zipRight8(write(left3), fromEffect5(set7(leftovers, right3)));
  },
  onFailure: failCause12,
  onDone: succeed15
});
var indexWhere = (self, predicate, from29 = 0) => {
  const iterator = self[Symbol.iterator]();
  let index3 = 0;
  let result = -1;
  let next6;
  while (result < 0 && (next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    if (index3 >= from29 && predicate(a)) {
      result = index3;
    }
    index3 = index3 + 1;
  }
  return result;
};
var succeed16 = (a) => new SinkImpl(succeed15(a));
var sum5 = foldLeftChunks(0, (acc, chunk7) => acc + reduce4(chunk7, 0, (s, a) => s + a));
var summarized3 = dual(3, (self, summary11, f2) => {
  const newChannel = pipe(fromEffect5(summary11), flatMap20((start5) => pipe(self, toChannel, flatMap20((done17) => pipe(fromEffect5(summary11), map28((end7) => [done17, f2(start5, end7)]))))));
  return new SinkImpl(newChannel);
});
var sync11 = (evaluate4) => new SinkImpl(sync10(evaluate4));
var take7 = (n) => pipe(foldChunks(empty7(), (chunk7) => chunk7.length < n, (acc, chunk7) => pipe(acc, appendAll3(chunk7))), flatMap21((acc) => {
  const [taken, leftover3] = pipe(acc, splitAt2(n));
  return new SinkImpl(pipe(write(leftover3), zipRight8(succeedNow(taken))));
}));
var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect7(self)) : self.channel;
var unwrap3 = (effect4) => new SinkImpl(unwrap2(pipe(effect4, map26((sink) => toChannel(sink)))));
var unwrapScoped4 = (effect4) => new SinkImpl(unwrapScoped3(effect4.pipe(map26((sink) => toChannel(sink)))));
var unwrapScopedWith2 = (f2) => new SinkImpl(unwrapScopedWith((scope6) => f2(scope6).pipe(map26((sink) => toChannel(sink)))));
var withDuration = (self) => pipe(self, summarized3(currentTimeMillis2, (start5, end7) => millis(end7 - start5)));
var zip14 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith14(self, that, (z, z2) => [z, z2], options));
var zipLeft9 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith14(self, that, (z, _) => z, options));
var zipRight9 = dual((args2) => isSink(args2[1]), (self, that, options) => zipWith14(self, that, (_, z2) => z2, options));
var zipWith14 = dual((args2) => isSink(args2[1]), (self, that, f2, options) => (options == null ? void 0 : options.concurrent) ? raceWith3(self, {
  other: that,
  onSelfDone: match7({
    onFailure: (cause3) => Done3(failCause10(cause3)),
    onSuccess: (leftZ) => Await(match7({
      onFailure: failCause10,
      onSuccess: (rightZ) => succeed13(f2(leftZ, rightZ))
    }))
  }),
  onOtherDone: match7({
    onFailure: (cause3) => Done3(failCause10(cause3)),
    onSuccess: (rightZ) => Await(match7({
      onFailure: failCause10,
      onSuccess: (leftZ) => succeed13(f2(leftZ, rightZ))
    }))
  })
}) : flatMap21(self, (z) => map29(that, (z2) => f2(z, z2))));
var channelToSink = (self) => new SinkImpl(self);
var count3 = foldLeftChunks(0, (acc, chunk7) => acc + chunk7.length);
var mkString = suspend7(() => {
  const strings = [];
  return pipe(foldLeftChunks(void 0, (_, elems) => map7(elems, (elem) => {
    strings.push(String(elem));
  })), map29(() => strings.join("")));
});
var timed3 = pipe(withDuration(drain2), map29((tuple7) => tuple7[1]));

// node_modules/effect/dist/esm/MergeDecision.js
var MergeDecision_exports = {};
__export(MergeDecision_exports, {
  Await: () => Await2,
  AwaitConst: () => AwaitConst2,
  Done: () => Done4,
  MergeDecisionTypeId: () => MergeDecisionTypeId2,
  isMergeDecision: () => isMergeDecision2,
  match: () => match28
});
var MergeDecisionTypeId2 = MergeDecisionTypeId;
var Done4 = Done3;
var Await2 = Await;
var AwaitConst2 = AwaitConst;
var isMergeDecision2 = isMergeDecision;
var match28 = match25;

// node_modules/effect/dist/esm/RcRef.js
var RcRef_exports = {};
__export(RcRef_exports, {
  TypeId: () => TypeId24,
  get: () => get16,
  make: () => make65
});

// node_modules/effect/dist/esm/internal/rcRef.js
var TypeId23 = Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance8 = {
  _A: identity,
  _E: identity
};
var _a65, _b20, _c4;
var RcRefImpl = class extends (_c4 = Class3, _b20 = TypeId23, _a65 = TypeId15, _c4) {
  constructor(acquire4, context15, scope6, idleTimeToLive) {
    super();
    __publicField(this, "acquire");
    __publicField(this, "context");
    __publicField(this, "scope");
    __publicField(this, "idleTimeToLive");
    __publicField(this, _b20, variance8);
    __publicField(this, _a65, TypeId15);
    __publicField(this, "state", stateEmpty2);
    __publicField(this, "semaphore", unsafeMakeSemaphore(1));
    __publicField(this, "get");
    this.acquire = acquire4;
    this.context = context15;
    this.scope = scope6;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get15(this);
  }
  commit() {
    return this.get;
  }
};
var make64 = (options) => withFiberRuntime((fiber) => {
  const context15 = fiber.getFiberRef(currentContext);
  const scope6 = get4(context15, scopeTag);
  const ref = new RcRefImpl(options.acquire, context15, scope6, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0);
  return as3(scope6.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close3 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_3;
    ref.state = stateClosed;
    return close3;
  }))), ref);
});
var get15 = (self_) => {
  const self = self_;
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self.state.refCount++;
        return self.state.fiber ? as3(interruptFiber(self.state.fiber), self.state) : succeed(self.state);
      }
      case "Empty": {
        return scopeMake2().pipe(bindTo5("scope"), bind5("value", ({
          scope: scope6
        }) => restore(fiberRefLocally(self.acquire, currentContext, add3(self.context, scopeTag, scope6)))), map14(({
          scope: scope6,
          value: value10
        }) => {
          const state = {
            _tag: "Acquired",
            value: value10,
            scope: scope6,
            fiber: void 0,
            refCount: 1
          };
          self.state = state;
          return state;
        }));
      }
    }
  })).pipe(self.semaphore.withPermits(1), bindTo5("state"), bind5("scope", () => scopeTag), tap2(({
    scope: scope6,
    state
  }) => scope6.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0) {
      return void_3;
    }
    if (self.idleTimeToLive === void 0) {
      self.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self.idleTimeToLive).pipe(interruptible2, zipRight2(suspend(() => {
      if (self.state._tag === "Acquired" && self.state.refCount === 0) {
        self.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_3;
    })), ensuring2(sync(() => {
      state.fiber = void 0;
    })), forkIn2(self.scope), tap2((fiber) => {
      state.fiber = fiber;
    }), self.semaphore.withPermits(1));
  }))), map14(({
    state
  }) => state.value));
};

// node_modules/effect/dist/esm/RcRef.js
var TypeId24 = TypeId23;
var make65 = make64;
var get16 = get15;

// node_modules/effect/dist/esm/Runtime.js
var Runtime_exports = {};
__export(Runtime_exports, {
  FiberFailureCauseId: () => FiberFailureCauseId2,
  FiberFailureId: () => FiberFailureId2,
  defaultRuntime: () => defaultRuntime2,
  defaultRuntimeFlags: () => defaultRuntimeFlags2,
  deleteFiberRef: () => deleteFiberRef2,
  disableRuntimeFlag: () => disableRuntimeFlag2,
  enableRuntimeFlag: () => enableRuntimeFlag2,
  isAsyncFiberException: () => isAsyncFiberException2,
  isFiberFailure: () => isFiberFailure2,
  make: () => make66,
  makeFiberFailure: () => makeFiberFailure,
  provideService: () => provideService7,
  runCallback: () => runCallback2,
  runFork: () => runFork3,
  runPromise: () => runPromise3,
  runPromiseExit: () => runPromiseExit3,
  runSync: () => runSync3,
  runSyncExit: () => runSyncExit3,
  setFiberRef: () => setFiberRef2,
  updateContext: () => updateContext3,
  updateFiberRefs: () => updateFiberRefs4,
  updateRuntimeFlags: () => updateRuntimeFlags3
});
var runFork3 = unsafeFork3;
var runSyncExit3 = unsafeRunSyncExit;
var runSync3 = unsafeRunSync;
var runCallback2 = unsafeRunCallback;
var runPromise3 = unsafeRunPromise;
var runPromiseExit3 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;
var defaultRuntimeFlags2 = defaultRuntimeFlags;
var make66 = make56;
var FiberFailureId2 = Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId2 = FiberFailureCauseId;
var isAsyncFiberException2 = isAsyncFiberException;
var isFiberFailure2 = isFiberFailure;
var makeFiberFailure = fiberFailure;
var updateRuntimeFlags3 = updateRuntimeFlags2;
var enableRuntimeFlag2 = enableRuntimeFlag;
var disableRuntimeFlag2 = disableRuntimeFlag;
var updateContext3 = updateContext2;
var provideService7 = provideService3;
var updateFiberRefs4 = updateFiberRefs2;
var setFiberRef2 = setFiberRef;
var deleteFiberRef2 = deleteFiberRef;

// node_modules/effect/dist/esm/Schedule.js
var Schedule_exports = {};
__export(Schedule_exports, {
  CurrentIterationMetadata: () => CurrentIterationMetadata2,
  ScheduleDriverTypeId: () => ScheduleDriverTypeId2,
  ScheduleTypeId: () => ScheduleTypeId2,
  addDelay: () => addDelay2,
  addDelayEffect: () => addDelayEffect2,
  andThen: () => andThen12,
  andThenEither: () => andThenEither2,
  as: () => as11,
  asVoid: () => asVoid8,
  bothInOut: () => bothInOut2,
  check: () => check3,
  checkEffect: () => checkEffect2,
  collectAllInputs: () => collectAllInputs2,
  collectAllOutputs: () => collectAllOutputs2,
  collectUntil: () => collectUntil2,
  collectUntilEffect: () => collectUntilEffect2,
  collectWhile: () => collectWhile2,
  collectWhileEffect: () => collectWhileEffect2,
  compose: () => compose5,
  count: () => count4,
  cron: () => cron2,
  dayOfMonth: () => dayOfMonth2,
  dayOfWeek: () => dayOfWeek2,
  delayed: () => delayed2,
  delayedEffect: () => delayedEffect2,
  delayedSchedule: () => delayedSchedule2,
  delays: () => delays2,
  driver: () => driver2,
  duration: () => duration2,
  either: () => either7,
  eitherWith: () => eitherWith2,
  elapsed: () => elapsed2,
  ensuring: () => ensuring7,
  exponential: () => exponential3,
  fibonacci: () => fibonacci2,
  fixed: () => fixed2,
  forever: () => forever5,
  fromDelay: () => fromDelay2,
  fromDelays: () => fromDelays2,
  fromFunction: () => fromFunction4,
  hourOfDay: () => hourOfDay2,
  identity: () => identity4,
  intersect: () => intersect6,
  intersectWith: () => intersectWith2,
  isSchedule: () => isSchedule2,
  jittered: () => jittered2,
  jitteredWith: () => jitteredWith2,
  linear: () => linear3,
  makeWithState: () => makeWithState2,
  map: () => map30,
  mapBoth: () => mapBoth7,
  mapBothEffect: () => mapBothEffect2,
  mapEffect: () => mapEffect7,
  mapInput: () => mapInput9,
  mapInputContext: () => mapInputContext5,
  mapInputEffect: () => mapInputEffect4,
  minuteOfHour: () => minuteOfHour2,
  modifyDelay: () => modifyDelay2,
  modifyDelayEffect: () => modifyDelayEffect2,
  onDecision: () => onDecision2,
  once: () => once4,
  passthrough: () => passthrough4,
  provideContext: () => provideContext6,
  provideService: () => provideService8,
  recurUntil: () => recurUntil2,
  recurUntilEffect: () => recurUntilEffect2,
  recurUntilOption: () => recurUntilOption2,
  recurUpTo: () => recurUpTo2,
  recurWhile: () => recurWhile2,
  recurWhileEffect: () => recurWhileEffect2,
  recurs: () => recurs2,
  reduce: () => reduce18,
  reduceEffect: () => reduceEffect4,
  repeatForever: () => repeatForever,
  repetitions: () => repetitions2,
  resetAfter: () => resetAfter2,
  resetWhen: () => resetWhen2,
  run: () => run3,
  secondOfMinute: () => secondOfMinute2,
  spaced: () => spaced2,
  stop: () => stop2,
  succeed: () => succeed17,
  sync: () => sync12,
  tapInput: () => tapInput2,
  tapOutput: () => tapOutput2,
  unfold: () => unfold4,
  union: () => union14,
  unionWith: () => unionWith3,
  untilInput: () => untilInput2,
  untilInputEffect: () => untilInputEffect2,
  untilOutput: () => untilOutput2,
  untilOutputEffect: () => untilOutputEffect2,
  upTo: () => upTo2,
  whileInput: () => whileInput2,
  whileInputEffect: () => whileInputEffect2,
  whileOutput: () => whileOutput2,
  whileOutputEffect: () => whileOutputEffect2,
  windowed: () => windowed2,
  zipLeft: () => zipLeft10,
  zipRight: () => zipRight10,
  zipWith: () => zipWith15
});
var ScheduleTypeId2 = ScheduleTypeId;
var ScheduleDriverTypeId2 = ScheduleDriverTypeId;
var makeWithState2 = makeWithState;
var isSchedule2 = isSchedule;
var addDelay2 = addDelay;
var addDelayEffect2 = addDelayEffect;
var andThen12 = andThen10;
var andThenEither2 = andThenEither;
var as11 = as7;
var asVoid8 = asVoid5;
var bothInOut2 = bothInOut;
var check3 = check2;
var checkEffect2 = checkEffect;
var collectAllInputs2 = collectAllInputs;
var collectAllOutputs2 = collectAllOutputs;
var collectUntil2 = collectUntil;
var collectUntilEffect2 = collectUntilEffect;
var collectWhile2 = collectWhile;
var collectWhileEffect2 = collectWhileEffect;
var compose5 = compose4;
var mapInput9 = mapInput6;
var mapInputEffect4 = mapInputEffect;
var mapInputContext5 = mapInputContext2;
var count4 = count2;
var cron2 = cron;
var secondOfMinute2 = secondOfMinute;
var minuteOfHour2 = minuteOfHour;
var hourOfDay2 = hourOfDay;
var dayOfMonth2 = dayOfMonth;
var dayOfWeek2 = dayOfWeek;
var delayed2 = delayed;
var delayedEffect2 = delayedEffect;
var delayedSchedule2 = delayedSchedule;
var delays2 = delays;
var mapBoth7 = mapBoth5;
var mapBothEffect2 = mapBothEffect;
var driver2 = driver;
var duration2 = duration;
var either7 = either5;
var eitherWith2 = eitherWith;
var elapsed2 = elapsed;
var ensuring7 = ensuring3;
var exponential3 = exponential2;
var fibonacci2 = fibonacci;
var fixed2 = fixed;
var forever5 = forever3;
var fromDelay2 = fromDelay;
var fromDelays2 = fromDelays;
var fromFunction4 = fromFunction2;
var identity4 = identity3;
var passthrough4 = passthrough2;
var intersect6 = intersect5;
var intersectWith2 = intersectWith;
var jittered2 = jittered;
var jitteredWith2 = jitteredWith;
var linear3 = linear2;
var map30 = map25;
var mapEffect7 = mapEffect4;
var modifyDelay2 = modifyDelay;
var modifyDelayEffect2 = modifyDelayEffect;
var onDecision2 = onDecision;
var once4 = once2;
var provideContext6 = provideContext3;
var provideService8 = provideService4;
var recurUntil2 = recurUntil;
var recurUntilEffect2 = recurUntilEffect;
var recurUntilOption2 = recurUntilOption;
var recurUpTo2 = recurUpTo;
var recurWhile2 = recurWhile;
var recurWhileEffect2 = recurWhileEffect;
var recurs2 = recurs;
var reduce18 = reduce16;
var reduceEffect4 = reduceEffect2;
var repeatForever = forever3;
var repetitions2 = repetitions;
var resetAfter2 = resetAfter;
var resetWhen2 = resetWhen;
var run3 = run;
var spaced2 = spaced;
var stop2 = stop;
var succeed17 = succeed11;
var sync12 = sync7;
var tapInput2 = tapInput;
var tapOutput2 = tapOutput;
var unfold4 = unfold3;
var union14 = union13;
var unionWith3 = unionWith2;
var untilInput2 = untilInput;
var untilInputEffect2 = untilInputEffect;
var untilOutput2 = untilOutput;
var untilOutputEffect2 = untilOutputEffect;
var upTo2 = upTo;
var whileInput2 = whileInput;
var whileInputEffect2 = whileInputEffect;
var whileOutput2 = whileOutput;
var whileOutputEffect2 = whileOutputEffect;
var windowed2 = windowed;
var zipLeft10 = zipLeft6;
var zipRight10 = zipRight6;
var zipWith15 = zipWith11;
var CurrentIterationMetadata2 = CurrentIterationMetadata;

// node_modules/effect/dist/esm/StreamHaltStrategy.js
var StreamHaltStrategy_exports = {};
__export(StreamHaltStrategy_exports, {
  Both: () => Both2,
  Either: () => Either2,
  Left: () => Left2,
  Right: () => Right2,
  fromInput: () => fromInput3,
  isBoth: () => isBoth2,
  isEither: () => isEither4,
  isLeft: () => isLeft4,
  isRight: () => isRight4,
  match: () => match30
});

// node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either = {
  _tag: OP_EITHER
};
var fromInput2 = (input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};
var isLeft3 = (self) => self._tag === OP_LEFT;
var isRight3 = (self) => self._tag === OP_RIGHT;
var isBoth = (self) => self._tag === OP_BOTH;
var isEither3 = (self) => self._tag === OP_EITHER;
var match29 = dual(2, (self, options) => {
  switch (self._tag) {
    case OP_LEFT: {
      return options.onLeft();
    }
    case OP_RIGHT: {
      return options.onRight();
    }
    case OP_BOTH: {
      return options.onBoth();
    }
    case OP_EITHER: {
      return options.onEither();
    }
  }
});

// node_modules/effect/dist/esm/StreamHaltStrategy.js
var Left2 = Left;
var Right2 = Right;
var Both2 = Both;
var Either2 = Either;
var fromInput3 = fromInput2;
var isLeft4 = isLeft3;
var isRight4 = isRight3;
var isBoth2 = isBoth;
var isEither4 = isEither3;
var match30 = match29;

// node_modules/effect/dist/esm/TPubSub.js
var TPubSub_exports = {};
__export(TPubSub_exports, {
  TPubSubTypeId: () => TPubSubTypeId2,
  awaitShutdown: () => awaitShutdown7,
  bounded: () => bounded8,
  capacity: () => capacity8,
  dropping: () => dropping7,
  isEmpty: () => isEmpty21,
  isFull: () => isFull8,
  isShutdown: () => isShutdown7,
  publish: () => publish4,
  publishAll: () => publishAll4,
  shutdown: () => shutdown7,
  size: () => size26,
  sliding: () => sliding7,
  subscribe: () => subscribe4,
  subscribeScoped: () => subscribeScoped2,
  unbounded: () => unbounded8
});

// node_modules/effect/dist/esm/internal/stm/versioned.js
var Versioned = class {
  constructor(value10) {
    __publicField(this, "value");
    this.value = value10;
  }
};

// node_modules/effect/dist/esm/internal/stm/entry.js
var make67 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet8 = (self) => {
  return self.newValue;
};
var unsafeSet = (self, value10) => {
  self.isChanged = true;
  self.newValue = value10;
};
var commit = (self) => {
  self.ref.versioned = new Versioned(self.newValue);
};
var copy3 = (self) => ({
  ref: self.ref,
  isNew: self.isNew,
  isChanged: self.isChanged,
  expected: self.expected,
  newValue: self.newValue
});
var isInvalid = (self) => {
  return self.ref.versioned !== self.expected;
};
var isChanged = (self) => {
  return self.isChanged;
};

// node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var prepareResetJournal = (journal) => {
  const saved = /* @__PURE__ */ new Map();
  for (const entry of journal) {
    saved.set(entry[0], copy3(entry[1]));
  }
  return () => {
    journal.clear();
    for (const entry of saved) {
      journal.set(entry[0], entry[1]);
    }
  };
};
var collectTodos = (journal) => {
  const allTodos = /* @__PURE__ */ new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = /* @__PURE__ */ new Map();
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning3 = (self) => {
  return self._tag === OP_RUNNING2;
};
var isDone6 = (self) => {
  return self._tag === OP_DONE6;
};
var done9 = (exit4) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit4,
    [symbol2]() {
      return pipe(hash(STMStateSymbolKey), combine2(hash(OP_DONE6)), combine2(hash(exit4)), cached(this));
    },
    [symbol3](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit4, that.exit);
    }
  };
};
var interruptedHash = pipe(hash(STMStateSymbolKey), combine2(hash(OP_INTERRUPTED)), combine2(hash("interrupted")));
var interrupted3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol2]() {
    return interruptedHash;
  },
  [symbol3](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = pipe(hash(STMStateSymbolKey), combine2(hash(OP_RUNNING2)), combine2(hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol2]() {
    return runningHash;
  },
  [symbol3](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done9(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done9(die4(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done9(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done9(succeed3(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = Symbol.for(TExitSymbolKey);
var variance9 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var isExit2 = (u) => hasProperty(u, TExitTypeId);
var isSuccess4 = (self) => {
  return self._tag === OP_SUCCEED3;
};
var isRetry = (self) => {
  return self._tag === OP_RETRY2;
};
var fail16 = (error4) => ({
  [TExitTypeId]: variance9,
  _tag: OP_FAIL5,
  error: error4,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_FAIL5)), combine2(hash(error4)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error4, that.error);
  }
});
var die11 = (defect) => ({
  [TExitTypeId]: variance9,
  _tag: OP_DIE3,
  defect,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_DIE3)), combine2(hash(defect)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt9 = (fiberId5) => ({
  [TExitTypeId]: variance9,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId5,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_INTERRUPT3)), combine2(hash(fiberId5)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId5, that.fiberId);
  }
});
var succeed18 = (value10) => ({
  [TExitTypeId]: variance9,
  _tag: OP_SUCCEED3,
  value: value10,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine2(hash(OP_SUCCEED3)), combine2(hash(value10)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value10, that.value);
  }
});
var retryHash = pipe(hash(TExitSymbolKey), combine2(hash(OP_RETRY2)), combine2(hash("retry")));
var retry5 = {
  [TExitTypeId]: variance9,
  _tag: OP_RETRY2,
  [symbol2]() {
    return retryHash;
  },
  [symbol3](that) {
    return isExit2(that) && isRetry(that);
  }
};
var void_9 = succeed18(void 0);

// node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done10 = (exit4) => {
  return {
    _tag: OP_DONE5,
    exit: exit4
  };
};
var suspend8 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make68 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = Symbol.for(STMSymbolKey2);
var stmVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var _a66, _b21, _c5, _d2;
var STMPrimitive = class {
  constructor(effect_instruction_i0) {
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "_op", OP_COMMIT);
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, _d2);
    __publicField(this, _c5);
    __publicField(this, _b21);
    __publicField(this, _a66);
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId4] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId3] = stmVariance;
    this[ChannelTypeId3] = stmVariance;
  }
  get [(_d2 = EffectTypeId4, _c5 = StreamTypeId, _b21 = SinkTypeId3, _a66 = ChannelTypeId3, STMTypeId2)]() {
    return stmVariance;
  }
  [symbol3](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random2(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSTM = (u) => hasProperty(u, STMTypeId2);
var commit2 = (self) => unsafeAtomically(self, constVoid, constVoid);
var unsafeAtomically = (self, onDone3, onInterrupt4) => withFiberRuntime((state) => {
  const fiberId5 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler2 = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId5, self, env, scheduler2, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone3(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make68();
      const state2 = {
        value: running3
      };
      const effect4 = async2((k) => tryCommitAsync(fiberId5, self, txnId, state2, env, scheduler2, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect4), catchAllCause4((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted3;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone3(currentState.exit);
          return currentState.exit;
        }
        onInterrupt4();
        return failCause10(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId5, stm, state, env, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId5, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail8(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die6(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt6(fiberId5);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend8(journal);
    }
  }
};
var tryCommitSync = (fiberId5, stm, env, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId5, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail8(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      const cause3 = die6(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt6(fiberId5);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend8(journal);
    }
  }
};
var tryCommitAsync = (fiberId5, self, txnId, state, context15, scheduler2, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId5, self, state, context15, scheduler2, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId5, self, txnId, state, context15, scheduler2, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit4, journal, scheduler2, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler2.scheduleTask(() => execTodos(todos), priority);
  }
  return done10(exit4);
};
var completeTryCommit = (exit4, k) => {
  k(exit4);
};
var context9 = () => effect3((_, __, env) => env);
var contextWith5 = (f2) => map31(context9(), f2);
var contextWithSTM = (f2) => flatMap22(context9(), f2);
var STMDriver = class {
  constructor(self, journal, fiberId5, r0) {
    __publicField(this, "self");
    __publicField(this, "journal");
    __publicField(this, "fiberId");
    __publicField(this, "contStack", []);
    __publicField(this, "env");
    this.self = self;
    this.journal = journal;
    this.fiberId = fiberId5;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextFailure() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextRetry() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
      current2 = this.popStack();
    }
    return current2;
  }
  run() {
    let curr = this.self;
    let exit4 = void 0;
    while (exit4 === void 0 && curr !== void 0) {
      try {
        const current2 = curr;
        if (current2) {
          switch (current2._op) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet3(env, current2));
              break;
            }
            case "Left": {
              curr = fail17(current2.left);
              break;
            }
            case "None": {
              curr = fail17(new NoSuchElementException3());
              break;
            }
            case "Right": {
              curr = succeed19(current2.right);
              break;
            }
            case "Some": {
              curr = succeed19(current2.value);
              break;
            }
            case "Commit": {
              switch (current2.effect_instruction_i0) {
                case OP_DIE2: {
                  exit4 = die11(internalCall(() => current2.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === void 0) {
                    exit4 = fail16(internalCall(() => current2.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current2.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === void 0) {
                    exit4 = retry5;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit4 = interrupt9(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current2.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current2);
                  curr = current2.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current2.effect_instruction_i2(env));
                  curr = pipe(current2.effect_instruction_i1, ensuring8(sync13(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value10 = current2.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed18(value10);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value10));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value10 = internalCall(() => current2.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed18(value10);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value10));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die12(e);
      }
    }
    return exit4;
  }
};
var catchAll7 = dual(2, (self, f2) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f2;
  return stm;
});
var mapInputContext6 = dual(2, (self, f2) => {
  const stm = new STMPrimitive(OP_PROVIDE3);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f2;
  return stm;
});
var die12 = (defect) => dieSync7(() => defect);
var dieMessage4 = (message) => dieSync7(() => new RuntimeException2(message));
var dieSync7 = (evaluate4) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate4;
  return stm;
};
var effect3 = (f2) => withSTMRuntime((_) => succeed19(f2(_.journal, _.fiberId, _.getEnv())));
var ensuring8 = dual(2, (self, finalizer3) => matchSTM(self, {
  onFailure: (e) => zipRight11(finalizer3, fail17(e)),
  onSuccess: (a) => zipRight11(finalizer3, succeed19(a))
}));
var fail17 = (error4) => failSync9(() => error4);
var failSync9 = (evaluate4) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate4;
  return stm;
};
var flatMap22 = dual(2, (self, f2) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f2;
  return stm;
});
var matchSTM = dual(2, (self, {
  onFailure,
  onSuccess
}) => pipe(self, map31(right2), catchAll7((e) => pipe(onFailure(e), map31(left2))), flatMap22((either14) => {
  switch (either14._tag) {
    case "Left": {
      return succeed19(either14.left);
    }
    case "Right": {
      return onSuccess(either14.right);
    }
  }
})));
var withSTMRuntime = (f2) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f2;
  return stm;
};
var interrupt10 = withSTMRuntime((_) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = _.fiberId;
  return stm;
});
var interruptAs2 = (fiberId5) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId5;
  return stm;
};
var map31 = dual(2, (self, f2) => pipe(self, flatMap22((a) => sync13(() => f2(a)))));
var orTry = dual(2, (self, that) => {
  const stm = new STMPrimitive(OP_ON_RETRY);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = that;
  return stm;
});
var retry6 = new STMPrimitive(OP_RETRY);
var succeed19 = (value10) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value10;
  return stm;
};
var sync13 = (evaluate4) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate4;
  return stm;
};
var zip15 = dual(2, (self, that) => pipe(self, zipWith16(that, (a, a1) => [a, a1])));
var zipLeft11 = dual(2, (self, that) => pipe(self, flatMap22((a) => pipe(that, map31(() => a)))));
var zipRight11 = dual(2, (self, that) => pipe(self, flatMap22(() => that)));
var zipWith16 = dual(3, (self, that, f2) => pipe(self, flatMap22((a) => pipe(that, map31((b) => f2(a, b))))));

// node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// node_modules/effect/dist/esm/internal/stm/stm.js
var acquireUseRelease5 = dual(3, (acquire4, use2, release4) => uninterruptibleMask3((restore) => {
  let state = running3;
  return pipe(restore(unsafeAtomically(acquire4, (exit4) => {
    state = done9(exit4);
  }, () => {
    state = interrupted3;
  })), matchCauseEffect3({
    onFailure: (cause3) => {
      if (isDone6(state) && isSuccess(state.exit)) {
        return pipe(release4(state.exit.value), matchCauseEffect3({
          onFailure: (cause22) => failCause10(parallel4(cause3, cause22)),
          onSuccess: () => failCause10(cause3)
        }));
      }
      return failCause10(cause3);
    },
    onSuccess: (a) => pipe(restore(use2(a)), matchCauseEffect3({
      onFailure: (cause3) => pipe(release4(a), matchCauseEffect3({
        onFailure: (cause22) => failCause10(parallel4(cause3, cause22)),
        onSuccess: () => failCause10(cause3)
      })),
      onSuccess: (a2) => pipe(release4(a), as8(a2))
    }))
  }));
}));
var as12 = dual(2, (self, value10) => pipe(self, map31(() => value10)));
var asSome4 = (self) => pipe(self, map31(some3));
var asSomeError3 = (self) => pipe(self, mapError9(some3));
var asVoid9 = (self) => pipe(self, map31(constVoid));
var attempt = (evaluate4) => suspend9(() => {
  try {
    return succeed19(evaluate4());
  } catch (defect) {
    return fail17(defect);
  }
});
var bind8 = dual(3, (self, tag5, f2) => flatMap22(self, (k) => map31(f2(k), (a) => ({
  ...k,
  [tag5]: a
}))));
var bindTo8 = dual(2, (self, tag5) => map31(self, (a) => ({
  [tag5]: a
})));
var let_8 = dual(3, (self, tag5, f2) => map31(self, (k) => ({
  ...k,
  [tag5]: f2(k)
})));
var catchSome3 = dual(2, (self, pf) => catchAll7(self, (e) => getOrElse2(pf(e), () => fail17(e))));
var catchTag4 = dual(3, (self, k, f2) => catchAll7(self, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f2(e);
  }
  return fail17(e);
}));
var catchTags3 = dual(2, (self, cases) => catchAll7(self, (e) => {
  const keys15 = Object.keys(cases);
  if ("_tag" in e && keys15.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail17(e);
}));
var check4 = (predicate) => suspend9(() => predicate() ? void_10 : retry6);
var collect3 = dual(2, (self, pf) => collectSTM(self, (a) => map2(pf(a), succeed19)));
var collectSTM = dual(2, (self, pf) => matchSTM(self, {
  onFailure: fail17,
  onSuccess: (a) => {
    const option11 = pf(a);
    return isSome2(option11) ? option11.value : retry6;
  }
}));
var commitEither = (self) => flatten13(commit2(either8(self)));
var cond = (predicate, error4, result) => {
  return suspend9(() => predicate() ? sync13(result) : failSync9(error4));
};
var either8 = (self) => match31(self, {
  onFailure: left2,
  onSuccess: right2
});
var eventually3 = (self) => matchSTM(self, {
  onFailure: () => eventually3(self),
  onSuccess: succeed19
});
var every15 = dual(2, (iterable, predicate) => pipe(flatMap22(sync13(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop5 = suspend9(() => {
    const next6 = iterator.next();
    if (next6.done) {
      return succeed19(true);
    }
    return pipe(predicate(next6.value), flatMap22((bool) => bool ? loop5 : succeed19(bool)));
  });
  return loop5;
})));
var exists5 = dual(2, (iterable, predicate) => flatMap22(sync13(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop5 = suspend9(() => {
    const next6 = iterator.next();
    if (next6.done) {
      return succeed19(false);
    }
    return flatMap22(predicate(next6.value), (bool) => bool ? succeed19(bool) : loop5);
  });
  return loop5;
}));
var fiberId3 = effect3((_, fiberId5) => fiberId5);
var filter17 = dual(2, (iterable, predicate) => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(predicate(curr), (as18, p) => {
  if (p) {
    as18.push(curr);
    return as18;
  }
  return as18;
})), succeed19([])));
var filterNot = dual(2, (iterable, predicate) => filter17(iterable, (a) => negate5(predicate(a))));
var filterOrDie3 = dual(3, (self, predicate, defect) => filterOrElse3(self, predicate, () => dieSync7(defect)));
var filterOrDieMessage3 = dual(3, (self, predicate, message) => filterOrElse3(self, predicate, () => dieMessage4(message)));
var filterOrElse3 = dual(3, (self, predicate, orElse24) => flatMap22(self, (a) => predicate(a) ? succeed19(a) : orElse24(a)));
var filterOrFail4 = dual(3, (self, predicate, orFailWith) => filterOrElse3(self, predicate, (a) => failSync9(() => orFailWith(a))));
var flatten16 = (self) => flatMap22(self, identity);
var flip6 = (self) => matchSTM(self, {
  onFailure: succeed19,
  onSuccess: fail17
});
var flipWith3 = dual(2, (self, f2) => flip6(f2(flip6(self))));
var match31 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => succeed19(onFailure(e)),
  onSuccess: (a) => succeed19(onSuccess(a))
}));
var forEach18 = dual((args2) => isIterable(args2[0]), (iterable, f2, options) => {
  if (options == null ? void 0 : options.discard) {
    return pipe(sync13(() => iterable[Symbol.iterator]()), flatMap22((iterator) => {
      const loop5 = suspend9(() => {
        const next6 = iterator.next();
        if (next6.done) {
          return void_10;
        }
        return pipe(f2(next6.value), flatMap22(() => loop5));
      });
      return loop5;
    }));
  }
  return suspend9(() => fromIterable2(iterable).reduce((acc, curr) => zipWith16(acc, f2(curr), (array8, elem) => {
    array8.push(elem);
    return array8;
  }), succeed19([])));
});
var fromEither4 = (either14) => {
  switch (either14._tag) {
    case "Left": {
      return fail17(either14.left);
    }
    case "Right": {
      return succeed19(either14.right);
    }
  }
};
var fromOption7 = (option11) => match2(option11, {
  onNone: () => fail17(none2()),
  onSome: succeed19
});
var gen7 = (...args2) => suspend9(() => {
  const f2 = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f2(pipe);
  const state = iterator.next();
  const run10 = (state2) => state2.done ? succeed19(state2.value) : flatMap22(yieldWrapGet(state2.value), (val) => run10(iterator.next(val)));
  return run10(state);
});
var head9 = (self) => pipe(self, matchSTM({
  onFailure: (e) => fail17(some3(e)),
  onSuccess: (a) => {
    const i = a[Symbol.iterator]();
    const res = i.next();
    if (res.done) {
      return fail17(none2());
    } else {
      return succeed19(res.value);
    }
  }
}));
var if_3 = dual((args2) => typeof args2[0] === "boolean" || isSTM(args2[0]), (self, {
  onFalse,
  onTrue
}) => {
  if (typeof self === "boolean") {
    return self ? onTrue : onFalse;
  }
  return flatMap22(self, (bool) => bool ? onTrue : onFalse);
});
var ignore4 = (self) => match31(self, {
  onFailure: () => void_10,
  onSuccess: () => void_10
});
var isFailure6 = (self) => match31(self, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess5 = (self) => match31(self, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate3 = (initial, options) => iterateLoop(initial, options.while, options.body);
var iterateLoop = (initial, cont, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22((z) => iterateLoop(z, cont, body)));
  }
  return succeed19(initial);
};
var loop3 = (initial, options) => options.discard ? loopDiscardLoop(initial, options.while, options.step, options.body) : map31(loopLoop(initial, options.while, options.step, options.body), (a) => Array.from(a));
var loopLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22((a) => pipe(loopLoop(inc(initial), cont, inc, body), map31(append3(a)))));
  }
  return succeed19(empty7());
};
var loopDiscardLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22(() => loopDiscardLoop(inc(initial), cont, inc, body)));
  }
  return void_10;
};
var mapAttempt = dual(2, (self, f2) => matchSTM(self, {
  onFailure: (e) => fail17(e),
  onSuccess: (a) => attempt(() => f2(a))
}));
var mapBoth8 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => fail17(onFailure(e)),
  onSuccess: (a) => succeed19(onSuccess(a))
}));
var mapError9 = dual(2, (self, f2) => matchSTM(self, {
  onFailure: (e) => fail17(f2(e)),
  onSuccess: succeed19
}));
var merge9 = (self) => matchSTM(self, {
  onFailure: (e) => succeed19(e),
  onSuccess: succeed19
});
var mergeAll8 = dual(3, (iterable, zero3, f2) => suspend9(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(curr, f2)), succeed19(zero3))));
var negate5 = (self) => pipe(self, map31((b) => !b));
var none10 = (self) => matchSTM(self, {
  onFailure: (e) => fail17(some3(e)),
  onSuccess: match2({
    onNone: () => void_10,
    onSome: () => fail17(none2())
  })
});
var option5 = (self) => match31(self, {
  onFailure: () => none2(),
  onSuccess: some3
});
var orDie7 = (self) => pipe(self, orDieWith4(identity));
var orDieWith4 = dual(2, (self, f2) => pipe(self, mapError9(f2), catchAll7(die12)));
var orElse12 = dual(2, (self, that) => flatMap22(effect3((journal) => prepareResetJournal(journal)), (reset4) => pipe(orTry(self, () => flatMap22(sync13(reset4), that)), catchAll7(() => flatMap22(sync13(reset4), that)))));
var orElseEither6 = dual(2, (self, that) => orElse12(map31(self, left2), () => map31(that(), right2)));
var orElseFail3 = dual(2, (self, error4) => orElse12(self, () => failSync9(error4)));
var orElseOptional = dual(2, (self, that) => catchAll7(self, match2({
  onNone: that,
  onSome: (e) => fail17(some3(e))
})));
var orElseSucceed4 = dual(2, (self, value10) => orElse12(self, () => sync13(value10)));
var provideContext7 = dual(2, (self, env) => mapInputContext6(self, (_) => env));
var provideSomeContext2 = dual(2, (self, context15) => mapInputContext6(self, (parent) => merge3(parent, context15)));
var provideService9 = dual(3, (self, tag5, resource) => provideServiceSTM(self, tag5, succeed19(resource)));
var provideServiceSTM = dual(3, (self, tag5, stm) => contextWithSTM((env) => flatMap22(stm, (service4) => provideContext7(self, add3(env, tag5, service4)))));
var reduce19 = dual(3, (iterable, zero3, f2) => suspend9(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, flatMap22((s) => f2(s, curr))), succeed19(zero3))));
var reduceAll = dual(3, (iterable, initial, f2) => suspend9(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(curr, f2)), initial)));
var reduceRight6 = dual(3, (iterable, zero3, f2) => suspend9(() => Array.from(iterable).reduceRight((acc, curr) => pipe(acc, flatMap22((s) => f2(s, curr))), succeed19(zero3))));
var refineOrDie2 = dual(2, (self, pf) => refineOrDieWith2(self, pf, identity));
var refineOrDieWith2 = dual(3, (self, pf, f2) => catchAll7(self, (e) => match2(pf(e), {
  onNone: () => die12(f2(e)),
  onSome: fail17
})));
var reject = dual(2, (self, pf) => rejectSTM(self, (a) => map2(pf(a), fail17)));
var rejectSTM = dual(2, (self, pf) => flatMap22(self, (a) => match2(pf(a), {
  onNone: () => succeed19(a),
  onSome: flatMap22(fail17)
})));
var repeatUntil = dual(2, (self, predicate) => repeatUntilLoop(self, predicate));
var repeatUntilLoop = (self, predicate) => flatMap22(self, (a) => predicate(a) ? succeed19(a) : repeatUntilLoop(self, predicate));
var repeatWhile = dual(2, (self, predicate) => repeatWhileLoop(self, predicate));
var repeatWhileLoop = (self, predicate) => pipe(flatMap22(self, (a) => predicate(a) ? repeatWhileLoop(self, predicate) : succeed19(a)));
var replicate6 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateSTM = dual(2, (self, n) => all12(replicate6(self, n)));
var replicateSTMDiscard = dual(2, (self, n) => all12(replicate6(self, n), {
  discard: true
}));
var retryUntil = dual(2, (self, predicate) => matchSTM(self, {
  onFailure: fail17,
  onSuccess: (a) => predicate(a) ? succeed19(a) : retry6
}));
var retryWhile = dual(2, (self, predicate) => matchSTM(self, {
  onFailure: fail17,
  onSuccess: (a) => !predicate(a) ? succeed19(a) : retry6
}));
var partition10 = dual(2, (elements, f2) => pipe(forEach18(elements, (a) => either8(f2(a))), map31((as18) => partitionMap6(as18, identity))));
var some16 = (self) => matchSTM(self, {
  onFailure: (e) => fail17(some3(e)),
  onSuccess: match2({
    onNone: () => fail17(none2()),
    onSome: succeed19
  })
});
var all12 = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach18(input, identity, options);
  } else if (options == null ? void 0 : options.discard) {
    return forEach18(Object.values(input), identity, options);
  }
  return map31(forEach18(Object.entries(input), ([_, e]) => map31(e, (a) => [_, a])), (values15) => {
    const res = {};
    for (const [k, v] of values15) {
      ;
      res[k] = v;
    }
    return res;
  });
};
var succeedNone4 = succeed19(none2());
var succeedSome4 = (value10) => succeed19(some3(value10));
var summarized4 = dual(3, (self, summary11, f2) => flatMap22(summary11, (start5) => flatMap22(self, (value10) => map31(summary11, (end7) => [f2(start5, end7), value10]))));
var suspend9 = (evaluate4) => flatten16(sync13(evaluate4));
var tap7 = dual(2, (self, f2) => flatMap22(self, (a) => as12(f2(a), a)));
var tapBoth3 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => pipe(onFailure(e), zipRight11(fail17(e))),
  onSuccess: (a) => pipe(onSuccess(a), as12(a))
}));
var tapError6 = dual(2, (self, f2) => matchSTM(self, {
  onFailure: (e) => zipRight11(f2(e), fail17(e)),
  onSuccess: succeed19
}));
var try_5 = (arg) => {
  const evaluate4 = typeof arg === "function" ? arg : arg.try;
  return suspend9(() => {
    try {
      return succeed19(evaluate4());
    } catch (error4) {
      return fail17("catch" in arg ? arg.catch(error4) : error4);
    }
  });
};
var void_10 = succeed19(void 0);
var unless3 = dual(2, (self, predicate) => suspend9(() => predicate() ? succeedNone4 : asSome4(self)));
var unlessSTM = dual(2, (self, predicate) => flatMap22(predicate, (bool) => bool ? succeedNone4 : asSome4(self)));
var unsome = (self) => matchSTM(self, {
  onFailure: match2({
    onNone: () => succeed19(none2()),
    onSome: fail17
  }),
  onSuccess: (a) => succeed19(some3(a))
});
var validateAll3 = dual(2, (elements, f2) => flatMap22(partition10(elements, f2), ([errors2, values15]) => isNonEmptyArray2(errors2) ? fail17(errors2) : succeed19(values15)));
var validateFirst3 = dual(2, (elements, f2) => flip6(forEach18(elements, (a) => flip6(f2(a)))));
var when4 = dual(2, (self, predicate) => suspend9(() => predicate() ? asSome4(self) : succeedNone4));
var whenSTM = dual(2, (self, predicate) => flatMap22(predicate, (bool) => bool ? asSome4(self) : succeedNone4));

// node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = Symbol.for(TRefSymbolKey);
var tRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a67;
_a67 = TRefTypeId;
var TRefImpl = class {
  constructor(value10) {
    __publicField(this, _a67, tRefVariance);
    /** @internal */
    __publicField(this, "todos");
    /** @internal */
    __publicField(this, "versioned");
    this.versioned = new Versioned(value10);
    this.todos = /* @__PURE__ */ new Map();
  }
  modify(f2) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f2(unsafeGet8(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make69 = (value10) => effect3((journal) => {
  const ref = new TRefImpl(value10);
  journal.set(ref, make67(ref, true));
  return ref;
});
var get17 = (self) => self.modify((a) => [a, a]);
var set10 = dual(2, (self, value10) => self.modify(() => [void 0, value10]));
var getAndSet5 = dual(2, (self, value10) => self.modify((a) => [a, value10]));
var getAndUpdate5 = dual(2, (self, f2) => self.modify((a) => [a, f2(a)]));
var getAndUpdateSome4 = dual(2, (self, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [a, a],
  onSome: (b) => [a, b]
})));
var setAndGet4 = dual(2, (self, value10) => self.modify(() => [value10, value10]));
var modify12 = dual(2, (self, f2) => self.modify(f2));
var modifySome4 = dual(3, (self, fallback3, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [fallback3, a],
  onSome: (b) => b
})));
var update8 = dual(2, (self, f2) => self.modify((a) => [void 0, f2(a)]));
var updateAndGet5 = dual(2, (self, f2) => self.modify((a) => {
  const b = f2(a);
  return [b, b];
}));
var updateSome4 = dual(2, (self, f2) => self.modify((a) => [void 0, match2(f2(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet4 = dual(2, (self, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [a, a],
  onSome: (b) => [b, b]
})));
var getOrMakeEntry = (self, journal) => {
  if (journal.has(self)) {
    return journal.get(self);
  }
  const entry = make67(self, false);
  journal.set(self, entry);
  return entry;
};
var unsafeGet9 = dual(2, (self, journal) => unsafeGet8(getOrMakeEntry(self, journal)));
var unsafeSet2 = dual(3, (self, value10, journal) => {
  const entry = getOrMakeEntry(self, journal);
  unsafeSet(entry, value10);
  return void 0;
});

// node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = Symbol.for(TDequeueSymbolKey);
var BackPressure2 = {
  _tag: OP_BACKPRESSURE_STRATEGY
};
var Dropping = {
  _tag: OP_DROPPING_STRATEGY
};
var Sliding = {
  _tag: OP_SLIDING_STRATEGY
};
var tDequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var tEnqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var _a68, _b22;
_b22 = TDequeueTypeId, _a68 = TEnqueueTypeId;
var TQueueImpl = class {
  constructor(ref, requestedCapacity, strategy) {
    __publicField(this, "ref");
    __publicField(this, "requestedCapacity");
    __publicField(this, "strategy");
    __publicField(this, _b22, tDequeueVariance);
    __publicField(this, _a68, tEnqueueVariance);
    __publicField(this, "size", withSTMRuntime((runtime8) => {
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      return succeed19(queue.length);
    }));
    __publicField(this, "isFull", map31(this.size, (size45) => size45 === this.requestedCapacity));
    __publicField(this, "isEmpty", map31(this.size, (size45) => size45 === 0));
    __publicField(this, "shutdown", withSTMRuntime((runtime8) => {
      unsafeSet2(this.ref, void 0, runtime8.journal);
      return void_10;
    }));
    __publicField(this, "isShutdown", effect3((journal) => {
      const queue = unsafeGet9(this.ref, journal);
      return queue === void 0;
    }));
    __publicField(this, "awaitShutdown", flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry6));
    __publicField(this, "peek", withSTMRuntime((runtime8) => {
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length === 0) {
        return retry6;
      }
      return succeed19(queue[0]);
    }));
    __publicField(this, "peekOption", withSTMRuntime((runtime8) => {
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      return succeed19(fromNullable2(queue[0]));
    }));
    __publicField(this, "take", withSTMRuntime((runtime8) => {
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length === 0) {
        return retry6;
      }
      const dequeued = queue.shift();
      unsafeSet2(this.ref, queue, runtime8.journal);
      return succeed19(dequeued);
    }));
    __publicField(this, "takeAll", withSTMRuntime((runtime8) => {
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      unsafeSet2(this.ref, [], runtime8.journal);
      return succeed19(queue);
    }));
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  offer(value10) {
    return withSTMRuntime((runtime8) => {
      const queue = pipe(this.ref, unsafeGet9(runtime8.journal));
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value10);
        unsafeSet2(this.ref, queue, runtime8.journal);
        return succeed19(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry6;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed19(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed19(true);
          }
          queue.shift();
          queue.push(value10);
          unsafeSet2(this.ref, queue, runtime8.journal);
          return succeed19(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime8) => {
      const as18 = Array.from(iterable);
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length + as18.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as18], runtime8.journal);
        return succeed19(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry6;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as18.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime8.journal);
          return succeed19(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as18.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime8.journal);
          return succeed19(true);
        }
      }
    });
  }
  takeUpTo(max14) {
    return withSTMRuntime((runtime8) => {
      const queue = unsafeGet9(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max14);
      unsafeSet2(this.ref, Array.from(remaining), runtime8.journal);
      return succeed19(Array.from(toTake));
    });
  }
};
var isTQueue = (u) => {
  return isTEnqueue(u) && isTDequeue(u);
};
var isTEnqueue = (u) => hasProperty(u, TEnqueueTypeId);
var isTDequeue = (u) => hasProperty(u, TDequeueTypeId);
var awaitShutdown5 = (self) => self.awaitShutdown;
var bounded6 = (requestedCapacity) => makeQueue(requestedCapacity, BackPressure2);
var capacity6 = (self) => {
  return self.capacity();
};
var dropping5 = (requestedCapacity) => makeQueue(requestedCapacity, Dropping);
var isEmpty19 = (self) => self.isEmpty;
var isFull6 = (self) => self.isFull;
var isShutdown5 = (self) => self.isShutdown;
var offer4 = dual(2, (self, value10) => self.offer(value10));
var offerAll4 = dual(2, (self, iterable) => self.offerAll(iterable));
var peek = (self) => self.peek;
var peekOption = (self) => self.peekOption;
var poll7 = (self) => pipe(self.takeUpTo(1), map31(head2));
var seek = dual(2, (self, predicate) => seekLoop(self, predicate));
var seekLoop = (self, predicate) => flatMap22(self.take, (a) => predicate(a) ? succeed19(a) : seekLoop(self, predicate));
var shutdown5 = (self) => self.shutdown;
var size24 = (self) => self.size;
var sliding5 = (requestedCapacity) => makeQueue(requestedCapacity, Sliding);
var take8 = (self) => self.take;
var takeAll3 = (self) => self.takeAll;
var takeBetween3 = dual(3, (self, min11, max14) => suspend9(() => {
  const takeRemainder = (min12, max15, acc) => {
    if (max15 < min12) {
      return succeed19(acc);
    }
    return pipe(self.takeUpTo(max15), flatMap22((taken) => {
      const remaining = min12 - taken.length;
      if (remaining === 1) {
        return pipe(self.take, map31((a) => pipe(acc, appendAll3(unsafeFromArray(taken)), append3(a))));
      }
      if (remaining > 1) {
        return pipe(self.take, flatMap22((a) => takeRemainder(remaining - 1, max15 - taken.length - 1, pipe(acc, appendAll3(unsafeFromArray(taken)), append3(a)))));
      }
      return succeed19(pipe(acc, appendAll3(unsafeFromArray(taken))));
    }));
  };
  return map31(takeRemainder(min11, max14, empty7()), (c) => Array.from(c));
}));
var takeN3 = dual(2, (self, n) => pipe(self, takeBetween3(n, n)));
var takeUpTo3 = dual(2, (self, max14) => self.takeUpTo(max14));
var unbounded6 = () => makeQueue(Number.MAX_SAFE_INTEGER, Dropping);
var makeQueue = (requestedCapacity, strategy) => map31(make69([]), (ref) => new TQueueImpl(ref, requestedCapacity, strategy));

// node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head13, subscribers, tail5) => ({
  head: head13,
  subscribers,
  tail: tail5
});
var _a69, _b23;
_b23 = TPubSubTypeId, _a69 = TEnqueueTypeId;
var TPubSubImpl = class {
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    __publicField(this, "pubsubSize");
    __publicField(this, "publisherHead");
    __publicField(this, "publisherTail");
    __publicField(this, "requestedCapacity");
    __publicField(this, "strategy");
    __publicField(this, "subscriberCount");
    __publicField(this, "subscribers");
    __publicField(this, _b23, {
      _A: (_) => _
    });
    __publicField(this, _a69, tEnqueueVariance);
    __publicField(this, "isShutdown", effect3((journal) => {
      const currentPublisherTail = unsafeGet9(this.publisherTail, journal);
      return currentPublisherTail === void 0;
    }));
    __publicField(this, "awaitShutdown", flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry6));
    __publicField(this, "size", withSTMRuntime((runtime8) => {
      const currentPublisherTail = unsafeGet9(this.publisherTail, runtime8.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      return succeed19(unsafeGet9(this.pubsubSize, runtime8.journal));
    }));
    __publicField(this, "isEmpty", map31(this.size, (size45) => size45 === 0));
    __publicField(this, "isFull", map31(this.size, (size45) => size45 === this.capacity()));
    __publicField(this, "shutdown", effect3((journal) => {
      const currentPublisherTail = unsafeGet9(this.publisherTail, journal);
      if (currentPublisherTail !== void 0) {
        unsafeSet2(this.publisherTail, void 0, journal);
        const currentSubscribers = unsafeGet9(this.subscribers, journal);
        forEach6(currentSubscribers, (subscriber) => {
          unsafeSet2(subscriber, void 0, journal);
        });
        unsafeSet2(this.subscribers, empty10(), journal);
      }
    }));
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  capacity() {
    return this.requestedCapacity;
  }
  offer(value10) {
    return withSTMRuntime((runtime8) => {
      const currentPublisherTail = unsafeGet9(this.publisherTail, runtime8.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const currentSubscriberCount = unsafeGet9(this.subscriberCount, runtime8.journal);
      if (currentSubscriberCount === 0) {
        return succeed19(true);
      }
      const currentPubSubSize = unsafeGet9(this.pubsubSize, runtime8.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(void 0);
        const updatedNode = makeNode2(value10, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime8.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime8.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime8.journal);
        return succeed19(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry6;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed19(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet9(this.publisherHead, runtime8.journal);
            let loop5 = true;
            while (loop5) {
              const node = unsafeGet9(currentPublisherHead, runtime8.journal);
              if (node === void 0) {
                return retry6;
              }
              const head13 = node.head;
              const tail5 = node.tail;
              if (head13 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime8.journal);
                unsafeSet2(this.publisherHead, tail5, runtime8.journal);
                loop5 = false;
              } else {
                currentPublisherHead = tail5;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(void 0);
          const updatedNode = makeNode2(value10, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime8.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime8.journal);
          return succeed19(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map31(forEach18(iterable, (a) => this.offer(a)), every3(identity));
  }
};
var _a70, _b24;
_b24 = TPubSubTypeId, _a70 = TDequeueTypeId;
var TPubSubSubscriptionImpl = class {
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    __publicField(this, "pubsubSize");
    __publicField(this, "publisherHead");
    __publicField(this, "requestedCapacity");
    __publicField(this, "subscriberHead");
    __publicField(this, "subscriberCount");
    __publicField(this, "subscribers");
    __publicField(this, _b24, TPubSubTypeId);
    __publicField(this, _a70, tDequeueVariance);
    __publicField(this, "isShutdown", effect3((journal) => {
      const currentSubscriberHead = unsafeGet9(this.subscriberHead, journal);
      return currentSubscriberHead === void 0;
    }));
    __publicField(this, "awaitShutdown", flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry6));
    __publicField(this, "size", withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      let loop5 = true;
      let size45 = 0;
      while (loop5) {
        const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          loop5 = false;
        } else {
          const head13 = node.head;
          const tail5 = node.tail;
          if (head13 !== AbsentValue2) {
            size45 = size45 + 1;
            if (size45 >= Number.MAX_SAFE_INTEGER) {
              loop5 = false;
            }
          }
          currentSubscriberHead = tail5;
        }
      }
      return succeed19(size45);
    }));
    __publicField(this, "isEmpty", map31(this.size, (size45) => size45 === 0));
    __publicField(this, "isFull", map31(this.size, (size45) => size45 === this.capacity()));
    __publicField(this, "peek", withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      let value10 = AbsentValue2;
      let loop5 = true;
      while (loop5) {
        const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          return retry6;
        }
        const head13 = node.head;
        const tail5 = node.tail;
        if (head13 !== AbsentValue2) {
          value10 = head13;
          loop5 = false;
        } else {
          currentSubscriberHead = tail5;
        }
      }
      return succeed19(value10);
    }));
    __publicField(this, "peekOption", withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      let value10 = none2();
      let loop5 = true;
      while (loop5) {
        const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          value10 = none2();
          loop5 = false;
        } else {
          const head13 = node.head;
          const tail5 = node.tail;
          if (head13 !== AbsentValue2) {
            value10 = some3(head13);
            loop5 = false;
          } else {
            currentSubscriberHead = tail5;
          }
        }
      }
      return succeed19(value10);
    }));
    __publicField(this, "shutdown", effect3((journal) => {
      let currentSubscriberHead = unsafeGet9(this.subscriberHead, journal);
      if (currentSubscriberHead !== void 0) {
        unsafeSet2(this.subscriberHead, void 0, journal);
        let loop5 = true;
        while (loop5) {
          const node = unsafeGet9(currentSubscriberHead, journal);
          if (node === void 0) {
            loop5 = false;
          } else {
            const head13 = node.head;
            const tail5 = node.tail;
            if (head13 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size45 = unsafeGet9(this.pubsubSize, journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail5);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
                unsafeSet2(this.publisherHead, tail5, journal);
                unsafeSet2(this.pubsubSize, size45 - 1, journal);
              } else {
                const updatedNode = makeNode2(head13, subscribers - 1, tail5);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
              }
            }
            currentSubscriberHead = tail5;
          }
        }
        const currentSubscriberCount = unsafeGet9(this.subscriberCount, journal);
        unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
        unsafeSet2(this.subscribers, remove6(unsafeGet9(this.subscribers, journal), this.subscriberHead), journal);
      }
    }));
    __publicField(this, "take", withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      let value10 = AbsentValue2;
      let loop5 = true;
      while (loop5) {
        const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          return retry6;
        }
        const head13 = node.head;
        const tail5 = node.tail;
        if (head13 !== AbsentValue2) {
          const subscribers = node.subscribers;
          if (subscribers === 1) {
            const size45 = unsafeGet9(this.pubsubSize, runtime8.journal);
            const updatedNode = makeNode2(AbsentValue2, 0, tail5);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
            unsafeSet2(this.publisherHead, tail5, runtime8.journal);
            unsafeSet2(this.pubsubSize, size45 - 1, runtime8.journal);
          } else {
            const updatedNode = makeNode2(head13, subscribers - 1, tail5);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
          }
          unsafeSet2(this.subscriberHead, tail5, runtime8.journal);
          value10 = head13;
          loop5 = false;
        } else {
          currentSubscriberHead = tail5;
        }
      }
      return succeed19(value10);
    }));
    __publicField(this, "takeAll", this.takeUpTo(Number.POSITIVE_INFINITY));
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  capacity() {
    return this.requestedCapacity;
  }
  takeUpTo(max14) {
    return withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max14) {
        const node = unsafeGet9(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          n = max14;
        } else {
          const head13 = node.head;
          const tail5 = node.tail;
          if (head13 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size45 = unsafeGet9(this.pubsubSize, runtime8.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail5);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
              unsafeSet2(this.publisherHead, tail5, runtime8.journal);
              unsafeSet2(this.pubsubSize, size45 - 1, runtime8.journal);
            } else {
              const updatedNode = makeNode2(head13, subscribers - 1, tail5);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
            }
            builder.push(head13);
            n = n + 1;
          }
          currentSubscriberHead = tail5;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime8.journal);
      return succeed19(builder);
    });
  }
};
var makeTPubSub = (requestedCapacity, strategy) => pipe(all12([make69(void 0), make69(0)]), flatMap22(([empty61, pubsubSize]) => pipe(all12([make69(empty61), make69(empty61), make69(0), make69(empty10())]), map31(([publisherHead, publisherTail, subscriberCount, subscribers]) => new TPubSubImpl(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers)))));
var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get17(publisherTail), flatMap22((currentPublisherTail) => pipe(all12([make69(currentPublisherTail), get17(subscriberCount), get17(subscribers)]), tap7(([_, currentSubscriberCount]) => pipe(subscriberCount, set10(currentSubscriberCount + 1))), tap7(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set10(pipe(currentSubscribers, add5(subscriberHead))))), map31(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
var awaitShutdown6 = (self) => self.awaitShutdown;
var bounded7 = (requestedCapacity) => makeTPubSub(requestedCapacity, BackPressure2);
var capacity7 = (self) => self.capacity();
var dropping6 = (requestedCapacity) => makeTPubSub(requestedCapacity, Dropping);
var isEmpty20 = (self) => self.isEmpty;
var isFull7 = (self) => self.isFull;
var isShutdown6 = (self) => self.isShutdown;
var publish3 = dual(2, (self, value10) => self.offer(value10));
var publishAll3 = dual(2, (self, iterable) => self.offerAll(iterable));
var size25 = (self) => self.size;
var shutdown6 = (self) => self.shutdown;
var sliding6 = (requestedCapacity) => makeTPubSub(requestedCapacity, Sliding);
var subscribe3 = (self) => makeSubscription2(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers);
var subscribeScoped = (self) => acquireRelease3(subscribe3(self), (dequeue) => shutdown5(dequeue));
var unbounded7 = () => makeTPubSub(Number.MAX_SAFE_INTEGER, Dropping);

// node_modules/effect/dist/esm/TPubSub.js
var TPubSubTypeId2 = TPubSubTypeId;
var awaitShutdown7 = awaitShutdown6;
var bounded8 = bounded7;
var capacity8 = capacity7;
var dropping7 = dropping6;
var isEmpty21 = isEmpty20;
var isFull8 = isFull7;
var shutdown7 = shutdown6;
var isShutdown7 = isShutdown6;
var publish4 = publish3;
var publishAll4 = publishAll3;
var size26 = size25;
var sliding7 = sliding6;
var subscribe4 = subscribe3;
var subscribeScoped2 = subscribeScoped;
var unbounded8 = unbounded7;

// node_modules/effect/dist/esm/TQueue.js
var TQueue_exports = {};
__export(TQueue_exports, {
  TDequeueTypeId: () => TDequeueTypeId2,
  TEnqueueTypeId: () => TEnqueueTypeId2,
  awaitShutdown: () => awaitShutdown8,
  bounded: () => bounded9,
  capacity: () => capacity9,
  dropping: () => dropping8,
  isEmpty: () => isEmpty22,
  isFull: () => isFull9,
  isShutdown: () => isShutdown8,
  isTDequeue: () => isTDequeue2,
  isTEnqueue: () => isTEnqueue2,
  isTQueue: () => isTQueue2,
  offer: () => offer5,
  offerAll: () => offerAll5,
  peek: () => peek2,
  peekOption: () => peekOption2,
  poll: () => poll8,
  seek: () => seek2,
  shutdown: () => shutdown8,
  size: () => size27,
  sliding: () => sliding8,
  take: () => take9,
  takeAll: () => takeAll4,
  takeBetween: () => takeBetween4,
  takeN: () => takeN4,
  takeUpTo: () => takeUpTo4,
  unbounded: () => unbounded9
});
var TDequeueTypeId2 = TDequeueTypeId;
var TEnqueueTypeId2 = TEnqueueTypeId;
var isTQueue2 = isTQueue;
var isTDequeue2 = isTDequeue;
var isTEnqueue2 = isTEnqueue;
var awaitShutdown8 = awaitShutdown5;
var bounded9 = bounded6;
var capacity9 = capacity6;
var dropping8 = dropping5;
var isEmpty22 = isEmpty19;
var isFull9 = isFull6;
var isShutdown8 = isShutdown5;
var offer5 = offer4;
var offerAll5 = offerAll4;
var peek2 = peek;
var peekOption2 = peekOption;
var poll8 = poll7;
var seek2 = seek;
var shutdown8 = shutdown5;
var size27 = size24;
var sliding8 = sliding5;
var take9 = take8;
var takeAll4 = takeAll3;
var takeBetween4 = takeBetween3;
var takeN4 = takeN3;
var takeUpTo4 = takeUpTo3;
var unbounded9 = unbounded6;

// node_modules/effect/dist/esm/internal/ringBuffer.js
var RingBuffer = class {
  constructor(capacity10) {
    __publicField(this, "capacity");
    __publicField(this, "array");
    __publicField(this, "size", 0);
    __publicField(this, "current", 0);
    this.capacity = capacity10;
    this.array = Array.from({
      length: capacity10
    }, constUndefined);
  }
  head() {
    return fromNullable2(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return void 0;
    }
    const index3 = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index3] ?? void 0;
  }
  put(value10) {
    this.array[this.current] = value10;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = void 0;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable3(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};

// node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
});
var current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});

// node_modules/effect/dist/esm/internal/stream/emit.js
var make70 = (emit2) => {
  const ops = {
    chunk(as18) {
      return this(succeed13(as18));
    },
    die(defect) {
      return this(die8(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit4) {
      return this(suspend4(() => mapBoth4(exit4, {
        onFailure: some3,
        onSuccess: of3
      })));
    },
    end() {
      return this(fail12(none2()));
    },
    fail(e) {
      return this(fail12(some3(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth6(effect4, {
        onFailure: some3,
        onSuccess: of3
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError5(some3)));
    },
    halt(cause3) {
      return this(failCause10(pipe(cause3, map22(some3))));
    },
    single(value10) {
      return this(succeed13(of3(value10)));
    }
  };
  return Object.assign(emit2, ops);
};
var makePush = (queue, scheduler2) => {
  let finished = false;
  let buffer7 = [];
  let running4 = false;
  function array8(items) {
    if (finished) return false;
    if (items.length <= 5e4) {
      buffer7.push.apply(buffer7, items);
    } else {
      for (let i = 0; i < items.length; i++) {
        buffer7.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler2.scheduleTask(flush, 0);
    }
    return true;
  }
  function flush() {
    running4 = false;
    if (buffer7.length > 0) {
      queue.unsafeOffer(buffer7);
      buffer7 = [];
    }
  }
  function done17(exit4) {
    if (finished) return;
    finished = true;
    if (exit4._tag === "Success") {
      buffer7.push(exit4.value);
    }
    flush();
    queue.unsafeOffer(exit4._tag === "Success" ? void_4 : exit4);
  }
  return {
    single(value10) {
      if (finished) return false;
      buffer7.push(value10);
      if (!running4) {
        running4 = true;
        scheduler2.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array8,
    chunk(chunk7) {
      return array8(toReadonlyArray(chunk7));
    },
    done: done17,
    end() {
      if (finished) return;
      finished = true;
      flush();
      queue.unsafeOffer(void_4);
    },
    halt(cause3) {
      return done17(failCause3(cause3));
    },
    fail(error4) {
      return done17(fail4(error4));
    },
    die(defect) {
      return done17(die4(defect));
    },
    dieMessage(message) {
      return done17(die4(new Error(message)));
    }
  };
};

// node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId = Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
var handoffStateFull = (value10, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value: value10,
  notifyProducer
});
var handoffStateMatch = (onEmpty, onFull) => {
  return (self) => {
    switch (self._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self.value, self.notifyProducer);
      }
    }
  };
};
var handoffVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var make71 = () => pipe(make24(), flatMap18((deferred) => make37(handoffStateEmpty(deferred))), map26((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
var offer6 = dual(2, (self, value10) => {
  return flatMap18(make24(), (deferred) => flatten13(modify8(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight7(succeed2(notifyConsumer, void 0), _await(deferred)), handoffStateFull(value10, deferred)], (_, notifyProducer) => [flatMap18(_await(notifyProducer), () => pipe(self, offer6(value10))), state])))));
});
var take10 = (self) => flatMap18(make24(), (deferred) => flatten13(modify8(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap18(_await(notifyConsumer), () => take10(self)), state], (value10, notifyProducer) => [as8(succeed2(notifyProducer, void 0), value10), handoffStateEmpty(deferred)])))));

// node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
});
var halt = (cause3) => ({
  _tag: OP_HALT,
  cause: cause3
});
var end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var _a71;
_a71 = TakeTypeId;
var TakeImpl = class {
  constructor(exit4) {
    __publicField(this, "exit");
    __publicField(this, _a71, takeVariance);
    this.exit = exit4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var chunk3 = (chunk7) => new TakeImpl(succeed3(chunk7));
var die13 = (defect) => new TakeImpl(die4(defect));
var dieMessage5 = (message) => new TakeImpl(die4(new RuntimeException2(message)));
var done11 = (self) => suspend4(() => self.exit);
var end4 = new TakeImpl(fail4(none2()));
var fail18 = (error4) => new TakeImpl(fail4(some3(error4)));
var failCause14 = (cause3) => new TakeImpl(failCause3(pipe(cause3, map22(some3))));
var fromEffect8 = (effect4) => matchCause4(effect4, {
  onFailure: failCause14,
  onSuccess: of7
});
var fromExit = (exit4) => new TakeImpl(pipe(exit4, mapBoth4({
  onFailure: some3,
  onSuccess: of3
})));
var fromPull = (pull) => matchCause4(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause14
  }),
  onSuccess: chunk3
});
var isDone7 = (self) => match7(self.exit, {
  onFailure: (cause3) => isNone2(flipCauseOption2(cause3)),
  onSuccess: constFalse
});
var isFailure7 = (self) => match7(self.exit, {
  onFailure: (cause3) => isSome2(flipCauseOption2(cause3)),
  onSuccess: constFalse
});
var isSuccess6 = (self) => match7(self.exit, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var make72 = (exit4) => new TakeImpl(exit4);
var match32 = dual(2, (self, {
  onEnd: onEnd3,
  onFailure,
  onSuccess
}) => match7(self.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd3,
    onSome: onFailure
  }),
  onSuccess
}));
var matchEffect5 = dual(2, (self, {
  onEnd: onEnd3,
  onFailure,
  onSuccess
}) => matchEffect2(self.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => onEnd3,
    onSome: onFailure
  }),
  onSuccess
}));
var map32 = dual(2, (self, f2) => new TakeImpl(pipe(self.exit, map15(map7(f2)))));
var of7 = (value10) => new TakeImpl(succeed3(of3(value10)));
var tap8 = dual(2, (self, f2) => pipe(self.exit, forEachEffect(f2), asVoid6));

// node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail12(none2());
var failCause15 = (cause3) => mapError5(failCause10(cause3), some3);

// node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
var PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});

// node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
});
var PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});

// node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId3 = Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};
var _a72;
_a72 = StreamTypeId3;
var StreamImpl = class {
  constructor(channel) {
    __publicField(this, "channel");
    __publicField(this, _a72, streamVariance);
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isStream = (u) => hasProperty(u, StreamTypeId3) || isEffect2(u);
var DefaultChunkSize = 4096;
var accumulate = (self) => chunks(accumulateChunks(self));
var accumulateChunks = (self) => {
  const accumulator = (s) => readWith({
    onInput: (input) => {
      const next6 = appendAll3(s, input);
      return flatMap20(write(next6), () => accumulator(next6));
    },
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipeTo(toChannel2(self), accumulator(empty7())));
};
var acquireRelease4 = (acquire4, release4) => scoped7(acquireRelease3(acquire4, release4));
var aggregate = dual(2, (self, sink) => aggregateWithin(self, sink, forever5));
var aggregateWithin = dual(3, (self, sink, schedule4) => filterMap12(aggregateWithinEither(self, sink, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some3
})));
var aggregateWithinEither = dual(3, (self, sink, schedule4) => {
  const layer = all11([make71(), make37(ScheduleEnd), make37(empty7()), driver2(schedule4), make37(false), make37(false)]);
  return fromEffect9(layer).pipe(flatMap23(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input) => flatMap20(fromEffect5(pipe(handoff, offer6(emit(input)), when3(() => isNonEmpty2(input)))), () => handoffProducer),
      onFailure: (cause3) => fromEffect5(offer6(handoff, halt(cause3))),
      onDone: () => fromEffect5(offer6(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet3(sinkLeftovers, empty7()), flatMap18((leftovers) => {
      if (isNonEmpty2(leftovers)) {
        return pipe(set7(consumed, true), zipRight7(succeed13(pipe(write(leftovers), flatMap20(() => handoffConsumer)))));
      }
      return pipe(take10(handoff), map26((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect5(set7(consumed, true)), zipRight8(write(signal.elements)), zipRight8(fromEffect5(get13(endAfterEmit))), flatMap20((bool) => bool ? void_8 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause12(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get13(consumed), map26((bool) => bool ? fromEffect5(pipe(set7(sinkEndReason, ScheduleEnd), zipRight7(set7(endAfterEmit, true)))) : pipe(fromEffect5(pipe(set7(sinkEndReason, ScheduleEnd), zipRight7(set7(endAfterEmit, true)))), flatMap20(() => handoffConsumer))), unwrap2);
            }
            return pipe(set7(sinkEndReason, signal.reason), zipRight7(set7(endAfterEmit, true)), fromEffect5);
          }
        }
      }));
    }), unwrap2);
    const timeout6 = (lastB) => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope6) => {
      const forkSink = pipe(set7(consumed, false), zipRight7(set7(endAfterEmit, false)), zipRight7(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn3(scope6))));
      const handleSide = (leftovers, b, c) => pipe(set7(sinkLeftovers, flatten5(leftovers)), zipRight7(map26(get13(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all11([get13(consumed), forkSink, pipe(timeout6(some3(b)), forkIn3(scope6))]), map26(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of3(right2(b)),
                onSome: (c2) => make9(right2(b), left2(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap20(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope6)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope6);
            }), unwrap2);
          }
          case OP_UPSTREAM_END: {
            return pipe(get13(consumed), map26((wasConsumed) => wasConsumed ? write(of3(right2(b))) : void_8), unwrap2);
          }
        }
      })), unwrap2);
      return unwrap2(raceWith2(join4(sinkFiber), join4(scheduleFiber), {
        onSelfDone: (sinkExit, _) => pipe(interrupt7(scheduleFiber), zipRight7(pipe(suspend4(() => sinkExit), map26(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
        onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend4(() => scheduleExit), {
          onFailure: (cause3) => match(failureOrCause2(cause3), {
            onLeft: () => pipe(handoff, offer6(end3(ScheduleEnd)), forkDaemon3, zipRight7(pipe(join4(sinkFiber), map26(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
            onRight: (cause4) => pipe(handoff, offer6(halt(cause4)), forkDaemon3, zipRight7(pipe(join4(sinkFiber), map26(([leftovers, b]) => handleSide(leftovers, b, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer6(end3(ScheduleEnd)), forkDaemon3, zipRight7(pipe(join4(sinkFiber), map26(([leftovers, b]) => handleSide(leftovers, b, some3(c))))))
        })
      }));
    };
    return unwrapScopedWith3((scope6) => pipeTo(toChannel2(self), handoffProducer).pipe(run2, forkIn3(scope6), zipRight7(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run2, forkIn3(scope6), flatMap18((sinkFiber) => timeout6(none2()).pipe(forkIn3(scope6), map26((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope6)))))))));
  }));
});
var as13 = dual(2, (self, value10) => map33(self, () => value10));
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded5();
  } else if (typeof bufferSize === "number" || bufferSize === void 0) {
    return bounded5(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping4(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding4(bufferSize.bufferSize ?? 16);
    default:
      return bounded5(bufferSize.bufferSize ?? 16);
  }
};
var _async = (register, bufferSize) => acquireRelease3(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap18((output) => runtime4().pipe(flatMap18((runtime8) => sync8(() => {
  const runPromiseExit4 = runPromiseExit3(runtime8);
  const canceler = register(make70((resume2) => fromPull(resume2).pipe(flatMap18((take16) => offer3(output, take16)), asVoid6, runPromiseExit4).then((exit4) => {
    if (isFailure2(exit4)) {
      if (!isInterrupted3(exit4.cause)) {
        throw squash(exit4.cause);
      }
    }
  })));
  return canceler;
})), map26((value10) => {
  const loop5 = take6(output).pipe(flatMap18((take16) => done11(take16)), match20({
    onFailure: (maybeError) => fromEffect5(shutdown4(output)).pipe(zipRight8(match2(maybeError, {
      onNone: () => void_8,
      onSome: (error4) => fail14(error4)
    }))),
    onSuccess: (chunk7) => write(chunk7).pipe(flatMap20(() => loop5))
  }), unwrap2);
  return fromChannel2(loop5).pipe(ensuring9(value10 ?? _void));
}))), unwrapScoped5);
var asyncEffect3 = (register, bufferSize) => pipe(acquireRelease3(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap18((output) => pipe(runtime4(), flatMap18((runtime8) => pipe(register(make70((k) => pipe(fromPull(k), flatMap18((take16) => offer3(output, take16)), asVoid6, runPromiseExit3(runtime8)).then((exit4) => {
  if (isFailure2(exit4)) {
    if (!isInterrupted3(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), map26(() => {
  const loop5 = pipe(take6(output), flatMap18(done11), match20({
    onFailure: (maybeError) => pipe(fromEffect5(shutdown4(output)), zipRight8(match2(maybeError, {
      onNone: () => void_8,
      onSome: fail14
    }))),
    onSuccess: (chunk7) => pipe(write(chunk7), flatMap20(() => loop5))
  }), unwrap2);
  return loop5;
}))))), unwrapScoped3, fromChannel2);
var queueFromBufferOptionsPush = (options) => {
  if ((options == null ? void 0 : options.bufferSize) === "unbounded" || (options == null ? void 0 : options.bufferSize) === void 0 && (options == null ? void 0 : options.strategy) === void 0) {
    return unbounded5();
  }
  switch (options == null ? void 0 : options.strategy) {
    case "sliding":
      return sliding4(options.bufferSize ?? 16);
    default:
      return dropping4((options == null ? void 0 : options.bufferSize) ?? 16);
  }
};
var asyncPush = (register, options) => acquireRelease3(queueFromBufferOptionsPush(options), shutdown4).pipe(tap5((queue) => getWith(currentScheduler2, (scheduler2) => register(makePush(queue, scheduler2)))), map26((queue) => {
  const loop5 = flatMap20(take6(queue), (item) => isExit(item) ? isSuccess(item) ? void_8 : failCause12(item.cause) : zipRight8(write(unsafeFromArray(item)), loop5));
  return loop5;
}), unwrapScoped3, fromChannel2);
var asyncScoped = (register, bufferSize) => pipe(acquireRelease3(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap18((output) => pipe(runtime4(), flatMap18((runtime8) => pipe(register(make70((k) => pipe(fromPull(k), flatMap18((take16) => offer3(output, take16)), asVoid6, runPromiseExit3(runtime8)).then((exit4) => {
  if (isFailure2(exit4)) {
    if (!isInterrupted3(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), zipRight7(make37(false)), flatMap18((ref) => pipe(get13(ref), map26((isDone9) => isDone9 ? end5() : pipe(take6(output), flatMap18(done11), onError3(() => pipe(set7(ref, true), zipRight7(shutdown4(output)))))))))))), scoped7, flatMap23(repeatEffectChunkOption));
var branchAfter = dual(3, (self, n, f2) => suspend10(() => {
  const buffering = (acc) => readWith({
    onInput: (input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b22] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll3(b1)), b22);
      }
      return buffering(pipe(acc, appendAll3(input)));
    },
    onFailure: fail14,
    onDone: () => running4(acc, empty7())
  });
  const running4 = (prefix, leftover3) => pipeTo(zipRight8(write(leftover3), identityChannel()), toChannel2(f2(prefix)));
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(buffering(empty7()))));
}));
var broadcast = dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), map26((tuple7) => tuple7.map((queue) => flattenTake(fromQueue3(queue, {
  shutdown: true
}))))));
var broadcastDynamic = dual(2, (self, maximumLag) => map26(toPubSub2(self, maximumLag), (pubsub) => flattenTake(fromPubSub3(pubsub))));
var share = dual(2, (self, options) => map26(make65({
  acquire: broadcastDynamic(self, options),
  idleTimeToLive: options.idleTimeToLive
}), (rcRef) => unwrapScoped5(get16(rcRef))));
var broadcastedQueues = dual(3, (self, n, maximumLag) => flatMap18(pubsubFromOptions(maximumLag), (pubsub) => pipe(all11(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap5(() => forkScoped3(runIntoPubSubScoped(self, pubsub))))));
var broadcastedQueuesDynamic = dual(2, (self, maximumLag) => map26(toPubSub2(self, maximumLag), subscribe2));
var buffer2 = dual(2, (self, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self, options.capacity);
  }
  const queue = toQueueOfElements(self, options);
  return new StreamImpl(unwrapScoped3(map26(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take6(queue2)), flatMap20(match7({
      onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: () => void_8,
        onSome: failCause12
      })),
      onSuccess: (value10) => flatMap20(write(of3(value10)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = dual(2, (self, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self, options.capacity);
  }
  const queue = toQueue2(self, options);
  return new StreamImpl(unwrapScoped3(map26(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take6(queue2)), flatMap20(match32({
      onEnd: () => void_8,
      onFailure: failCause12,
      onSuccess: (value10) => pipe(write(value10), flatMap20(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = dual(2, (self, capacity10) => {
  const queue = acquireRelease3(dropping4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferChunksSliding = dual(2, (self, capacity10) => {
  const queue = acquireRelease3(sliding4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferDropping = dual(2, (self, capacity10) => {
  const queue = acquireRelease3(dropping4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self))));
});
var bufferSliding = dual(2, (self, capacity10) => {
  const queue = acquireRelease3(sliding4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self, rechunk(1)))));
});
var bufferUnbounded = (self) => {
  const queue = toQueue2(self, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map26(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take6(queue2)), flatMap20(match32({
      onEnd: () => void_8,
      onFailure: failCause12,
      onSuccess: (value10) => flatMap20(write(value10), () => process2)
    })));
    return process2;
  })));
};
var bufferSignal = (scoped10, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take16) => pipe(get13(ref), tap5(_await), zipRight7(make24()), flatMap18((deferred) => pipe(offer3(queue, [take16, deferred]), zipRight7(set7(ref, deferred)), zipRight7(_await(deferred)))), asVoid6, fromEffect5);
    return readWithCause({
      onInput: (input) => pipe(make24(), flatMap18((deferred) => pipe(offer3(queue, [chunk3(input), deferred]), flatMap18((added) => pipe(set7(ref, deferred), when3(() => added))))), asVoid6, fromEffect5, flatMap20(() => producer(queue, ref))),
      onFailure: (error4) => terminate(failCause14(error4)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect5(take6(queue)), flatMap20(([take16, deferred]) => zipRight8(fromEffect5(succeed2(deferred, void 0)), match32(take16, {
      onEnd: () => void_8,
      onFailure: failCause12,
      onSuccess: (value10) => pipe(write(value10), flatMap20(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped3(pipe(scoped10, flatMap18((queue) => pipe(make24(), tap5((start5) => succeed2(start5, void 0)), flatMap18((start5) => pipe(make37(start5), flatMap18((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped3)), as8(consumer(queue))))))));
};
var catchAll8 = dual(2, (self, f2) => catchAllCause7(self, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f2,
  onRight: failCause16
})));
var catchAllCause7 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), catchAllCause6((cause3) => toChannel2(f2(cause3))))));
var catchSome4 = dual(2, (self, pf) => pipe(self, catchAll8((error4) => pipe(pf(error4), getOrElse2(() => fail19(error4))))));
var catchSomeCause3 = dual(2, (self, pf) => pipe(self, catchAllCause7((cause3) => pipe(pf(cause3), getOrElse2(() => failCause16(cause3))))));
var catchTag5 = dual(3, (self, k, f2) => catchAll8(self, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f2(e);
  }
  return fail19(e);
}));
var catchTags4 = dual(2, (self, cases) => catchAll8(self, (e) => {
  const keys15 = Object.keys(cases);
  if ("_tag" in e && keys15.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail19(e);
}));
var changes = (self) => pipe(self, changesWith((x, y) => equals(y)(x)));
var changesWith = dual(2, (self, f2) => {
  const writer = (last8) => readWithCause({
    onInput: (input) => {
      const [newLast, newChunk] = reduce4(input, [last8, empty7()], ([option11, outputs], output) => {
        if (isSome2(option11) && f2(option11.value, output)) {
          return [some3(output), outputs];
        }
        return [some3(output), pipe(outputs, append3(output))];
      });
      return flatMap20(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var changesWithEffect = dual(2, (self, f2) => {
  const writer = (last8) => readWithCause({
    onInput: (input) => pipe(input, reduce17([last8, empty7()], ([option11, outputs], output) => {
      if (isSome2(option11)) {
        return pipe(f2(option11.value, output), map26((bool) => bool ? [some3(output), outputs] : [some3(output), pipe(outputs, append3(output))]));
      }
      return succeed13([some3(output), pipe(outputs, append3(output))]);
    }), fromEffect5, flatMap20(([newLast, newChunk]) => pipe(write(newChunk), flatMap20(() => writer(newLast))))),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var chunks = (self) => pipe(self, mapChunks(of3));
var chunksWith = dual(2, (self, f2) => flattenChunks(f2(chunks(self))));
var unsome2 = (effect4) => catchAll4(asSome3(effect4), (o) => o._tag === "None" ? succeedNone3 : fail12(o.value));
var combine16 = dual(4, (self, that, s, f2) => {
  function producer(handoff, latch) {
    return fromEffect5(take10(latch)).pipe(zipRight8(readWithCause({
      onInput: (input) => flatMap20(fromEffect5(offer6(handoff, succeed3(input))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect5(offer6(handoff, failCause3(pipe(cause3, map22(some3))))),
      onDone: () => flatMap20(fromEffect5(offer6(handoff, fail4(none2()))), () => producer(handoff, latch))
    })));
  }
  return new StreamImpl(unwrapScopedWith((scope6) => all11([make71(), make71(), make71(), make71()]).pipe(tap5(([left3, _, latchL]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope6), forkIn3(scope6))), tap5(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope6), forkIn3(scope6))), map26(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer6(latchL, void 0).pipe(zipRight7(take10(left3).pipe(flatMap18(identity))));
    const pullRight = offer6(latchR, void 0).pipe(zipRight7(take10(right3).pipe(flatMap18(identity))));
    return toChannel2(unfoldEffect(s, (s2) => flatMap18(f2(s2, pullLeft, pullRight), unsome2)));
  }))));
});
var combineChunks = dual(4, (self, that, s, f2) => {
  const producer = (handoff, latch) => zipRight8(fromEffect5(take10(latch)), readWithCause({
    onInput: (input) => flatMap20(fromEffect5(pipe(handoff, offer6(chunk3(input)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect5(offer6(handoff, failCause14(cause3))),
    onDone: () => fromEffect5(offer6(handoff, end4))
  }));
  return new StreamImpl(unwrapScopedWith((scope6) => all11([make71(), make71(), make71(), make71()]).pipe(tap5(([left3, _, latchL]) => pipeTo(toChannel2(self), producer(left3, latchL)).pipe(runIn(scope6), forkIn3(scope6))), tap5(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope6), forkIn3(scope6))), map26(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer6(latchL, void 0).pipe(zipRight7(take10(left3).pipe(flatMap18(done11))));
    const pullRight = offer6(latchR, void 0).pipe(zipRight7(take10(right3).pipe(flatMap18(done11))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap18(f2(s2, pullLeft, pullRight), unsome2)));
  }))));
});
var concat6 = dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), zipRight8(toChannel2(that)))));
var concatAll2 = (streams) => suspend10(() => pipe(streams, reduce4(empty43, (x, y) => concat6(y)(x))));
var cross = dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
var crossLeft = dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
var crossRight = dual(2, (left3, right3) => flatMap23(left3, () => right3));
var crossWith = dual(3, (left3, right3, f2) => pipe(left3, flatMap23((a) => pipe(right3, map33((b) => f2(a, b))))));
var debounce = dual(2, (self, duration5) => unwrapScopedWith3((scope6) => gen6(function* () {
  const handoff = yield* make71();
  function enqueue(last8) {
    return sleep2(duration5).pipe(as8(last8), forkIn3(scope6), map26((fiber) => consumer(previous(fiber))));
  }
  const producer = readWithCause({
    onInput: (input) => match2(last2(input), {
      onNone: () => producer,
      onSome: (elem) => fromEffect5(offer6(handoff, emit(of3(elem)))).pipe(flatMap20(() => producer))
    }),
    onFailure: (cause3) => fromEffect5(offer6(handoff, halt(cause3))),
    onDone: () => fromEffect5(offer6(handoff, end3(UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return unwrap2(take10(handoff).pipe(map26((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap2(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause12(signal.cause);
            }
            case OP_END: {
              return void_8;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap2(take10(handoff).pipe(forkIn3(scope6), flatMap18((handoffFiber) => raceWith2(join4(state.fiber), join4(handoffFiber), {
          onSelfDone: (leftExit, current2) => match7(leftExit, {
            onFailure: (cause3) => interrupt7(current2).pipe(as8(failCause12(cause3))),
            onSuccess: (chunk7) => interrupt7(current2).pipe(zipRight7(succeed13(write(chunk7).pipe(flatMap20(() => consumer(current(handoffFiber)))))))
          }),
          onOtherDone: (rightExit, previous2) => match7(rightExit, {
            onFailure: (cause3) => interrupt7(previous2).pipe(as8(failCause12(cause3))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt7(previous2).pipe(zipRight7(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt7(previous2).pipe(as8(failCause12(signal.cause)));
                }
                case OP_END: {
                  return join4(previous2).pipe(map26((chunk7) => write(chunk7).pipe(zipRight8(void_8))));
                }
              }
            }
          })
        }))));
      }
      case OP_CURRENT: {
        return unwrap2(join4(state.fiber).pipe(map26((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap2(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause12(signal.cause);
            }
            case OP_END: {
              return void_8;
            }
          }
        })));
      }
    }
  }
  return scopedWith4((scope7) => pipeTo(toChannel2(self), producer).pipe(runIn(scope7), forkIn3(scope7))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die14 = (defect) => fromEffect9(die8(defect));
var dieSync8 = (evaluate4) => fromEffect9(dieSync4(evaluate4));
var dieMessage6 = (message) => fromEffect9(dieMessage2(message));
var distributedWith = dual(2, (self, options) => pipe(make24(), flatMap18((deferred) => pipe(self, distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: (a) => flatMap18(_await(deferred), (f2) => f2(a))
}), flatMap18((next6) => pipe(all11(map7(range3(0, options.size - 1), (id3) => map26(next6, ([key, queue]) => [[key, id3], queue]))), map26(unsafeFromArray), flatMap18((entries6) => {
  const [mappings, queues] = reduceRight2(entries6, [/* @__PURE__ */ new Map(), empty7()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend3(queue))]);
  return pipe(succeed2(deferred, (a) => map26(options.decide(a), (f2) => (key) => pipe(f2(mappings.get(key))))), as8(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
};
var distributedWithDynamic = dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => _void));
var distributedWithDynamicCallback = dual(4, (self, maximumLag, decide, done17) => pipe(acquireRelease3(make37(/* @__PURE__ */ new Map()), (ref, _) => pipe(get13(ref), flatMap18((queues) => pipe(queues.values(), forEach16(shutdown4))))), flatMap18((queuesRef) => gen6(function* () {
  const offer9 = (a) => pipe(decide(a), flatMap18((shouldProcess) => pipe(get13(queuesRef), flatMap18((queues) => pipe(queues.entries(), reduce17(empty7(), (acc, [id3, queue]) => {
    if (shouldProcess(id3)) {
      return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
        onFailure: (cause3) => (
          // Ignore all downstream queues that were shut
          // down and remove them later
          isInterrupted3(cause3) ? succeed13(pipe(acc, prepend3(id3))) : failCause10(cause3)
        ),
        onSuccess: () => succeed13(acc)
      }));
    }
    return succeed13(acc);
  }), flatMap18((ids3) => {
    if (isNonEmpty2(ids3)) {
      return pipe(update4(queuesRef, (map49) => {
        for (const id3 of ids3) {
          map49.delete(id3);
        }
        return map49;
      }));
    }
    return _void;
  }))))), asVoid6);
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make37(pipe(bounded5(maximumLag), flatMap18((queue) => {
    const id3 = newDistributedWithDynamicId();
    return pipe(update4(queuesRef, (map49) => map49.set(id3, queue)), as8([id3, queue]));
  })));
  const finalize = (endTake) => (
    // Make sure that no queues are currently being added
    queuesLock.withPermits(1)(pipe(set7(newQueue, pipe(
      // All newly created queues should end immediately
      bounded5(1),
      tap5((queue) => offer3(queue, endTake)),
      flatMap18((queue) => {
        const id3 = newDistributedWithDynamicId();
        return pipe(update4(queuesRef, (map49) => map49.set(id3, queue)), as8(make3(id3, queue)));
      })
    )), zipRight7(pipe(get13(queuesRef), flatMap18((map49) => pipe(fromIterable3(map49.values()), forEach16((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted3(cause3) ? some3(_void) : none2()))))))), zipRight7(done17(endTake)), asVoid6))
  );
  yield* pipe(self, runForEachScoped(offer9), matchCauseEffect3({
    onFailure: (cause3) => finalize(failCause3(pipe(cause3, map22(some3)))),
    onSuccess: () => finalize(fail4(none2()))
  }), forkScoped3);
  return queuesLock.withPermits(1)(flatten13(get13(newQueue)));
}))));
var drain3 = (self) => new StreamImpl(drain(toChannel2(self)));
var drainFork = dual(2, (self, that) => fromEffect9(make24()).pipe(flatMap23((backgroundDied) => scopedWith4((scope6) => toChannel2(that).pipe(drain, runIn(scope6), catchAllCause4((cause3) => failCause2(backgroundDied, cause3)), forkIn3(scope6))).pipe(crossRight(interruptWhenDeferred2(self, backgroundDied))))));
var drop6 = dual(2, (self, n) => {
  const loop5 = (r) => readWith({
    onInput: (input) => {
      const dropped = pipe(input, drop3(r));
      const leftover3 = Math.max(0, r - input.length);
      const more = isEmpty2(input) || leftover3 > 0;
      if (more) {
        return loop5(leftover3);
      }
      return pipe(write(dropped), zipRight8(identityChannel()));
    },
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5(n))));
});
var dropRight3 = dual(2, (self, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend10(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: (input) => {
        const outputs = pipe(input, filterMap5((elem) => {
          const head13 = queue.head();
          queue.put(elem);
          return head13;
        }));
        return pipe(write(outputs), flatMap20(() => reader));
      },
      onFailure: fail14,
      onDone: () => void_8
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(reader)));
  });
});
var dropUntil4 = dual(2, (self, predicate) => drop6(dropWhile6(self, (a) => !predicate(a)), 1));
var dropUntilEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(dropUntil2(input, predicate), map26(unsafeFromArray), map26((leftover3) => {
      const more = isEmpty2(leftover3);
      if (more) {
        return suspend6(() => loop5);
      }
      return pipe(write(leftover3), zipRight8(identityChannel()));
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var dropWhile6 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const output = dropWhile2(input, predicate);
      if (isEmpty2(output)) {
        return suspend6(() => loop5);
      }
      return zipRight8(write(output), identityChannel());
    },
    onFailure: fail14,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop5));
});
var dropWhileEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(dropWhile4(input, predicate), map26(unsafeFromArray), map26((leftover3) => {
      const more = isEmpty2(leftover3);
      if (more) {
        return suspend6(() => loop5);
      }
      return zipRight8(write(leftover3), identityChannel());
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop5));
});
var either9 = (self) => pipe(self, map33(right2), catchAll8((error4) => make73(left2(error4))));
var empty43 = new StreamImpl(void_8);
var ensuring9 = dual(2, (self, finalizer3) => new StreamImpl(pipe(toChannel2(self), ensuring5(finalizer3))));
var ensuringWith3 = dual(2, (self, finalizer3) => new StreamImpl(ensuringWith(toChannel2(self), finalizer3)));
var context10 = () => fromEffect9(context5());
var contextWith6 = (f2) => pipe(context10(), map33(f2));
var contextWithEffect5 = (f2) => pipe(context10(), mapEffectSequential(f2));
var contextWithStream = (f2) => pipe(context10(), flatMap23(f2));
var execute = (effect4) => drain3(fromEffect9(effect4));
var fail19 = (error4) => fromEffectOption(fail12(some3(error4)));
var failSync10 = (evaluate4) => fromEffectOption(failSync5(() => some3(evaluate4())));
var failCause16 = (cause3) => fromEffect9(failCause10(cause3));
var failCauseSync9 = (evaluate4) => fromEffect9(failCauseSync5(evaluate4));
var filter18 = dual(2, (self, predicate) => mapChunks(self, filter5(predicate)));
var filterEffect = dual(2, (self, f2) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    } else {
      return pipe(f2(next6.value), map26((bool) => bool ? pipe(write(of3(next6.value)), flatMap20(() => loop5(iterator))) : loop5(iterator)), unwrap2);
    }
  };
  return new StreamImpl(suspend6(() => pipe(toChannel2(self), pipeTo(loop5(empty7()[Symbol.iterator]())))));
});
var filterMap12 = dual(2, (self, pf) => mapChunks(self, filterMap5(pf)));
var filterMapEffect = dual(2, (self, pf) => suspend10(() => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    } else {
      return pipe(pf(next6.value), match2({
        onNone: () => sync8(() => loop5(iterator)),
        onSome: map26((a2) => flatMap20(write(of3(a2)), () => loop5(iterator)))
      }), unwrap2);
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty7()[Symbol.iterator]()))));
}));
var filterMapWhile4 = dual(2, (self, pf) => {
  const loop5 = readWith({
    onInput: (input) => {
      const mapped = filterMapWhile3(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap20(() => loop5));
      }
      return write(mapped);
    },
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var filterMapWhileEffect = dual(2, (self, pf) => suspend10(() => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    } else {
      return unwrap2(match2(pf(next6.value), {
        onNone: () => succeed13(void_8),
        onSome: map26((a2) => flatMap20(write(of3(a2)), () => loop5(iterator)))
      }));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5(empty7()[Symbol.iterator]()))));
}));
var finalizer = (finalizer3) => acquireRelease4(_void, () => finalizer3);
var find3 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => match2(findFirst4(input, predicate), {
      onNone: () => loop5,
      onSome: (n) => write(of3(n))
    }),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var findEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(findFirst11(input, predicate), map26(match2({
      onNone: () => loop5,
      onSome: (n) => write(of3(n))
    })), unwrap2),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var flatMap23 = dual((args2) => isStream(args2[0]), (self, f2, options) => {
  const bufferSize = (options == null ? void 0 : options.bufferSize) ?? 16;
  if (options == null ? void 0 : options.switch) {
    return matchConcurrency(options == null ? void 0 : options.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f2), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f2));
  }
  return matchConcurrency(options == null ? void 0 : options.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as18) => pipe(as18, map7((a) => toChannel2(f2(a))), reduce4(void_8, (left3, right3) => pipe(left3, zipRight8(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f2(out)), options))));
});
var matchConcurrency = (concurrency, sequential6, bounded10) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return bounded10(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded10(concurrency) : sequential6();
  }
};
var flatMapParSwitchBuffer = dual(4, (self, n, bufferSize, f2) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f2(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten17 = dual((args2) => isStream(args2[0]), (self, options) => flatMap23(self, identity, options));
var flattenChunks = (self) => {
  const flatten22 = readWithCause({
    onInput: (chunks3) => flatMap20(writeChunk(chunks3), () => flatten22),
    onFailure: failCause12,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(flatten22)));
};
var flattenEffect = dual((args2) => isStream(args2[0]), (self, options) => (options == null ? void 0 : options.unordered) ? flatMap23(self, (a) => fromEffect9(a), {
  concurrency: options.concurrency
}) : matchConcurrency(options == null ? void 0 : options.concurrency, () => mapEffectSequential(self, identity), (n) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of3)))));
var flattenExitOption = (self) => {
  const processChunk = (chunk7, cont) => {
    const [toEmit, rest] = pipe(chunk7, splitWhere2((exit4) => !isSuccess(exit4)));
    const next6 = pipe(head3(rest), match2({
      onNone: () => cont,
      onSome: match7({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_8,
          onSome: failCause12
        }),
        onSuccess: () => void_8
      })
    }));
    return pipe(write(pipe(toEmit, filterMap5((exit4) => isSuccess(exit4) ? some3(exit4.value) : none2()))), flatMap20(() => next6));
  };
  const process2 = readWithCause({
    onInput: (chunk7) => processChunk(chunk7, process2),
    onFailure: (cause3) => failCause12(cause3),
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
};
var flattenIterables = (self) => pipe(self, map33(fromIterable3), flattenChunks);
var flattenTake = (self) => flattenChunks(flattenExitOption(pipe(self, map33((take16) => take16.exit))));
var forever6 = (self) => new StreamImpl(repeated(toChannel2(self)));
var fromAsyncIterable = (iterable, onError6) => pipe(acquireRelease3(sync8(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise3(async () => iterator.return()) : _void), map26((iterator) => repeatEffectOption(pipe(tryPromise3({
  try: async () => iterator.next(),
  catch: (reason) => some3(onError6(reason))
}), flatMap18((result) => result.done ? fail12(none2()) : succeed13(result.value))))), unwrapScoped5);
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream2) => {
  if ("channel" in stream2) {
    return stream2.channel;
  } else if (isEffect2(stream2)) {
    return toChannel2(fromEffect9(stream2));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromChunk = (chunk7) => new StreamImpl(isEmpty2(chunk7) ? void_8 : write(chunk7));
var fromChunkPubSub = (pubsub, options) => {
  if (options == null ? void 0 : options.scoped) {
    const effect4 = map26(subscribe2(pubsub), fromChunkQueue);
    return options.shutdown ? map26(effect4, ensuring9(shutdown3(pubsub))) : effect4;
  }
  const stream2 = flatMap23(scoped7(subscribe2(pubsub)), fromChunkQueue);
  return (options == null ? void 0 : options.shutdown) ? ensuring9(stream2, shutdown3(pubsub)) : stream2;
};
var fromChunkQueue = (queue, options) => pipe(take6(queue), catchAllCause4((cause3) => pipe(isShutdown4(queue), flatMap18((isShutdown9) => isShutdown9 && isInterrupted3(cause3) ? end5() : failCause15(cause3)))), repeatEffectChunkOption, (options == null ? void 0 : options.shutdown) ? ensuring9(shutdown4(queue)) : identity);
var fromChunks = (...chunks3) => pipe(fromIterable17(chunks3), flatMap23(fromChunk));
var fromEffect9 = (effect4) => pipe(effect4, mapError5(some3), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap2(match20(effect4, {
  onFailure: match2({
    onNone: () => void_8,
    onSome: fail14
  }),
  onSuccess: (a) => write(of3(a))
})));
var fromPubSub3 = (pubsub, options) => {
  const maxChunkSize = (options == null ? void 0 : options.maxChunkSize) ?? DefaultChunkSize;
  if (options == null ? void 0 : options.scoped) {
    const effect4 = map26(subscribe2(pubsub), (queue) => fromQueue3(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map26(effect4, ensuring9(shutdown3(pubsub))) : effect4;
  }
  const stream2 = flatMap23(scoped7(subscribe2(pubsub)), (queue) => fromQueue3(queue, {
    maxChunkSize
  }));
  return (options == null ? void 0 : options.shutdown) ? ensuring9(stream2, shutdown3(pubsub)) : stream2;
};
var fromTPubSub = (pubsub) => {
  return unwrapScoped5(map26(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
};
var fromIterable17 = (iterable) => suspend10(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
var fromIterableEffect = (effect4) => pipe(effect4, map26(fromIterable17), unwrap4);
var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync8(() => {
    let builder = [];
    const loop5 = (iterator2) => pipe(sync8(() => {
      let next6 = iterator2.next();
      if (maxChunkSize === 1) {
        if (next6.done) {
          return void_8;
        }
        return pipe(write(of3(next6.value)), flatMap20(() => loop5(iterator2)));
      }
      builder = [];
      let count9 = 0;
      while (next6.done === false) {
        builder.push(next6.value);
        count9 = count9 + 1;
        if (count9 >= maxChunkSize) {
          break;
        }
        next6 = iterator2.next();
      }
      if (count9 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap20(() => loop5(iterator2)));
      }
      return void_8;
    }), unwrap2);
    return new StreamImpl(loop5(iterator));
  }), unwrap4);
};
var fromPull2 = (effect4) => pipe(effect4, map26(repeatEffectChunkOption), unwrapScoped5);
var fromQueue3 = (queue, options) => pipe(takeBetween2(queue, 1, (options == null ? void 0 : options.maxChunkSize) ?? DefaultChunkSize), catchAllCause4((cause3) => pipe(isShutdown4(queue), flatMap18((isShutdown9) => isShutdown9 && isInterrupted3(cause3) ? end5() : failCause15(cause3)))), repeatEffectChunkOption, (options == null ? void 0 : options.shutdown) ? ensuring9(shutdown4(queue)) : identity);
var fromTQueue = (queue) => pipe(take9(queue), map26(of3), catchAllCause4((cause3) => pipe(isShutdown8(queue), flatMap18((isShutdown9) => isShutdown9 && isInterrupted3(cause3) ? end5() : failCause15(cause3)))), repeatEffectChunkOption);
var fromSchedule = (schedule4) => pipe(driver2(schedule4), map26((driver3) => repeatEffectOption(driver3.next(void 0))), unwrap4);
var fromReadableStream = (...args2) => {
  const evaluate4 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError6 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped5(map26(acquireRelease3(sync8(() => evaluate4().getReader()), (reader) => releaseLockOnEnd ? sync8(() => reader.releaseLock()) : promise3(() => reader.cancel())), (reader) => repeatEffectOption(flatMap18(tryPromise3({
    try: () => reader.read(),
    catch: (reason) => some3(onError6(reason))
  }), ({
    done: done17,
    value: value10
  }) => done17 ? fail12(none2()) : succeed13(value10)))));
};
var fromReadableStreamByob = (...args2) => {
  const evaluate4 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError6 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped5(map26(acquireRelease3(sync8(() => evaluate4().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync8(() => reader.releaseLock()) : promise3(() => reader.cancel())), (reader) => catchAll8(forever6(readChunkStreamByobReader(reader, onError6, allocSize)), (error4) => error4 === EOF ? empty43 : fail19(error4))));
};
var EOF = Symbol.for("effect/Stream/EOF");
var readChunkStreamByobReader = (reader, onError6, size45) => {
  const buffer7 = new ArrayBuffer(size45);
  return paginateEffect(0, (offset) => flatMap18(tryPromise3({
    try: () => reader.read(new Uint8Array(buffer7, offset, buffer7.byteLength - offset)),
    catch: (reason) => onError6(reason)
  }), ({
    done: done17,
    value: value10
  }) => {
    if (done17) {
      return fail12(EOF);
    }
    const newOffset = offset + value10.byteLength;
    return succeed13([value10, newOffset >= buffer7.byteLength ? none2() : some3(newOffset)]);
  }));
};
var groupAdjacentBy = dual(2, (self, f2) => {
  const groupAdjacentByChunk = (state, chunk7) => {
    if (isEmpty2(chunk7)) {
      return [state, empty7()];
    }
    const builder = [];
    let from29 = 0;
    let until = 0;
    let key = void 0;
    let previousChunk = empty7();
    switch (state._tag) {
      case "Some": {
        const tuple7 = state.value;
        key = tuple7[0];
        let loop5 = true;
        while (loop5 && until < chunk7.length) {
          const input = unsafeGet4(chunk7, until);
          const updatedKey = f2(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple7[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk7).slice(from29, until));
            const group5 = appendAll3(previousChunk2, additionalChunk);
            builder.push([key, group5]);
            key = updatedKey;
            from29 = until;
            loop5 = false;
          }
          until = until + 1;
        }
        if (loop5) {
          previousChunk = tuple7[1];
        }
        break;
      }
      case "None": {
        key = f2(unsafeGet4(chunk7, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk7.length) {
      const input = unsafeGet4(chunk7, until);
      const updatedKey = f2(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk7).slice(from29, until))]);
        key = updatedKey;
        from29 = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll3(previousChunk, unsafeFromArray(Array.from(chunk7).slice(from29, until)));
    const output = unsafeFromArray(builder);
    return [some3([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = (state) => readWithCause({
    onInput: (input) => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return isEmpty2(output) ? groupAdjacent(updatedState) : flatMap20(write(output), () => groupAdjacent(updatedState));
    },
    onFailure: (cause3) => match2(state, {
      onNone: () => failCause12(cause3),
      onSome: (output) => flatMap20(write(of3(output)), () => failCause12(cause3))
    }),
    onDone: (done17) => match2(state, {
      onNone: () => succeedNow(done17),
      onSome: (output) => flatMap20(write(of3(output)), () => succeedNow(done17))
    })
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), groupAdjacent(none2())));
});
var grouped = dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));
var groupedWithin = dual(3, (self, chunkSize, duration5) => aggregateWithin(self, collectAllN(chunkSize), spaced2(duration5)));
var haltWhen = dual(2, (self, effect4) => {
  const writer = (fiber) => pipe(poll4(fiber), map26(match2({
    onNone: () => readWith({
      onInput: (input) => flatMap20(write(input), () => writer(fiber)),
      onFailure: fail14,
      onDone: () => void_8
    }),
    onSome: match7({
      onFailure: failCause12,
      onSuccess: () => void_8
    })
  })), unwrap2);
  return new StreamImpl(unwrapScopedWith((scope6) => effect4.pipe(forkIn3(scope6), map26((fiber) => toChannel2(self).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = dual(2, (self, duration5) => pipe(self, haltWhen(sleep2(duration5))));
var haltWhenDeferred = dual(2, (self, deferred) => {
  const writer = pipe(poll(deferred), map26(match2({
    onNone: () => readWith({
      onInput: (input) => pipe(write(input), flatMap20(() => writer)),
      onFailure: fail14,
      onDone: () => void_8
    }),
    onSome: (effect4) => unwrap2(match20(effect4, {
      onFailure: fail14,
      onSuccess: () => void_8
    }))
  })), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var identityStream = () => new StreamImpl(identityChannel());
var interleave = dual(2, (self, that) => pipe(self, interleaveWith(that, forever6(make73(true, false)))));
var interleaveWith = dual(3, (self, that, decider) => {
  const producer = (handoff) => readWithCause({
    onInput: (value10) => flatMap20(fromEffect5(offer6(handoff, of7(value10))), () => producer(handoff)),
    onFailure: (cause3) => fromEffect5(offer6(handoff, failCause14(cause3))),
    onDone: () => fromEffect5(offer6(handoff, end4))
  });
  return new StreamImpl(unwrapScopedWith((scope6) => pipe(make71(), zip12(make71()), tap5(([left3]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope6), forkIn3(scope6))), tap5(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope6), forkIn3(scope6))), map26(([left3, right3]) => {
    const process2 = (leftDone, rightDone) => readWithCause({
      onInput: (bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect5(take10(left3)), flatMap20(match32({
            onEnd: () => rightDone ? void_8 : process2(true, rightDone),
            onFailure: failCause12,
            onSuccess: (chunk7) => pipe(write(chunk7), flatMap20(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect5(take10(right3)), flatMap20(match32({
            onEnd: () => leftDone ? void_8 : process2(leftDone, true),
            onFailure: failCause12,
            onSuccess: (chunk7) => pipe(write(chunk7), flatMap20(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause12,
      onDone: () => void_8
    });
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse3 = dual(2, (self, element2) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(suspend6(() => {
  const writer = (isFirst) => readWithCause({
    onInput: (chunk7) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk7) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element2);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap20(() => writer(flagResult)));
    },
    onFailure: failCause12,
    onDone: () => void_8
  });
  return writer(true);
})))));
var intersperseAffixes = dual(2, (self, {
  end: end7,
  middle,
  start: start5
}) => pipe(make73(start5), concat6(pipe(self, intersperse3(middle))), concat6(make73(end7))));
var interruptAfter2 = dual(2, (self, duration5) => pipe(self, interruptWhen2(sleep2(duration5))));
var interruptWhen2 = dual(2, (self, effect4) => new StreamImpl(pipe(toChannel2(self), interruptWhen(effect4))));
var interruptWhenDeferred2 = dual(2, (self, deferred) => new StreamImpl(pipe(toChannel2(self), interruptWhenDeferred(deferred))));
var iterate4 = (value10, next6) => unfold5(value10, (a) => some3([a, next6(a)]));
var make73 = (...as18) => fromIterable17(as18);
var map33 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapOut(map7(f2)))));
var mapAccum5 = dual(3, (self, s, f2) => {
  const accumulator = (s2) => readWith({
    onInput: (input) => {
      const [nextS, chunk7] = mapAccum2(input, s2, f2);
      return flatMap20(write(chunk7), () => accumulator(nextS));
    },
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(accumulator(s))));
});
var mapAccumEffect = dual(3, (self, s, f2) => suspend10(() => {
  const accumulator = (s2) => readWith({
    onInput: (input) => pipe(suspend4(() => {
      const outputs = [];
      const emit2 = (output) => sync8(() => {
        outputs.push(output);
      });
      return pipe(input, reduce17(s2, (s3, a) => pipe(f2(s3, a), flatMap18(([s4, a2]) => pipe(emit2(a2), as8(s4))))), match20({
        onFailure: (error4) => {
          if (outputs.length !== 0) {
            return zipRight8(write(unsafeFromArray(outputs)), fail14(error4));
          }
          return fail14(error4);
        },
        onSuccess: (s3) => flatMap20(write(unsafeFromArray(outputs)), () => accumulator(s3))
      }));
    }), unwrap2),
    onFailure: fail14,
    onDone: () => void_8
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(accumulator(s))));
}));
var mapBoth9 = dual(2, (self, options) => pipe(self, mapError10(options.onFailure), map33(options.onSuccess)));
var mapChunks = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapOut(f2))));
var mapChunksEffect = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapOutEffect(f2))));
var mapConcat = dual(2, (self, f2) => pipe(self, mapConcatChunk((a) => fromIterable3(f2(a)))));
var mapConcatChunk = dual(2, (self, f2) => pipe(self, mapChunks(flatMap5(f2))));
var mapConcatChunkEffect = dual(2, (self, f2) => pipe(self, mapEffectSequential(f2), mapConcatChunk(identity)));
var mapConcatEffect = dual(2, (self, f2) => pipe(self, mapEffectSequential((a) => pipe(f2(a), map26(fromIterable3))), mapConcatChunk(identity)));
var mapEffectSequential = dual(2, (self, f2) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (elem) => loop5(elem[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    } else {
      const value10 = next6.value;
      return unwrap2(map26(f2(value10), (a2) => flatMap20(write(of3(a2)), () => loop5(iterator))));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(suspend6(() => loop5(empty7()[Symbol.iterator]())))));
});
var mapEffectPar = dual(3, (self, n, f2) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(f2, n), mapOut(of3))));
var mapError10 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapError7(f2))));
var mapErrorCause6 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), mapErrorCause5(f2))));
var merge10 = dual((args2) => isStream(args2[1]), (self, that, options) => mergeWith3(self, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options == null ? void 0 : options.haltStrategy
}));
var mergeAll9 = dual((args2) => Symbol.iterator in args2[0], (streams, options) => flatten17(fromIterable17(streams), options));
var mergeWithTag = dual(2, (streams, options) => {
  const keys15 = Object.keys(streams);
  const values15 = keys15.map((key) => streams[key].pipe(map33((value10) => ({
    _tag: key,
    value: value10
  }))));
  return mergeAll9(values15, options);
});
var mergeEither = dual(2, (self, that) => mergeWith3(self, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = dual(2, (left3, right3) => pipe(left3, merge10(drain3(right3))));
var mergeRight = dual(2, (left3, right3) => pipe(drain3(left3), merge10(right3)));
var mergeWith3 = dual(3, (self, other, options) => {
  const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
  const handler = (terminate) => (exit4) => terminate || !isSuccess(exit4) ? (
    // TODO: remove
    Done4(suspend4(() => exit4))
  ) : Await2((exit5) => suspend4(() => exit5));
  return new StreamImpl(mergeWith2(toChannel2(map33(self, options.onSelf)), {
    other: toChannel2(map33(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = (self) => run4(self, mkString);
var never8 = fromEffect9(never5);
var onEnd = dual(2, (self, effect4) => concat6(self, drain3(fromEffect9(effect4))));
var onError4 = dual(2, (self, cleanup) => pipe(self, catchAllCause7((cause3) => fromEffect9(pipe(cleanup(cause3), zipRight7(failCause10(cause3)))))));
var onDone = dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel2(self), ensuringWith((exit4) => isSuccess(exit4) ? cleanup() : _void))));
var onStart = dual(2, (self, effect4) => unwrap4(as8(effect4, self)));
var orDie8 = (self) => pipe(self, orDieWith5(identity));
var orDieWith5 = dual(2, (self, f2) => new StreamImpl(pipe(toChannel2(self), orDieWith3(f2))));
var orElse13 = dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), orElse10(() => toChannel2(that())))));
var orElseEither7 = dual(2, (self, that) => pipe(self, map33(left2), orElse13(() => pipe(that(), map33(right2)))));
var orElseFail4 = dual(2, (self, error4) => pipe(self, orElse13(() => failSync10(error4))));
var orElseIfEmpty = dual(2, (self, element2) => pipe(self, orElseIfEmptyChunk(() => of3(element2()))));
var orElseIfEmptyChunk = dual(2, (self, chunk7) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(write(chunk7())))));
var orElseIfEmptyStream = dual(2, (self, stream2) => {
  const writer = readWith({
    onInput: (input) => {
      if (isEmpty2(input)) {
        return suspend6(() => writer);
      }
      return pipe(write(input), zipRight8(identityChannel()));
    },
    onFailure: fail14,
    onDone: () => suspend6(() => toChannel2(stream2()))
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var orElseSucceed5 = dual(2, (self, value10) => pipe(self, orElse13(() => sync14(value10))));
var paginate = (s, f2) => paginateChunk(s, (s2) => {
  const page = f2(s2);
  return [of3(page[0]), page[1]];
});
var paginateChunk = (s, f2) => {
  const loop5 = (s2) => {
    const page = f2(s2);
    return match2(page[1], {
      onNone: () => zipRight8(write(page[0]), void_8),
      onSome: (s3) => flatMap20(write(page[0]), () => loop5(s3))
    });
  };
  return new StreamImpl(suspend6(() => loop5(s)));
};
var paginateChunkEffect = (s, f2) => {
  const loop5 = (s2) => unwrap2(map26(f2(s2), ([chunk7, option11]) => match2(option11, {
    onNone: () => zipRight8(write(chunk7), void_8),
    onSome: (s3) => flatMap20(write(chunk7), () => loop5(s3))
  })));
  return new StreamImpl(suspend6(() => loop5(s)));
};
var paginateEffect = (s, f2) => paginateChunkEffect(s, (s2) => pipe(f2(s2), map26(([a, s3]) => [of3(a), s3])));
var peel = dual(2, (self, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make24(), flatMap18((deferred) => pipe(make71(), map26((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error4) => zipRight9(fromEffect7(fail3(deferred, error4)), fail15(error4)),
      onSuccess: ([z, leftovers]) => {
        const loop5 = readWithCause({
          onInput: (elements) => flatMap20(fromEffect5(offer6(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop5),
          onFailure: (cause3) => zipRight8(fromEffect5(offer6(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause12(cause3)),
          onDone: (_) => zipRight8(fromEffect5(offer6(handoff, {
            _tag: OP_END2
          })), void_8)
        });
        return fromChannel(pipe(fromEffect5(succeed2(deferred, z)), zipRight8(fromEffect5(pipe(handoff, offer6({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight8(loop5)));
      }
    });
    const producer = pipe(take10(handoff), map26((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap20(() => producer));
        }
        case OP_HALT2: {
          return failCause12(signal.cause);
        }
        case OP_END2: {
          return void_8;
        }
      }
    }), unwrap2);
    return pipe(self, tapErrorCause6((cause3) => failCause2(deferred, cause3)), run4(consumer), forkScoped3, zipRight7(_await(deferred)), map26((z) => [z, new StreamImpl(producer)]));
  }))), flatten13);
});
var partition11 = dual((args2) => typeof args2[1] === "function", (self, predicate, options) => partitionEither(self, (a) => succeed13(predicate(a) ? right2(a) : left2(a)), options));
var partitionEither = dual((args2) => typeof args2[1] === "function", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({
  size: 2,
  maximumLag: (options == null ? void 0 : options.bufferSize) ?? 16,
  decide: match({
    onLeft: () => succeed13((n) => n === 0),
    onRight: () => succeed13((n) => n === 1)
  })
}), flatMap18(([queue1, queue2]) => succeed13([filterMap12(flattenExitOption(fromQueue3(queue1, {
  shutdown: true
})), (_) => match(_, {
  onLeft: some3,
  onRight: none2
})), filterMap12(flattenExitOption(fromQueue3(queue2, {
  shutdown: true
})), (_) => match(_, {
  onLeft: none2,
  onRight: some3
}))]))));
var pipeThrough = dual(2, (self, sink) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
var pipeThroughChannelOrFail = dual(2, (self, chan) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(chan))));
var prepend6 = dual(2, (self, values15) => new StreamImpl(zipRight8(write(values15), toChannel2(self))));
var provideContext8 = dual(2, (self, context15) => new StreamImpl(pipe(toChannel2(self), provideContext4(context15))));
var provideSomeContext3 = dual(2, (self, context15) => mapInputContext7(self, merge3(context15)));
var provideLayer2 = dual(2, (self, layer) => new StreamImpl(unwrapScopedWith((scope6) => buildWithScope2(layer, scope6).pipe(map26((env) => pipe(toChannel2(self), provideContext4(env)))))));
var provideService10 = dual(3, (self, tag5, resource) => provideServiceEffect4(self, tag5, succeed13(resource)));
var provideServiceEffect4 = dual(3, (self, tag5, effect4) => provideServiceStream(self, tag5, fromEffect9(effect4)));
var provideServiceStream = dual(3, (self, tag5, stream2) => contextWithStream((env) => flatMap23(stream2, (service4) => pipe(self, provideContext8(add3(env, tag5, service4))))));
var mapInputContext7 = dual(2, (self, f2) => contextWithStream((env) => pipe(self, provideContext8(f2(env)))));
var provideSomeLayer3 = dual(2, (self, layer) => (
  // @ts-expect-error
  // @effect-diagnostics-next-line missingEffectContext:off
  pipe(self, provideLayer2(pipe(context6(), merge8(layer))))
));
var range4 = (min11, max14, chunkSize = DefaultChunkSize) => suspend10(() => {
  if (min11 > max14) {
    return empty43;
  }
  const go5 = (min12, max15, chunkSize2) => {
    const remaining = max15 - min12 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range3(min12, min12 + chunkSize2 - 1)), flatMap20(() => go5(min12 + chunkSize2, max15, chunkSize2)));
    }
    return write(range3(min12, min12 + remaining - 1));
  };
  return new StreamImpl(go5(min11, max14, chunkSize));
});
var race5 = dual(2, (left3, right3) => raceAll4(left3, right3));
var raceAll4 = (...streams) => make24().pipe(map26((halt2) => {
  let winner = null;
  return mergeAll9(streams.map((stream2, index3) => stream2.pipe(takeWhile6(() => {
    if (winner === null) {
      winner = index3;
      unsafeDone(halt2, void_4);
      return true;
    }
    return winner === index3;
  }), interruptWhen2(_await(halt2).pipe(flatMap18(() => winner === index3 ? never5 : _void))))), {
    concurrency: streams.length
  });
}), unwrap4);
var rechunk = dual(2, (self, n) => suspend10(() => {
  const target = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
}));
var rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk7) => {
    if (chunk7.length === target && rechunker.isEmpty()) {
      return flatMap20(write(chunk7), () => rechunkProcess(rechunker, target));
    }
    if (chunk7.length > 0) {
      const chunks3 = [];
      let result = void 0;
      let index3 = 0;
      while (index3 < chunk7.length) {
        while (index3 < chunk7.length && result === void 0) {
          result = rechunker.write(pipe(chunk7, unsafeGet4(index3)));
          index3 = index3 + 1;
        }
        if (result !== void 0) {
          chunks3.push(result);
          result = void 0;
        }
      }
      return flatMap20(writeAll(...chunks3), () => rechunkProcess(rechunker, target));
    }
    return suspend6(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause3) => zipRight8(rechunker.emitIfNotEmpty(), failCause12(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
});
var StreamRechunker = class {
  constructor(n) {
    __publicField(this, "n");
    __publicField(this, "builder", []);
    __publicField(this, "pos", 0);
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return void 0;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_8;
  }
};
var refineOrDie3 = dual(2, (self, pf) => pipe(self, refineOrDieWith3(pf, identity)));
var refineOrDieWith3 = dual(3, (self, pf, f2) => new StreamImpl(catchAll6(toChannel2(self), (error4) => match2(pf(error4), {
  onNone: () => failCause12(die6(f2(error4))),
  onSome: fail14
}))));
var repeat4 = dual(2, (self, schedule4) => filterMap12(repeatEither(self, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some3
})));
var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError5(some3)));
var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError5(some3)));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map26(effect5, (chunk7) => some3([chunk7, effect5])), catchAll4(match2({
  onNone: () => succeed13(none2()),
  onSome: fail12
}))));
var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map26(of3)));
var repeatEither = dual(2, (self, schedule4) => repeatWith(self, schedule4, {
  onElement: (a) => right2(a),
  onSchedule: left2
}));
var repeatElements = dual(2, (self, schedule4) => filterMap12(repeatElementsWith(self, schedule4, {
  onElement: (a) => some3(a),
  onSchedule: none2
}), identity));
var repeatElementsWith = dual(3, (self, schedule4, options) => {
  const driver3 = pipe(driver2(schedule4), map26((driver4) => {
    const feed = (input) => match2(head3(input), {
      onNone: () => loop5,
      onSome: (a) => zipRight8(write(of3(options.onElement(a))), step4(pipe(input, drop3(1)), a))
    });
    const step4 = (input, a) => {
      const advance = pipe(driver4.next(a), as8(pipe(write(of3(options.onElement(a))), flatMap20(() => step4(input, a)))));
      const reset4 = pipe(driver4.last, orDie4, flatMap18((b) => pipe(driver4.reset, map26(() => pipe(write(of3(options.onSchedule(b))), zipRight8(feed(input)))))));
      return pipe(advance, orElse8(() => reset4), unwrap2);
    };
    const loop5 = readWith({
      onInput: feed,
      onFailure: fail14,
      onDone: () => void_8
    });
    return loop5;
  }), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(driver3)));
});
var repeatValue = (value10) => new StreamImpl(repeated(write(of3(value10))));
var repeatWith = dual(3, (self, schedule4, options) => {
  return pipe(driver2(schedule4), map26((driver3) => {
    const provideLastIterationInfo = provideServiceEffect4(CurrentIterationMetadata2, get13(driver3.iterationMeta));
    const process2 = pipe(self, provideLastIterationInfo, map33(options.onElement), toChannel2);
    const loop5 = unwrap2(match20(driver3.next(void 0), {
      onFailure: () => void_8,
      onSuccess: (output) => flatMap20(process2, () => zipRight8(write(of3(options.onSchedule(output))), loop5))
    }));
    return new StreamImpl(zipRight8(process2, loop5));
  }), unwrap4);
});
var repeatWithSchedule = (value10, schedule4) => repeatEffectWithSchedule(succeed13(value10), schedule4);
var repeatEffectWithSchedule = (effect4, schedule4) => flatMap23(fromEffect9(zip12(effect4, driver2(schedule4))), ([a, driver3]) => {
  const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get13(driver3.iterationMeta));
  return concat6(succeed20(a), unfoldEffect(a, (s) => matchEffect4(driver3.next(s), {
    onFailure: succeed13,
    onSuccess: () => map26(provideLastIterationInfo(effect4), (nextA) => some3([nextA, nextA]))
  })));
});
var retry7 = dual(2, (self, policy) => driver2(policy).pipe(map26((driver3) => {
  const provideLastIterationInfo = provideServiceEffect4(CurrentIterationMetadata2, get13(driver3.iterationMeta));
  const loop5 = toChannel2(provideLastIterationInfo(self)).pipe(mapOutEffect((out) => as8(driver3.reset, out)), catchAll6((error4) => driver3.next(error4).pipe(match20({
    onFailure: () => fail14(error4),
    onSuccess: () => loop5
  }), unwrap2)));
  return loop5;
}), unwrap2, fromChannel2));
var withExecutionPlan3 = dual((args2) => isStream(args2[0]), (self, policy, options) => suspend10(() => {
  const preventFallbackOnPartialStream = (options == null ? void 0 : options.preventFallbackOnPartialStream) ?? false;
  let i = 0;
  let lastError = none2();
  const loop5 = suspend10(() => {
    const step4 = policy.steps[i++];
    if (!step4) {
      return fail19(getOrThrow2(lastError));
    }
    let nextStream = isContext2(step4.provide) ? provideSomeContext3(self, step4.provide) : provideSomeLayer3(self, step4.provide);
    let receivedElements = false;
    if (isSome2(lastError)) {
      const error4 = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      nextStream = suspend10(() => {
        if (attempted) return wrapped;
        attempted = true;
        return fail19(error4);
      });
      nextStream = scheduleDefectRefail2(retry7(nextStream, scheduleFromStep(step4, false)));
    } else {
      const schedule4 = scheduleFromStep(step4, true);
      nextStream = schedule4 ? scheduleDefectRefail2(retry7(nextStream, schedule4)) : nextStream;
    }
    return catchAll8(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk7) => {
      receivedElements = true;
      return chunk7;
    }) : nextStream, (error4) => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail19(error4);
      }
      lastError = some3(error4);
      return loop5;
    });
  });
  return loop5;
}));
var scheduleDefectRefail2 = (self) => catchAllCause7(self, (cause3) => failCause16(scheduleDefectRefailCause(cause3)));
var run4 = dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect2 = (self) => run4(self, collectAll());
var runCount = (self) => run4(self, count3);
var runDrain2 = (self) => run4(self, drain2);
var runFold = dual(3, (self, s, f2) => runFoldWhile(self, s, constTrue, f2));
var runFoldEffect = dual(3, (self, s, f2) => runFoldWhileEffect(self, s, constTrue, f2));
var runFoldScoped = dual(3, (self, s, f2) => pipe(self, runFoldWhileScoped(s, constTrue, f2)));
var runFoldScopedEffect = dual(3, (self, s, f2) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f2)));
var runFoldWhile = dual(4, (self, s, cont, f2) => run4(self, fold(s, cont, f2)));
var runFoldWhileEffect = dual(4, (self, s, cont, f2) => run4(self, foldEffect(s, cont, f2)));
var runFoldWhileScoped = dual(4, (self, s, cont, f2) => pipe(self, runScoped2(fold(s, cont, f2))));
var runFoldWhileScopedEffect = dual(4, (self, s, cont, f2) => pipe(self, runScoped2(foldEffect(s, cont, f2))));
var runForEach = dual(2, (self, f2) => run4(self, forEach17(f2)));
var runForEachChunk = dual(2, (self, f2) => run4(self, forEachChunk(f2)));
var runForEachChunkScoped = dual(2, (self, f2) => pipe(self, runScoped2(forEachChunk(f2))));
var runForEachScoped = dual(2, (self, f2) => pipe(self, runScoped2(forEach17(f2))));
var runForEachWhile = dual(2, (self, f2) => run4(self, forEachWhile(f2)));
var runForEachWhileScoped = dual(2, (self, f2) => pipe(self, runScoped2(forEachWhile(f2))));
var runHead = (self) => run4(self, head8());
var runIntoPubSub = dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));
var runIntoPubSubScoped = dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));
var runIntoQueue = dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), scoped4));
var runIntoQueueElementsScoped = dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap20(fromEffect5(offerAll3(queue, map7(input, succeed3))), () => writer),
    onFailure: (cause3) => fromEffect5(offer3(queue, failCause3(map22(cause3, some3)))),
    onDone: () => fromEffect5(offer3(queue, fail4(none2())))
  });
  return pipe(pipeTo(toChannel2(self), writer), drain, runScoped, asVoid6);
});
var runIntoQueueScoped = dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap20(write(chunk3(input)), () => writer),
    onFailure: (cause3) => write(failCause14(cause3)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take16) => offer3(queue, take16)), drain, runScoped, asVoid6);
});
var runLast = (self) => run4(self, last6());
var runScoped2 = dual(2, (self, sink) => pipe(toChannel2(self), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = (self) => run4(self, sum5);
var scan3 = dual(3, (self, s, f2) => pipe(self, scanEffect(s, (s2, a) => succeed13(f2(s2, a)))));
var scanReduce = dual(2, (self, f2) => pipe(self, scanReduceEffect((a2, a) => succeed13(f2(a2, a)))));
var scanReduceEffect = dual(2, (self, f2) => pipe(self, mapAccumEffect(none2(), (option11, a) => {
  switch (option11._tag) {
    case "None": {
      return succeed13([some3(a), a]);
    }
    case "Some": {
      return pipe(f2(option11.value, a), map26((b) => [some3(b), b]));
    }
  }
})));
var schedule2 = dual(2, (self, schedule4) => filterMap12(scheduleWith(self, schedule4, {
  onElement: some3,
  onSchedule: none2
}), identity));
var scheduleWith = dual(3, (self, schedule4, options) => {
  const loop5 = (driver3, iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (chunk7) => loop5(driver3, chunk7[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeedNow
      });
    }
    return unwrap2(matchEffect4(driver3.next(next6.value), {
      onFailure: () => pipe(driver3.last, orDie4, map26((b) => pipe(write(make9(options.onElement(next6.value), options.onSchedule(b))), flatMap20(() => loop5(driver3, iterator)))), zipLeft7(driver3.reset)),
      onSuccess: () => succeed13(pipe(write(of3(options.onElement(next6.value))), flatMap20(() => loop5(driver3, iterator))))
    }));
  };
  return new StreamImpl(pipe(fromEffect5(driver2(schedule4)), flatMap20((driver3) => pipe(toChannel2(self), pipeTo(loop5(driver3, empty7()[Symbol.iterator]()))))));
});
var scanEffect = dual(3, (self, s, f2) => new StreamImpl(pipe(write(of3(s)), flatMap20(() => toChannel2(pipe(self, mapAccumEffect(s, (s2, a) => pipe(f2(s2, a), map26((s3) => [s3, s3])))))))));
var scoped7 = (effect4) => new StreamImpl(ensuring5(scoped6(pipe(effect4, map26(of3))), _void));
var scopedWith4 = (f2) => new StreamImpl(scopedWith3((scope6) => f2(scope6).pipe(map26(of3))));
var some17 = (self) => pipe(self, mapError10(some3), someOrFail(() => none2()));
var someOrElse = dual(2, (self, fallback3) => pipe(self, map33(getOrElse2(fallback3))));
var someOrFail = dual(2, (self, error4) => mapEffectSequential(self, match2({
  onNone: () => failSync5(error4),
  onSome: succeed13
})));
var sliding9 = dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
var slidingSize = dual(3, (self, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die14(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend6(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty2(items) ? empty7() : of3(items);
        return pipe(write(result2), flatMap20(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight2(leftovers));
      const result = isEmpty2(lastItems) ? empty7() : of3(lastItems);
      return pipe(write(result), flatMap20(() => channelEnd));
    };
    const reader = (queueSize) => readWithCause({
      onInput: (input) => flatMap20(write(filterMap5(input, (element2, index3) => {
        queue.put(element2);
        const currentIndex = queueSize + index3 + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some3(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause12(cause3)),
      onDone: () => emitOnStreamEnd(queueSize, void_8)
    });
    return pipe(toChannel2(self), pipeTo(reader(0)));
  }));
});
var split4 = dual(2, (self, predicate) => {
  const split8 = (leftovers, input) => {
    const [chunk7, remaining] = pipe(leftovers, appendAll3(input), splitWhere2(predicate));
    if (isEmpty2(chunk7) || isEmpty2(remaining)) {
      return loop5(pipe(chunk7, appendAll3(pipe(remaining, drop3(1)))));
    }
    return pipe(write(of3(chunk7)), flatMap20(() => split8(empty7(), pipe(remaining, drop3(1)))));
  };
  const loop5 = (leftovers) => readWith({
    onInput: (input) => split8(leftovers, input),
    onFailure: fail14,
    onDone: () => {
      if (isEmpty2(leftovers)) {
        return void_8;
      }
      if (isNone2(pipe(leftovers, findFirst4(predicate)))) {
        return zipRight8(write(of3(leftovers)), void_8);
      }
      return zipRight8(split8(empty7(), leftovers), void_8);
    }
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty7()))));
});
var splitOnChunk = dual(2, (self, delimiter) => {
  const next6 = (leftover3, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer7;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce4([pipe(leftover3, getOrElse2(() => empty7())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append3(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer7 === void 0) {
              buffer7 = [];
            }
            buffer7.push(pipe(concatenated, take3(concatenated.length - delimiter.length)));
            return [empty7(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
      }));
      const output = buffer7 === void 0 ? empty7() : unsafeFromArray(buffer7);
      return flatMap20(write(output), () => next6(isNonEmpty2(carry) ? some3(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause3) => match2(leftover3, {
      onNone: () => failCause12(cause3),
      onSome: (chunk7) => zipRight8(write(of3(chunk7)), failCause12(cause3))
    }),
    onDone: (done17) => match2(leftover3, {
      onNone: () => succeed15(done17),
      onSome: (chunk7) => zipRight8(write(of3(chunk7)), succeed15(done17))
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(next6(none2(), 0))));
});
var splitLines2 = (self) => pipeThroughChannel(self, splitLines());
var succeed20 = (value10) => fromChunk(of3(value10));
var sync14 = (evaluate4) => suspend10(() => fromChunk(of3(evaluate4())));
var suspend10 = (stream2) => new StreamImpl(suspend6(() => toChannel2(stream2())));
var take11 = dual(2, (self, n) => {
  if (!Number.isInteger(n)) {
    return die14(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop5 = (n2) => readWith({
    onInput: (input) => {
      const taken = pipe(input, take3(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover3 = Math.max(0, n2 - taken.length);
      const more = leftover3 > 0;
      if (more) {
        return pipe(write(taken), flatMap20(() => loop5(leftover3)));
      }
      return write(taken);
    },
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(0 < n ? loop5(n) : void_8)));
});
var takeRight4 = dual(2, (self, n) => {
  if (n <= 0) {
    return empty43;
  }
  return new StreamImpl(pipe(succeed13(new RingBuffer(n)), map26((queue) => {
    const reader = readWith({
      onInput: (input) => {
        for (const element2 of input) {
          queue.put(element2);
        }
        return reader;
      },
      onFailure: fail14,
      onDone: () => pipe(write(queue.toChunk()), zipRight8(void_8))
    });
    return pipe(toChannel2(self), pipeTo(reader));
  }), unwrap2));
});
var takeUntil3 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile3((a) => !predicate(a)));
      const last8 = pipe(input, drop3(taken.length), take3(1));
      if (isEmpty2(last8)) {
        return pipe(write(taken), flatMap20(() => loop5));
      }
      return write(pipe(taken, appendAll3(last8)));
    },
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var takeUntilEffect = dual(2, (self, predicate) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (elem) => loop5(elem[Symbol.iterator]()),
        onFailure: failCause12,
        onDone: succeed15
      });
    }
    return pipe(predicate(next6.value), map26((bool) => bool ? write(of3(next6.value)) : pipe(write(of3(next6.value)), flatMap20(() => loop5(iterator)))), unwrap2);
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty7()[Symbol.iterator]()))));
});
var takeWhile6 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile3(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap20(() => loop5));
      }
      return write(taken);
    },
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var tap9 = dual(2, (self, f2) => mapEffectSequential(self, (a) => as8(f2(a), a)));
var tapBoth4 = dual(2, (self, options) => pipe(self, tapError7(options.onFailure), tap9(options.onSuccess)));
var tapError7 = dual(2, (self, f2) => catchAll8(self, (error4) => fromEffect9(zipRight7(f2(error4), fail12(error4)))));
var tapErrorCause6 = dual(2, (self, f2) => {
  const loop5 = readWithCause({
    onInput: (chunk7) => flatMap20(write(chunk7), () => loop5),
    onFailure: (cause3) => fromEffect5(zipRight7(f2(cause3), failCause10(cause3))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var tapSink = dual(2, (self, sink) => pipe(fromEffect9(all11([bounded5(1), make24()])), flatMap23(([queue, deferred]) => {
  const right3 = flattenTake(fromQueue3(queue, {
    maxChunkSize: 1
  }));
  const loop5 = readWithCause({
    onInput: (chunk7) => pipe(fromEffect5(offer3(queue, chunk3(chunk7))), foldCauseChannel({
      onFailure: () => flatMap20(write(chunk7), () => identityChannel()),
      onSuccess: () => flatMap20(write(chunk7), () => loop5)
    })),
    onFailure: (cause3) => pipe(fromEffect5(offer3(queue, failCause14(cause3))), foldCauseChannel({
      onFailure: () => failCause12(cause3),
      onSuccess: () => failCause12(cause3)
    })),
    onDone: () => pipe(fromEffect5(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_8,
      onSuccess: () => void_8
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self), loop5), ensuring5(zipRight7(forkDaemon3(offer3(queue, end4)), _await(deferred))))), merge10(execute(pipe(run4(right3, sink), ensuring4(zipRight7(shutdown4(queue), succeed2(deferred, void 0)))))));
})));
var throttle = dual(2, (self, options) => throttleEffect(self, {
  ...options,
  cost: (chunk7) => succeed13(options.cost(chunk7))
}));
var throttleEffect = dual(2, (self, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
});
var throttleEnforceEffect = (self, cost, units2, duration5, burst) => {
  const loop5 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip12(currentTimeMillis2), map26(([weight, currentTimeMillis4]) => {
      const elapsed3 = currentTimeMillis4 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration5);
      const sum7 = tokens + cycles * units2;
      const max14 = units2 + burst < 0 ? Number.POSITIVE_INFINITY : units2 + burst;
      const available3 = sum7 < 0 ? max14 : Math.min(sum7, max14);
      if (weight <= available3) {
        return pipe(write(input), flatMap20(() => loop5(available3 - weight, currentTimeMillis4)));
      }
      return loop5(tokens, timestampMillis);
    }), unwrap2),
    onFailure: failCause12,
    onDone: () => void_8
  });
  const throttled = pipe(currentTimeMillis2, map26((currentTimeMillis4) => loop5(units2, currentTimeMillis4)), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var throttleShapeEffect = (self, costFn, units2, duration5, burst) => {
  const loop5 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip12(currentTimeMillis2), map26(([weight, currentTimeMillis4]) => {
      const elapsed3 = currentTimeMillis4 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration5);
      const sum7 = tokens + cycles * units2;
      const max14 = units2 + burst < 0 ? Number.POSITIVE_INFINITY : units2 + burst;
      const available3 = sum7 < 0 ? max14 : Math.min(sum7, max14);
      const remaining = available3 - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units2;
      const delay4 = millis(Math.max(0, waitCycles * toMillis(duration5)));
      if (greaterThan5(delay4, zero2)) {
        return pipe(fromEffect5(sleep2(delay4)), zipRight8(write(input)), flatMap20(() => loop5(remaining, currentTimeMillis4)));
      }
      return flatMap20(write(input), () => loop5(remaining, currentTimeMillis4));
    }), unwrap2),
    onFailure: failCause12,
    onDone: () => void_8
  });
  const throttled = pipe(currentTimeMillis2, map26((currentTimeMillis4) => loop5(units2, currentTimeMillis4)), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var tick = (interval) => repeatWithSchedule(void 0, spaced2(interval));
var timeout4 = dual(2, (self, duration5) => pipe(toPull2(self), map26(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration5
})), fromPull2));
var timeoutFail3 = dual(3, (self, error4, duration5) => pipe(self, timeoutTo3(duration5, failSync10(error4))));
var timeoutFailCause3 = dual(3, (self, cause3, duration5) => pipe(toPull2(self), map26(timeoutFailCause2({
  onTimeout: () => map22(cause3(), some3),
  duration: duration5
})), fromPull2));
var timeoutTo3 = dual(3, (self, duration5, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self, timeoutFailCause3(() => die6(StreamTimeout), duration5), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== void 0 && cause3.defect.message === "Stream Timeout" ? some3(that) : none2()));
});
var pubsubFromOptions = (options) => {
  if (typeof options === "number") {
    return bounded4(options);
  } else if (options.capacity === "unbounded") {
    return unbounded4({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return dropping3(options);
    case "sliding":
      return sliding3(options);
    default:
      return bounded4(options);
  }
};
var toPubSub2 = dual(2, (self, capacity10) => pipe(acquireRelease3(pubsubFromOptions(capacity10), (pubsub) => shutdown3(pubsub)), tap5((pubsub) => pipe(self, runIntoPubSubScoped(pubsub), forkScoped3))));
var toPull2 = (self) => map26(toPull(toChannel2(self)), (pull) => pipe(pull, mapError5(some3), flatMap18(match({
  onLeft: () => fail12(none2()),
  onRight: succeed13
}))));
var toQueue2 = dual((args2) => isStream(args2[0]), (self, options) => tap5(acquireRelease3((options == null ? void 0 : options.strategy) === "unbounded" ? unbounded5() : (options == null ? void 0 : options.strategy) === "dropping" ? dropping4(options.capacity ?? 2) : (options == null ? void 0 : options.strategy) === "sliding" ? sliding4(options.capacity ?? 2) : bounded5((options == null ? void 0 : options.capacity) ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped3(runIntoQueueScoped(self, queue))));
var toQueueOfElements = dual((args2) => isStream(args2[0]), (self, options) => tap5(acquireRelease3(bounded5((options == null ? void 0 : options.capacity) ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped3(runIntoQueueElementsScoped(self, queue))));
var toReadableStream = dual((args2) => isStream(args2[0]), (self, options) => toReadableStreamRuntime(self, defaultRuntime2, options));
var toReadableStreamEffect = dual((args2) => isStream(args2[0]), (self, options) => map26(runtime4(), (runtime8) => toReadableStreamRuntime(self, runtime8, options)));
var toReadableStreamRuntime = dual((args2) => isStream(args2[0]), (self, runtime8, options) => {
  const runFork4 = runFork3(runtime8);
  let currentResolve = void 0;
  let fiber = void 0;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self, (chunk7) => {
        if (chunk7.length === 0) return _void;
        return latch.whenOpen(sync8(() => {
          latch.unsafeClose();
          for (const item of chunk7) {
            controller.enqueue(item);
          }
          currentResolve();
          currentResolve = void 0;
        }));
      }));
      fiber.addObserver((exit4) => {
        try {
          if (exit4._tag === "Failure") {
            controller.error(squash(exit4.cause));
          } else {
            controller.close();
          }
        } catch {
        }
      });
    },
    pull() {
      return new Promise((resolve) => {
        currentResolve = resolve;
        runSync2(latch.open);
      });
    },
    cancel() {
      if (!fiber) return;
      return runPromise2(asVoid6(interrupt7(fiber)));
    }
  }, options == null ? void 0 : options.strategy);
});
var transduce = dual(2, (self, sink) => {
  const newChannel = suspend6(() => {
    const leftovers = {
      ref: empty7()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer7 = suspend6(() => {
      const leftover3 = leftovers.ref;
      if (isEmpty2(leftover3)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap20(() => buffer7)),
          onFailure: fail14,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty7();
      return pipe(writeChunk(leftover3), flatMap20(() => buffer7));
    });
    const concatAndGet = (chunk7) => {
      const leftover3 = leftovers.ref;
      const concatenated = appendAll3(leftover3, filter5(chunk7, (chunk8) => chunk8.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap20(write(input), () => upstreamMarker),
      onFailure: fail14,
      onDone: (done17) => zipRight8(sync10(() => {
        upstreamDone.ref = true;
      }), succeedNow(done17))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap20(([leftover3, z]) => pipe(succeed15([upstreamDone.ref, concatAndGet(leftover3)]), flatMap20(([done17, newLeftovers]) => {
      const nextChannel = done17 && isEmpty2(newLeftovers) ? void_8 : transducer;
      return pipe(write(of3(z)), flatMap20(() => nextChannel));
    }))));
    return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer7), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var toAsyncIterableRuntime = dual((args2) => isStream(args2[0]), (self, runtime8) => {
  const runFork4 = runFork3(runtime8);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = void 0;
      let currentReject = void 0;
      let fiber = void 0;
      const latch = unsafeMakeLatch2(false);
      return {
        next() {
          if (!fiber) {
            fiber = runFork4(runForEach(self, (value10) => latch.whenOpen(sync8(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value: value10
              });
              currentResolve = currentReject = void 0;
            }))));
            fiber.addObserver((exit4) => {
              fiber = runFork2(latch.whenOpen(sync8(() => {
                if (exit4._tag === "Failure") {
                  currentReject(squash(exit4.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: void 0
                  });
                }
                currentResolve = currentReject = void 0;
              })));
            });
          }
          return new Promise((resolve, reject3) => {
            currentResolve = resolve;
            currentReject = reject3;
            latch.unsafeOpen();
          });
        },
        return() {
          if (!fiber) return Promise.resolve({
            done: true,
            value: void 0
          });
          return runPromise2(as8(interrupt7(fiber), {
            done: true,
            value: void 0
          }));
        }
      };
    }
  };
});
var toAsyncIterable = (self) => toAsyncIterableRuntime(self, defaultRuntime2);
var toAsyncIterableEffect = (self) => map26(runtime4(), (runtime8) => toAsyncIterableRuntime(self, runtime8));
var unfold5 = (s, f2) => unfoldChunk(s, (s2) => pipe(f2(s2), map2(([a, s3]) => [of3(a), s3])));
var unfoldChunk = (s, f2) => {
  const loop5 = (s2) => match2(f2(s2), {
    onNone: () => void_8,
    onSome: ([chunk7, s3]) => flatMap20(write(chunk7), () => loop5(s3))
  });
  return new StreamImpl(suspend6(() => loop5(s)));
};
var unfoldChunkEffect = (s, f2) => suspend10(() => {
  const loop5 = (s2) => unwrap2(map26(f2(s2), match2({
    onNone: () => void_8,
    onSome: ([chunk7, s3]) => flatMap20(write(chunk7), () => loop5(s3))
  })));
  return new StreamImpl(loop5(s));
});
var unfoldEffect = (s, f2) => unfoldChunkEffect(s, (s2) => pipe(f2(s2), map26(map2(([a, s3]) => [of3(a), s3]))));
var void_11 = succeed20(void 0);
var unwrap4 = (effect4) => flatten17(fromEffect9(effect4));
var unwrapScoped5 = (effect4) => flatten17(scoped7(effect4));
var unwrapScopedWith3 = (f2) => flatten17(scopedWith4((scope6) => f2(scope6)));
var updateService6 = dual(3, (self, tag5, f2) => pipe(self, mapInputContext7((context15) => pipe(context15, add3(tag5, f2(pipe(context15, unsafeGet3(tag5))))))));
var when5 = dual(2, (self, test3) => pipe(self, whenEffect3(sync8(test3))));
var whenCase = (evaluate4, pf) => whenCaseEffect(pf)(sync8(evaluate4));
var whenCaseEffect = dual(2, (self, pf) => pipe(fromEffect9(self), flatMap23((a) => pipe(pf(a), getOrElse2(() => empty43)))));
var whenEffect3 = dual(2, (self, effect4) => pipe(fromEffect9(effect4), flatMap23((bool) => bool ? self : empty43)));
var withSpan6 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return new StreamImpl(withSpan5(toChannel2(self), name, options));
  }
  return (self) => new StreamImpl(withSpan5(toChannel2(self), name, options));
};
var zip16 = dual(2, (self, that) => pipe(self, zipWith17(that, (a, a2) => [a, a2])));
var zipFlatten2 = dual(2, (self, that) => pipe(self, zipWith17(that, (a, a2) => [...a, a2])));
var zipAll = dual(2, (self, options) => zipAllWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
var zipAllLeft = dual(3, (self, other, defaultSelf) => zipAllWith(self, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a) => a
}));
var zipAllRight = dual(3, (self, other, defaultRight) => zipAllWith(self, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_, a2) => a2
}));
var zipAllSortedByKey = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
var zipAllSortedByKeyLeft = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: (a) => a,
  order: options.order
}));
var zipAllSortedByKeyRight = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_, a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyWith = dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match20({
          onFailure: fail4,
          onSuccess: (leftChunk) => succeed3([map7(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match20({
          onFailure: fail4,
          onSuccess: (rightChunk) => succeed3([map7(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome2(pullLeft), zip12(unsome2(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error4) => succeed13(fail4(some3(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty2(leftOption.value) && isEmpty2(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty2(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty2(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed13(succeed3(merge16(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty2(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed13(succeed3([pipe(leftOption.value, map7(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty2(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed13(succeed3([pipe(rightOption.value, map7(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
            }
            return succeed13(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: match2({
            onNone: () => succeed13(succeed3([pipe(state.rightChunk, map7(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
            onSome: (error4) => succeed13(fail4(some3(error4)))
          }),
          onSuccess: (leftChunk) => isEmpty2(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed13(succeed3(merge16(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: match2({
            onNone: () => succeed13(succeed3([map7(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
            onSome: (error4) => succeed13(fail4(some3(error4)))
          }),
          onSuccess: (rightChunk) => isEmpty2(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed13(succeed3(merge16(state.leftChunk, rightChunk)))
        });
      }
    }
  };
  const merge16 = (leftChunk, rightChunk) => {
    const hasNext = (chunk7, index3) => index3 < chunk7.length - 1;
    const builder = [];
    let state = void 0;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop5 = true;
    while (loop5) {
      const compare3 = options.order(k1, k2);
      if (compare3 === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop3(leftIndex + 1)));
          loop5 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop3(rightIndex + 1)));
          loop5 = false;
        } else {
          state = PullBoth;
          loop5 = false;
        }
      } else if (compare3 < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop5 = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop5 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipAllWith = dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: (error4) => succeed13(fail4(error4)),
          onSuccess: (leftChunk) => succeed13(succeed3([map7(leftChunk, options.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: (error4) => succeed13(fail4(error4)),
          onSuccess: (rightChunk) => succeed13(succeed3([map7(rightChunk, options.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome2(pullLeft), zip12(unsome2(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error4) => succeed13(fail4(some3(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty2(leftOption.value) && isEmpty2(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty2(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty2(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed13(succeed3(zip27(leftOption.value, rightOption.value, options.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed13(succeed3([map7(leftOption.value, options.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed13(succeed3([map7(rightOption.value, options.onOther), DrainRight]));
            }
            return succeed13(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect4(pullLeft, {
          onFailure: match2({
            onNone: () => succeed13(succeed3([map7(state.rightChunk, options.onOther), DrainRight])),
            onSome: (error4) => succeed13(fail4(some3(error4)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty2(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty2(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed13(succeed3(zip27(leftChunk, state.rightChunk, options.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect4(pullRight, {
          onFailure: match2({
            onNone: () => succeed13(succeed3([map7(state.leftChunk, options.onSelf), DrainLeft])),
            onSome: (error4) => succeed13(fail4(some3(error4)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty2(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty2(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed13(succeed3(zip27(state.leftChunk, rightChunk, options.onBoth)));
          }
        });
      }
    }
  };
  const zip27 = (leftChunk, rightChunk, f2) => {
    const [output, either14] = zipChunks(leftChunk, rightChunk, f2);
    switch (either14._tag) {
      case "Left": {
        if (isEmpty2(either14.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either14.left)];
      }
      case "Right": {
        if (isEmpty2(either14.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either14.right)];
      }
    }
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipLatest = dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
var zipLatestAll = (...streams) => {
  if (streams.length === 0) {
    return empty43;
  } else if (streams.length === 1) {
    return map33(streams[0], (x) => [x]);
  }
  const [head13, ...tail5] = streams;
  return zipLatestWith(head13, zipLatestAll(...tail5), (first5, second) => [first5, ...second]);
};
var zipLatestWith = dual(3, (left3, right3, f2) => {
  const pullNonEmpty = (pull) => pipe(pull, flatMap18((chunk7) => isEmpty2(chunk7) ? pullNonEmpty(pull) : succeed13(chunk7)));
  return pipe(toPull2(left3), map26(pullNonEmpty), zip12(pipe(toPull2(right3), map26(pullNonEmpty))), flatMap18(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend4(() => leftDone), zipWith12(join4(rightFiber), (l, r) => [l, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend4(() => rightDone), zipWith12(join4(leftFiber), (l, r) => [r, l, false]))
  })), flatMap23(([l, r, leftFirst]) => pipe(fromEffect9(make37([unsafeLast(l), unsafeLast(r)])), flatMap23((latest) => pipe(fromChunk(leftFirst ? pipe(r, map7((a2) => f2(unsafeLast(l), a2))) : pipe(l, map7((a) => f2(a, unsafeLast(r))))), concat6(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: (leftChunk) => pipe(modify8(latest, ([_, rightLatest]) => [pipe(leftChunk, map7((a) => f2(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]])),
    onRight: (rightChunk) => pipe(modify8(latest, ([leftLatest, _]) => [pipe(rightChunk, map7((a2) => f2(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]))
  })), flatMap23(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft12 = dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take3(right4.length)), left2(pipe(left4, take3(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop3(left4.length)))];
})));
var zipRight12 = dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take3(right4.length)))];
  }
  return [pipe(right4, take3(left4.length)), right2(pipe(right4, drop3(left4.length)))];
})));
var zipWith17 = dual(3, (left3, right3, f2) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f2))));
var zipWithChunks = dual(3, (self, that, f2) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome2(pullLeft), zip12(unsome2(pullRight), {
          concurrent: true
        }), matchEffect4({
          onFailure: (error4) => succeed13(fail4(some3(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty2(leftOption.value) && isEmpty2(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty2(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty2(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed13(succeed3(zip27(leftOption.value, rightOption.value)));
            }
            return succeed13(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect4(pullLeft, {
          onFailure: (error4) => succeed13(fail4(error4)),
          onSuccess: (leftChunk) => {
            if (isEmpty2(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty2(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed13(succeed3(zip27(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect4(pullRight, {
          onFailure: (error4) => succeed13(fail4(error4)),
          onSuccess: (rightChunk) => {
            if (isEmpty2(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty2(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed13(succeed3(zip27(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  };
  const zip27 = (leftChunk, rightChunk) => {
    const [output, either14] = f2(leftChunk, rightChunk);
    switch (either14._tag) {
      case "Left": {
        if (isEmpty2(either14.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either14.left)];
      }
      case "Right": {
        if (isEmpty2(either14.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either14.right)];
      }
    }
  };
  return pipe(self, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = (self) => pipe(self, mapAccum5(0, (index3, a) => [index3 + 1, [a, index3]]));
var zipWithNext = (self) => {
  const process2 = (last8) => readWithCause({
    onInput: (input) => {
      const [newLast, chunk7] = mapAccum2(input, last8, (prev, curr) => [some3(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output = filterMap5(chunk7, (option11) => isSome2(option11) ? some3([option11.value[0], some3(option11.value[1])]) : none2());
      return flatMap20(write(output), () => process2(newLast));
    },
    onFailure: failCause12,
    onDone: () => match2(last8, {
      onNone: () => void_8,
      onSome: (value10) => zipRight8(write(of3([value10, none2()])), void_8)
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(process2(none2()))));
};
var zipWithPrevious = (self) => pipe(self, mapAccum5(none2(), (prev, curr) => [some3(curr), [prev, curr]]));
var zipWithPreviousAndNext = (self) => pipe(zipWithNext(zipWithPrevious(self)), map33(([[prev, curr], next6]) => [prev, curr, pipe(next6, map2((tuple7) => tuple7[1]))]));
var zipChunks = (left3, right3, f2) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take3(right3.length), zipWith5(right3, f2)), left2(pipe(left3, drop3(right3.length)))];
  }
  return [pipe(left3, zipWith5(pipe(right3, take3(left3.length)), f2)), right2(pipe(right3, drop3(left3.length)))];
};
var Do7 = succeed20({});
var bind9 = dual((args2) => typeof args2[0] !== "string", (self, tag5, f2, options) => flatMap23(self, (k) => map33(f2(k), (a) => ({
  ...k,
  [tag5]: a
})), options));
var bindTo9 = bindTo(map33);
var let_9 = let_(map33);
var channelToStream = (self) => {
  return new StreamImpl(self);
};
var decodeText = dual((args2) => isStream(args2[0]), (self, encoding = "utf-8") => suspend10(() => {
  const decoder4 = new TextDecoder(encoding);
  return map33(self, (s) => decoder4.decode(s));
}));
var encodeText = (self) => suspend10(() => {
  const encoder3 = new TextEncoder();
  return map33(self, (s) => encoder3.encode(s));
});
var fromEventListener = (target, type8, options) => asyncPush((emit2) => acquireRelease3(sync8(() => target.addEventListener(type8, emit2.single, options)), () => sync8(() => target.removeEventListener(type8, emit2.single, options))), {
  bufferSize: typeof options === "object" ? options.bufferSize : void 0
});

// node_modules/effect/dist/esm/Channel.js
var ChannelTypeId4 = ChannelTypeId3;
var ChannelExceptionTypeId2 = ChannelExceptionTypeId;
var isChannel2 = isChannel;
var acquireUseRelease6 = acquireUseRelease4;
var acquireReleaseOut2 = acquireReleaseOut;
var as14 = as9;
var asVoid10 = asVoid7;
var buffer3 = buffer;
var bufferChunk2 = bufferChunk;
var catchAll9 = catchAll6;
var catchAllCause8 = catchAllCause6;
var concatAll3 = concatAll;
var concatAllWith2 = concatAllWith;
var concatMap2 = concatMap;
var concatMapWith2 = concatMapWith;
var concatMapWithCustom2 = concatMapWithCustom;
var collect4 = collect2;
var concatOut2 = concatOut;
var mapInput10 = mapInput7;
var mapInputEffect5 = mapInputEffect2;
var mapInputError2 = mapInputError;
var mapInputErrorEffect2 = mapInputErrorEffect;
var mapInputIn2 = mapInputIn;
var mapInputInEffect2 = mapInputInEffect;
var doneCollect2 = doneCollect;
var drain4 = drain;
var embedInput2 = embedInput;
var emitCollect2 = emitCollect;
var ensuring10 = ensuring5;
var ensuringWith4 = ensuringWith;
var context11 = context7;
var contextWith7 = contextWith3;
var contextWithChannel2 = contextWithChannel;
var contextWithEffect6 = contextWithEffect3;
var fail20 = fail14;
var failSync11 = failSync7;
var failCause17 = failCause12;
var failCauseSync10 = failCauseSync7;
var flatMap24 = flatMap20;
var flatten18 = flatten15;
var foldChannel2 = foldChannel;
var foldCauseChannel2 = foldCauseChannel;
var fromEffect10 = fromEffect5;
var fromEither5 = fromEither3;
var fromInput4 = fromInput;
var fromPubSub4 = fromPubSub;
var fromPubSubScoped2 = fromPubSubScoped;
var fromOption8 = fromOption6;
var fromQueue4 = fromQueue;
var identity5 = identityChannel;
var interruptWhen3 = interruptWhen;
var interruptWhenDeferred3 = interruptWhenDeferred;
var map34 = map28;
var mapEffect8 = mapEffect5;
var mapError11 = mapError7;
var mapErrorCause7 = mapErrorCause5;
var mapOut2 = mapOut;
var mapOutEffect2 = mapOutEffect;
var mapOutEffectPar2 = mapOutEffectPar;
var mergeAll10 = mergeAll7;
var mergeAllUnbounded2 = mergeAllUnbounded;
var mergeAllUnboundedWith2 = mergeAllUnboundedWith;
var mergeAllWith2 = mergeAllWith;
var mergeMap2 = mergeMap;
var mergeOut2 = mergeOut;
var mergeOutWith2 = mergeOutWith;
var mergeWith4 = mergeWith2;
var never9 = never6;
var orDie9 = orDie6;
var orDieWith6 = orDieWith3;
var orElse14 = orElse10;
var pipeTo2 = pipeTo;
var pipeToOrFail2 = pipeToOrFail;
var provideContext9 = provideContext4;
var provideLayer3 = provideLayer;
var mapInputContext8 = mapInputContext4;
var provideSomeLayer4 = provideSomeLayer2;
var provideService11 = provideService6;
var read2 = read;
var readOrFail2 = readOrFail;
var readWith2 = readWith;
var readWithCause2 = readWithCause;
var repeated2 = repeated;
var run5 = run2;
var runCollect3 = runCollect;
var runDrain3 = runDrain;
var runScoped3 = runScoped;
var scoped8 = scoped6;
var scopedWith5 = scopedWith3;
var splitLines3 = splitLines;
var succeed21 = succeed15;
var suspend11 = suspend6;
var sync15 = sync10;
var toPubSub3 = toPubSub;
var toPull3 = toPull;
var toPullIn2 = toPullIn;
var toQueue3 = toQueue;
var toSink = channelToSink;
var toStream = channelToStream;
var void_12 = void_8;
var unwrap5 = unwrap2;
var unwrapScoped6 = unwrapScoped3;
var unwrapScopedWith4 = unwrapScopedWith;
var updateService7 = updateService5;
var withSpan7 = withSpan5;
var write2 = write;
var writeAll2 = writeAll;
var writeChunk2 = writeChunk;
var zip17 = zip13;
var zipLeft13 = zipLeft8;
var zipRight13 = zipRight8;
var ChannelException2 = ChannelException;
var isChannelException2 = isChannelException;

// node_modules/effect/dist/esm/ChildExecutorDecision.js
var ChildExecutorDecision_exports = {};
__export(ChildExecutorDecision_exports, {
  ChildExecutorDecisionTypeId: () => ChildExecutorDecisionTypeId2,
  Close: () => Close2,
  Continue: () => Continue2,
  Yield: () => Yield3,
  isChildExecutorDecision: () => isChildExecutorDecision2,
  isClose: () => isClose2,
  isContinue: () => isContinue4,
  isYield: () => isYield2,
  match: () => match33
});
var ChildExecutorDecisionTypeId2 = ChildExecutorDecisionTypeId;
var Continue2 = Continue;
var Close2 = Close;
var Yield3 = Yield2;
var isChildExecutorDecision2 = isChildExecutorDecision;
var isContinue4 = isContinue3;
var isClose2 = isClose;
var isYield2 = isYield;
var match33 = match22;

// node_modules/effect/dist/esm/Config.js
var Config_exports = {};
__export(Config_exports, {
  ConfigTypeId: () => ConfigTypeId2,
  all: () => all14,
  array: () => array7,
  boolean: () => boolean5,
  branded: () => branded2,
  chunk: () => chunk5,
  date: () => date3,
  duration: () => duration4,
  fail: () => fail22,
  hashMap: () => hashMap4,
  hashSet: () => hashSet4,
  integer: () => integer3,
  isConfig: () => isConfig2,
  literal: () => literal2,
  logLevel: () => logLevel2,
  map: () => map36,
  mapAttempt: () => mapAttempt3,
  mapOrFail: () => mapOrFail2,
  nested: () => nested4,
  nonEmptyString: () => nonEmptyString2,
  number: () => number5,
  option: () => option7,
  orElse: () => orElse16,
  orElseIf: () => orElseIf2,
  port: () => port2,
  primitive: () => primitive2,
  redacted: () => redacted2,
  repeat: () => repeat6,
  secret: () => secret2,
  string: () => string6,
  succeed: () => succeed23,
  suspend: () => suspend13,
  sync: () => sync17,
  unwrap: () => unwrap7,
  url: () => url2,
  validate: () => validate6,
  withDefault: () => withDefault2,
  withDescription: () => withDescription2,
  zip: () => zip19,
  zipWith: () => zipWith19
});

// node_modules/effect/dist/esm/ConfigError.js
var ConfigError_exports = {};
__export(ConfigError_exports, {
  And: () => And2,
  ConfigErrorTypeId: () => ConfigErrorTypeId2,
  InvalidData: () => InvalidData2,
  MissingData: () => MissingData2,
  Or: () => Or2,
  SourceUnavailable: () => SourceUnavailable2,
  Unsupported: () => Unsupported2,
  isAnd: () => isAnd2,
  isConfigError: () => isConfigError2,
  isInvalidData: () => isInvalidData2,
  isMissingData: () => isMissingData2,
  isMissingDataOnly: () => isMissingDataOnly2,
  isOr: () => isOr2,
  isSourceUnavailable: () => isSourceUnavailable2,
  isUnsupported: () => isUnsupported2,
  prefixed: () => prefixed2,
  reduceWithContext: () => reduceWithContext4
});
var ConfigErrorTypeId2 = ConfigErrorTypeId;
var And2 = And;
var Or2 = Or;
var MissingData2 = MissingData;
var InvalidData2 = InvalidData;
var SourceUnavailable2 = SourceUnavailable;
var Unsupported2 = Unsupported;
var isConfigError2 = isConfigError;
var isAnd2 = isAnd;
var isOr2 = isOr;
var isInvalidData2 = isInvalidData;
var isMissingData2 = isMissingData;
var isMissingDataOnly2 = isMissingDataOnly;
var isSourceUnavailable2 = isSourceUnavailable;
var isUnsupported2 = isUnsupported;
var prefixed2 = prefixed;
var reduceWithContext4 = reduceWithContext2;

// node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = Symbol.for(RedactedSymbolKey);
var proto12 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol2]() {
    return pipe(hash(RedactedSymbolKey), combine2(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol3](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make74 = (value10) => {
  const redacted3 = Object.create(proto12);
  redactedRegistry.set(redacted3, value10);
  return redacted3;
};
var value2 = (self) => {
  if (redactedRegistry.has(self)) {
    return redactedRegistry.get(self);
  } else {
    throw new Error("Unable to get redacted value");
  }
};
var unsafeWipe = (self) => redactedRegistry.delete(self);

// node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = Symbol.for(SecretSymbolKey);
var isSecret = (u) => hasProperty(u, SecretTypeId);
var SecretProto = {
  ...proto12,
  [SecretTypeId]: SecretTypeId
};
var make75 = (bytes) => {
  const secret3 = Object.create(SecretProto);
  Object.defineProperty(secret3, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret3, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret3, "raw", {
    enumerable: false,
    value: bytes
  });
  redactedRegistry.set(secret3, bytes.map((byte) => String.fromCharCode(byte)).join(""));
  return secret3;
};
var fromIterable18 = (iterable) => make75(fromIterable2(iterable).map((char2) => char2.charCodeAt(0)));
var fromString5 = (text) => {
  return make75(text.split("").map((char2) => char2.charCodeAt(0)));
};
var value3 = (self) => {
  return self.raw.map((byte) => String.fromCharCode(byte)).join("");
};
var unsafeWipe2 = (self) => {
  for (let i = 0; i < self.raw.length; i++) {
    self.raw[i] = 0;
  }
  redactedRegistry.delete(self);
};

// node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto13 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var boolean4 = (name) => {
  const config2 = primitive("a boolean property", (text) => {
    switch (text) {
      case "true":
      case "yes":
      case "on":
      case "1": {
        return right2(true);
      }
      case "false":
      case "no":
      case "off":
      case "0": {
        return right2(false);
      }
      default: {
        const error4 = InvalidData([], `Expected a boolean value but received ${text}`);
        return left2(error4);
      }
    }
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var url = (name) => {
  const config2 = primitive("an URL property", (text) => try_({
    try: () => new URL(text),
    catch: (_) => InvalidData([], `Expected an URL value but received ${text}`)
  }));
  return name === void 0 ? config2 : nested3(config2, name);
};
var port = (name) => {
  const config2 = primitive("a network port property", (text) => {
    const result = Number(text);
    if (Number.isNaN(result) || result.toString() !== text.toString() || !Number.isInteger(result) || result < 1 || result > 65535) {
      return left2(InvalidData([], `Expected a network port value but received ${text}`));
    }
    return right2(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var array6 = (config2, name) => {
  return pipe(chunk4(config2, name), map35(toArray2));
};
var chunk4 = (config2, name) => {
  return map35(name === void 0 ? repeat5(config2) : nested3(repeat5(config2), name), unsafeFromArray);
};
var date2 = (name) => {
  const config2 = primitive("a date property", (text) => {
    const result = Date.parse(text);
    if (Number.isNaN(result)) {
      return left2(InvalidData([], `Expected a Date value but received ${text}`));
    }
    return right2(new Date(result));
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var fail21 = (message) => {
  const fail30 = Object.create(proto13);
  fail30._tag = OP_FAIL2;
  fail30.message = message;
  fail30.parse = () => left2(Unsupported([], message));
  return fail30;
};
var number4 = (name) => {
  const config2 = primitive("a number property", (text) => {
    const result = Number(text);
    if (Number.isNaN(result)) {
      return left2(InvalidData([], `Expected a number value but received ${text}`));
    }
    return right2(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var integer2 = (name) => {
  const config2 = primitive("an integer property", (text) => {
    const result = Number(text);
    if (!Number.isInteger(result)) {
      return left2(InvalidData([], `Expected an integer value but received ${text}`));
    }
    return right2(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var literal = (...literals) => (name) => {
  const valuesString = literals.map(String).join(", ");
  const config2 = primitive(`one of (${valuesString})`, (text) => {
    const found = literals.find((value10) => String(value10) === text);
    if (found === void 0) {
      return left2(InvalidData([], `Expected one of (${valuesString}) but received ${text}`));
    }
    return right2(found);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var logLevel = (name) => {
  const config2 = mapOrFail(string5(), (value10) => {
    const label = value10.toUpperCase();
    const level = allLogLevels.find((level2) => level2.label === label);
    return level === void 0 ? left2(InvalidData([], `Expected a log level but received ${value10}`)) : right2(level);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var duration3 = (name) => {
  const config2 = mapOrFail(string5(), (value10) => {
    const duration5 = decodeUnknown(value10);
    return fromOption2(duration5, () => InvalidData([], `Expected a duration but received ${value10}`));
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var map35 = dual(2, (self, f2) => mapOrFail(self, (a) => right2(f2(a))));
var mapAttempt2 = dual(2, (self, f2) => mapOrFail(self, (a) => {
  try {
    return right2(f2(a));
  } catch (error4) {
    return left2(InvalidData([], error4 instanceof Error ? error4.message : `${error4}`));
  }
}));
var mapOrFail = dual(2, (self, f2) => {
  const mapOrFail3 = Object.create(proto13);
  mapOrFail3._tag = OP_MAP_OR_FAIL;
  mapOrFail3.original = self;
  mapOrFail3.mapOrFail = f2;
  return mapOrFail3;
});
var nested3 = dual(2, (self, name) => {
  const nested7 = Object.create(proto13);
  nested7._tag = OP_NESTED;
  nested7.name = name;
  nested7.config = self;
  return nested7;
});
var orElse15 = dual(2, (self, that) => {
  const fallback3 = Object.create(proto13);
  fallback3._tag = OP_FALLBACK;
  fallback3.first = self;
  fallback3.second = suspend12(that);
  fallback3.condition = constTrue;
  return fallback3;
});
var orElseIf = dual(2, (self, options) => {
  const fallback3 = Object.create(proto13);
  fallback3._tag = OP_FALLBACK;
  fallback3.first = self;
  fallback3.second = suspend12(options.orElse);
  fallback3.condition = options.if;
  return fallback3;
});
var option6 = (self) => {
  return pipe(self, map35(some3), orElseIf({
    orElse: () => succeed22(none2()),
    if: isMissingDataOnly2
  }));
};
var primitive = (description, parse5) => {
  const primitive3 = Object.create(proto13);
  primitive3._tag = OP_PRIMITIVE;
  primitive3.description = description;
  primitive3.parse = parse5;
  return primitive3;
};
var repeat5 = (self) => {
  const repeat8 = Object.create(proto13);
  repeat8._tag = OP_SEQUENCE;
  repeat8.config = self;
  return repeat8;
};
var secret = (name) => {
  const config2 = primitive("a secret property", (text) => right2(fromString5(text)));
  return name === void 0 ? config2 : nested3(config2, name);
};
var redacted = (nameOrConfig) => {
  const config2 = isConfig(nameOrConfig) ? nameOrConfig : string5(nameOrConfig);
  return map35(config2, make74);
};
var branded = dual(2, (nameOrConfig, constructor) => {
  const config2 = isConfig(nameOrConfig) ? nameOrConfig : string5(nameOrConfig);
  return mapOrFail(config2, (a) => constructor.either(a).pipe(mapLeft((brandErrors) => InvalidData([], brandErrors.map((brandError) => brandError.message).join("\n")))));
});
var hashSet3 = (config2, name) => {
  const newConfig = map35(chunk4(config2), fromIterable6);
  return name === void 0 ? newConfig : nested3(newConfig, name);
};
var string5 = (name) => {
  const config2 = primitive("a text property", right2);
  return name === void 0 ? config2 : nested3(config2, name);
};
var nonEmptyString = (name) => {
  const config2 = primitive("a non-empty text property", liftPredicate((text) => text.length > 0, () => MissingData([], "Expected a non-empty string")));
  return name === void 0 ? config2 : nested3(config2, name);
};
var all13 = (arg) => {
  if (Array.isArray(arg)) {
    return tuple6(arg);
  } else if (Symbol.iterator in arg) {
    return tuple6([...arg]);
  }
  return struct6(arg);
};
var struct6 = (r) => {
  const entries6 = Object.entries(r);
  let result = pipe(entries6[0][1], map35((value10) => ({
    [entries6[0][0]]: value10
  })));
  if (entries6.length === 1) {
    return result;
  }
  const rest = entries6.slice(1);
  for (const [key, config2] of rest) {
    result = pipe(result, zipWith18(config2, (record4, value10) => ({
      ...record4,
      [key]: value10
    })));
  }
  return result;
};
var succeed22 = (value10) => {
  const constant3 = Object.create(proto13);
  constant3._tag = OP_CONSTANT;
  constant3.value = value10;
  constant3.parse = () => right2(value10);
  return constant3;
};
var suspend12 = (config2) => {
  const lazy = Object.create(proto13);
  lazy._tag = OP_LAZY;
  lazy.config = config2;
  return lazy;
};
var sync16 = (value10) => {
  return suspend12(() => succeed22(value10()));
};
var hashMap3 = (config2, name) => {
  const table3 = Object.create(proto13);
  table3._tag = OP_HASHMAP;
  table3.valueConfig = config2;
  return name === void 0 ? table3 : nested3(table3, name);
};
var isConfig = (u) => hasProperty(u, ConfigTypeId);
var tuple6 = (tuple7) => {
  if (tuple7.length === 0) {
    return succeed22([]);
  }
  if (tuple7.length === 1) {
    return map35(tuple7[0], (x) => [x]);
  }
  let result = map35(tuple7[0], (x) => [x]);
  for (let i = 1; i < tuple7.length; i++) {
    const config2 = tuple7[i];
    result = pipe(result, zipWith18(config2, (tuple8, value10) => [...tuple8, value10]));
  }
  return result;
};
var unwrap6 = (wrapped) => {
  if (isConfig(wrapped)) {
    return wrapped;
  }
  return struct6(Object.fromEntries(Object.entries(wrapped).map(([k, a]) => [k, unwrap6(a)])));
};
var validate5 = dual(2, (self, {
  message,
  validation
}) => mapOrFail(self, (a) => {
  if (validation(a)) {
    return right2(a);
  }
  return left2(InvalidData([], message));
}));
var withDefault = dual(2, (self, def) => orElseIf(self, {
  orElse: () => succeed22(def),
  if: isMissingDataOnly2
}));
var withDescription = dual(2, (self, description) => {
  const described = Object.create(proto13);
  described._tag = OP_DESCRIBED;
  described.config = self;
  described.description = description;
  return described;
});
var zip18 = dual(2, (self, that) => zipWith18(self, that, (a, b) => [a, b]));
var zipWith18 = dual(3, (self, that, f2) => {
  const zipWith23 = Object.create(proto13);
  zipWith23._tag = OP_ZIP_WITH;
  zipWith23.left = self;
  zipWith23.right = that;
  zipWith23.zip = f2;
  return zipWith23;
});

// node_modules/effect/dist/esm/Config.js
var ConfigTypeId2 = ConfigTypeId;
var all14 = all13;
var array7 = array6;
var boolean5 = boolean4;
var port2 = port;
var url2 = url;
var chunk5 = chunk4;
var date3 = date2;
var fail22 = fail21;
var number5 = number4;
var integer3 = integer2;
var literal2 = literal;
var logLevel2 = logLevel;
var duration4 = duration3;
var isConfig2 = isConfig;
var map36 = map35;
var mapAttempt3 = mapAttempt2;
var mapOrFail2 = mapOrFail;
var nested4 = nested3;
var orElse16 = orElse15;
var orElseIf2 = orElseIf;
var option7 = option6;
var primitive2 = primitive;
var repeat6 = repeat5;
var secret2 = secret;
var redacted2 = redacted;
var branded2 = branded;
var hashSet4 = hashSet3;
var string6 = string5;
var nonEmptyString2 = nonEmptyString;
var succeed23 = succeed22;
var suspend13 = suspend12;
var sync17 = sync16;
var hashMap4 = hashMap3;
var unwrap7 = unwrap6;
var validate6 = validate5;
var withDefault2 = withDefault;
var withDescription2 = withDescription;
var zip19 = zip18;
var zipWith19 = zipWith18;

// node_modules/effect/dist/esm/ConfigProvider.js
var ConfigProvider_exports = {};
__export(ConfigProvider_exports, {
  ConfigProvider: () => ConfigProvider,
  ConfigProviderTypeId: () => ConfigProviderTypeId2,
  FlatConfigProviderTypeId: () => FlatConfigProviderTypeId2,
  constantCase: () => constantCase3,
  fromEnv: () => fromEnv2,
  fromFlat: () => fromFlat2,
  fromJson: () => fromJson2,
  fromMap: () => fromMap2,
  kebabCase: () => kebabCase3,
  lowerCase: () => lowerCase3,
  make: () => make76,
  makeFlat: () => makeFlat2,
  mapInputPath: () => mapInputPath2,
  nested: () => nested5,
  orElse: () => orElse17,
  snakeCase: () => snakeCase3,
  unnested: () => unnested3,
  upperCase: () => upperCase3,
  within: () => within2
});
var ConfigProviderTypeId2 = ConfigProviderTypeId;
var FlatConfigProviderTypeId2 = FlatConfigProviderTypeId;
var ConfigProvider = configProviderTag;
var make76 = make29;
var makeFlat2 = makeFlat;
var fromEnv2 = fromEnv;
var fromFlat2 = fromFlat;
var fromJson2 = fromJson;
var fromMap2 = fromMap;
var constantCase3 = constantCase2;
var mapInputPath2 = mapInputPath;
var kebabCase3 = kebabCase2;
var lowerCase3 = lowerCase2;
var nested5 = nested2;
var orElse17 = orElse4;
var unnested3 = unnested2;
var snakeCase3 = snakeCase2;
var upperCase3 = upperCase2;
var within2 = within;

// node_modules/effect/dist/esm/ConfigProviderPathPatch.js
var ConfigProviderPathPatch_exports = {};
__export(ConfigProviderPathPatch_exports, {
  andThen: () => andThen13,
  empty: () => empty44,
  mapName: () => mapName2,
  nested: () => nested6,
  unnested: () => unnested4
});
var empty44 = empty25;
var andThen13 = andThen7;
var mapName2 = mapName;
var nested6 = nested;
var unnested4 = unnested;

// node_modules/effect/dist/esm/Console.js
var Console_exports = {};
__export(Console_exports, {
  Console: () => Console,
  TypeId: () => TypeId25,
  assert: () => assert3,
  clear: () => clear3,
  consoleWith: () => consoleWith3,
  count: () => count5,
  countReset: () => countReset2,
  debug: () => debug2,
  dir: () => dir2,
  dirxml: () => dirxml2,
  error: () => error3,
  group: () => group4,
  info: () => info2,
  log: () => log4,
  setConsole: () => setConsole2,
  table: () => table2,
  time: () => time2,
  timeLog: () => timeLog2,
  trace: () => trace2,
  warn: () => warn2,
  withConsole: () => withConsole3,
  withGroup: () => withGroup2,
  withTime: () => withTime2
});
var TypeId25 = TypeId14;
var Console = consoleTag;
var withConsole3 = withConsole;
var setConsole2 = setConsole;
var consoleWith3 = consoleWith;
var assert3 = assert2;
var clear3 = clear2;
var count5 = count;
var countReset2 = countReset;
var debug2 = debug;
var dir2 = dir;
var dirxml2 = dirxml;
var error3 = error2;
var group4 = group3;
var info2 = info;
var log4 = log2;
var table2 = table;
var time2 = time;
var timeLog2 = timeLog;
var trace2 = trace;
var warn2 = warn;
var withGroup2 = withGroup;
var withTime2 = withTime;

// node_modules/effect/dist/esm/DateTime.js
var DateTime_exports = {};
__export(DateTime_exports, {
  CurrentTimeZone: () => CurrentTimeZone,
  Equivalence: () => Equivalence9,
  Order: () => Order11,
  TimeZoneTypeId: () => TimeZoneTypeId2,
  TypeId: () => TypeId26,
  add: () => add8,
  addDuration: () => addDuration2,
  between: () => between7,
  clamp: () => clamp8,
  distance: () => distance2,
  distanceDuration: () => distanceDuration2,
  distanceDurationEither: () => distanceDurationEither2,
  endOf: () => endOf2,
  format: () => format6,
  formatIntl: () => formatIntl2,
  formatIso: () => formatIso3,
  formatIsoDate: () => formatIsoDate2,
  formatIsoDateUtc: () => formatIsoDateUtc2,
  formatIsoOffset: () => formatIsoOffset2,
  formatIsoZoned: () => formatIsoZoned2,
  formatLocal: () => formatLocal2,
  formatUtc: () => formatUtc2,
  getPart: () => getPart2,
  getPartUtc: () => getPartUtc2,
  greaterThan: () => greaterThan10,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo7,
  isDateTime: () => isDateTime2,
  isFuture: () => isFuture2,
  isPast: () => isPast2,
  isTimeZone: () => isTimeZone2,
  isTimeZoneNamed: () => isTimeZoneNamed2,
  isTimeZoneOffset: () => isTimeZoneOffset2,
  isUtc: () => isUtc2,
  isZoned: () => isZoned2,
  layerCurrentZone: () => layerCurrentZone,
  layerCurrentZoneLocal: () => layerCurrentZoneLocal,
  layerCurrentZoneNamed: () => layerCurrentZoneNamed,
  layerCurrentZoneOffset: () => layerCurrentZoneOffset,
  lessThan: () => lessThan14,
  lessThanOrEqualTo: () => lessThanOrEqualTo7,
  make: () => make77,
  makeZoned: () => makeZoned2,
  makeZonedFromString: () => makeZonedFromString2,
  mapEpochMillis: () => mapEpochMillis2,
  match: () => match34,
  max: () => max12,
  min: () => min10,
  mutate: () => mutate6,
  mutateUtc: () => mutateUtc2,
  nearest: () => nearest2,
  now: () => now2,
  nowAsDate: () => nowAsDate2,
  nowInCurrentZone: () => nowInCurrentZone,
  removeTime: () => removeTime2,
  setParts: () => setParts2,
  setPartsUtc: () => setPartsUtc2,
  setZone: () => setZone2,
  setZoneCurrent: () => setZoneCurrent,
  setZoneNamed: () => setZoneNamed2,
  setZoneOffset: () => setZoneOffset2,
  startOf: () => startOf2,
  subtract: () => subtract6,
  subtractDuration: () => subtractDuration2,
  toDate: () => toDate2,
  toDateUtc: () => toDateUtc2,
  toEpochMillis: () => toEpochMillis2,
  toParts: () => toParts2,
  toPartsUtc: () => toPartsUtc2,
  toUtc: () => toUtc2,
  unsafeFromDate: () => unsafeFromDate2,
  unsafeIsFuture: () => unsafeIsFuture2,
  unsafeIsPast: () => unsafeIsPast2,
  unsafeMake: () => unsafeMake14,
  unsafeMakeZoned: () => unsafeMakeZoned2,
  unsafeNow: () => unsafeNow2,
  unsafeSetZoneNamed: () => unsafeSetZoneNamed2,
  withCurrentZone: () => withCurrentZone,
  withCurrentZoneLocal: () => withCurrentZoneLocal,
  withCurrentZoneNamed: () => withCurrentZoneNamed,
  withCurrentZoneOffset: () => withCurrentZoneOffset,
  withDate: () => withDate2,
  withDateUtc: () => withDateUtc2,
  zoneFromString: () => zoneFromString2,
  zoneMakeLocal: () => zoneMakeLocal2,
  zoneMakeNamed: () => zoneMakeNamed2,
  zoneMakeNamedEffect: () => zoneMakeNamedEffect2,
  zoneMakeOffset: () => zoneMakeOffset2,
  zoneToString: () => zoneToString2,
  zoneUnsafeMakeNamed: () => zoneUnsafeMakeNamed2,
  zonedOffset: () => zonedOffset2,
  zonedOffsetIso: () => zonedOffsetIso2
});
var TypeId26 = TypeId20;
var TimeZoneTypeId2 = TimeZoneTypeId;
var isDateTime2 = isDateTime;
var isTimeZone2 = isTimeZone;
var isTimeZoneOffset2 = isTimeZoneOffset;
var isTimeZoneNamed2 = isTimeZoneNamed;
var isUtc2 = isUtc;
var isZoned2 = isZoned;
var Equivalence9 = Equivalence6;
var Order11 = Order9;
var clamp8 = clamp7;
var unsafeFromDate2 = unsafeFromDate;
var unsafeMake14 = unsafeMake11;
var unsafeMakeZoned2 = unsafeMakeZoned;
var makeZoned2 = makeZoned;
var make77 = make57;
var makeZonedFromString2 = makeZonedFromString;
var now2 = now;
var nowAsDate2 = nowAsDate;
var unsafeNow2 = unsafeNow;
var toUtc2 = toUtc;
var setZone2 = setZone;
var setZoneOffset2 = setZoneOffset;
var zoneUnsafeMakeNamed2 = zoneUnsafeMakeNamed;
var zoneMakeOffset2 = zoneMakeOffset;
var zoneMakeNamed2 = zoneMakeNamed;
var zoneMakeNamedEffect2 = zoneMakeNamedEffect;
var zoneMakeLocal2 = zoneMakeLocal;
var zoneFromString2 = zoneFromString;
var zoneToString2 = zoneToString;
var setZoneNamed2 = setZoneNamed;
var unsafeSetZoneNamed2 = unsafeSetZoneNamed;
var distance2 = distance;
var distanceDurationEither2 = distanceDurationEither;
var distanceDuration2 = distanceDuration;
var min10 = min9;
var max12 = max11;
var greaterThan10 = greaterThan9;
var greaterThanOrEqualTo7 = greaterThanOrEqualTo6;
var lessThan14 = lessThan13;
var lessThanOrEqualTo7 = lessThanOrEqualTo6;
var between7 = between6;
var isFuture2 = isFuture;
var unsafeIsFuture2 = unsafeIsFuture;
var isPast2 = isPast;
var unsafeIsPast2 = unsafeIsPast;
var toDateUtc2 = toDateUtc;
var toDate2 = toDate;
var zonedOffset2 = zonedOffset;
var zonedOffsetIso2 = zonedOffsetIso;
var toEpochMillis2 = toEpochMillis;
var removeTime2 = removeTime;
var toParts2 = toParts;
var toPartsUtc2 = toPartsUtc;
var getPartUtc2 = getPartUtc;
var getPart2 = getPart;
var setParts2 = setParts;
var setPartsUtc2 = setPartsUtc;
var CurrentTimeZone = class extends Tag2("effect/DateTime/CurrentTimeZone")() {
};
var setZoneCurrent = (self) => map26(CurrentTimeZone, (zone) => setZone2(self, zone));
var withCurrentZone = dual(2, (effect4, zone) => provideService5(effect4, CurrentTimeZone, zone));
var withCurrentZoneLocal = (effect4) => provideServiceEffect3(effect4, CurrentTimeZone, sync8(zoneMakeLocal2));
var withCurrentZoneOffset = dual(2, (effect4, offset) => provideService5(effect4, CurrentTimeZone, zoneMakeOffset2(offset)));
var withCurrentZoneNamed = dual(2, (effect4, zone) => provideServiceEffect3(effect4, CurrentTimeZone, zoneMakeNamedEffect2(zone)));
var nowInCurrentZone = flatMap18(now2, setZoneCurrent);
var mutate6 = mutate5;
var mutateUtc2 = mutateUtc;
var mapEpochMillis2 = mapEpochMillis;
var withDate2 = withDate;
var withDateUtc2 = withDateUtc;
var match34 = match17;
var addDuration2 = addDuration;
var subtractDuration2 = subtractDuration;
var add8 = add7;
var subtract6 = subtract5;
var startOf2 = startOf;
var endOf2 = endOf;
var nearest2 = nearest;
var format6 = format5;
var formatLocal2 = formatLocal;
var formatUtc2 = formatUtc;
var formatIntl2 = formatIntl;
var formatIso3 = formatIso2;
var formatIsoDate2 = formatIsoDate;
var formatIsoDateUtc2 = formatIsoDateUtc;
var formatIsoOffset2 = formatIsoOffset;
var formatIsoZoned2 = formatIsoZoned;
var layerCurrentZone = (zone) => succeed14(CurrentTimeZone, zone);
var layerCurrentZoneOffset = (offset) => succeed14(CurrentTimeZone, zoneMakeOffset(offset));
var layerCurrentZoneNamed = (zoneId) => effect(CurrentTimeZone, zoneMakeNamedEffect(zoneId));
var layerCurrentZoneLocal = sync9(CurrentTimeZone, zoneMakeLocal2);

// node_modules/effect/dist/esm/DefaultServices.js
var DefaultServices_exports = {};
__export(DefaultServices_exports, {
  currentServices: () => currentServices2,
  liveServices: () => liveServices2
});
var liveServices2 = liveServices;
var currentServices2 = currentServices;

// node_modules/effect/dist/esm/Encoding.js
var Encoding_exports = {};
__export(Encoding_exports, {
  DecodeException: () => DecodeException2,
  DecodeExceptionTypeId: () => DecodeExceptionTypeId2,
  EncodeException: () => EncodeException2,
  EncodeExceptionTypeId: () => EncodeExceptionTypeId2,
  decodeBase64: () => decodeBase64,
  decodeBase64String: () => decodeBase64String,
  decodeBase64Url: () => decodeBase64Url,
  decodeBase64UrlString: () => decodeBase64UrlString,
  decodeHex: () => decodeHex,
  decodeHexString: () => decodeHexString,
  decodeUriComponent: () => decodeUriComponent,
  encodeBase64: () => encodeBase64,
  encodeBase64Url: () => encodeBase64Url,
  encodeHex: () => encodeHex,
  encodeUriComponent: () => encodeUriComponent,
  isDecodeException: () => isDecodeException2,
  isEncodeException: () => isEncodeException2
});

// node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId = Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = (input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var isDecodeException = (u) => hasProperty(u, DecodeExceptionTypeId);
var EncodeExceptionTypeId = Symbol.for("effect/Encoding/errors/Encode");
var EncodeException = (input, message) => {
  const out = {
    _tag: "EncodeException",
    [EncodeExceptionTypeId]: EncodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var isEncodeException = (u) => hasProperty(u, EncodeExceptionTypeId);
var encoder = new TextEncoder();
var decoder = new TextDecoder();

// node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes) => {
  const length6 = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length6; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length6 + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length6) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var decode2 = (str) => {
  const stripped = stripCrlf(str);
  const length6 = stripped.length;
  if (length6 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length6}`));
  }
  const index3 = stripped.indexOf("=");
  if (index3 !== -1 && (index3 < length6 - 2 || index3 === length6 - 2 && stripped[length6 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length6 / 4) - missingOctets);
    for (let i = 0, j = 0; i < length6; i += 4, j += 3) {
      const buffer7 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
      result[j] = buffer7 >> 16;
      result[j + 1] = buffer7 >> 8 & 255;
      result[j + 2] = buffer7 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
};
var stripCrlf = (str) => str.replace(/[\n\r]/g, "");
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
var decode3 = (str) => {
  const stripped = stripCrlf(str);
  const length6 = stripped.length;
  if (length6 % 4 === 1) {
    return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length6}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
    return left2(DecodeException(stripped, "Invalid input"));
  }
  let sanitized = length6 % 4 === 2 ? `${stripped}==` : length6 % 4 === 3 ? `${stripped}=` : stripped;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
};

// node_modules/effect/dist/esm/internal/encoding/hex.js
var encode3 = (bytes) => {
  let result = "";
  for (let i = 0; i < bytes.length; ++i) {
    result += bytesToHex3[bytes[i]];
  }
  return result;
};
var decode4 = (str) => {
  const bytes = new TextEncoder().encode(str);
  if (bytes.length % 2 !== 0) {
    return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
  }
  try {
    const length6 = bytes.length / 2;
    const result = new Uint8Array(length6);
    for (let i = 0; i < length6; i++) {
      const a = fromHexChar(bytes[i * 2]);
      const b = fromHexChar(bytes[i * 2 + 1]);
      result[i] = a << 4 | b;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
};
var bytesToHex3 = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = (byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
};

// node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
var decodeBase64 = (str) => decode2(str);
var decodeBase64String = (str) => map(decodeBase64(str), (_) => decoder.decode(_));
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);
var decodeBase64Url = (str) => decode3(str);
var decodeBase64UrlString = (str) => map(decodeBase64Url(str), (_) => decoder.decode(_));
var encodeHex = (input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input);
var decodeHex = (str) => decode4(str);
var decodeHexString = (str) => map(decodeHex(str), (_) => decoder.decode(_));
var encodeUriComponent = (str) => try_({
  try: () => encodeURIComponent(str),
  catch: (e) => EncodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var decodeUriComponent = (str) => try_({
  try: () => decodeURIComponent(str),
  catch: (e) => DecodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var DecodeExceptionTypeId2 = DecodeExceptionTypeId;
var DecodeException2 = DecodeException;
var isDecodeException2 = isDecodeException;
var EncodeExceptionTypeId2 = EncodeExceptionTypeId;
var EncodeException2 = EncodeException;
var isEncodeException2 = isEncodeException;

// node_modules/effect/dist/esm/ExecutionPlan.js
var ExecutionPlan_exports = {};
__export(ExecutionPlan_exports, {
  TypeId: () => TypeId27,
  isExecutionPlan: () => isExecutionPlan2,
  make: () => make78,
  merge: () => merge11
});
var TypeId27 = TypeId22;
var isExecutionPlan2 = isExecutionPlan;
var make78 = (...steps) => makeProto(steps.map((options, i) => {
  if (options.attempts && options.attempts < 1) {
    throw new Error(`ExecutionPlan.make: step[${i}].attempts must be greater than 0`);
  }
  return {
    schedule: options.schedule,
    attempts: options.attempts,
    while: options.while ? (input) => suspend4(() => {
      const result = options.while(input);
      return typeof result === "boolean" ? succeed13(result) : result;
    }) : void 0,
    provide: options.provide
  };
}));
var Proto3 = {
  [TypeId27]: TypeId27,
  get withRequirements() {
    const self = this;
    return contextWith2((context15) => makeProto(self.steps.map((step4) => ({
      ...step4,
      provide: isLayer2(step4.provide) ? provide3(step4.provide, succeedContext2(context15)) : step4.provide
    }))));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeProto = (steps) => {
  const self = Object.create(Proto3);
  self.steps = steps;
  return self;
};
var merge11 = (...plans) => makeProto(plans.flatMap((plan) => plan.steps));

// node_modules/effect/dist/esm/FiberHandle.js
var FiberHandle_exports = {};
__export(FiberHandle_exports, {
  TypeId: () => TypeId28,
  awaitEmpty: () => awaitEmpty,
  clear: () => clear4,
  get: () => get18,
  isFiberHandle: () => isFiberHandle,
  join: () => join5,
  make: () => make79,
  makeRuntime: () => makeRuntime,
  makeRuntimePromise: () => makeRuntimePromise,
  run: () => run6,
  runtime: () => runtime5,
  runtimePromise: () => runtimePromise,
  set: () => set11,
  unsafeGet: () => unsafeGet10,
  unsafeSet: () => unsafeSet3
});
var TypeId28 = Symbol.for("effect/FiberHandle");
var isFiberHandle = (u) => hasProperty(u, TypeId28);
var Proto4 = {
  [TypeId28]: TypeId28,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake15 = (deferred) => {
  const self = Object.create(Proto4);
  self.state = {
    _tag: "Open",
    fiber: void 0
  };
  self.deferred = deferred;
  return self;
};
var make79 = () => acquireRelease3(map26(make24(), (deferred) => unsafeMake15(deferred)), (handle) => withFiberRuntime2((parent) => {
  const state = handle.state;
  if (state._tag === "Closed") return _void;
  handle.state = {
    _tag: "Closed"
  };
  return state.fiber ? intoDeferred2(asVoid6(interruptAs(state.fiber, combine5(parent.id(), internalFiberId))), handle.deferred) : done2(handle.deferred, void_4);
}));
var makeRuntime = () => flatMap18(make79(), (self) => runtime5(self)());
var makeRuntimePromise = () => flatMap18(make79(), (self) => runtimePromise(self)());
var internalFiberIdId = -1;
var internalFiberId = make17(internalFiberIdId, 0);
var isInternalInterruption = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeSet3 = dual((args2) => isFiberHandle(args2[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5((options == null ? void 0 : options.interruptAs) ?? none4, internalFiberId));
    return;
  } else if (self.state.fiber !== void 0) {
    if ((options == null ? void 0 : options.onlyIfMissing) === true) {
      fiber.unsafeInterruptAsFork(combine5((options == null ? void 0 : options.interruptAs) ?? none4, internalFiberId));
      return;
    } else if (self.state.fiber === fiber) {
      return;
    }
    self.state.fiber.unsafeInterruptAsFork(combine5((options == null ? void 0 : options.interruptAs) ?? none4, internalFiberId));
    self.state.fiber = void 0;
  }
  self.state.fiber = fiber;
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Open" && fiber === self.state.fiber) {
      self.state.fiber = void 0;
    }
    if (isFailure2(exit4) && ((options == null ? void 0 : options.propagateInterruption) === true ? !isInternalInterruption(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var set11 = dual((args2) => isFiberHandle(args2[0]), (self, fiber, options) => fiberIdWith2((fiberId5) => sync8(() => unsafeSet3(self, fiber, {
  interruptAs: fiberId5,
  onlyIfMissing: options == null ? void 0 : options.onlyIfMissing,
  propagateInterruption: options == null ? void 0 : options.propagateInterruption
}))));
var unsafeGet10 = (self) => self.state._tag === "Closed" ? none2() : fromNullable2(self.state.fiber);
var get18 = (self) => suspend4(() => unsafeGet10(self));
var clear4 = (self) => uninterruptibleMask3((restore) => withFiberRuntime2((fiber) => {
  if (self.state._tag === "Closed" || self.state.fiber === void 0) {
    return _void;
  }
  return zipRight7(restore(interruptAs(self.state.fiber, combine5(fiber.id(), internalFiberId))), sync8(() => {
    if (self.state._tag === "Open") {
      self.state.fiber = void 0;
    }
  }));
}));
var constInterruptedFiber = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt8);
    }
    return fiber;
  };
}();
var run6 = function() {
  const self = arguments[0];
  if (isEffect2(arguments[1])) {
    return runImpl(self, arguments[1], arguments[2]);
  }
  const options = arguments[1];
  return (effect4) => runImpl(self, effect4, options);
};
var runImpl = (self, effect4, options) => fiberIdWith2((fiberId5) => {
  if (self.state._tag === "Closed") {
    return interrupt8;
  } else if (self.state.fiber !== void 0 && (options == null ? void 0 : options.onlyIfMissing) === true) {
    return sync8(constInterruptedFiber);
  }
  return tap5(forkDaemon3(effect4), (fiber) => unsafeSet3(self, fiber, {
    ...options,
    interruptAs: fiberId5
  }));
});
var runtime5 = (self) => () => map26(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (effect4, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber();
    } else if (self.state.fiber !== void 0 && (options == null ? void 0 : options.onlyIfMissing) === true) {
      return constInterruptedFiber();
    }
    const fiber = runFork4(effect4, options);
    unsafeSet3(self, fiber, options);
    return fiber;
  };
});
var runtimePromise = (self) => () => map26(runtime5(self)(), (runFork4) => (effect4, options) => new Promise((resolve, reject3) => runFork4(effect4, options).addObserver((exit4) => {
  if (isSuccess(exit4)) {
    resolve(exit4.value);
  } else {
    reject3(squash(exit4.cause));
  }
})));
var join5 = (self) => _await(self.deferred);
var awaitEmpty = (self) => suspend4(() => {
  if (self.state._tag === "Closed" || self.state.fiber === void 0) {
    return _void;
  }
  return _await3(self.state.fiber);
});

// node_modules/effect/dist/esm/FiberMap.js
var FiberMap_exports = {};
__export(FiberMap_exports, {
  TypeId: () => TypeId29,
  awaitEmpty: () => awaitEmpty2,
  clear: () => clear5,
  get: () => get19,
  has: () => has10,
  isFiberMap: () => isFiberMap,
  join: () => join6,
  make: () => make80,
  makeRuntime: () => makeRuntime2,
  makeRuntimePromise: () => makeRuntimePromise2,
  remove: () => remove11,
  run: () => run7,
  runtime: () => runtime6,
  runtimePromise: () => runtimePromise2,
  set: () => set12,
  size: () => size28,
  unsafeGet: () => unsafeGet11,
  unsafeHas: () => unsafeHas,
  unsafeSet: () => unsafeSet4
});
var TypeId29 = Symbol.for("effect/FiberMap");
var isFiberMap = (u) => hasProperty(u, TypeId29);
var Proto5 = {
  [TypeId29]: TypeId29,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty2();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake16 = (backing, deferred) => {
  const self = Object.create(Proto5);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make80 = () => acquireRelease3(map26(make24(), (deferred) => unsafeMake16(empty23(), deferred)), (map49) => withFiberRuntime2((parent) => {
  const state = map49.state;
  if (state._tag === "Closed") return _void;
  map49.state = {
    _tag: "Closed"
  };
  return interruptAllAs2(map4(state.backing, ([, fiber]) => fiber), combine5(parent.id(), internalFiberId2)).pipe(intoDeferred2(map49.deferred));
}));
var makeRuntime2 = () => flatMap18(make80(), (self) => runtime6(self)());
var makeRuntimePromise2 = () => flatMap18(make80(), (self) => runtimePromise2(self)());
var internalFiberIdId2 = -1;
var internalFiberId2 = make17(internalFiberIdId2, 0);
var isInternalInterruption2 = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId2),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeSet4 = dual((args2) => isFiberMap(args2[0]), (self, key, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5((options == null ? void 0 : options.interruptAs) ?? none4, internalFiberId2));
    return;
  }
  const previous2 = get9(self.state.backing, key);
  if (previous2._tag === "Some") {
    if ((options == null ? void 0 : options.onlyIfMissing) === true) {
      fiber.unsafeInterruptAsFork(combine5((options == null ? void 0 : options.interruptAs) ?? none4, internalFiberId2));
      return;
    } else if (previous2.value === fiber) {
      return;
    }
    previous2.value.unsafeInterruptAsFork(combine5((options == null ? void 0 : options.interruptAs) ?? none4, internalFiberId2));
  }
  set5(self.state.backing, key, fiber);
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Closed") {
      return;
    }
    const current2 = get9(self.state.backing, key);
    if (isSome2(current2) && fiber === current2.value) {
      remove8(self.state.backing, key);
    }
    if (isFailure2(exit4) && ((options == null ? void 0 : options.propagateInterruption) === true ? !isInternalInterruption2(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var set12 = dual((args2) => isFiberMap(args2[0]), (self, key, fiber, options) => fiberIdWith2((fiberId5) => sync8(() => unsafeSet4(self, key, fiber, {
  ...options,
  interruptAs: fiberId5
}))));
var unsafeGet11 = dual(2, (self, key) => self.state._tag === "Closed" ? none2() : get9(self.state.backing, key));
var get19 = dual(2, (self, key) => suspend4(() => unsafeGet11(self, key)));
var unsafeHas = dual(2, (self, key) => self.state._tag === "Closed" ? false : has6(self.state.backing, key));
var has10 = dual(2, (self, key) => sync8(() => unsafeHas(self, key)));
var remove11 = dual(2, (self, key) => withFiberRuntime2((removeFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  const fiber = get9(self.state.backing, key);
  if (fiber._tag === "None") {
    return _void;
  }
  return interruptAs(fiber.value, combine5(removeFiber.id(), internalFiberId2));
}));
var clear5 = (self) => withFiberRuntime2((clearFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  return forEach16(self.state.backing, ([, fiber]) => (
    // will be removed by the observer
    interruptAs(fiber, combine5(clearFiber.id(), internalFiberId2))
  ));
});
var constInterruptedFiber2 = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt8);
    }
    return fiber;
  };
}();
var run7 = function() {
  const self = arguments[0];
  if (isEffect2(arguments[2])) {
    return runImpl2(self, arguments[1], arguments[2], arguments[3]);
  }
  const key = arguments[1];
  const options = arguments[2];
  return (effect4) => runImpl2(self, key, effect4, options);
};
var runImpl2 = (self, key, effect4, options) => fiberIdWith2((fiberId5) => {
  if (self.state._tag === "Closed") {
    return interrupt8;
  } else if ((options == null ? void 0 : options.onlyIfMissing) === true && unsafeHas(self, key)) {
    return sync8(constInterruptedFiber2);
  }
  return tap5(forkDaemon3(effect4), (fiber) => unsafeSet4(self, key, fiber, {
    ...options,
    interruptAs: fiberId5
  }));
});
var runtime6 = (self) => () => map26(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (key, effect4, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber2();
    } else if ((options == null ? void 0 : options.onlyIfMissing) === true && unsafeHas(self, key)) {
      return constInterruptedFiber2();
    }
    const fiber = runFork4(effect4, options);
    unsafeSet4(self, key, fiber, options);
    return fiber;
  };
});
var runtimePromise2 = (self) => () => map26(runtime6(self)(), (runFork4) => (key, effect4, options) => new Promise((resolve, reject3) => runFork4(key, effect4, options).addObserver((exit4) => {
  if (isSuccess(exit4)) {
    resolve(exit4.value);
  } else {
    reject3(squash(exit4.cause));
  }
})));
var size28 = (self) => sync8(() => self.state._tag === "Closed" ? 0 : size13(self.state.backing));
var join6 = (self) => _await(self.deferred);
var awaitEmpty2 = (self) => whileLoop3({
  while: () => self.state._tag === "Open" && size13(self.state.backing) > 0,
  body: () => _await3(unsafeHead(self)[1]),
  step: constVoid
});

// node_modules/effect/dist/esm/FiberSet.js
var FiberSet_exports = {};
__export(FiberSet_exports, {
  TypeId: () => TypeId30,
  add: () => add9,
  awaitEmpty: () => awaitEmpty3,
  clear: () => clear6,
  isFiberSet: () => isFiberSet,
  join: () => join7,
  make: () => make81,
  makeRuntime: () => makeRuntime3,
  makeRuntimePromise: () => makeRuntimePromise3,
  run: () => run8,
  runtime: () => runtime7,
  runtimePromise: () => runtimePromise3,
  size: () => size29,
  unsafeAdd: () => unsafeAdd
});
var TypeId30 = Symbol.for("effect/FiberSet");
var isFiberSet = (u) => hasProperty(u, TypeId30);
var Proto6 = {
  [TypeId30]: TypeId30,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty2();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake17 = (backing, deferred) => {
  const self = Object.create(Proto6);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make81 = () => acquireRelease3(map26(make24(), (deferred) => unsafeMake17(/* @__PURE__ */ new Set(), deferred)), (set26) => withFiberRuntime2((parent) => {
  const state = set26.state;
  if (state._tag === "Closed") return _void;
  set26.state = {
    _tag: "Closed"
  };
  const fibers2 = state.backing;
  return interruptAllAs2(fibers2, combine5(parent.id(), internalFiberId3)).pipe(intoDeferred2(set26.deferred));
}));
var makeRuntime3 = () => flatMap18(make81(), (self) => runtime7(self)());
var makeRuntimePromise3 = () => flatMap18(make81(), (self) => runtimePromise3(self)());
var internalFiberIdId3 = -1;
var internalFiberId3 = make17(internalFiberIdId3, 0);
var isInternalInterruption3 = reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId3),
  sequentialCase: (_, left3, right3) => left3 || right3,
  parallelCase: (_, left3, right3) => left3 || right3
});
var unsafeAdd = dual((args2) => isFiberSet(args2[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine5((options == null ? void 0 : options.interruptAs) ?? none4, internalFiberId3));
    return;
  } else if (self.state.backing.has(fiber)) {
    return;
  }
  self.state.backing.add(fiber);
  fiber.addObserver((exit4) => {
    if (self.state._tag === "Closed") {
      return;
    }
    self.state.backing.delete(fiber);
    if (isFailure2(exit4) && ((options == null ? void 0 : options.propagateInterruption) === true ? !isInternalInterruption3(exit4.cause) : !isInterruptedOnly2(exit4.cause))) {
      unsafeDone(self.deferred, exit4);
    }
  });
});
var add9 = dual((args2) => isFiberSet(args2[0]), (self, fiber, options) => fiberIdWith2((fiberId5) => sync8(() => unsafeAdd(self, fiber, {
  ...options,
  interruptAs: fiberId5
}))));
var clear6 = (self) => withFiberRuntime2((clearFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  return forEach16(self.state.backing, (fiber) => (
    // will be removed by the observer
    interruptAs(fiber, combine5(clearFiber.id(), internalFiberId3))
  ));
});
var constInterruptedFiber3 = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt8);
    }
    return fiber;
  };
}();
var run8 = function() {
  const self = arguments[0];
  if (!isEffect2(arguments[1])) {
    const options = arguments[1];
    return (effect4) => runImpl3(self, effect4, options);
  }
  return runImpl3(self, arguments[1], arguments[2]);
};
var runImpl3 = (self, effect4, options) => fiberIdWith2((fiberId5) => {
  if (self.state._tag === "Closed") {
    return sync8(constInterruptedFiber3);
  }
  return tap5(forkDaemon3(effect4), (fiber) => unsafeAdd(self, fiber, {
    ...options,
    interruptAs: fiberId5
  }));
});
var runtime7 = (self) => () => map26(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (effect4, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber3();
    }
    const fiber = runFork4(effect4, options);
    unsafeAdd(self, fiber);
    return fiber;
  };
});
var runtimePromise3 = (self) => () => map26(runtime7(self)(), (runFork4) => (effect4, options) => new Promise((resolve, reject3) => runFork4(effect4, options).addObserver((exit4) => {
  if (isSuccess(exit4)) {
    resolve(exit4.value);
  } else {
    reject3(squash(exit4.cause));
  }
})));
var size29 = (self) => sync8(() => self.state._tag === "Closed" ? 0 : self.state.backing.size);
var join7 = (self) => _await(self.deferred);
var awaitEmpty3 = (self) => whileLoop3({
  while: () => self.state._tag === "Open" && self.state.backing.size > 0,
  body: () => _await3(unsafeHead(self)),
  step: constVoid
});

// node_modules/effect/dist/esm/GroupBy.js
var GroupBy_exports = {};
__export(GroupBy_exports, {
  GroupByTypeId: () => GroupByTypeId2,
  evaluate: () => evaluate3,
  filter: () => filter20,
  first: () => first4,
  make: () => make83
});

// node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
var evaluate2 = dual((args2) => isGroupBy(args2[0]), (self, f2, options) => flatMap23(self.grouped, ([key, queue]) => f2(key, flattenTake(fromQueue3(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: (options == null ? void 0 : options.bufferSize) ?? 16
}));
var filter19 = dual(2, (self, predicate) => make82(pipe(self.grouped, filterEffect((tuple7) => {
  if (predicate(tuple7[0])) {
    return pipe(succeed13(tuple7), as8(true));
  }
  return pipe(shutdown4(tuple7[1]), as8(false));
}))));
var first3 = dual(2, (self, n) => make82(pipe(zipWithIndex(self.grouped), filterEffect((tuple7) => {
  const index3 = tuple7[1];
  const queue = tuple7[0][1];
  if (index3 < n) {
    return pipe(succeed13(tuple7), as8(true));
  }
  return pipe(shutdown4(queue), as8(false));
}), map33((tuple7) => tuple7[0]))));
var make82 = (grouped3) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped3
});
var groupBy3 = dual((args2) => isStream(args2[0]), (self, f2, options) => make82(unwrapScoped5(gen6(function* () {
  const decider = yield* make24();
  const output = yield* acquireRelease3(bounded5((options == null ? void 0 : options.bufferSize) ?? 16), (queue) => shutdown4(queue));
  const ref = yield* make37(/* @__PURE__ */ new Map());
  const add14 = yield* pipe(mapEffectSequential(self, f2), distributedWithDynamicCallback((options == null ? void 0 : options.bufferSize) ?? 16, ([key, value10]) => flatMap18(_await(decider), (f3) => f3(key, value10)), (exit4) => offer3(output, exit4)));
  yield* succeed2(decider, (key, _) => pipe(get13(ref), map26((map49) => fromNullable2(map49.get(key))), flatMap18(match2({
    onNone: () => flatMap18(add14, ([index3, queue]) => zipRight7(update4(ref, (map49) => map49.set(key, index3)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit4) => new TakeImpl(pipe(exit4, map15((tuple7) => of3(tuple7[1])))))])), as8((n) => n === index3)))),
    onSome: (index3) => succeed13((n) => n === index3)
  }))));
  return flattenExitOption(fromQueue3(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = dual((args2) => typeof args2[0] !== "function", (self, f2, options) => {
  if (options == null ? void 0 : options.key) {
    return evaluate2(groupByKey(self, options.key, {
      bufferSize: options.bufferSize
    }), (_, s) => mapEffectSequential(s, f2));
  }
  return matchConcurrency(options == null ? void 0 : options.concurrency, () => mapEffectSequential(self, f2), (n) => (options == null ? void 0 : options.unordered) ? flatMap23(self, (a) => fromEffect9(f2(a)), {
    concurrency: n
  }) : mapEffectPar(self, n, f2));
});
var bindEffect = dual((args2) => typeof args2[0] !== "string", (self, tag5, f2, options) => mapEffectOptions(self, (k) => map26(f2(k), (a) => ({
  ...k,
  [tag5]: a
})), options));
var mapDequeue = (dequeue, f2) => new MapDequeue(dequeue, f2);
var _a73, _b25;
var MapDequeue = class extends (_b25 = Class3, _a73 = DequeueTypeId2, _b25) {
  constructor(dequeue, f2) {
    super();
    __publicField(this, "dequeue");
    __publicField(this, "f");
    __publicField(this, _a73, {
      _Out: (_) => _
    });
    this.dequeue = dequeue;
    this.f = f2;
  }
  capacity() {
    return capacity5(this.dequeue);
  }
  get size() {
    return size23(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown4(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown4(this.dequeue);
  }
  get shutdown() {
    return shutdown4(this.dequeue);
  }
  get isFull() {
    return isFull5(this.dequeue);
  }
  get isEmpty() {
    return isEmpty18(this.dequeue);
  }
  get take() {
    return pipe(take6(this.dequeue), map26((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map26(map7((a) => this.f(a))));
  }
  takeUpTo(max14) {
    return pipe(takeUpTo2(this.dequeue, max14), map26(map7((a) => this.f(a))));
  }
  takeBetween(min11, max14) {
    return pipe(takeBetween2(this.dequeue, min11, max14), map26(map7((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map26(map7((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map26(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
};
var groupByKey = dual((args2) => typeof args2[0] !== "function", (self, f2, options) => {
  const loop5 = (map49, outerQueue) => readWithCause({
    onInput: (input) => flatMap20(fromEffect5(forEach16(groupByIterable(input, f2), ([key, values15]) => {
      const innerQueue = map49.get(key);
      if (innerQueue === void 0) {
        return pipe(bounded5((options == null ? void 0 : options.bufferSize) ?? 16), flatMap18((innerQueue2) => pipe(sync8(() => {
          map49.set(key, innerQueue2);
        }), zipRight7(offer3(outerQueue, of7([key, innerQueue2]))), zipRight7(pipe(offer3(innerQueue2, chunk3(values15)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk3(values15)), (cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2());
    }, {
      discard: true
    })), () => loop5(map49, outerQueue)),
    onFailure: (cause3) => fromEffect5(offer3(outerQueue, failCause14(cause3))),
    onDone: () => pipe(fromEffect5(pipe(forEach16(map49.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2())), {
      discard: true
    }), zipRight7(offer3(outerQueue, end4)))))
  });
  return make82(unwrapScopedWith3((scope6) => gen6(function* () {
    const map49 = /* @__PURE__ */ new Map();
    const queue = yield* unbounded5();
    yield* addFinalizer3(scope6, shutdown4(queue));
    return yield* toChannel2(self).pipe(pipeTo(loop5(map49, queue)), drain, runIn(scope6), forkIn3(scope6), as8(flattenTake(fromQueue3(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = dual(2, (iterable, f2) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map49 = /* @__PURE__ */ new Map();
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const value10 = next6.value;
    const key = f2(value10);
    if (map49.has(key)) {
      const innerBuilder = map49.get(key);
      innerBuilder.push(value10);
    } else {
      const innerBuilder = [value10];
      builder.push([key, innerBuilder]);
      map49.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple7) => [tuple7[0], unsafeFromArray(tuple7[1])]));
});

// node_modules/effect/dist/esm/GroupBy.js
var GroupByTypeId2 = GroupByTypeId;
var evaluate3 = evaluate2;
var filter20 = filter19;
var first4 = first3;
var make83 = make82;

// node_modules/effect/dist/esm/HKT.js
var HKT_exports = {};

// node_modules/effect/dist/esm/JSONSchema.js
var JSONSchema_exports = {};
__export(JSONSchema_exports, {
  fromAST: () => fromAST,
  make: () => make84
});

// node_modules/effect/dist/esm/ParseResult.js
var ParseResult_exports = {};
__export(ParseResult_exports, {
  ArrayFormatter: () => ArrayFormatter,
  Composite: () => Composite2,
  Forbidden: () => Forbidden,
  Missing: () => Missing,
  ParseError: () => ParseError2,
  ParseErrorTypeId: () => ParseErrorTypeId2,
  Pointer: () => Pointer,
  Refinement: () => Refinement2,
  Transformation: () => Transformation2,
  TreeFormatter: () => TreeFormatter,
  Type: () => Type2,
  Unexpected: () => Unexpected,
  asserts: () => asserts,
  decode: () => decode5,
  decodeEither: () => decodeEither,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown2,
  decodeUnknownEither: () => decodeUnknownEither,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownSync: () => decodeUnknownSync,
  eitherOrUndefined: () => eitherOrUndefined,
  encode: () => encode4,
  encodeEither: () => encodeEither,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown,
  encodeUnknownEither: () => encodeUnknownEither,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownSync: () => encodeUnknownSync,
  fail: () => fail23,
  flatMap: () => flatMap25,
  fromOption: () => fromOption9,
  getFinalTransformation: () => getFinalTransformation,
  getLiterals: () => getLiterals,
  getOption: () => getOption3,
  getRefinementExpected: () => getRefinementExpected,
  getSearchTree: () => getSearchTree,
  is: () => is,
  isComposite: () => isComposite3,
  isParseError: () => isParseError2,
  map: () => map37,
  mapBoth: () => mapBoth10,
  mapError: () => mapError12,
  mergeInternalOptions: () => mergeInternalOptions,
  orElse: () => orElse18,
  parseError: () => parseError,
  succeed: () => succeed24,
  try: () => _try,
  validate: () => validate7,
  validateEither: () => validateEither,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise,
  validateSync: () => validateSync
});
var Pointer = class {
  constructor(path2, actual, issue) {
    __publicField(this, "path");
    __publicField(this, "actual");
    __publicField(this, "issue");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Pointer");
    this.path = path2;
    this.actual = actual;
    this.issue = issue;
  }
};
var Unexpected = class {
  constructor(actual, message) {
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Unexpected");
    this.actual = actual;
    this.message = message;
  }
};
var Missing = class {
  constructor(ast, message) {
    __publicField(this, "ast");
    __publicField(this, "message");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Missing");
    /**
     * @since 3.10.0
     */
    __publicField(this, "actual");
    this.ast = ast;
    this.message = message;
  }
};
var Composite2 = class {
  constructor(ast, actual, issues, output) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "issues");
    __publicField(this, "output");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Composite");
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
};
var Refinement2 = class {
  constructor(ast, actual, kind, issue) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "kind");
    __publicField(this, "issue");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Refinement");
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Transformation2 = class {
  constructor(ast, actual, kind, issue) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "kind");
    __publicField(this, "issue");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Transformation");
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Type2 = class {
  constructor(ast, actual, message) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Type");
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var Forbidden = class {
  constructor(ast, actual, message) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Forbidden");
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var ParseErrorTypeId2 = Symbol.for("effect/Schema/ParseErrorTypeId");
var isParseError2 = (u) => hasProperty(u, ParseErrorTypeId2);
var _a74;
var ParseError2 = class extends TaggedError2("ParseError") {
  constructor() {
    super(...arguments);
    /**
     * @since 3.10.0
     */
    __publicField(this, _a74, ParseErrorTypeId2);
  }
  get message() {
    return this.toString();
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 3.10.0
   */
  [(_a74 = ParseErrorTypeId2, NodeInspectSymbol)]() {
    return this.toJSON();
  }
};
var parseError = (issue) => new ParseError2({
  issue
});
var succeed24 = right2;
var fail23 = left2;
var _try = try_;
var fromOption9 = fromOption2;
var isEither5 = isEither2;
var flatMap25 = dual(2, (self, f2) => {
  return isEither5(self) ? match(self, {
    onLeft: left2,
    onRight: f2
  }) : flatMap18(self, f2);
});
var map37 = dual(2, (self, f2) => {
  return isEither5(self) ? map(self, f2) : map26(self, f2);
});
var mapError12 = dual(2, (self, f2) => {
  return isEither5(self) ? mapLeft(self, f2) : mapError5(self, f2);
});
var eitherOrUndefined = (self) => {
  if (isEither5(self)) {
    return self;
  }
};
var mapBoth10 = dual(2, (self, options) => {
  return isEither5(self) ? mapBoth(self, {
    onLeft: options.onFailure,
    onRight: options.onSuccess
  }) : mapBoth6(self, options);
});
var orElse18 = dual(2, (self, f2) => {
  return isEither5(self) ? match(self, {
    onLeft: f2,
    onRight: right2
  }) : catchAll4(self, f2);
});
var mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options;
  }
  if (options === void 0) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getOption3 = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getRight3(parser(input, overrideOptions));
};
var getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
var decodeUnknownOption = (schema, options) => getOption3(schema.ast, true, options);
var decodeUnknownEither = (schema, options) => getEither(schema.ast, true, options);
var decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown2(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var decodeUnknown2 = (schema, options) => getEffect(schema.ast, true, options);
var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
var encodeUnknownOption = (schema, options) => getOption3(schema.ast, false, options);
var encodeUnknownEither = (schema, options) => getEither(schema.ast, false, options);
var encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
var decodeSync = decodeUnknownSync;
var decodeOption = decodeUnknownOption;
var decodeEither = decodeUnknownEither;
var decodePromise = decodeUnknownPromise;
var decode5 = decodeUnknown2;
var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
var validateOption = (schema, options) => getOption3(typeAST(schema.ast), true, options);
var validateEither = (schema, options) => getEither(typeAST(schema.ast), true, options);
var validatePromise = (schema, options) => {
  const parser = validate7(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var validate7 = (schema, options) => getEffect(typeAST(schema.ast), true, options);
var is = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options, overrideOptions)
  }));
};
var asserts = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions(options, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError(result.left);
    }
  };
};
var encodeSync = encodeUnknownSync;
var encodeOption = encodeUnknownOption;
var encodeEither = encodeUnknownEither;
var encodePromise = encodeUnknownPromise;
var encode4 = encodeUnknown;
var decodeMemoMap = globalValue(Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = globalValue(Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo2 = memoMap.get(ast);
  if (memo2) {
    return memo2;
  }
  const raw = go2(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse18(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined2(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined2(getBatchingAnnotation(ast));
var go2 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from29 = goMemo(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption;
          const allErrors = (options == null ? void 0 : options.errors) === "all";
          const result = flatMap25(orElse18(from29(i, options), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite3(ef)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options);
        };
      } else {
        const from29 = goMemo(typeAST(ast), true);
        const to3 = goMemo(dropRightRefinement(ast.from), false);
        return (i, options) => handleForbidden(flatMap25(from29(i, options), (a) => to3(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform10 = getFinalTransformation(ast.transformation, isDecoding);
      const from29 = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to3 = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options) => handleForbidden(flatMap25(mapError12(from29(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap25(mapError12(transform10(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError12(to3(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse5 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden(parse5(i, options ?? defaultParseOption, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value10]) => value10 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = (options == null ? void 0 : options.errors) === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te2 = parser(input[i], options);
            if (isEither5(te2)) {
              if (isLeft2(te2)) {
                const e = new Pointer(i, input, te2.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te2.right]);
            } else {
              const nk = stepKey++;
              const index3 = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap18(either6(te2), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index3, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head13, ...tail5] = rest;
          for (; i < len - tail5.length; i++) {
            const te2 = head13(input[i], options);
            if (isEither5(te2)) {
              if (isLeft2(te2)) {
                const e = new Pointer(i, input, te2.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te2.right]);
              }
            } else {
              const nk = stepKey++;
              const index3 = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap18(either6(te2), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index3, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0; j < tail5.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te2 = tail5[j](input[i], options);
              if (isEither5(te2)) {
                if (isLeft2(te2)) {
                  const e = new Pointer(i, input, te2.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te2.right]);
              } else {
                const nk = stepKey++;
                const index3 = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap18(either6(te2), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index3, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap18(forEach16(cqueue, (f2) => f2(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is4) => [goMemo(is4.parameter, isDecoding), goMemo(is4.type, isDecoding), is4.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is4) => is4.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = (options == null ? void 0 : options.errors) === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = (options == null ? void 0 : options.onExcessProperty) === "error";
        const onExcessPropertyPreserve = (options == null ? void 0 : options.onExcessProperty) === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const te2 = expected(key, options);
            if (isEither5(te2) && isLeft2(te2)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = (options == null ? void 0 : options.exact) === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te2 = parser(input[name], options);
          if (isEither5(te2)) {
            if (isLeft2(te2)) {
              const e = new Pointer(name, input, hasKey ? te2.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te2.right;
          } else {
            const nk = stepKey++;
            const index3 = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap18(either6(te2), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index3, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index3] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type8 = indexSignature[1];
          const keys15 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys15) {
            const keu = parameter(key, options);
            if (isEither5(keu) && isRight2(keu)) {
              const vpr = type8(input[key], options);
              if (isEither5(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index3 = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap18(either6(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index3, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if ((options == null ? void 0 : options.propertyOrder) === "original") {
            const keys15 = inputKeys || ownKeys(input);
            for (const name of expectedKeys) {
              if (keys15.indexOf(name) === -1) {
                keys15.push(name);
              }
            }
            const out = {};
            for (const key of keys15) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap18(forEach16(cqueue, (f2) => f2(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys2 = ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys2.length;
      const astTypesLen = ast.types.length;
      const map49 = /* @__PURE__ */ new Map();
      for (let i = 0; i < astTypesLen; i++) {
        map49.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name = ownKeys2[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal3 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal3)) {
                  candidates = candidates.concat(buckets[literal3]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map49.get(candidate)(input, options);
          if (isEither5(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend4(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap18(either6(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
          // this should never happen
          left2(new Type2(ast, input))
        );
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es)
            };
            return flatMap18(forEach16(cqueue, (f2) => f2(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get48 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
      return (a, options) => get48()(a, options);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature2 = ast.propertySignatures[i];
        const type8 = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
        if (isLiteral(type8) && !propertySignature2.isOptional) {
          out.push([propertySignature2.name, type8]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element2 = ast.elements[i];
        const type8 = isDecoding ? encodedAST(element2.type) : typeAST(element2.type);
        if (isLiteral(type8) && !element2.isOptional) {
          out.push([i, type8]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys15 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags3 = getLiterals(member, isDecoding);
    if (tags3.length > 0) {
      candidates.push(member);
      for (let j = 0; j < tags3.length; j++) {
        const [key, literal3] = tags3[j];
        const hash11 = String(literal3.literal);
        keys15[key] = keys15[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys15[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash11)) {
          if (j < tags3.length - 1) {
            continue;
          }
          buckets[hash11].push(member);
          keys15[key].literals.push(literal3);
          keys15[key].candidates.push(member);
        } else {
          buckets[hash11] = [member];
          keys15[key].literals.push(literal3);
          keys15[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys15,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect4, ast, actual, options) => {
  if ((options == null ? void 0 : options.isEffectAllowed) === true) {
    return effect4;
  }
  if (isEither5(effect4)) {
    return effect4;
  }
  const scheduler2 = new SyncScheduler();
  const fiber = runFork2(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const exit4 = fiber.unsafePoll();
  if (exit4) {
    if (isSuccess(exit4)) {
      return right2(exit4.value);
    }
    const cause3 = exit4.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty3(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from29, to3] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f2 = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from29) ? some3(input2[from29]) : none2());
            delete input2[from29];
            if (isSome2(o)) {
              input2[to3] = o.value;
            }
            return input2;
          };
          out = map37(out, f2);
        }
        return out;
      };
  }
};
var makeTree = (value10, forest = []) => ({
  value: value10,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map37(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither5(e) ? getOrThrow(e) : runSync2(e);
  },
  formatError: (error4) => TreeFormatter.formatIssue(error4.issue),
  formatErrorSync: (error4) => TreeFormatter.formatIssueSync(error4.issue)
};
var drawTree = (tree) => tree.value + draw("\n", tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "" : "") + " " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => "ast" in issue ? some3(issue.ast) : none2();
var Either_void = right2(void 0);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap2(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union17 = messageAnnotation(issue);
    if (isString(union17)) {
      return right2({
        message: union17,
        override: false
      });
    }
    if (isEffect2(union17)) {
      return map26(union17, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union17.message)) {
      return right2({
        message: union17.message,
        override: union17.override
      });
    }
    return map26(union17.message, (message) => ({
      message,
      override: union17.override
    }));
  }
}));
var createParseIssueGuard = (tag5) => (issue) => issue._tag === tag5;
var isComposite3 = createParseIssueGuard("Composite");
var isRefinement2 = createParseIssueGuard("Refinement");
var isTransformation2 = createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap25(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== void 0) {
    const useInnerMessage = !currentMessage.override && (isComposite3(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap2(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined2);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse2(() => getTitleAnnotation(ast)), orElse2(() => getAutoTitleAnnotation(ast)), orElse2(() => getIdentifierAnnotation(ast)), getOrElse2(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map37(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map37(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map37(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map37(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map37(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map37(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty(issue.issues) ? map37(forEach16(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map37(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};
var makeArrayFormatterIssue = (_tag, path2, message) => ({
  _tag,
  path: path2,
  message
});
var ArrayFormatter = {
  formatIssue: (issue) => getArrayFormatterIssues(issue, void 0, []),
  formatIssueSync: (issue) => {
    const e = ArrayFormatter.formatIssue(issue);
    return isEither5(e) ? getOrThrow(e) : runSync2(e);
  },
  formatError: (error4) => ArrayFormatter.formatIssue(error4.issue),
  formatErrorSync: (error4) => ArrayFormatter.formatIssueSync(error4.issue)
};
var getArrayFormatterIssues = (issue, parentTag, path2) => {
  const _tag = issue._tag;
  switch (_tag) {
    case "Type":
      return map37(formatTypeMessage(issue), (message) => [makeArrayFormatterIssue(parentTag ?? _tag, path2, message)]);
    case "Forbidden":
      return right2([makeArrayFormatterIssue(_tag, path2, formatForbiddenMessage(issue))]);
    case "Unexpected":
      return right2([makeArrayFormatterIssue(_tag, path2, formatUnexpectedMessage(issue))]);
    case "Missing":
      return map37(formatMissingMessage(issue), (message) => [makeArrayFormatterIssue(_tag, path2, message)]);
    case "Pointer":
      return getArrayFormatterIssues(issue.issue, void 0, path2.concat(issue.path));
    case "Composite":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path2, message)]);
        }
        return isNonEmpty(issue.issues) ? map37(forEach16(issue.issues, (issue2) => getArrayFormatterIssues(issue2, void 0, path2)), flatten3) : getArrayFormatterIssues(issue.issues, void 0, path2);
      });
    case "Refinement":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path2, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Predicate" ? _tag : void 0, path2);
      });
    case "Transformation":
      return flatMap25(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path2, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Transformation" ? _tag : void 0, path2);
      });
  }
};

// node_modules/effect/dist/esm/JSONSchema.js
var make84 = (schema) => {
  const definitions = {};
  const ast = isTransformation(schema.ast) && isParseJsonTransformation(schema.ast.from) ? schema.ast.to : schema.ast;
  const jsonSchema = fromAST(ast, {
    definitions
  });
  const out = {
    $schema,
    $defs: {},
    ...jsonSchema
  };
  if (isEmptyRecord(definitions)) {
    delete out.$defs;
  } else {
    out.$defs = definitions;
  }
  return out;
};
var fromAST = (ast, options) => {
  const definitionPath = options.definitionPath ?? "#/$defs/";
  const getRef = (id3) => definitionPath + id3;
  const target = options.target ?? "jsonSchema7";
  const handleIdentifier = options.topLevelReferenceStrategy !== "skip";
  const additionalPropertiesStrategy = options.additionalPropertiesStrategy ?? "strict";
  return go3(ast, options.definitions, handleIdentifier, [], {
    getRef,
    target,
    additionalPropertiesStrategy
  });
};
var constNever = {
  "$id": "/schemas/never",
  "not": {}
};
var constAny = {
  "$id": "/schemas/any"
};
var constUnknown = {
  "$id": "/schemas/unknown"
};
var constVoid2 = {
  "$id": "/schemas/void"
};
var constAnyObject = {
  "$id": "/schemas/object",
  "anyOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
var constEmpty2 = {
  "$id": "/schemas/%7B%7D",
  "anyOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
var $schema = "http://json-schema.org/draft-07/schema#";
var getJsonSchemaAnnotations = (ast, annotated) => {
  annotated ?? (annotated = ast);
  const out = getSomes2({
    description: getDescriptionAnnotation(annotated),
    title: getTitleAnnotation(annotated),
    default: getDefaultAnnotation(annotated)
  });
  const oexamples = getExamplesAnnotation(annotated);
  if (isSome2(oexamples) && oexamples.value.length > 0) {
    const getOption4 = getOption3(ast, false);
    const examples = filterMap4(oexamples.value, (e) => getOption4(e));
    if (examples.length > 0) {
      out.examples = examples;
    }
  }
  return out;
};
var removeDefaultJsonSchemaAnnotations = (jsonSchemaAnnotations, ast) => {
  if (jsonSchemaAnnotations["title"] === ast.annotations[TitleAnnotationId]) {
    delete jsonSchemaAnnotations["title"];
  }
  if (jsonSchemaAnnotations["description"] === ast.annotations[DescriptionAnnotationId]) {
    delete jsonSchemaAnnotations["description"];
  }
  return jsonSchemaAnnotations;
};
var getASTJsonSchemaAnnotations = (ast) => {
  const jsonSchemaAnnotations = getJsonSchemaAnnotations(ast);
  switch (ast._tag) {
    case "StringKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, stringKeyword);
    case "NumberKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, numberKeyword);
    case "BooleanKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, booleanKeyword);
    default:
      return jsonSchemaAnnotations;
  }
};
var pruneUndefined2 = (ast) => {
  if (isNone2(getJSONSchemaAnnotation(ast))) {
    return pruneUndefined(ast, pruneUndefined2, (ast2) => pruneUndefined2(ast2.from));
  }
};
var isParseJsonTransformation = (ast) => ast.annotations[SchemaIdAnnotationId] === ParseJsonSchemaId;
var isOverrideAnnotation = (jsonSchema) => {
  return "type" in jsonSchema || "oneOf" in jsonSchema || "anyOf" in jsonSchema || "const" in jsonSchema || "enum" in jsonSchema || "$ref" in jsonSchema;
};
var isMergeableEnum = (jsonSchema) => {
  const len = Object.keys(jsonSchema).length;
  return "enum" in jsonSchema && (len === 1 || "type" in jsonSchema && len === 2);
};
var addEnumType = (jsonSchema) => {
  if ("enum" in jsonSchema && !("type" in jsonSchema)) {
    const type8 = jsonSchema.enum.every(isString) ? "string" : jsonSchema.enum.every(isNumber) ? "number" : jsonSchema.enum.every(isBoolean) ? "boolean" : void 0;
    if (type8 !== void 0) {
      return {
        type: type8,
        ...jsonSchema
      };
    }
  }
  return jsonSchema;
};
var mergeRefinements = (from29, jsonSchema, annotations4) => {
  const out = {
    ...from29,
    ...annotations4,
    ...jsonSchema
  };
  out.allOf ?? (out.allOf = []);
  const handle = (name, filter26) => {
    if (name in jsonSchema && name in from29) {
      out.allOf.unshift({
        [name]: from29[name]
      });
      out.allOf = out.allOf.filter(filter26);
    }
  };
  handle("minLength", (i) => i.minLength > jsonSchema.minLength);
  handle("maxLength", (i) => i.maxLength < jsonSchema.maxLength);
  handle("pattern", (i) => i.pattern !== jsonSchema.pattern);
  handle("minItems", (i) => i.minItems > jsonSchema.minItems);
  handle("maxItems", (i) => i.maxItems < jsonSchema.maxItems);
  handle("minimum", (i) => i.minimum > jsonSchema.minimum);
  handle("maximum", (i) => i.maximum < jsonSchema.maximum);
  handle("exclusiveMinimum", (i) => i.exclusiveMinimum > jsonSchema.exclusiveMinimum);
  handle("exclusiveMaximum", (i) => i.exclusiveMaximum < jsonSchema.exclusiveMaximum);
  handle("multipleOf", (i) => i.multipleOf !== jsonSchema.multipleOf);
  if (out.allOf.length === 0) {
    delete out.allOf;
  }
  return out;
};
function isContentSchemaSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
      return false;
    case "jsonSchema2019-09":
    case "openApi3.1":
      return true;
  }
}
function isNullTypeKeywordSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
    case "jsonSchema2019-09":
      return true;
    case "openApi3.1":
      return false;
  }
}
function isNullableKeywordSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
    case "jsonSchema2019-09":
      return false;
    case "openApi3.1":
      return true;
  }
}
function getAdditionalProperties(options) {
  switch (options.additionalPropertiesStrategy) {
    case "allow":
      return true;
    case "strict":
      return false;
  }
}
var isNeverJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/never";
var isAnyJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/any";
var isUnknownJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/unknown";
var isVoidJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/void";
var shrink = (members) => {
  let i = members.findIndex(isAnyJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  i = members.findIndex(isUnknownJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  i = members.findIndex(isVoidJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  return members;
};
var go3 = (ast, $defs, handleIdentifier, path2, options) => {
  if (handleIdentifier) {
    const identifier2 = getJSONIdentifier(ast);
    if (isSome2(identifier2)) {
      const id3 = identifier2.value;
      const escapedId = id3.replace(/~/ig, "~0").replace(/\//ig, "~1");
      const out = {
        $ref: options.getRef(escapedId)
      };
      if (!has($defs, id3)) {
        $defs[id3] = out;
        $defs[id3] = go3(ast, $defs, false, path2, options);
      }
      return out;
    }
  }
  const hook = getJSONSchemaAnnotation(ast);
  if (isSome2(hook)) {
    const handler = hook.value;
    if (isRefinement(ast)) {
      const t = getTransformationFrom(ast);
      if (t === void 0) {
        return mergeRefinements(go3(ast.from, $defs, handleIdentifier, path2, options), handler, getJsonSchemaAnnotations(ast));
      } else if (!isOverrideAnnotation(handler)) {
        return go3(t, $defs, handleIdentifier, path2, options);
      }
    }
    if (isDeclaration(ast)) {
      return {
        ...handler,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    return handler;
  }
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    return go3(surrogate.value, $defs, handleIdentifier, path2, options);
  }
  switch (ast._tag) {
    case "Declaration":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path2, ast));
    case "Literal": {
      const literal3 = ast.literal;
      if (literal3 === null) {
        if (isNullTypeKeywordSupported(options)) {
          return {
            type: "null",
            ...getJsonSchemaAnnotations(ast)
          };
        } else {
          return {
            // @ts-expect-error
            enum: [null],
            ...getJsonSchemaAnnotations(ast)
          };
        }
      } else if (isString(literal3)) {
        return {
          type: "string",
          enum: [literal3],
          ...getJsonSchemaAnnotations(ast)
        };
      } else if (isNumber(literal3)) {
        return {
          type: "number",
          enum: [literal3],
          ...getJsonSchemaAnnotations(ast)
        };
      } else if (isBoolean(literal3)) {
        return {
          type: "boolean",
          enum: [literal3],
          ...getJsonSchemaAnnotations(ast)
        };
      }
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path2, ast));
    }
    case "UniqueSymbol":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path2, ast));
    case "UndefinedKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path2, ast));
    case "VoidKeyword":
      return {
        ...constVoid2,
        ...getJsonSchemaAnnotations(ast)
      };
    case "NeverKeyword":
      return {
        ...constNever,
        ...getJsonSchemaAnnotations(ast)
      };
    case "UnknownKeyword":
      return {
        ...constUnknown,
        ...getJsonSchemaAnnotations(ast)
      };
    case "AnyKeyword":
      return {
        ...constAny,
        ...getJsonSchemaAnnotations(ast)
      };
    case "ObjectKeyword":
      return {
        ...constAnyObject,
        ...getJsonSchemaAnnotations(ast)
      };
    case "StringKeyword":
      return {
        type: "string",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "NumberKeyword":
      return {
        type: "number",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "BooleanKeyword":
      return {
        type: "boolean",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "BigIntKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path2, ast));
    case "SymbolKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path2, ast));
    case "TupleType": {
      const elements = ast.elements.map((e, i) => ({
        ...go3(e.type, $defs, true, path2.concat(i), options),
        ...getJsonSchemaAnnotations(e.type, e)
      }));
      const rest = ast.rest.map((annotatedAST) => ({
        ...go3(annotatedAST.type, $defs, true, path2, options),
        ...getJsonSchemaAnnotations(annotatedAST.type, annotatedAST)
      }));
      const output = {
        type: "array"
      };
      const len = ast.elements.length;
      if (len > 0) {
        output.minItems = len - ast.elements.filter((element2) => element2.isOptional).length;
        output.items = elements;
      }
      const restLength = rest.length;
      if (restLength > 0) {
        const head13 = rest[0];
        const isHomogeneous = restLength === 1 && ast.elements.every((e) => e.type === ast.rest[0].type);
        if (isHomogeneous) {
          output.items = head13;
        } else {
          output.additionalItems = head13;
        }
        if (restLength > 1) {
          throw new Error(getJSONSchemaUnsupportedPostRestElementsErrorMessage(path2));
        }
      } else {
        if (len > 0) {
          output.additionalItems = false;
        } else {
          output.maxItems = 0;
        }
      }
      return {
        ...output,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return {
          ...constEmpty2,
          ...getJsonSchemaAnnotations(ast)
        };
      }
      const output = {
        type: "object",
        required: [],
        properties: {},
        additionalProperties: getAdditionalProperties(options)
      };
      let patternProperties = void 0;
      let propertyNames = void 0;
      for (const is4 of ast.indexSignatures) {
        const pruned = pruneUndefined2(is4.type) ?? is4.type;
        const parameter = is4.parameter;
        switch (parameter._tag) {
          case "StringKeyword": {
            output.additionalProperties = go3(pruned, $defs, true, path2, options);
            break;
          }
          case "TemplateLiteral": {
            patternProperties = go3(pruned, $defs, true, path2, options);
            propertyNames = {
              type: "string",
              pattern: getTemplateLiteralRegExp(parameter).source
            };
            break;
          }
          case "Refinement": {
            patternProperties = go3(pruned, $defs, true, path2, options);
            propertyNames = go3(parameter, $defs, true, path2, options);
            break;
          }
          case "SymbolKeyword": {
            const indexSignaturePath = path2.concat("[symbol]");
            output.additionalProperties = go3(pruned, $defs, true, indexSignaturePath, options);
            propertyNames = go3(parameter, $defs, true, indexSignaturePath, options);
            break;
          }
        }
      }
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const ps = ast.propertySignatures[i];
        const name = ps.name;
        if (isString(name)) {
          const pruned = pruneUndefined2(ps.type);
          const type8 = pruned ?? ps.type;
          output.properties[name] = {
            ...go3(type8, $defs, true, path2.concat(ps.name), options),
            ...getJsonSchemaAnnotations(type8, ps)
          };
          if (!ps.isOptional && pruned === void 0) {
            output.required.push(name);
          }
        } else {
          throw new Error(getJSONSchemaUnsupportedKeyErrorMessage(name, path2));
        }
      }
      if (patternProperties !== void 0) {
        delete output.additionalProperties;
        output.patternProperties = {
          "": patternProperties
        };
      }
      if (propertyNames !== void 0) {
        output.propertyNames = propertyNames;
      }
      return {
        ...output,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Union": {
      const members = [];
      for (const type8 of ast.types) {
        const jsonSchema = go3(type8, $defs, true, path2, options);
        if (!isNeverJSONSchema(jsonSchema)) {
          const last8 = members[members.length - 1];
          if (isMergeableEnum(jsonSchema) && last8 !== void 0 && isMergeableEnum(last8)) {
            members[members.length - 1] = {
              enum: last8.enum.concat(jsonSchema.enum)
            };
          } else {
            members.push(jsonSchema);
          }
        }
      }
      const anyOf = shrink(members);
      const finalize = (anyOf2) => {
        switch (anyOf2.length) {
          case 0:
            return {
              ...constNever,
              ...getJsonSchemaAnnotations(ast)
            };
          case 1: {
            return {
              ...addEnumType(anyOf2[0]),
              ...getJsonSchemaAnnotations(ast)
            };
          }
          default:
            return {
              anyOf: anyOf2.map(addEnumType),
              ...getJsonSchemaAnnotations(ast)
            };
        }
      };
      if (isNullableKeywordSupported(options)) {
        let nullable = false;
        const nonNullables = [];
        for (const s of anyOf) {
          if ("nullable" in s) {
            nullable = true;
            const nn = {
              ...s
            };
            delete nn.nullable;
            nonNullables.push(nn);
          } else if (isMergeableEnum(s)) {
            const nnes = s.enum.filter((e) => e !== null);
            if (nnes.length < s.enum.length) {
              nullable = true;
              if (nnes.length === 0) {
                continue;
              }
              const nn = {
                ...s
              };
              nn.enum = nnes;
              nonNullables.push(nn);
            }
          } else {
            nonNullables.push(s);
          }
        }
        if (nullable) {
          const out = finalize(nonNullables);
          if (!isAnyJSONSchema(out) && !isUnknownJSONSchema(out)) {
            out.nullable = nullable;
          }
          return out;
        }
      }
      return finalize(anyOf);
    }
    case "Enums": {
      const anyOf = ast.enums.map((e) => addEnumType({
        title: e[0],
        enum: [e[1]]
      }));
      return anyOf.length >= 1 ? {
        $comment: "/schemas/enums",
        anyOf,
        ...getJsonSchemaAnnotations(ast)
      } : {
        ...constNever,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Refinement": {
      if (getTransformationFrom(ast) === void 0) {
        throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path2, ast));
      }
      return go3(ast.from, $defs, handleIdentifier, path2, options);
    }
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return {
        type: "string",
        title: String(ast),
        description: "a template literal",
        pattern: regex.source,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Suspend": {
      const identifier2 = orElse2(getJSONIdentifier(ast), () => getJSONIdentifier(ast.f()));
      if (isNone2(identifier2)) {
        throw new Error(getJSONSchemaMissingIdentifierAnnotationErrorMessage(path2, ast));
      }
      return go3(ast.f(), $defs, handleIdentifier, path2, options);
    }
    case "Transformation": {
      if (isParseJsonTransformation(ast.from)) {
        const out = {
          "type": "string",
          "contentMediaType": "application/json"
        };
        if (isContentSchemaSupported(options)) {
          out["contentSchema"] = go3(ast.to, $defs, handleIdentifier, path2, options);
        }
        return out;
      }
      let next6 = ast.from;
      if (isTypeLiteralTransformation(ast.transformation)) {
        const identifier2 = getIdentifierAnnotation(ast);
        if (isSome2(identifier2) && isNone2(getIdentifierAnnotation(next6))) {
          next6 = annotations(next6, {
            [IdentifierAnnotationId]: identifier2.value
          });
        }
        const title = getTitleAnnotation(ast);
        if (isSome2(title) && isNone2(getTitleAnnotation(next6))) {
          next6 = annotations(next6, {
            [TitleAnnotationId]: title.value
          });
        }
        const description = getDescriptionAnnotation(ast);
        if (isSome2(description) && isNone2(getDescriptionAnnotation(next6))) {
          next6 = annotations(next6, {
            [DescriptionAnnotationId]: description.value
          });
        }
      }
      return go3(next6, $defs, handleIdentifier, path2, options);
    }
  }
};

// node_modules/effect/dist/esm/KeyedPool.js
var KeyedPool_exports = {};
__export(KeyedPool_exports, {
  KeyedPoolTypeId: () => KeyedPoolTypeId2,
  get: () => get22,
  invalidate: () => invalidate3,
  make: () => make87,
  makeWith: () => makeWith6,
  makeWithTTL: () => makeWithTTL3,
  makeWithTTLBy: () => makeWithTTLBy2
});

// node_modules/effect/dist/esm/internal/pool.js
var PoolTypeId = Symbol.for("effect/Pool");
var poolVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var isPool = (u) => hasProperty(u, PoolTypeId);
var makeWith4 = (options) => uninterruptibleMask((restore) => flatMap12(context2(), (context15) => {
  const scope6 = get4(context15, scopeTag);
  const acquire4 = mapInputContext(options.acquire, (input) => merge3(context15, input));
  const pool = new PoolImpl(scope6, acquire4, options.concurrency ?? 1, options.min, options.max, options.strategy, Math.min(Math.max(options.targetUtilization ?? 1, 0.1), 1));
  const initialize = tap2(forkDaemon2(restore(pool.resize)), (fiber) => scope6.addFinalizer(() => interruptFiber(fiber)));
  const runStrategy = tap2(forkDaemon2(restore(options.strategy.run(pool))), (fiber) => scope6.addFinalizer(() => interruptFiber(fiber)));
  return succeed(pool).pipe(zipLeft2(scope6.addFinalizer(() => pool.shutdown)), zipLeft2(initialize), zipLeft2(runStrategy));
}));
var make85 = (options) => makeWith4({
  ...options,
  min: options.size,
  max: options.size,
  strategy: strategyNoop()
});
var makeWithTTL = (options) => flatMap12(options.timeToLiveStrategy === "creation" ? strategyCreationTTL(options.timeToLive) : strategyUsageTTL(options.timeToLive), (strategy) => makeWith4({
  ...options,
  strategy
}));
var get20 = (self) => self.get;
var invalidate = dual(2, (self, item) => self.invalidate(item));
var _a75, _b26;
var PoolImpl = class extends (_b26 = Class3, _a75 = PoolTypeId, _b26) {
  constructor(scope6, acquire4, concurrency, minSize, maxSize, strategy, targetUtilization) {
    super();
    __publicField(this, "scope");
    __publicField(this, "acquire");
    __publicField(this, "concurrency");
    __publicField(this, "minSize");
    __publicField(this, "maxSize");
    __publicField(this, "strategy");
    __publicField(this, "targetUtilization");
    __publicField(this, _a75);
    __publicField(this, "isShuttingDown", false);
    __publicField(this, "semaphore");
    __publicField(this, "items", /* @__PURE__ */ new Set());
    __publicField(this, "available", /* @__PURE__ */ new Set());
    __publicField(this, "availableLatch", unsafeMakeLatch(false));
    __publicField(this, "invalidated", /* @__PURE__ */ new Set());
    __publicField(this, "waiters", 0);
    __publicField(this, "allocate", acquireUseRelease(scopeMake2(), (scope6) => this.acquire.pipe(scopeExtend(scope6), exit, flatMap12((exit4) => {
      const item = {
        exit: exit4,
        finalizer: catchAllCause(scope6.close(exit4), reportUnhandledError),
        refCount: 0,
        disableReclaim: false
      };
      this.items.add(item);
      this.available.add(item);
      return as3(exit4._tag === "Success" ? this.strategy.onAcquire(item) : zipRight2(item.finalizer, this.strategy.onAcquire(item)), item);
    })), (scope6, exit4) => exit4._tag === "Failure" ? scope6.close(exit4) : void_3));
    __publicField(this, "resizeLoop", suspend(() => {
      if (this.activeSize >= this.targetSize) {
        return void_3;
      }
      const toAcquire = this.targetSize - this.activeSize;
      return this.strategy.reclaim(this).pipe(flatMap12(match2({
        onNone: () => this.allocate,
        onSome: succeed
      })), replicateEffect2(toAcquire, {
        concurrency: toAcquire
      }), zipLeft2(this.availableLatch.open), flatMap12((items) => items.some((_) => _.exit._tag === "Failure") ? void_3 : this.resizeLoop));
    }));
    __publicField(this, "resizeSemaphore", unsafeMakeSemaphore(1));
    __publicField(this, "resize", this.resizeSemaphore.withPermits(1)(this.resizeLoop));
    __publicField(this, "getPoolItem", uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight2(scopeTag), flatMap12((scope6) => suspend(() => {
      this.waiters++;
      if (this.isShuttingDown) {
        return interrupt2;
      } else if (this.targetSize > this.activeSize) {
        const self = this;
        return flatMap12(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn2(interruptible2(this.resize), this.scope)), function loop5() {
          if (self.isShuttingDown) {
            return interrupt2;
          } else if (self.available.size > 0) {
            return succeed(unsafeHead(self.available));
          }
          self.availableLatch.unsafeClose();
          return flatMap12(self.availableLatch.await, loop5);
        });
      }
      return succeed(unsafeHead(this.available));
    }).pipe(ensuring2(sync(() => this.waiters--)), tap2((item) => {
      if (item.exit._tag === "Failure") {
        this.items.delete(item);
        this.invalidated.delete(item);
        this.available.delete(item);
        return this.semaphore.release(1);
      }
      item.refCount++;
      this.available.delete(item);
      if (item.refCount < this.concurrency) {
        this.available.add(item);
      }
      return scope6.addFinalizer(() => zipRight2(suspend(() => {
        item.refCount--;
        if (this.invalidated.has(item)) {
          return this.invalidatePoolItem(item);
        }
        this.available.add(item);
        return exitVoid;
      }), this.semaphore.release(1)));
    }), onInterrupt(() => this.semaphore.release(1)))))));
    __publicField(this, "get", flatMap12(suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_) => _.exit));
    this.scope = scope6;
    this.acquire = acquire4;
    this.concurrency = concurrency;
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.strategy = strategy;
    this.targetUtilization = targetUtilization;
    this[PoolTypeId] = poolVariance;
    this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
  }
  get currentUsage() {
    let count9 = this.waiters;
    for (const item of this.items) {
      count9 += item.refCount;
    }
    return count9;
  }
  get targetSize() {
    if (this.isShuttingDown) return 0;
    const utilization = this.currentUsage / this.targetUtilization;
    const target = Math.ceil(utilization / this.concurrency);
    return Math.min(Math.max(this.minSize, target), this.maxSize);
  }
  get activeSize() {
    return this.items.size - this.invalidated.size;
  }
  commit() {
    return this.get;
  }
  invalidate(item) {
    return suspend(() => {
      if (this.isShuttingDown) return void_3;
      for (const poolItem of this.items) {
        if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
          poolItem.disableReclaim = true;
          return uninterruptible(this.invalidatePoolItem(poolItem));
        }
      }
      return void_3;
    });
  }
  invalidatePoolItem(poolItem) {
    return suspend(() => {
      if (!this.items.has(poolItem)) {
        return void_3;
      } else if (poolItem.refCount === 0) {
        this.items.delete(poolItem);
        this.available.delete(poolItem);
        this.invalidated.delete(poolItem);
        return zipRight2(poolItem.finalizer, forkIn2(interruptible2(this.resize), this.scope));
      }
      this.invalidated.add(poolItem);
      this.available.delete(poolItem);
      return void_3;
    });
  }
  get shutdown() {
    return suspend(() => {
      if (this.isShuttingDown) return void_3;
      this.isShuttingDown = true;
      const size45 = this.items.size;
      const semaphore = unsafeMakeSemaphore(size45);
      return forEachSequentialDiscard(this.items, (item) => {
        if (item.refCount > 0) {
          item.finalizer = zipLeft2(item.finalizer, semaphore.release(1));
          this.invalidated.add(item);
          return semaphore.take(1);
        }
        this.items.delete(item);
        this.available.delete(item);
        this.invalidated.delete(item);
        return item.finalizer;
      }).pipe(zipRight2(this.semaphore.releaseAll), zipRight2(this.availableLatch.open), zipRight2(semaphore.take(size45)));
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var strategyNoop = () => ({
  run: (_) => void_3,
  onAcquire: (_) => void_3,
  reclaim: (_) => succeedNone
});
var strategyCreationTTL = (ttl) => clockWith((clock3) => map14(unbounded2(), (queue) => {
  const ttlMillis = toMillis(ttl);
  const creationTimes = /* @__PURE__ */ new WeakMap();
  return identity({
    run: (pool) => {
      const process2 = (item) => suspend(() => {
        if (!pool.items.has(item) || pool.invalidated.has(item)) {
          return void_3;
        }
        const now3 = clock3.unsafeCurrentTimeMillis();
        const created = creationTimes.get(item);
        const remaining = ttlMillis - (now3 - created);
        return remaining > 0 ? delay(process2(item), remaining) : pool.invalidatePoolItem(item);
      });
      return queue.take.pipe(tap2(process2), forever);
    },
    onAcquire: (item) => suspend(() => {
      creationTimes.set(item, clock3.unsafeCurrentTimeMillis());
      return queue.offer(item);
    }),
    reclaim: (_) => succeedNone
  });
}));
var strategyUsageTTL = (ttl) => map14(unbounded2(), (queue) => {
  return identity({
    run: (pool) => {
      const process2 = suspend(() => {
        const excess = pool.activeSize - pool.targetSize;
        if (excess <= 0) return void_3;
        return queue.take.pipe(tap2((item) => pool.invalidatePoolItem(item)), zipRight2(process2));
      });
      return process2.pipe(delay(ttl), forever);
    },
    onAcquire: (item) => queue.offer(item),
    reclaim(pool) {
      return suspend(() => {
        if (pool.invalidated.size === 0) {
          return succeedNone;
        }
        const item = head(filter2(pool.invalidated, (item2) => !item2.disableReclaim));
        if (item._tag === "None") {
          return succeedNone;
        }
        pool.invalidated.delete(item.value);
        if (item.value.refCount < pool.concurrency) {
          pool.available.add(item.value);
        }
        return as3(queue.offer(item.value), item);
      });
    }
  });
});
var reportUnhandledError = (cause3) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause3, unhandledLogLevel);
  }
  return void_3;
});

// node_modules/effect/dist/esm/internal/keyedPool.js
var KeyedPoolSymbolKey = "effect/KeyedPool";
var KeyedPoolTypeId = Symbol.for(KeyedPoolSymbolKey);
var KeyedPoolMapValueSymbol = Symbol.for("effect/KeyedPool/MapValue");
var keyedPoolVariance = {
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var _a76;
_a76 = KeyedPoolTypeId;
var KeyedPoolImpl = class {
  constructor(getOrCreatePool, activePools) {
    __publicField(this, "getOrCreatePool");
    __publicField(this, "activePools");
    __publicField(this, _a76, keyedPoolVariance);
    this.getOrCreatePool = getOrCreatePool;
    this.activePools = activePools;
  }
  get(key) {
    return flatMap12(this.getOrCreatePool(key), get20);
  }
  invalidate(item) {
    return flatMap12(this.activePools, forEachSequentialDiscard((pool) => pool.invalidate(item)));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a77;
var Complete = class {
  constructor(pool) {
    __publicField(this, "pool");
    __publicField(this, "_tag", "Complete");
    __publicField(this, _a77, KeyedPoolMapValueSymbol);
    this.pool = pool;
  }
  [(_a77 = KeyedPoolMapValueSymbol, symbol2)]() {
    return pipe(string2("effect/KeyedPool/Complete"), combine2(hash(this.pool)), cached(this));
  }
  [symbol3](u) {
    return isComplete(u) && equals(this.pool, u.pool);
  }
};
var isComplete = (u) => isTagged(u, "Complete") && KeyedPoolMapValueSymbol in u;
var _a78;
var Pending = class {
  constructor(deferred) {
    __publicField(this, "deferred");
    __publicField(this, "_tag", "Pending");
    __publicField(this, _a78, KeyedPoolMapValueSymbol);
    this.deferred = deferred;
  }
  [(_a78 = KeyedPoolMapValueSymbol, symbol2)]() {
    return pipe(string2("effect/KeyedPool/Pending"), combine2(hash(this.deferred)), cached(this));
  }
  [symbol3](u) {
    return isPending(u) && equals(this.deferred, u.deferred);
  }
};
var isPending = (u) => isTagged(u, "Pending") && KeyedPoolMapValueSymbol in u;
var makeImpl4 = (get48, min11, max14, timeToLive) => pipe(all9([context2(), fiberId, sync(() => make15(empty11())), scopeMake2()]), map14(([context15, fiberId5, map49, scope6]) => {
  const getOrCreatePool = (key) => suspend(() => {
    let value10 = getOrUndefined2(get8(get7(map49), key));
    if (value10 === void 0) {
      return uninterruptibleMask((restore) => {
        const deferred = deferredUnsafeMake(fiberId5);
        value10 = new Pending(deferred);
        let previous2 = void 0;
        if (has5(get7(map49), key)) {
          previous2 = getOrUndefined2(get8(get7(map49), key));
        } else {
          update(map49, set4(key, value10));
        }
        if (previous2 === void 0) {
          return pipe(restore(scopeExtend(makeWithTTL({
            acquire: provideContext(get48(key), context15),
            min: min11(key),
            max: max14(key),
            timeToLive: getOrElse2(timeToLive(key), () => infinity)
          }), scope6)), matchCauseEffect({
            onFailure: (cause3) => {
              const current2 = getOrUndefined2(get8(get7(map49), key));
              if (equals(current2, value10)) {
                update(map49, remove7(key));
              }
              return zipRight2(deferredFailCause(deferred, cause3), failCause(cause3));
            },
            onSuccess: (pool) => {
              update(map49, set4(key, new Complete(pool)));
              return as3(deferredSucceed(deferred, pool), pool);
            }
          }));
        }
        switch (previous2._tag) {
          case "Complete": {
            return succeed(previous2.pool);
          }
          case "Pending": {
            return restore(deferredAwait(previous2.deferred));
          }
        }
      });
    }
    switch (value10._tag) {
      case "Complete": {
        return succeed(value10.pool);
      }
      case "Pending": {
        return deferredAwait(value10.deferred);
      }
    }
  });
  const activePools = suspend(() => forEachSequential(toValues2(get7(map49)), (value10) => {
    switch (value10._tag) {
      case "Complete": {
        return succeed(value10.pool);
      }
      case "Pending": {
        return deferredAwait(value10.deferred);
      }
    }
  }));
  return new KeyedPoolImpl(getOrCreatePool, activePools);
}));
var make86 = (options) => makeImpl4(options.acquire, () => options.size, () => options.size, () => none2());
var makeWith5 = (options) => makeImpl4(options.acquire, options.size, options.size, () => none2());
var makeWithTTL2 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeImpl4(options.acquire, options.min, options.max, () => some3(timeToLive));
};
var makeWithTTLBy = (options) => makeImpl4(options.acquire, options.min, options.max, (key) => some3(decode(options.timeToLive(key))));
var get21 = dual(2, (self, key) => self.get(key));
var invalidate2 = dual(2, (self, item) => self.invalidate(item));

// node_modules/effect/dist/esm/KeyedPool.js
var KeyedPoolTypeId2 = KeyedPoolTypeId;
var make87 = make86;
var makeWith6 = makeWith5;
var makeWithTTL3 = makeWithTTL2;
var makeWithTTLBy2 = makeWithTTLBy;
var get22 = get21;
var invalidate3 = invalidate2;

// node_modules/effect/dist/esm/LayerMap.js
var LayerMap_exports = {};
__export(LayerMap_exports, {
  Service: () => Service2,
  TypeId: () => TypeId33,
  fromRecord: () => fromRecord3,
  make: () => make90
});

// node_modules/effect/dist/esm/RcMap.js
var RcMap_exports = {};
__export(RcMap_exports, {
  TypeId: () => TypeId32,
  get: () => get24,
  invalidate: () => invalidate5,
  keys: () => keys8,
  make: () => make89,
  touch: () => touch2
});

// node_modules/effect/dist/esm/internal/rcMap.js
var TypeId31 = Symbol.for("effect/RcMap");
var variance10 = {
  _K: identity,
  _A: identity,
  _E: identity
};
var _a79;
_a79 = TypeId31;
var RcMapImpl = class {
  constructor(lookup, context15, scope6, idleTimeToLive, capacity10) {
    __publicField(this, "lookup");
    __publicField(this, "context");
    __publicField(this, "scope");
    __publicField(this, "idleTimeToLive");
    __publicField(this, "capacity");
    __publicField(this, _a79);
    __publicField(this, "state", {
      _tag: "Open",
      map: empty23()
    });
    __publicField(this, "semaphore", unsafeMakeSemaphore(1));
    this.lookup = lookup;
    this.context = context15;
    this.scope = scope6;
    this.idleTimeToLive = idleTimeToLive;
    this.capacity = capacity10;
    this[TypeId31] = variance10;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make88 = (options) => withFiberRuntime((fiber) => {
  const context15 = fiber.getFiberRef(currentContext);
  const scope6 = get4(context15, scopeTag);
  const self = new RcMapImpl(options.lookup, context15, scope6, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0, Math.max(options.capacity ?? Number.POSITIVE_INFINITY, 0));
  return as3(scope6.addFinalizer(() => suspend(() => {
    if (self.state._tag === "Closed") {
      return void_3;
    }
    const map49 = self.state.map;
    self.state = {
      _tag: "Closed"
    };
    return forEachSequentialDiscard(map49, ([, entry]) => scopeClose(entry.scope, exitVoid)).pipe(tap2(() => {
      clear(map49);
    }), self.semaphore.withPermits(1));
  })), self);
});
var get23 = dual(2, (self_, key) => {
  const self = self_;
  return uninterruptibleMask((restore) => getImpl(self, key, restore));
});
var getImpl = fnUntraced(function* (self, key, restore) {
  if (self.state._tag === "Closed") {
    return yield* interrupt2;
  }
  const state = self.state;
  const o = get9(state.map, key);
  let entry;
  if (o._tag === "Some") {
    entry = o.value;
    entry.refCount++;
  } else if (Number.isFinite(self.capacity) && size13(self.state.map) >= self.capacity) {
    return yield* fail2(new ExceededCapacityException(`RcMap attempted to exceed capacity of ${self.capacity}`));
  } else {
    entry = yield* self.semaphore.withPermits(1)(acquire(self, key, restore));
  }
  const scope6 = yield* scopeTag;
  yield* scope6.addFinalizer(() => entry.finalizer);
  return yield* restore(deferredAwait(entry.deferred));
});
var acquire = fnUntraced(function* (self, key, restore) {
  const scope6 = yield* scopeMake2();
  const deferred = yield* deferredMake();
  const acquire4 = self.lookup(key);
  const contextMap = new Map(self.context.unsafeMap);
  yield* restore(mapInputContext(acquire4, (inputContext) => {
    inputContext.unsafeMap.forEach((value10, key2) => {
      contextMap.set(key2, value10);
    });
    contextMap.set(scopeTag.key, scope6);
    return unsafeMake(contextMap);
  })).pipe(exit, flatMap12((exit4) => deferredDone(deferred, exit4)), forkIn2(scope6));
  const entry = {
    deferred,
    scope: scope6,
    finalizer: void 0,
    fiber: void 0,
    expiresAt: 0,
    refCount: 1
  };
  entry.finalizer = release(self, key, entry);
  if (self.state._tag === "Open") {
    set5(self.state.map, key, entry);
  }
  return entry;
});
var release = (self, key, entry) => clockWith3((clock3) => {
  entry.refCount--;
  if (entry.refCount > 0) {
    return void_3;
  } else if (self.state._tag === "Closed" || !has6(self.state.map, key) || self.idleTimeToLive === void 0) {
    if (self.state._tag === "Open") {
      remove8(self.state.map, key);
    }
    return scopeClose(entry.scope, exitVoid);
  }
  if (!isFinite(self.idleTimeToLive)) {
    return void_3;
  }
  entry.expiresAt = clock3.unsafeCurrentTimeMillis() + toMillis(self.idleTimeToLive);
  if (entry.fiber) return void_3;
  return interruptibleMask(function loop5(restore) {
    const now3 = clock3.unsafeCurrentTimeMillis();
    const remaining = entry.expiresAt - now3;
    if (remaining <= 0) {
      if (self.state._tag === "Closed" || entry.refCount > 0) return void_3;
      remove8(self.state.map, key);
      return restore(scopeClose(entry.scope, exitVoid));
    }
    return flatMap12(clock3.sleep(millis(remaining)), () => loop5(restore));
  }).pipe(ensuring2(sync(() => {
    entry.fiber = void 0;
  })), forkIn2(self.scope), tap2((fiber) => {
    entry.fiber = fiber;
  }), self.semaphore.withPermits(1));
});
var keys7 = (self) => {
  const impl = self;
  return suspend(() => impl.state._tag === "Closed" ? interrupt2 : succeed(keys4(impl.state.map)));
};
var invalidate4 = dual(2, fnUntraced(function* (self_, key) {
  const self = self_;
  if (self.state._tag === "Closed") return;
  const o = get9(self.state.map, key);
  if (o._tag === "None") return;
  const entry = o.value;
  remove8(self.state.map, key);
  if (entry.refCount > 0) return;
  yield* scopeClose(entry.scope, exitVoid);
  if (entry.fiber) yield* interruptFiber(entry.fiber);
}));
var touch = dual(2, (self_, key) => clockWith3((clock3) => {
  const self = self_;
  if (!self.idleTimeToLive || self.state._tag === "Closed") return void_3;
  const o = get9(self.state.map, key);
  if (o._tag === "None") return void_3;
  o.value.expiresAt = clock3.unsafeCurrentTimeMillis() + toMillis(self.idleTimeToLive);
  return void_3;
}));

// node_modules/effect/dist/esm/RcMap.js
var TypeId32 = TypeId31;
var make89 = make88;
var get24 = get23;
var keys8 = keys7;
var invalidate5 = invalidate4;
var touch2 = touch;

// node_modules/effect/dist/esm/LayerMap.js
var TypeId33 = Symbol.for("effect/LayerMap");
var make90 = fnUntraced2(function* (lookup, options) {
  const context15 = yield* context5();
  const memoMap = context15.unsafeMap.has(CurrentMemoMap2.key) ? get4(context15, CurrentMemoMap2) : yield* makeMemoMap2;
  const rcMap = yield* make89({
    lookup: (key) => scopeWith2((scope6) => diffFiberRefs2(buildWithMemoMap2(lookup(key), memoMap, scope6))).pipe(map26(([patch14, context16]) => ({
      layer: scopedContext2(withFiberRuntime((fiber) => {
        const scope6 = unsafeGet3(fiber.currentContext, Scope);
        const oldRefs = fiber.getFiberRefs();
        const newRefs = patch10(patch14, fiber.id(), oldRefs);
        const revert2 = diff9(newRefs, oldRefs);
        fiber.setFiberRefs(newRefs);
        return as8(addFinalizerExit(scope6, () => {
          fiber.setFiberRefs(patch10(revert2, fiber.id(), fiber.getFiberRefs()));
          return _void;
        }), context16);
      })),
      runtimeEffect: withFiberRuntime2((fiber) => {
        const fiberRefs4 = patch10(patch14, fiber.id(), fiber.getFiberRefs());
        return succeed13(make66({
          context: context16,
          fiberRefs: fiberRefs4,
          runtimeFlags: defaultRuntime2.runtimeFlags
        }));
      })
    }))),
    idleTimeToLive: options == null ? void 0 : options.idleTimeToLive
  });
  return identity({
    [TypeId33]: TypeId33,
    rcMap,
    get: (key) => unwrapScoped2(map26(get24(rcMap, key), ({
      layer
    }) => layer)),
    runtime: (key) => flatMap18(get24(rcMap, key), ({
      runtimeEffect
    }) => runtimeEffect),
    invalidate: (key) => invalidate5(rcMap, key)
  });
});
var fromRecord3 = (layers, options) => make90((key) => layers[key], options);
var Service2 = () => (id3, options) => {
  const Err = globalThis.Error;
  const limit2 = Err.stackTraceLimit;
  Err.stackTraceLimit = 2;
  const creationError = new Err();
  Err.stackTraceLimit = limit2;
  function TagClass() {
  }
  const TagClass_ = TagClass;
  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(GenericTag(id3)));
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  TagClass_.DefaultWithoutDependencies = scoped5(TagClass_, "lookup" in options ? make90(options.lookup, options) : fromRecord3(options.layers, options));
  TagClass_.Default = options.dependencies && options.dependencies.length > 0 ? provide3(TagClass_.DefaultWithoutDependencies, options.dependencies) : TagClass_.DefaultWithoutDependencies;
  TagClass_.get = (key) => unwrapScoped2(map26(TagClass_, (layerMap) => layerMap.get(key)));
  TagClass_.runtime = (key) => flatMap18(TagClass_, (layerMap) => layerMap.runtime(key));
  TagClass_.invalidate = (key) => flatMap18(TagClass_, (layerMap) => layerMap.invalidate(key));
  return TagClass;
};

// node_modules/effect/dist/esm/Logger.js
var Logger_exports = {};
__export(Logger_exports, {
  LoggerTypeId: () => LoggerTypeId2,
  add: () => add10,
  addEffect: () => addEffect,
  addScoped: () => addScoped,
  batched: () => batched,
  defaultLogger: () => defaultLogger2,
  filterLogLevel: () => filterLogLevel2,
  isLogger: () => isLogger2,
  json: () => json2,
  jsonLogger: () => jsonLogger3,
  logFmt: () => logFmt,
  logfmtLogger: () => logfmtLogger2,
  make: () => make91,
  map: () => map38,
  mapInput: () => mapInput11,
  mapInputOptions: () => mapInputOptions2,
  minimumLogLevel: () => minimumLogLevel2,
  none: () => none11,
  pretty: () => pretty5,
  prettyLogger: () => prettyLogger3,
  prettyLoggerDefault: () => prettyLoggerDefault2,
  remove: () => remove12,
  replace: () => replace6,
  replaceEffect: () => replaceEffect,
  replaceScoped: () => replaceScoped,
  simple: () => simple2,
  stringLogger: () => stringLogger2,
  structured: () => structured,
  structuredLogger: () => structuredLogger3,
  succeed: () => succeed25,
  sync: () => sync18,
  test: () => test2,
  tracerLogger: () => tracerLogger2,
  withConsoleError: () => withConsoleError,
  withConsoleLog: () => withConsoleLog,
  withLeveledConsole: () => withLeveledConsole,
  withMinimumLogLevel: () => withMinimumLogLevel2,
  withSpanAnnotations: () => withSpanAnnotations,
  zip: () => zip20,
  zipLeft: () => zipLeft14,
  zipRight: () => zipRight14
});

// node_modules/effect/dist/esm/internal/logger-circular.js
var test = dual(2, (self, input) => self.log({
  fiberId: none3,
  logLevel: logLevelInfo,
  message: input,
  cause: empty35,
  context: empty26(),
  spans: empty12(),
  annotations: empty11(),
  date: /* @__PURE__ */ new Date()
}));

// node_modules/effect/dist/esm/Logger.js
var LoggerTypeId2 = LoggerTypeId;
var make91 = makeLogger;
var add10 = addLogger;
var addEffect = addLoggerEffect;
var addScoped = addLoggerScoped;
var mapInput11 = mapInput4;
var mapInputOptions2 = mapInputOptions;
var filterLogLevel2 = filterLogLevel;
var map38 = map19;
var batched = batchedLogger;
var withConsoleLog = loggerWithConsoleLog;
var withLeveledConsole = loggerWithLeveledLog;
var withConsoleError = loggerWithConsoleError;
var none11 = none7;
var remove12 = removeLogger;
var replace6 = replaceLogger;
var replaceEffect = replaceLoggerEffect;
var replaceScoped = replaceLoggerScoped;
var simple2 = simple;
var succeed25 = succeed6;
var sync18 = sync4;
var test2 = test;
var withMinimumLogLevel2 = withMinimumLogLevel;
var withSpanAnnotations = loggerWithSpanAnnotations;
var zip20 = zip8;
var zipLeft14 = zipLeft4;
var zipRight14 = zipRight4;
var defaultLogger2 = defaultLogger;
var jsonLogger3 = jsonLogger;
var logfmtLogger2 = logfmtLogger;
var stringLogger2 = stringLogger;
var prettyLogger3 = prettyLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;
var structuredLogger3 = structuredLogger;
var tracerLogger2 = tracerLogger;
var json2 = replace6(defaultLogger, jsonLogger2);
var logFmt = replace6(defaultLogger, logFmtLogger);
var pretty5 = replace6(defaultLogger, prettyLogger2);
var structured = replace6(defaultLogger, structuredLogger2);
var minimumLogLevel2 = minimumLogLevel;
var isLogger2 = isLogger;

// node_modules/effect/dist/esm/Mailbox.js
var Mailbox_exports = {};
__export(Mailbox_exports, {
  ReadonlyTypeId: () => ReadonlyTypeId2,
  TypeId: () => TypeId35,
  fromStream: () => fromStream2,
  into: () => into2,
  isMailbox: () => isMailbox,
  isReadonlyMailbox: () => isReadonlyMailbox,
  make: () => make93,
  toChannel: () => toChannel4,
  toStream: () => toStream3
});

// node_modules/effect/dist/esm/internal/mailbox.js
var TypeId34 = Symbol.for("effect/Mailbox");
var ReadonlyTypeId = Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty45 = empty7();
var exitEmpty = exitSucceed(empty45);
var exitFalse = exitSucceed(false);
var exitTrue = exitSucceed(true);
var constDone = [empty45, true];
var _a80, _b27;
var MailboxImpl = class extends Class3 {
  constructor(scheduler2, capacity10, strategy) {
    super();
    __publicField(this, "scheduler");
    __publicField(this, "capacity");
    __publicField(this, "strategy");
    __publicField(this, _b27, TypeId34);
    __publicField(this, _a80, ReadonlyTypeId);
    __publicField(this, "state", {
      _tag: "Open",
      takers: /* @__PURE__ */ new Set(),
      offers: /* @__PURE__ */ new Set(),
      awaiters: /* @__PURE__ */ new Set()
    });
    __publicField(this, "messages", []);
    __publicField(this, "messagesChunk", empty7());
    __publicField(this, "shutdown", sync(() => {
      if (this.state._tag === "Done") {
        return true;
      }
      this.messages = [];
      this.messagesChunk = empty45;
      const offers = this.state.offers;
      this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
      if (offers.size > 0) {
        for (const entry of offers) {
          if (entry._tag === "Single") {
            entry.resume(exitFalse);
          } else {
            entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
          }
        }
        offers.clear();
      }
      return true;
    }));
    __publicField(this, "end", this.done(exitVoid));
    __publicField(this, "clear", suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, empty45);
      }
      const messages = this.unsafeTakeAll();
      this.releaseCapacity();
      return succeed(messages);
    }));
    __publicField(this, "takeAll", suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      }
      const messages = this.unsafeTakeAll();
      if (messages.length === 0) {
        return zipRight2(this.awaitTake, this.takeAll);
      }
      return succeed([messages, this.releaseCapacity()]);
    }));
    __publicField(this, "take", suspend(() => this.unsafeTake() ?? zipRight2(this.awaitTake, this.take)));
    __publicField(this, "await", asyncInterrupt((resume2) => {
      if (this.state._tag === "Done") {
        return resume2(this.state.exit);
      }
      this.state.awaiters.add(resume2);
      return sync(() => {
        if (this.state._tag !== "Done") {
          this.state.awaiters.delete(resume2);
        }
      });
    }));
    __publicField(this, "size", sync(() => this.unsafeSize()));
    __publicField(this, "awaitTake", asyncInterrupt((resume2) => {
      if (this.state._tag === "Done") {
        return resume2(this.state.exit);
      }
      this.state.takers.add(resume2);
      return sync(() => {
        if (this.state._tag !== "Done") {
          this.state.takers.delete(resume2);
        }
      });
    }));
    __publicField(this, "scheduleRunning", false);
    __publicField(this, "releaseTaker", () => {
      this.scheduleRunning = false;
      if (this.state._tag === "Done") {
        return;
      } else if (this.state.takers.size === 0) {
        return;
      }
      const taker = unsafeHead(this.state.takers);
      this.state.takers.delete(taker);
      taker(exitVoid);
    });
    this.scheduler = scheduler2;
    this.capacity = capacity10;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable3(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable2(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll3(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll3(fromIterable3(messages)), takeRight2(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll3(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable2(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable2(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error4) {
    return this.done(exitFail(error4));
  }
  failCause(cause3) {
    return this.done(exitFailCause(cause3));
  }
  unsafeDone(exit4) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit4);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit4
    };
    return true;
  }
  done(exit4) {
    return sync(() => this.unsafeDone(exit4));
  }
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty45, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take3(this.messagesChunk, n);
        this.messagesChunk = drop3(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll3(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take3(this.messagesChunk, n);
        this.messagesChunk = drop3(this.messagesChunk, n);
      } else {
        return zipRight2(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException3()));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop3(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop3(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : void 0;
    } else {
      return void 0;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  unsafeSize() {
    const size45 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some3(size45);
  }
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [(_b27 = TypeId34, _a80 = ReadonlyTypeId, NodeInspectSymbol)]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0) return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (; entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0) return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll3(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty45;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of3(this.messages.pop());
    }
    return empty45;
  }
  finalize(exit4) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit4
    };
    for (const taker of openState.takers) {
      taker(exit4);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit4);
    }
    openState.awaiters.clear();
  }
};
var make92 = (capacity10) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity10 === "number" ? capacity10 : (capacity10 == null ? void 0 : capacity10.capacity) ?? Number.POSITIVE_INFINITY, typeof capacity10 === "number" ? "suspend" : (capacity10 == null ? void 0 : capacity10.strategy) ?? "suspend")));
var into = dual(2, (effect4, self) => uninterruptibleMask((restore) => matchCauseEffect(restore(effect4), {
  onFailure: (cause3) => self.failCause(cause3),
  onSuccess: (_) => self.end
})));
var toChannel3 = (self) => {
  const loop5 = flatMap20(self.takeAll, ([messages, done17]) => done17 ? messages.length === 0 ? void_8 : write(messages) : zipRight8(write(messages), loop5));
  return loop5;
};
var toStream2 = (self) => fromChannel2(toChannel3(self));
var fromStream = dual((args2) => isStream(args2[0]), (self, options) => tap2(acquireRelease2(make92(options), (mailbox) => mailbox.shutdown), (mailbox) => {
  const writer = readWithCause({
    onInput: (input) => flatMap20(mailbox.offerAll(input), () => writer),
    onFailure: (cause3) => mailbox.failCause(cause3),
    onDone: () => mailbox.end
  });
  return scopeWith((scope6) => toChannel2(self).pipe(pipeTo(writer), runIn(scope6), forkIn2(scope6)));
}));

// node_modules/effect/dist/esm/Mailbox.js
var TypeId35 = TypeId34;
var ReadonlyTypeId2 = ReadonlyTypeId;
var isMailbox = (u) => hasProperty(u, TypeId35);
var isReadonlyMailbox = (u) => hasProperty(u, ReadonlyTypeId2);
var make93 = make92;
var into2 = into;
var toChannel4 = toChannel3;
var toStream3 = toStream2;
var fromStream2 = fromStream;

// node_modules/effect/dist/esm/ManagedRuntime.js
var ManagedRuntime_exports = {};
__export(ManagedRuntime_exports, {
  TypeId: () => TypeId36,
  isManagedRuntime: () => isManagedRuntime2,
  make: () => make95
});

// node_modules/effect/dist/esm/internal/managedRuntime.js
var isManagedRuntime = (u) => hasProperty(u, TypeId19);
function provide4(managed, effect4) {
  return flatMap12(managed.runtimeEffect, (rt) => withFiberRuntime((fiber) => {
    fiber.setFiberRefs(rt.fiberRefs);
    fiber.currentRuntimeFlags = rt.runtimeFlags;
    return provideContext(effect4, rt.context);
  }));
}
var ManagedRuntimeProto = {
  ...CommitPrototype2,
  [TypeId19]: TypeId19,
  pipe() {
    return pipeArguments(this, arguments);
  },
  commit() {
    return this.runtimeEffect;
  }
};
var make94 = (layer, memoMap) => {
  memoMap = memoMap ?? unsafeMakeMemoMap();
  const scope6 = unsafeRunSyncEffect(scopeMake2());
  let buildFiber;
  const runtimeEffect = withFiberRuntime((fiber) => {
    if (!buildFiber) {
      buildFiber = unsafeForkEffect(tap2(extend3(toRuntimeWithMemoMap(layer, memoMap), scope6), (rt) => {
        self.cachedRuntime = rt;
      }), {
        scope: scope6,
        scheduler: fiber.currentScheduler
      });
    }
    return flatten8(buildFiber.await);
  });
  const self = Object.assign(Object.create(ManagedRuntimeProto), {
    memoMap,
    scope: scope6,
    runtimeEffect,
    cachedRuntime: void 0,
    runtime() {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseEffect(self.runtimeEffect) : Promise.resolve(self.cachedRuntime);
    },
    dispose() {
      return unsafeRunPromiseEffect(self.disposeEffect);
    },
    disposeEffect: suspend(() => {
      ;
      self.runtimeEffect = die2("ManagedRuntime disposed");
      self.cachedRuntime = void 0;
      return close(self.scope, exitVoid);
    }),
    runFork(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeForkEffect(provide4(self, effect4), options) : unsafeFork3(self.cachedRuntime)(effect4, options);
    },
    runSyncExit(effect4) {
      return self.cachedRuntime === void 0 ? unsafeRunSyncExitEffect(provide4(self, effect4)) : unsafeRunSyncExit(self.cachedRuntime)(effect4);
    },
    runSync(effect4) {
      return self.cachedRuntime === void 0 ? unsafeRunSyncEffect(provide4(self, effect4)) : unsafeRunSync(self.cachedRuntime)(effect4);
    },
    runPromiseExit(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseExitEffect(provide4(self, effect4), options) : unsafeRunPromiseExit(self.cachedRuntime)(effect4, options);
    },
    runCallback(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunCallback(defaultRuntime)(provide4(self, effect4), options) : unsafeRunCallback(self.cachedRuntime)(effect4, options);
    },
    runPromise(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseEffect(provide4(self, effect4), options) : unsafeRunPromise(self.cachedRuntime)(effect4, options);
    }
  });
  return self;
};

// node_modules/effect/dist/esm/ManagedRuntime.js
var TypeId36 = TypeId19;
var isManagedRuntime2 = isManagedRuntime;
var make95 = make94;

// node_modules/effect/dist/esm/Match.js
var Match_exports = {};
__export(Match_exports, {
  MatcherTypeId: () => MatcherTypeId,
  SafeRefinementId: () => SafeRefinementId,
  any: () => any2,
  bigint: () => bigint3,
  boolean: () => boolean6,
  date: () => date4,
  defined: () => defined2,
  discriminator: () => discriminator2,
  discriminatorStartsWith: () => discriminatorStartsWith2,
  discriminators: () => discriminators2,
  discriminatorsExhaustive: () => discriminatorsExhaustive2,
  either: () => either11,
  exhaustive: () => exhaustive2,
  instanceOf: () => instanceOf2,
  instanceOfUnsafe: () => instanceOfUnsafe,
  is: () => is3,
  nonEmptyString: () => nonEmptyString4,
  not: () => not4,
  null: () => _null,
  number: () => number6,
  option: () => option9,
  orElse: () => orElse20,
  orElseAbsurd: () => orElseAbsurd2,
  record: () => record3,
  string: () => string7,
  symbol: () => symbol4,
  tag: () => tag2,
  tagStartsWith: () => tagStartsWith2,
  tags: () => tags2,
  tagsExhaustive: () => tagsExhaustive2,
  type: () => type2,
  typeTags: () => typeTags2,
  undefined: () => _undefined,
  value: () => value5,
  valueTags: () => valueTags2,
  when: () => when7,
  whenAnd: () => whenAnd2,
  whenOr: () => whenOr2,
  withReturnType: () => withReturnType2
});

// node_modules/effect/dist/esm/internal/matcher.js
var TypeId37 = Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId37]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case2) {
    return makeTypeMatcher([...this.cases, _case2]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId37]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case2) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case2._tag === "When" && _case2.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case2.evaluate(this.provided)));
    } else if (_case2._tag === "Not" && _case2.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case2.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value10) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value10;
  return matcher;
}
var makeWhen = (guard, evaluate4) => ({
  _tag: "When",
  guard,
  evaluate: evaluate4
});
var makeNot = (guard, evaluate4) => ({
  _tag: "Not",
  guard,
  evaluate: evaluate4
});
var makePredicate = (pattern2) => {
  if (typeof pattern2 === "function") {
    return pattern2;
  } else if (Array.isArray(pattern2)) {
    const predicates = pattern2.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern2 !== null && typeof pattern2 === "object") {
    const keysAndPredicates = Object.entries(pattern2).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern2;
};
var makeOrPredicate = (patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
};
var makeAndPredicate = (patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
};
var type = () => makeTypeMatcher([]);
var value4 = (i) => makeValueMatcher(i, left2(i));
var valueTags = dual(2, (input, fields) => {
  const match43 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return match43(input);
});
var typeTags = () => (fields) => {
  const match43 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return (input) => match43(input);
};
var withReturnType = () => (self) => self;
var when6 = (pattern2, f2) => (self) => self.add(makeWhen(makePredicate(pattern2), f2));
var whenOr = (...args2) => (self) => {
  const onMatch = args2[args2.length - 1];
  const patterns = args2.slice(0, -1);
  return self.add(makeWhen(makeOrPredicate(patterns), onMatch));
};
var whenAnd = (...args2) => (self) => {
  const onMatch = args2[args2.length - 1];
  const patterns = args2.slice(0, -1);
  return self.add(makeWhen(makeAndPredicate(patterns), onMatch));
};
var discriminator = (field) => (...pattern2) => {
  const f2 = pattern2[pattern2.length - 1];
  const values15 = pattern2.slice(0, -1);
  const pred = values15.length === 1 ? (_) => _[field] === values15[0] : (_) => values15.includes(_[field]);
  return (self) => self.add(makeWhen(pred, f2));
};
var discriminatorStartsWith = (field) => (pattern2, f2) => {
  const pred = (_) => typeof _[field] === "string" && _[field].startsWith(pattern2);
  return (self) => self.add(makeWhen(pred, f2));
};
var discriminators = (field) => (fields) => {
  const predicate = makeWhen((arg) => arg != null && arg[field] in fields, (data) => fields[data[field]](data));
  return (self) => self.add(predicate);
};
var discriminatorsExhaustive = (field) => (fields) => {
  const addCases = discriminators(field)(fields);
  return (matcher) => exhaustive(addCases(matcher));
};
var tag = discriminator("_tag");
var tagStartsWith = discriminatorStartsWith("_tag");
var tags = discriminators("_tag");
var tagsExhaustive = discriminatorsExhaustive("_tag");
var not3 = (pattern2, f2) => (self) => self.add(makeNot(makePredicate(pattern2), f2));
var nonEmptyString3 = (u) => typeof u === "string" && u.length > 0;
var is2 = (...literals) => {
  const len = literals.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
};
var any = () => true;
var defined = (u) => u !== void 0 && u !== null;
var instanceOf = (constructor) => (u) => u instanceof constructor;
var orElse19 = (f2) => (self) => {
  const result = either10(self);
  if (isEither2(result)) {
    return result._tag === "Right" ? result.right : f2(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f2(a.left);
  };
};
var orElseAbsurd = (self) => orElse19(() => {
  throw new Error("effect/Match/orElseAbsurd: absurd");
})(self);
var either10 = (self) => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case2 = self.cases[0];
    return (input) => {
      if (_case2._tag === "When" && _case2.guard(input) === true) {
        return right2(_case2.evaluate(input));
      } else if (_case2._tag === "Not" && _case2.guard(input) === false) {
        return right2(_case2.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case2 = self.cases[i];
      if (_case2._tag === "When" && _case2.guard(input) === true) {
        return right2(_case2.evaluate(input));
      } else if (_case2._tag === "Not" && _case2.guard(input) === false) {
        return right2(_case2.evaluate(input));
      }
    }
    return left2(input);
  };
};
var option8 = (self) => {
  const toEither = either10(self);
  if (isEither2(toEither)) {
    return match(toEither, {
      onLeft: () => none2(),
      onRight: some3
    });
  }
  return (input) => match(toEither(input), {
    onLeft: () => none2(),
    onRight: some3
  });
};
var getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
var exhaustive = (self) => {
  const toEither = either10(self);
  if (isEither2(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  }
  return (u) => {
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  };
};

// node_modules/effect/dist/esm/Match.js
var MatcherTypeId = TypeId37;
var type2 = type;
var value5 = value4;
var valueTags2 = valueTags;
var typeTags2 = typeTags;
var withReturnType2 = withReturnType;
var when7 = when6;
var whenOr2 = whenOr;
var whenAnd2 = whenAnd;
var discriminator2 = discriminator;
var discriminatorStartsWith2 = discriminatorStartsWith;
var discriminators2 = discriminators;
var discriminatorsExhaustive2 = discriminatorsExhaustive;
var tag2 = tag;
var tagStartsWith2 = tagStartsWith;
var tags2 = tags;
var tagsExhaustive2 = tagsExhaustive;
var not4 = not3;
var nonEmptyString4 = nonEmptyString3;
var is3 = is2;
var string7 = isString;
var number6 = isNumber;
var any2 = any;
var defined2 = defined;
var boolean6 = isBoolean;
var _undefined = isUndefined;
var _null = isNull;
var bigint3 = isBigInt;
var symbol4 = isSymbol;
var date4 = isDate;
var record3 = isRecord;
var instanceOf2 = instanceOf;
var instanceOfUnsafe = instanceOf;
var orElse20 = orElse19;
var orElseAbsurd2 = orElseAbsurd;
var either11 = either10;
var option9 = option8;
var exhaustive2 = exhaustive;
var SafeRefinementId = Symbol.for("effect/SafeRefinement");
var Fail2 = Symbol.for("effect/Fail");

// node_modules/effect/dist/esm/MergeState.js
var MergeState_exports = {};
__export(MergeState_exports, {
  BothRunning: () => BothRunning2,
  LeftDone: () => LeftDone2,
  MergeStateTypeId: () => MergeStateTypeId2,
  RightDone: () => RightDone2,
  isBothRunning: () => isBothRunning2,
  isLeftDone: () => isLeftDone2,
  isMergeState: () => isMergeState2,
  isRightDone: () => isRightDone2,
  match: () => match35
});
var MergeStateTypeId2 = MergeStateTypeId;
var BothRunning2 = BothRunning;
var LeftDone2 = LeftDone;
var RightDone2 = RightDone;
var isMergeState2 = isMergeState;
var isBothRunning2 = isBothRunning;
var isLeftDone2 = isLeftDone;
var isRightDone2 = isRightDone;
var match35 = match26;

// node_modules/effect/dist/esm/MergeStrategy.js
var MergeStrategy_exports = {};
__export(MergeStrategy_exports, {
  BackPressure: () => BackPressure3,
  BufferSliding: () => BufferSliding2,
  MergeStrategyTypeId: () => MergeStrategyTypeId2,
  isBackPressure: () => isBackPressure2,
  isBufferSliding: () => isBufferSliding2,
  isMergeStrategy: () => isMergeStrategy2,
  match: () => match36
});
var MergeStrategyTypeId2 = MergeStrategyTypeId;
var BackPressure3 = BackPressure;
var BufferSliding2 = BufferSliding;
var isMergeStrategy2 = isMergeStrategy;
var isBackPressure2 = isBackPressure;
var isBufferSliding2 = isBufferSliding;
var match36 = match27;

// node_modules/effect/dist/esm/Metric.js
var Metric_exports = {};
__export(Metric_exports, {
  MetricTypeId: () => MetricTypeId2,
  counter: () => counter7,
  fiberActive: () => fiberActive2,
  fiberFailures: () => fiberFailures2,
  fiberLifetimes: () => fiberLifetimes2,
  fiberStarted: () => fiberStarted2,
  fiberSuccesses: () => fiberSuccesses2,
  frequency: () => frequency6,
  fromMetricKey: () => fromMetricKey2,
  gauge: () => gauge6,
  globalMetricRegistry: () => globalMetricRegistry2,
  histogram: () => histogram6,
  increment: () => increment5,
  incrementBy: () => incrementBy2,
  make: () => make96,
  map: () => map39,
  mapInput: () => mapInput12,
  mapType: () => mapType2,
  modify: () => modify13,
  set: () => set13,
  snapshot: () => snapshot2,
  succeed: () => succeed26,
  summary: () => summary6,
  summaryTimestamp: () => summaryTimestamp2,
  sync: () => sync19,
  tagged: () => tagged6,
  taggedWithLabels: () => taggedWithLabels3,
  taggedWithLabelsInput: () => taggedWithLabelsInput2,
  timer: () => timer3,
  timerWithBoundaries: () => timerWithBoundaries2,
  trackAll: () => trackAll2,
  trackDefect: () => trackDefect2,
  trackDefectWith: () => trackDefectWith2,
  trackDuration: () => trackDuration2,
  trackDurationWith: () => trackDurationWith2,
  trackError: () => trackError2,
  trackErrorWith: () => trackErrorWith2,
  trackSuccess: () => trackSuccess2,
  trackSuccessWith: () => trackSuccessWith2,
  unsafeSnapshot: () => unsafeSnapshot2,
  update: () => update9,
  value: () => value6,
  withConstantInput: () => withConstantInput2,
  withNow: () => withNow2,
  zip: () => zip21
});
var MetricTypeId2 = MetricTypeId;
var globalMetricRegistry2 = globalMetricRegistry;
var make96 = make44;
var mapInput12 = mapInput5;
var counter7 = counter6;
var frequency6 = frequency5;
var withConstantInput2 = withConstantInput;
var fromMetricKey2 = fromMetricKey;
var gauge6 = gauge5;
var histogram6 = histogram5;
var increment5 = increment4;
var incrementBy2 = incrementBy;
var map39 = map20;
var mapType2 = mapType;
var modify13 = modify9;
var set13 = set8;
var snapshot2 = snapshot;
var succeed26 = succeed7;
var sync19 = sync5;
var summary6 = summary5;
var summaryTimestamp2 = summaryTimestamp;
var tagged6 = tagged2;
var taggedWithLabelsInput2 = taggedWithLabelsInput;
var taggedWithLabels3 = taggedWithLabels2;
var timer3 = timer2;
var timerWithBoundaries2 = timerWithBoundaries;
var trackAll2 = trackAll;
var trackDefect2 = trackDefect;
var trackDefectWith2 = trackDefectWith;
var trackDuration2 = trackDuration;
var trackDurationWith2 = trackDurationWith;
var trackError2 = trackError;
var trackErrorWith2 = trackErrorWith;
var trackSuccess2 = trackSuccess;
var trackSuccessWith2 = trackSuccessWith;
var update9 = update5;
var value6 = value;
var withNow2 = withNow;
var zip21 = zip9;
var unsafeSnapshot2 = unsafeSnapshot;
var fiberStarted2 = fiberStarted;
var fiberSuccesses2 = fiberSuccesses;
var fiberFailures2 = fiberFailures;
var fiberLifetimes2 = fiberLifetimes;
var fiberActive2 = fiberActive;

// node_modules/effect/dist/esm/MetricBoundaries.js
var MetricBoundaries_exports = {};
__export(MetricBoundaries_exports, {
  MetricBoundariesTypeId: () => MetricBoundariesTypeId2,
  exponential: () => exponential4,
  fromIterable: () => fromIterable19,
  isMetricBoundaries: () => isMetricBoundaries2,
  linear: () => linear4
});
var MetricBoundariesTypeId2 = MetricBoundariesTypeId;
var isMetricBoundaries2 = isMetricBoundaries;
var fromIterable19 = fromIterable11;
var linear4 = linear;
var exponential4 = exponential;

// node_modules/effect/dist/esm/MetricHook.js
var MetricHook_exports = {};
__export(MetricHook_exports, {
  MetricHookTypeId: () => MetricHookTypeId2,
  counter: () => counter8,
  frequency: () => frequency7,
  gauge: () => gauge7,
  histogram: () => histogram7,
  make: () => make97,
  onModify: () => onModify2,
  onUpdate: () => onUpdate2,
  summary: () => summary7
});
var MetricHookTypeId2 = MetricHookTypeId;
var make97 = make41;
var counter8 = counter5;
var frequency7 = frequency4;
var gauge7 = gauge4;
var histogram7 = histogram4;
var summary7 = summary4;
var onUpdate2 = onUpdate;
var onModify2 = onModify;

// node_modules/effect/dist/esm/MetricKey.js
var MetricKey_exports = {};
__export(MetricKey_exports, {
  MetricKeyTypeId: () => MetricKeyTypeId2,
  counter: () => counter9,
  frequency: () => frequency8,
  gauge: () => gauge8,
  histogram: () => histogram8,
  isMetricKey: () => isMetricKey2,
  summary: () => summary8,
  tagged: () => tagged7,
  taggedWithLabels: () => taggedWithLabels4
});
var MetricKeyTypeId2 = MetricKeyTypeId;
var isMetricKey2 = isMetricKey;
var counter9 = counter3;
var frequency8 = frequency2;
var gauge8 = gauge2;
var histogram8 = histogram2;
var summary8 = summary2;
var tagged7 = tagged;
var taggedWithLabels4 = taggedWithLabels;

// node_modules/effect/dist/esm/MetricKeyType.js
var MetricKeyType_exports = {};
__export(MetricKeyType_exports, {
  CounterKeyTypeTypeId: () => CounterKeyTypeTypeId2,
  FrequencyKeyTypeTypeId: () => FrequencyKeyTypeTypeId2,
  GaugeKeyTypeTypeId: () => GaugeKeyTypeTypeId2,
  HistogramKeyTypeTypeId: () => HistogramKeyTypeTypeId2,
  MetricKeyTypeTypeId: () => MetricKeyTypeTypeId2,
  SummaryKeyTypeTypeId: () => SummaryKeyTypeTypeId2,
  counter: () => counter10,
  frequency: () => frequency9,
  gauge: () => gauge9,
  histogram: () => histogram9,
  isCounterKey: () => isCounterKey2,
  isFrequencyKey: () => isFrequencyKey2,
  isGaugeKey: () => isGaugeKey2,
  isHistogramKey: () => isHistogramKey2,
  isMetricKeyType: () => isMetricKeyType2,
  isSummaryKey: () => isSummaryKey2,
  summary: () => summary9
});
var MetricKeyTypeTypeId2 = MetricKeyTypeTypeId;
var CounterKeyTypeTypeId2 = CounterKeyTypeTypeId;
var FrequencyKeyTypeTypeId2 = FrequencyKeyTypeTypeId;
var GaugeKeyTypeTypeId2 = GaugeKeyTypeTypeId;
var HistogramKeyTypeTypeId2 = HistogramKeyTypeTypeId;
var SummaryKeyTypeTypeId2 = SummaryKeyTypeTypeId;
var counter10 = counter2;
var frequency9 = frequency;
var gauge9 = gauge;
var histogram9 = histogram;
var summary9 = summary;
var isMetricKeyType2 = isMetricKeyType;
var isCounterKey2 = isCounterKey;
var isFrequencyKey2 = isFrequencyKey;
var isGaugeKey2 = isGaugeKey;
var isHistogramKey2 = isHistogramKey;
var isSummaryKey2 = isSummaryKey;

// node_modules/effect/dist/esm/MetricLabel.js
var MetricLabel_exports = {};
__export(MetricLabel_exports, {
  MetricLabelTypeId: () => MetricLabelTypeId2,
  isMetricLabel: () => isMetricLabel2,
  make: () => make98
});
var MetricLabelTypeId2 = MetricLabelTypeId;
var make98 = make39;
var isMetricLabel2 = isMetricLabel;

// node_modules/effect/dist/esm/MetricPair.js
var MetricPair_exports = {};
__export(MetricPair_exports, {
  MetricPairTypeId: () => MetricPairTypeId2,
  make: () => make99,
  unsafeMake: () => unsafeMake18
});
var MetricPairTypeId2 = MetricPairTypeId;
var make99 = make42;
var unsafeMake18 = unsafeMake10;

// node_modules/effect/dist/esm/MetricPolling.js
var MetricPolling_exports = {};
__export(MetricPolling_exports, {
  MetricPollingTypeId: () => MetricPollingTypeId2,
  collectAll: () => collectAll3,
  launch: () => launch4,
  make: () => make101,
  poll: () => poll10,
  pollAndUpdate: () => pollAndUpdate2,
  retry: () => retry9,
  zip: () => zip23
});

// node_modules/effect/dist/esm/internal/metric/polling.js
var MetricPollingSymbolKey = "effect/MetricPolling";
var MetricPollingTypeId = Symbol.for(MetricPollingSymbolKey);
var make100 = (metric, poll14) => {
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    metric,
    poll: poll14
  };
};
var collectAll2 = (iterable) => {
  const metrics = Array.from(iterable);
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    metric: make44(Array.of(void 0), (inputs, extraTags) => {
      for (let i = 0; i < inputs.length; i++) {
        const pollingMetric = metrics[i];
        const input = pipe(inputs, (x) => x[i]);
        pollingMetric.metric.unsafeUpdate(input, extraTags);
      }
    }, (extraTags) => Array.from(metrics.map((pollingMetric) => pollingMetric.metric.unsafeValue(extraTags))), (inputs, extraTags) => {
      for (let i = 0; i < inputs.length; i++) {
        const pollingMetric = metrics[i];
        const input = pipe(inputs, (x) => x[i]);
        pollingMetric.metric.unsafeModify(input, extraTags);
      }
    }),
    poll: forEachSequential(metrics, (metric) => metric.poll)
  };
};
var launch3 = dual(2, (self, schedule4) => pipe(pollAndUpdate(self), zipRight2(value(self.metric)), scheduleForked(schedule4)));
var poll9 = (self) => self.poll;
var pollAndUpdate = (self) => flatMap12(self.poll, (value10) => update5(self.metric, value10));
var retry8 = dual(2, (self, policy) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: self.metric,
  poll: retry_Effect(self.poll, policy)
}));
var zip22 = dual(2, (self, that) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: pipe(self.metric, zip9(that.metric)),
  poll: zip5(self.poll, that.poll)
}));

// node_modules/effect/dist/esm/MetricPolling.js
var MetricPollingTypeId2 = MetricPollingTypeId;
var make101 = make100;
var collectAll3 = collectAll2;
var launch4 = launch3;
var poll10 = poll9;
var pollAndUpdate2 = pollAndUpdate;
var retry9 = retry8;
var zip23 = zip22;

// node_modules/effect/dist/esm/MetricRegistry.js
var MetricRegistry_exports = {};
__export(MetricRegistry_exports, {
  MetricRegistryTypeId: () => MetricRegistryTypeId2,
  make: () => make102
});
var MetricRegistryTypeId2 = MetricRegistryTypeId;
var make102 = make43;

// node_modules/effect/dist/esm/MetricState.js
var MetricState_exports = {};
__export(MetricState_exports, {
  CounterStateTypeId: () => CounterStateTypeId2,
  FrequencyStateTypeId: () => FrequencyStateTypeId2,
  GaugeStateTypeId: () => GaugeStateTypeId2,
  HistogramStateTypeId: () => HistogramStateTypeId2,
  MetricStateTypeId: () => MetricStateTypeId2,
  SummaryStateTypeId: () => SummaryStateTypeId2,
  counter: () => counter11,
  frequency: () => frequency10,
  gauge: () => gauge10,
  histogram: () => histogram10,
  isCounterState: () => isCounterState2,
  isFrequencyState: () => isFrequencyState2,
  isGaugeState: () => isGaugeState2,
  isHistogramState: () => isHistogramState2,
  isMetricState: () => isMetricState2,
  isSummaryState: () => isSummaryState2,
  summary: () => summary10
});
var MetricStateTypeId2 = MetricStateTypeId;
var CounterStateTypeId2 = CounterStateTypeId;
var FrequencyStateTypeId2 = FrequencyStateTypeId;
var GaugeStateTypeId2 = GaugeStateTypeId;
var HistogramStateTypeId2 = HistogramStateTypeId;
var SummaryStateTypeId2 = SummaryStateTypeId;
var counter11 = counter4;
var frequency10 = frequency3;
var gauge10 = gauge3;
var histogram10 = histogram3;
var summary10 = summary3;
var isMetricState2 = isMetricState;
var isCounterState2 = isCounterState;
var isFrequencyState2 = isFrequencyState;
var isGaugeState2 = isGaugeState;
var isHistogramState2 = isHistogramState;
var isSummaryState2 = isSummaryState;

// node_modules/effect/dist/esm/ModuleVersion.js
var ModuleVersion_exports = {};
__export(ModuleVersion_exports, {
  getCurrentVersion: () => getCurrentVersion2,
  setCurrentVersion: () => setCurrentVersion2
});
var getCurrentVersion2 = getCurrentVersion;
var setCurrentVersion2 = setCurrentVersion;

// node_modules/effect/dist/esm/MutableHashSet.js
var MutableHashSet_exports = {};
__export(MutableHashSet_exports, {
  add: () => add11,
  clear: () => clear7,
  empty: () => empty46,
  fromIterable: () => fromIterable20,
  has: () => has11,
  make: () => make103,
  remove: () => remove13,
  size: () => size30
});
var TypeId38 = Symbol.for("effect/MutableHashSet");
var MutableHashSetProto = {
  [TypeId38]: TypeId38,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromHashMap = (keyMap) => {
  const set26 = Object.create(MutableHashSetProto);
  set26.keyMap = keyMap;
  return set26;
};
var empty46 = () => fromHashMap(empty23());
var fromIterable20 = (keys15) => fromHashMap(fromIterable9(Array.from(keys15).map((k) => [k, true])));
var make103 = (...keys15) => fromIterable20(keys15);
var add11 = dual(2, (self, key) => (set5(self.keyMap, key, true), self));
var has11 = dual(2, (self, key) => has6(self.keyMap, key));
var remove13 = dual(2, (self, key) => (remove8(self.keyMap, key), self));
var size30 = (self) => size13(self.keyMap);
var clear7 = (self) => (clear(self.keyMap), self);

// node_modules/effect/dist/esm/NonEmptyIterable.js
var NonEmptyIterable_exports = {};
__export(NonEmptyIterable_exports, {
  unprepend: () => unprepend2
});
var unprepend2 = (self) => {
  const iterator = self[Symbol.iterator]();
  const next6 = iterator.next();
  if (next6.done) {
    throw new Error("BUG: NonEmptyIterator should not be empty - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return [next6.value, iterator];
};

// node_modules/effect/dist/esm/Ordering.js
var Ordering_exports = {};
__export(Ordering_exports, {
  combine: () => combine17,
  combineAll: () => combineAll5,
  combineMany: () => combineMany3,
  match: () => match37,
  reverse: () => reverse5
});
var reverse5 = (o) => o === -1 ? 1 : o === 1 ? -1 : 0;
var match37 = dual(2, (self, {
  onEqual,
  onGreaterThan,
  onLessThan
}) => self === -1 ? onLessThan() : self === 0 ? onEqual() : onGreaterThan());
var combine17 = dual(2, (self, that) => self !== 0 ? self : that);
var combineMany3 = dual(2, (self, collection) => {
  let ordering = self;
  if (ordering !== 0) {
    return ordering;
  }
  for (ordering of collection) {
    if (ordering !== 0) {
      return ordering;
    }
  }
  return ordering;
});
var combineAll5 = (collection) => combineMany3(0, collection);

// node_modules/effect/dist/esm/Pool.js
var Pool_exports = {};
__export(Pool_exports, {
  PoolTypeId: () => PoolTypeId2,
  get: () => get25,
  invalidate: () => invalidate6,
  isPool: () => isPool2,
  make: () => make104,
  makeWithTTL: () => makeWithTTL4
});
var PoolTypeId2 = PoolTypeId;
var isPool2 = isPool;
var make104 = make85;
var makeWithTTL4 = makeWithTTL;
var get25 = get20;
var invalidate6 = invalidate;

// node_modules/effect/dist/esm/Pretty.js
var Pretty_exports = {};
__export(Pretty_exports, {
  make: () => make105,
  match: () => match38
});
var make105 = (schema) => compile(schema.ast, []);
var getPrettyAnnotation = getAnnotation(PrettyAnnotationId);
var getMatcher = (defaultPretty) => (ast) => match2(getPrettyAnnotation(ast), {
  onNone: () => defaultPretty,
  onSome: (handler) => handler()
});
var toString3 = getMatcher((a) => String(a));
var stringify4 = getMatcher((a) => JSON.stringify(a));
var formatUnknown2 = getMatcher(formatUnknown);
var match38 = {
  "Declaration": (ast, go5, path2) => {
    const annotation = getPrettyAnnotation(ast);
    if (isSome2(annotation)) {
      return annotation.value(...ast.typeParameters.map((tp) => go5(tp, path2)));
    }
    throw new Error(getPrettyMissingAnnotationErrorMessage(path2, ast));
  },
  "VoidKeyword": getMatcher(() => "void(0)"),
  "NeverKeyword": getMatcher(() => {
    throw new Error(getPrettyNeverErrorMessage);
  }),
  "Literal": getMatcher((literal3) => typeof literal3 === "bigint" ? `${String(literal3)}n` : JSON.stringify(literal3)),
  "SymbolKeyword": toString3,
  "UniqueSymbol": toString3,
  "TemplateLiteral": stringify4,
  "UndefinedKeyword": toString3,
  "UnknownKeyword": formatUnknown2,
  "AnyKeyword": formatUnknown2,
  "ObjectKeyword": formatUnknown2,
  "StringKeyword": stringify4,
  "NumberKeyword": toString3,
  "BooleanKeyword": toString3,
  "BigIntKeyword": getMatcher((a) => `${String(a)}n`),
  "Enums": stringify4,
  "TupleType": (ast, go5, path2) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const elements = ast.elements.map((e, i) => go5(e.type, path2.concat(i)));
    const rest = ast.rest.map((annotatedAST) => go5(annotatedAST.type, path2));
    return (input) => {
      const output = [];
      let i = 0;
      for (; i < elements.length; i++) {
        if (input.length < i + 1) {
          if (ast.elements[i].isOptional) {
            continue;
          }
        } else {
          output.push(elements[i](input[i]));
        }
      }
      if (isNonEmptyReadonlyArray(rest)) {
        const [head13, ...tail5] = rest;
        for (; i < input.length - tail5.length; i++) {
          output.push(head13(input[i]));
        }
        for (let j = 0; j < tail5.length; j++) {
          i += j;
          output.push(tail5[j](input[i]));
        }
      }
      return "[" + output.join(", ") + "]";
    };
  },
  "TypeLiteral": (ast, go5, path2) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const propertySignaturesTypes = ast.propertySignatures.map((ps) => go5(ps.type, path2.concat(ps.name)));
    const indexSignatureTypes = ast.indexSignatures.map((is4) => go5(is4.type, path2));
    const expectedKeys = {};
    for (let i = 0; i < propertySignaturesTypes.length; i++) {
      expectedKeys[ast.propertySignatures[i].name] = null;
    }
    return (input) => {
      const output = [];
      for (let i = 0; i < propertySignaturesTypes.length; i++) {
        const ps = ast.propertySignatures[i];
        const name = ps.name;
        if (ps.isOptional && !Object.prototype.hasOwnProperty.call(input, name)) {
          continue;
        }
        output.push(`${formatPropertyKey(name)}: ${propertySignaturesTypes[i](input[name])}`);
      }
      if (indexSignatureTypes.length > 0) {
        for (let i = 0; i < indexSignatureTypes.length; i++) {
          const type8 = indexSignatureTypes[i];
          const keys15 = getKeysForIndexSignature(input, ast.indexSignatures[i].parameter);
          for (const key of keys15) {
            if (Object.prototype.hasOwnProperty.call(expectedKeys, key)) {
              continue;
            }
            output.push(`${formatPropertyKey(key)}: ${type8(input[key])}`);
          }
        }
      }
      return isNonEmptyReadonlyArray(output) ? "{ " + output.join(", ") + " }" : "{}";
    };
  },
  "Union": (ast, go5, path2) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome2(hook)) {
      return hook.value();
    }
    const types3 = ast.types.map((ast2) => [is({
      ast: ast2
    }), go5(ast2, path2)]);
    return (a) => {
      const index3 = types3.findIndex(([is4]) => is4(a));
      if (index3 === -1) {
        throw new Error(getPrettyNoMatchingSchemaErrorMessage(a, path2, ast));
      }
      return types3[index3][1](a);
    };
  },
  "Suspend": (ast, go5, path2) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => {
        const get48 = memoizeThunk(() => go5(ast.f(), path2));
        return (a) => get48()(a);
      },
      onSome: (handler) => handler()
    });
  },
  "Refinement": (ast, go5, path2) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => go5(ast.from, path2),
      onSome: (handler) => handler()
    });
  },
  "Transformation": (ast, go5, path2) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => go5(ast.to, path2),
      onSome: (handler) => handler()
    });
  }
};
var compile = getCompiler(match38);

// node_modules/effect/dist/esm/PrimaryKey.js
var PrimaryKey_exports = {};
__export(PrimaryKey_exports, {
  symbol: () => symbol5,
  value: () => value7
});
var symbol5 = Symbol.for("effect/PrimaryKey");
var value7 = (self) => self[symbol5]();

// node_modules/effect/dist/esm/RateLimiter.js
var RateLimiter_exports = {};
__export(RateLimiter_exports, {
  make: () => make107,
  withCost: () => withCost2
});

// node_modules/effect/dist/esm/internal/rateLimiter.js
var make106 = ({
  algorithm = "token-bucket",
  interval,
  limit: limit2
}) => {
  switch (algorithm) {
    case "fixed-window": {
      return fixedWindow(limit2, interval);
    }
    case "token-bucket": {
      return tokenBucket(limit2, interval);
    }
  }
};
var tokenBucket = (limit2, window3) => gen6(function* () {
  const millisPerToken = Math.ceil(toMillis(window3) / limit2);
  const semaphore = yield* makeSemaphore2(limit2);
  const latch = yield* makeSemaphore2(0);
  const refill = sleep5(millisPerToken).pipe(zipRight7(latch.releaseAll), zipRight7(semaphore.release(1)), flatMap18((free) => free === limit2 ? _void : refill));
  yield* pipe(latch.take(1), zipRight7(refill), forever4, forkScoped3, interruptible4);
  const take16 = uninterruptibleMask3((restore) => flatMap18(get14(currentCost), (cost) => zipRight7(restore(semaphore.take(cost)), latch.release(1))));
  return (effect4) => zipRight7(take16, effect4);
});
var fixedWindow = (limit2, window3) => gen6(function* () {
  const semaphore = yield* makeSemaphore2(limit2);
  const latch = yield* makeSemaphore2(0);
  yield* pipe(latch.take(1), zipRight7(sleep5(window3)), zipRight7(latch.releaseAll), zipRight7(semaphore.releaseAll), forever4, forkScoped3, interruptible4);
  const take16 = uninterruptibleMask3((restore) => flatMap18(get14(currentCost), (cost) => zipRight7(restore(semaphore.take(cost)), latch.release(1))));
  return (effect4) => zipRight7(take16, effect4);
});
var currentCost = globalValue(Symbol.for("effect/RateLimiter/currentCost"), () => unsafeMake12(1));
var withCost = (cost) => locally2(currentCost, cost);

// node_modules/effect/dist/esm/RateLimiter.js
var make107 = make106;
var withCost2 = withCost;

// node_modules/effect/dist/esm/Redacted.js
var Redacted_exports = {};
__export(Redacted_exports, {
  RedactedTypeId: () => RedactedTypeId2,
  getEquivalence: () => getEquivalence9,
  isRedacted: () => isRedacted2,
  make: () => make108,
  unsafeWipe: () => unsafeWipe3,
  value: () => value8
});
var RedactedTypeId2 = RedactedTypeId;
var isRedacted2 = isRedacted;
var make108 = make74;
var value8 = value2;
var unsafeWipe3 = unsafeWipe;
var getEquivalence9 = (isEquivalent) => make((x, y) => isEquivalent(value8(x), value8(y)));

// node_modules/effect/dist/esm/Reloadable.js
var Reloadable_exports = {};
__export(Reloadable_exports, {
  ReloadableTypeId: () => ReloadableTypeId2,
  auto: () => auto2,
  autoFromConfig: () => autoFromConfig2,
  get: () => get28,
  manual: () => manual2,
  reload: () => reload2,
  reloadFork: () => reloadFork2,
  tag: () => tag3
});

// node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef";
var ScopedRefTypeId = Symbol.for(ScopedRefSymbolKey);
var scopedRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto14 = {
  ...CommitPrototype,
  commit() {
    return get26(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
};
var close2 = (self) => flatMap12(get12(self.ref), (tuple7) => tuple7[0].close(exitVoid));
var fromAcquire = (acquire4) => uninterruptible(scopeMake2().pipe(flatMap12((newScope) => acquire4.pipe(mapInputContext(add3(scopeTag, newScope)), onError((cause3) => newScope.close(exitFail(cause3))), flatMap12((value10) => makeSynchronized([newScope, value10]).pipe(flatMap12((ref) => {
  const scopedRef = Object.create(proto14);
  scopedRef.ref = ref;
  return pipe(addFinalizer2(() => close2(scopedRef)), as3(scopedRef));
})))))));
var get26 = (self) => map14(get12(self.ref), (tuple7) => tuple7[1]);
var make109 = (evaluate4) => fromAcquire(sync(evaluate4));
var set14 = dual(2, (self, acquire4) => flatten8(modifyEffect(self.ref, ([oldScope, value10]) => uninterruptible(scopeClose(oldScope, exitVoid).pipe(zipRight2(scopeMake2()), flatMap12((newScope) => exit(scopeExtend(acquire4, newScope)).pipe(flatMap12((exit4) => exitMatch(exit4, {
  onFailure: (cause3) => scopeClose(newScope, exitVoid).pipe(as3([failCause(cause3), [oldScope, value10]])),
  onSuccess: (value11) => succeed([void_3, [newScope, value11]])
})))))))));

// node_modules/effect/dist/esm/internal/reloadable.js
var ReloadableSymbolKey = "effect/Reloadable";
var ReloadableTypeId = Symbol.for(ReloadableSymbolKey);
var reloadableVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var auto = (tag5, options) => scoped3(reloadableTag(tag5), pipe(build(manual(tag5, {
  layer: options.layer
})), map14(unsafeGet3(reloadableTag(tag5))), tap2((reloadable) => acquireRelease2(pipe(reloadable.reload, ignoreLogged, schedule_Effect(options.schedule), forkDaemon2), interruptFiber))));
var autoFromConfig = (tag5, options) => scoped3(reloadableTag(tag5), pipe(context2(), flatMap12((env) => pipe(build(auto(tag5, {
  layer: options.layer,
  schedule: options.scheduleFromConfig(env)
})), map14(unsafeGet3(reloadableTag(tag5)))))));
var get27 = (tag5) => flatMap12(reloadableTag(tag5), (reloadable) => get26(reloadable.scopedRef));
var manual = (tag5, options) => scoped3(reloadableTag(tag5), pipe(context2(), flatMap12((env) => pipe(fromAcquire(pipe(build(options.layer), map14(unsafeGet3(tag5)))), map14((ref) => ({
  [ReloadableTypeId]: reloadableVariance,
  scopedRef: ref,
  reload: pipe(set14(ref, pipe(build(options.layer), map14(unsafeGet3(tag5)))), provideContext(env))
}))))));
var reloadableTag = (tag5) => {
  return GenericTag(`effect/Reloadable<${tag5.key}>`);
};
var reload = (tag5) => flatMap12(reloadableTag(tag5), (reloadable) => reloadable.reload);
var reloadFork = (tag5) => flatMap12(reloadableTag(tag5), (reloadable) => pipe(reloadable.reload, ignoreLogged, forkDaemon2, asVoid2));

// node_modules/effect/dist/esm/Reloadable.js
var ReloadableTypeId2 = ReloadableTypeId;
var auto2 = auto;
var autoFromConfig2 = autoFromConfig;
var get28 = get27;
var manual2 = manual;
var reload2 = reload;
var tag3 = reloadableTag;
var reloadFork2 = reloadFork;

// node_modules/effect/dist/esm/RequestBlock.js
var RequestBlock_exports = {};
__export(RequestBlock_exports, {
  empty: () => empty47,
  mapRequestResolvers: () => mapRequestResolvers2,
  parallel: () => parallel5,
  reduce: () => reduce20,
  sequential: () => sequential5,
  single: () => single2
});
var single2 = single;
var empty47 = empty21;
var mapRequestResolvers2 = mapRequestResolvers;
var parallel5 = par;
var reduce20 = reduce10;
var sequential5 = seq;

// node_modules/effect/dist/esm/RequestResolver.js
var RequestResolver_exports = {};
__export(RequestResolver_exports, {
  RequestResolverTypeId: () => RequestResolverTypeId2,
  around: () => around2,
  aroundRequests: () => aroundRequests2,
  batchN: () => batchN2,
  contextFromEffect: () => contextFromEffect,
  contextFromServices: () => contextFromServices,
  eitherWith: () => eitherWith4,
  fromEffect: () => fromEffect12,
  fromEffectTagged: () => fromEffectTagged2,
  fromFunction: () => fromFunction6,
  fromFunctionBatched: () => fromFunctionBatched2,
  isRequestResolver: () => isRequestResolver2,
  locally: () => locally4,
  make: () => make111,
  makeBatched: () => makeBatched3,
  makeWithEntry: () => makeWithEntry2,
  mapInputContext: () => mapInputContext10,
  never: () => never11,
  provideContext: () => provideContext11,
  race: () => race7
});

// node_modules/effect/dist/esm/internal/dataSource.js
var make110 = (runAll) => new RequestResolverImpl((requests) => runAll(requests.map((_) => _.map((_2) => _2.request))));
var makeWithEntry = (runAll) => new RequestResolverImpl((requests) => runAll(requests));
var makeBatched2 = (run10) => new RequestResolverImpl((requests) => {
  if (requests.length > 1) {
    return forEachSequentialDiscard(requests, (block) => {
      const filtered = block.filter((_) => !_.state.completed).map((_) => _.request);
      if (!isNonEmptyArray2(filtered)) {
        return void_3;
      }
      return invokeWithInterrupt(run10(filtered), block);
    });
  } else if (requests.length === 1) {
    const filtered = requests[0].filter((_) => !_.state.completed).map((_) => _.request);
    if (!isNonEmptyArray2(filtered)) {
      return void_3;
    }
    return run10(filtered);
  }
  return void_3;
});
var around = dual(3, (self, before3, after3) => new RequestResolverImpl((requests) => acquireUseRelease(before3, () => self.runAll(requests), after3), make9("Around", self, before3, after3)));
var aroundRequests = dual(3, (self, before3, after3) => new RequestResolverImpl((requests) => {
  const flatRequests = requests.flatMap((chunk7) => chunk7.map((entry) => entry.request));
  return acquireUseRelease(before3(flatRequests), () => self.runAll(requests), (a2) => after3(flatRequests, a2));
}, make9("AroundRequests", self, before3, after3)));
var batchN = dual(2, (self, n) => new RequestResolverImpl((requests) => {
  return n < 1 ? die2(new IllegalArgumentException2("RequestResolver.batchN: n must be at least 1")) : self.runAll(Array.from(map7(reduce3(requests, empty7(), (acc, chunk7) => appendAll3(acc, chunksOf3(unsafeFromArray(chunk7), n))), (chunk7) => Array.from(chunk7))));
}, make9("BatchN", self, n)));
var mapInputContext9 = dual(2, (self, f2) => new RequestResolverImpl((requests) => mapInputContext(self.runAll(requests), (context15) => f2(context15)), make9("MapInputContext", self, f2)));
var eitherWith3 = dual(3, (self, that, f2) => new RequestResolverImpl((batch) => pipe(forEachSequential(batch, (requests) => {
  const [as18, bs] = pipe(requests, partitionMap3(f2));
  return zipWithOptions(self.runAll(Array.of(as18)), that.runAll(Array.of(bs)), () => void 0, {
    concurrent: true
  });
})), make9("EitherWith", self, that, f2)));
var fromFunction5 = (f2) => makeBatched2((requests) => forEachSequentialDiscard(requests, (request2) => complete2(request2, exitSucceed(f2(request2))))).identified("FromFunction", f2);
var fromFunctionBatched = (f2) => makeBatched2((as18) => forEach16(f2(as18), (res, i) => complete2(as18[i], exitSucceed(res)), {
  discard: true
})).identified("FromFunctionBatched", f2);
var fromEffect11 = (f2) => makeBatched2((requests) => forEach16(requests, (a) => flatMap18(exit3(f2(a)), (e) => complete2(a, e)), {
  concurrency: "unbounded",
  discard: true
})).identified("FromEffect", f2);
var fromEffectTagged = () => (fns) => makeBatched2((requests) => {
  const grouped3 = {};
  const tags3 = [];
  for (let i = 0, len = requests.length; i < len; i++) {
    if (tags3.includes(requests[i]._tag)) {
      grouped3[requests[i]._tag].push(requests[i]);
    } else {
      grouped3[requests[i]._tag] = [requests[i]];
      tags3.push(requests[i]._tag);
    }
  }
  return forEach16(tags3, (tag5) => matchCauseEffect3(fns[tag5](grouped3[tag5]), {
    onFailure: (cause3) => forEach16(grouped3[tag5], (req) => complete2(req, exitFail(cause3)), {
      discard: true
    }),
    onSuccess: (res) => forEach16(grouped3[tag5], (req, i) => complete2(req, exitSucceed(res[i])), {
      discard: true
    })
  }), {
    concurrency: "unbounded",
    discard: true
  });
}).identified("FromEffectTagged", fns);
var never10 = make110(() => never5).identified("Never");
var provideContext10 = dual(2, (self, context15) => mapInputContext9(self, (_) => context15).identified("ProvideContext", self, context15));
var race6 = dual(2, (self, that) => new RequestResolverImpl((requests) => race3(self.runAll(requests), that.runAll(requests))).identified("Race", self, that));

// node_modules/effect/dist/esm/RequestResolver.js
var RequestResolverTypeId2 = RequestResolverTypeId;
var contextFromEffect = (self) => contextWith2((_) => provideContext11(self, _));
var contextFromServices = (...services) => (self) => contextWith2((_) => provideContext11(self, pick3(...services)(_)));
var isRequestResolver2 = isRequestResolver;
var make111 = make110;
var makeWithEntry2 = makeWithEntry;
var makeBatched3 = makeBatched2;
var around2 = around;
var aroundRequests2 = aroundRequests;
var batchN2 = batchN;
var mapInputContext10 = mapInputContext9;
var eitherWith4 = eitherWith3;
var fromFunction6 = fromFunction5;
var fromFunctionBatched2 = fromFunctionBatched;
var fromEffect12 = fromEffect11;
var fromEffectTagged2 = fromEffectTagged;
var never11 = never10;
var provideContext11 = provideContext10;
var race7 = race6;
var locally4 = resolverLocally;

// node_modules/effect/dist/esm/Resource.js
var Resource_exports = {};
__export(Resource_exports, {
  ResourceTypeId: () => ResourceTypeId2,
  auto: () => auto4,
  get: () => get30,
  manual: () => manual4,
  refresh: () => refresh2
});

// node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource";
var ResourceTypeId = Symbol.for(ResourceSymbolKey);
var resourceVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var proto15 = {
  ...CommitPrototype,
  commit() {
    return get29(this);
  },
  [ResourceTypeId]: resourceVariance
};
var auto3 = (acquire4, policy) => tap2(manual3(acquire4), (manual5) => acquireRelease2(pipe(refresh(manual5), schedule_Effect(policy), interruptible2, forkDaemon2), interruptFiber));
var manual3 = (acquire4) => flatMap12(context2(), (env) => pipe(fromAcquire(exit(acquire4)), map14((ref) => {
  const resource = Object.create(proto15);
  resource.scopedRef = ref;
  resource.acquire = provideContext(acquire4, env);
  return resource;
})));
var get29 = (self) => flatMap12(get26(self.scopedRef), identity);
var refresh = (self) => set14(self.scopedRef, map14(self.acquire, exitSucceed));

// node_modules/effect/dist/esm/Resource.js
var ResourceTypeId2 = ResourceTypeId;
var auto4 = auto3;
var get30 = get29;
var manual4 = manual3;
var refresh2 = refresh;

// node_modules/effect/dist/esm/RuntimeFlags.js
var RuntimeFlags_exports = {};
__export(RuntimeFlags_exports, {
  CooperativeYielding: () => CooperativeYielding2,
  Interruption: () => Interruption2,
  None: () => None4,
  OpSupervision: () => OpSupervision2,
  RuntimeMetrics: () => RuntimeMetrics2,
  WindDown: () => WindDown2,
  cooperativeYielding: () => cooperativeYielding2,
  diff: () => diff12,
  differ: () => differ3,
  disable: () => disable4,
  disableAll: () => disableAll2,
  disableCooperativeYielding: () => disableCooperativeYielding2,
  disableInterruption: () => disableInterruption2,
  disableOpSupervision: () => disableOpSupervision2,
  disableRuntimeMetrics: () => disableRuntimeMetrics2,
  disableWindDown: () => disableWindDown2,
  enable: () => enable4,
  enableAll: () => enableAll2,
  enableCooperativeYielding: () => enableCooperativeYielding2,
  enableInterruption: () => enableInterruption2,
  enableOpSupervision: () => enableOpSupervision2,
  enableRuntimeMetrics: () => enableRuntimeMetrics2,
  enableWindDown: () => enableWindDown2,
  interruptible: () => interruptible5,
  interruption: () => interruption2,
  isDisabled: () => isDisabled4,
  isEnabled: () => isEnabled4,
  make: () => make112,
  none: () => none12,
  opSupervision: () => opSupervision2,
  patch: () => patch13,
  render: () => render5,
  runtimeMetrics: () => runtimeMetrics2,
  toSet: () => toSet5,
  windDown: () => windDown2
});
var None4 = None2;
var Interruption2 = Interruption;
var OpSupervision2 = OpSupervision;
var RuntimeMetrics2 = RuntimeMetrics;
var WindDown2 = WindDown;
var CooperativeYielding2 = CooperativeYielding;
var cooperativeYielding2 = cooperativeYielding;
var diff12 = diff7;
var differ3 = differ;
var disable4 = disable2;
var disableAll2 = disableAll;
var disableCooperativeYielding2 = disableCooperativeYielding;
var disableInterruption2 = disableInterruption;
var disableOpSupervision2 = disableOpSupervision;
var disableRuntimeMetrics2 = disableRuntimeMetrics;
var disableWindDown2 = disableWindDown;
var enable4 = enable2;
var enableAll2 = enableAll;
var enableCooperativeYielding2 = enableCooperativeYielding;
var enableInterruption2 = enableInterruption;
var enableOpSupervision2 = enableOpSupervision;
var enableRuntimeMetrics2 = enableRuntimeMetrics;
var enableWindDown2 = enableWindDown;
var interruptible5 = interruptible;
var interruption2 = interruption;
var isEnabled4 = isEnabled2;
var isDisabled4 = isDisabled2;
var make112 = make22;
var none12 = none5;
var opSupervision2 = opSupervision;
var patch13 = patch7;
var render5 = render;
var runtimeMetrics2 = runtimeMetrics;
var toSet5 = toSet3;
var windDown2 = windDown;

// node_modules/effect/dist/esm/STM.js
var STM_exports = {};
__export(STM_exports, {
  Do: () => Do8,
  STMTypeId: () => STMTypeId3,
  acquireUseRelease: () => acquireUseRelease7,
  all: () => all15,
  as: () => as15,
  asSome: () => asSome5,
  asSomeError: () => asSomeError4,
  asVoid: () => asVoid11,
  attempt: () => attempt2,
  bind: () => bind10,
  bindTo: () => bindTo10,
  catchAll: () => catchAll10,
  catchSome: () => catchSome5,
  catchTag: () => catchTag6,
  catchTags: () => catchTags5,
  check: () => check5,
  collect: () => collect5,
  collectSTM: () => collectSTM2,
  commit: () => commit3,
  commitEither: () => commitEither2,
  cond: () => cond2,
  context: () => context12,
  contextWith: () => contextWith8,
  contextWithSTM: () => contextWithSTM2,
  die: () => die15,
  dieMessage: () => dieMessage7,
  dieSync: () => dieSync9,
  either: () => either12,
  ensuring: () => ensuring11,
  eventually: () => eventually4,
  every: () => every16,
  exists: () => exists6,
  fail: () => fail24,
  failSync: () => failSync12,
  fiberId: () => fiberId4,
  filter: () => filter21,
  filterNot: () => filterNot2,
  filterOrDie: () => filterOrDie4,
  filterOrDieMessage: () => filterOrDieMessage4,
  filterOrElse: () => filterOrElse4,
  filterOrFail: () => filterOrFail5,
  firstSuccessOf: () => firstSuccessOf3,
  flatMap: () => flatMap26,
  flatten: () => flatten19,
  flip: () => flip7,
  flipWith: () => flipWith4,
  forEach: () => forEach19,
  fromEither: () => fromEither6,
  fromOption: () => fromOption10,
  gen: () => gen8,
  head: () => head10,
  if: () => if_4,
  ignore: () => ignore5,
  interrupt: () => interrupt11,
  interruptAs: () => interruptAs3,
  isFailure: () => isFailure8,
  isSTM: () => isSTM2,
  isSuccess: () => isSuccess7,
  iterate: () => iterate5,
  let: () => let_10,
  loop: () => loop4,
  map: () => map40,
  mapAttempt: () => mapAttempt4,
  mapBoth: () => mapBoth11,
  mapError: () => mapError13,
  mapInputContext: () => mapInputContext11,
  match: () => match39,
  matchSTM: () => matchSTM2,
  merge: () => merge12,
  mergeAll: () => mergeAll11,
  negate: () => negate6,
  none: () => none13,
  option: () => option10,
  orDie: () => orDie10,
  orDieWith: () => orDieWith7,
  orElse: () => orElse21,
  orElseEither: () => orElseEither8,
  orElseFail: () => orElseFail5,
  orElseOptional: () => orElseOptional2,
  orElseSucceed: () => orElseSucceed6,
  orTry: () => orTry2,
  partition: () => partition12,
  provideContext: () => provideContext12,
  provideService: () => provideService12,
  provideServiceSTM: () => provideServiceSTM2,
  provideSomeContext: () => provideSomeContext4,
  reduce: () => reduce21,
  reduceAll: () => reduceAll2,
  reduceRight: () => reduceRight7,
  refineOrDie: () => refineOrDie4,
  refineOrDieWith: () => refineOrDieWith4,
  reject: () => reject2,
  rejectSTM: () => rejectSTM2,
  repeatUntil: () => repeatUntil2,
  repeatWhile: () => repeatWhile2,
  replicate: () => replicate7,
  replicateSTM: () => replicateSTM2,
  replicateSTMDiscard: () => replicateSTMDiscard2,
  retry: () => retry10,
  retryUntil: () => retryUntil2,
  retryWhile: () => retryWhile2,
  some: () => some18,
  succeed: () => succeed27,
  succeedNone: () => succeedNone5,
  succeedSome: () => succeedSome5,
  summarized: () => summarized5,
  suspend: () => suspend14,
  sync: () => sync20,
  tap: () => tap10,
  tapBoth: () => tapBoth5,
  tapError: () => tapError8,
  try: () => try_6,
  unless: () => unless4,
  unlessSTM: () => unlessSTM2,
  unsome: () => unsome3,
  validateAll: () => validateAll4,
  validateFirst: () => validateFirst4,
  void: () => void_13,
  when: () => when8,
  whenSTM: () => whenSTM2,
  zip: () => zip24,
  zipLeft: () => zipLeft15,
  zipRight: () => zipRight15,
  zipWith: () => zipWith20
});
var STMTypeId3 = STMTypeId2;
var isSTM2 = isSTM;
var acquireUseRelease7 = acquireUseRelease5;
var all15 = all12;
var as15 = as12;
var asSome5 = asSome4;
var asSomeError4 = asSomeError3;
var asVoid11 = asVoid9;
var attempt2 = attempt;
var catchAll10 = catchAll7;
var catchSome5 = catchSome3;
var catchTag6 = catchTag4;
var catchTags5 = catchTags3;
var check5 = check4;
var collect5 = collect3;
var collectSTM2 = collectSTM;
var commit3 = commit2;
var commitEither2 = commitEither;
var cond2 = cond;
var context12 = context9;
var contextWith8 = contextWith5;
var contextWithSTM2 = contextWithSTM;
var mapInputContext11 = mapInputContext6;
var die15 = die12;
var dieMessage7 = dieMessage4;
var dieSync9 = dieSync7;
var either12 = either8;
var ensuring11 = ensuring8;
var eventually4 = eventually3;
var every16 = every15;
var exists6 = exists5;
var fail24 = fail17;
var failSync12 = failSync9;
var fiberId4 = fiberId3;
var filter21 = filter17;
var filterNot2 = filterNot;
var filterOrDie4 = filterOrDie3;
var filterOrDieMessage4 = filterOrDieMessage3;
var filterOrElse4 = filterOrElse3;
var filterOrFail5 = filterOrFail4;
var flatMap26 = flatMap22;
var flatten19 = flatten16;
var flip7 = flip6;
var flipWith4 = flipWith3;
var match39 = match31;
var matchSTM2 = matchSTM;
var forEach19 = forEach18;
var fromEither6 = fromEither4;
var fromOption10 = fromOption7;
var gen8 = gen7;
var head10 = head9;
var if_4 = if_3;
var ignore5 = ignore4;
var interrupt11 = interrupt10;
var interruptAs3 = interruptAs2;
var isFailure8 = isFailure6;
var isSuccess7 = isSuccess5;
var iterate5 = iterate3;
var loop4 = loop3;
var map40 = map31;
var mapAttempt4 = mapAttempt;
var mapBoth11 = mapBoth8;
var mapError13 = mapError9;
var merge12 = merge9;
var mergeAll11 = mergeAll8;
var negate6 = negate5;
var none13 = none10;
var option10 = option5;
var orDie10 = orDie7;
var orDieWith7 = orDieWith4;
var orElse21 = orElse12;
var orElseEither8 = orElseEither6;
var orElseFail5 = orElseFail3;
var orElseOptional2 = orElseOptional;
var orElseSucceed6 = orElseSucceed4;
var orTry2 = orTry;
var partition12 = partition10;
var provideContext12 = provideContext7;
var provideSomeContext4 = provideSomeContext2;
var provideService12 = provideService9;
var provideServiceSTM2 = provideServiceSTM;
var reduce21 = reduce19;
var reduceAll2 = reduceAll;
var reduceRight7 = reduceRight6;
var refineOrDie4 = refineOrDie2;
var refineOrDieWith4 = refineOrDieWith2;
var reject2 = reject;
var rejectSTM2 = rejectSTM;
var repeatUntil2 = repeatUntil;
var repeatWhile2 = repeatWhile;
var replicate7 = replicate6;
var replicateSTM2 = replicateSTM;
var replicateSTMDiscard2 = replicateSTMDiscard;
var retry10 = retry6;
var retryUntil2 = retryUntil;
var retryWhile2 = retryWhile;
var some18 = some16;
var succeed27 = succeed19;
var succeedNone5 = succeedNone4;
var succeedSome5 = succeedSome4;
var summarized5 = summarized4;
var suspend14 = suspend9;
var sync20 = sync13;
var tap10 = tap7;
var tapBoth5 = tapBoth3;
var tapError8 = tapError6;
var try_6 = try_5;
var unless4 = unless3;
var unlessSTM2 = unlessSTM;
var unsome3 = unsome;
var void_13 = void_10;
var validateAll4 = validateAll3;
var validateFirst4 = validateFirst3;
var when8 = when4;
var whenSTM2 = whenSTM;
var zip24 = zip15;
var zipLeft15 = zipLeft11;
var zipRight15 = zipRight11;
var zipWith20 = zipWith16;
var firstSuccessOf3 = (effects) => suspend14(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty2(list)) {
    return dieSync9(() => new IllegalArgumentException2(`Received an empty collection of effects`));
  }
  return reduce4(tailNonEmpty2(list), headNonEmpty2(list), (left3, right3) => orElse21(left3, () => right3));
});
var Do8 = succeed27({});
var bind10 = bind8;
var let_10 = let_8;
var bindTo10 = bindTo8;

// node_modules/effect/dist/esm/Schema.js
var Schema_exports = {};
__export(Schema_exports, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class7,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either3,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map41,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set15,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass4,
  TaggedError: () => TaggedError3,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId39,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between8,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp9,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose6,
  declare: () => declare,
  decode: () => decode6,
  decodeEither: () => decodeEither2,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise2,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown3,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise2,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode5,
  encodeEither: () => encodeEither2,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise2,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise2,
  encodeUnknownSync: () => encodeUnknownSync,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith2,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend4,
  failureSchema: () => failureSchema,
  filter: () => filter22,
  filterEffect: () => filterEffect2,
  finite: () => finite,
  format: () => format7,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  greaterThan: () => greaterThan11,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo8,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  head: () => head11,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes3,
  instanceOf: () => instanceOf3,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length5,
  lessThan: () => lessThan15,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo8,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make113,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString5,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit5,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick5,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split5,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith2,
  successSchema: () => successSchema,
  suspend: () => suspend15,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag4,
  transform: () => transform3,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate8,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise2,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});

// node_modules/effect/dist/esm/Struct.js
var Struct_exports = {};
__export(Struct_exports, {
  evolve: () => evolve,
  get: () => get31,
  getEquivalence: () => getEquivalence10,
  getOrder: () => getOrder6,
  keys: () => keys9,
  omit: () => omit4,
  pick: () => pick4
});
var pick4 = dual((args2) => isObject(args2[0]), (s, ...keys15) => {
  const out = {};
  for (const k of keys15) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit4 = dual((args2) => isObject(args2[0]), (s, ...keys15) => {
  const out = {
    ...s
  };
  for (const k of keys15) {
    delete out[k];
  }
  return out;
});
var getEquivalence10 = struct;
var getOrder6 = struct3;
var evolve = dual(2, (obj, t) => {
  const out = {
    ...obj
  };
  for (const k in t) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      out[k] = t[k](obj[k]);
    }
  }
  return out;
});
var get31 = (key) => (s) => s[key];
var keys9 = (o) => Object.keys(o);

// node_modules/effect/dist/esm/Schema.js
var TypeId39 = Symbol.for("effect/Schema");
function make113(ast) {
  var _a106, _b32, _c7;
  return _b32 = TypeId39, _a106 = TypeId39, _c7 = class {
    constructor() {
      __publicField(this, _b32, variance11);
    }
    static annotations(annotations4) {
      return make113(mergeSchemaAnnotations(this.ast, annotations4));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
  }, __publicField(_c7, "ast", ast), __publicField(_c7, "Type"), __publicField(_c7, "Encoded"), __publicField(_c7, "Context"), __publicField(_c7, _a106, variance11), _c7;
}
var variance11 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _I: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var makeStandardResult = (exit4) => isSuccess(exit4) ? exit4.value : makeStandardFailureResult(pretty3(exit4.cause));
var makeStandardFailureResult = (message) => ({
  issues: [{
    message
  }]
});
var makeStandardFailureFromParseIssue = (issue) => map26(ArrayFormatter.formatIssue(issue), (issues) => ({
  issues: issues.map((issue2) => ({
    path: issue2.path,
    message: issue2.message
  }))
}));
var standardSchemaV1 = (schema, overrideOptions) => {
  var _a106;
  const decodeUnknown4 = decodeUnknown2(schema, {
    errors: "all"
  });
  return _a106 = class extends make113(schema.ast) {
  }, __publicField(_a106, "~standard", {
    version: 1,
    vendor: "effect",
    validate(value10) {
      const scheduler2 = new SyncScheduler();
      const fiber = runFork2(matchEffect4(decodeUnknown4(value10, overrideOptions), {
        onFailure: makeStandardFailureFromParseIssue,
        onSuccess: (value11) => succeed13({
          value: value11
        })
      }), {
        scheduler: scheduler2
      });
      scheduler2.flush();
      const exit4 = fiber.unsafePoll();
      if (exit4) {
        return makeStandardResult(exit4);
      }
      return new Promise((resolve) => {
        fiber.addObserver((exit5) => {
          resolve(makeStandardResult(exit5));
        });
      });
    }
  }), _a106;
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations4) => {
  if (!annotations4) {
    return {};
  }
  const out = {
    ...annotations4
  };
  for (const key in builtInAnnotations) {
    if (key in annotations4) {
      const id3 = builtInAnnotations[key];
      out[id3] = annotations4[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations4) => annotations(ast, toASTAnnotations(annotations4));
function asSchema(schema) {
  return schema;
}
var format7 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make113(encodedAST(schema.ast));
var encodedBoundSchema = (schema) => make113(encodedBoundAST(schema.ast));
var typeSchema = (schema) => make113(typeAST(schema.ast));
var encodeUnknown2 = (schema, options) => {
  const encodeUnknown3 = encodeUnknown(schema, options);
  return (u, overrideOptions) => mapError12(encodeUnknown3(u, overrideOptions), parseError);
};
var encodeUnknownEither2 = (schema, options) => {
  const encodeUnknownEither3 = encodeUnknownEither(schema, options);
  return (u, overrideOptions) => mapLeft(encodeUnknownEither3(u, overrideOptions), parseError);
};
var encodeUnknownPromise2 = (schema, options) => {
  const parser = encodeUnknown2(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var encode5 = encodeUnknown2;
var encodeEither2 = encodeUnknownEither2;
var encodePromise2 = encodeUnknownPromise2;
var decodeUnknown3 = (schema, options) => {
  const decodeUnknown4 = decodeUnknown2(schema, options);
  return (u, overrideOptions) => mapError12(decodeUnknown4(u, overrideOptions), parseError);
};
var decodeUnknownEither2 = (schema, options) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema, options);
  return (u, overrideOptions) => mapLeft(decodeUnknownEither3(u, overrideOptions), parseError);
};
var decodeUnknownPromise2 = (schema, options) => {
  const parser = decodeUnknown3(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var decode6 = decodeUnknown3;
var decodeEither2 = decodeUnknownEither2;
var decodePromise2 = decodeUnknownPromise2;
var validate8 = (schema, options) => {
  const validate22 = validate7(schema, options);
  return (u, overrideOptions) => mapError12(validate22(u, overrideOptions), parseError);
};
var validateEither2 = (schema, options) => {
  const validateEither3 = validateEither(schema, options);
  return (u, overrideOptions) => mapLeft(validateEither3(u, overrideOptions), parseError);
};
var validatePromise2 = (schema, options) => {
  const parser = validate8(schema, options);
  return (u, overrideOptions) => runPromise2(parser(u, overrideOptions));
};
var isSchema = (u) => hasProperty(u, TypeId39) && isObject(u[TypeId39]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal3) => new Literal(literal3))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  var _a106;
  return _a106 = class extends make113(ast) {
    static annotations(annotations4) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "literals", [...literals]), _a106;
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var pickLiteral = (...literals) => (_schema) => Literal2(...literals);
var UniqueSymbolFromSelf = (symbol6) => make113(new UniqueSymbol(symbol6));
var getDefaultEnumsAST = (enums) => new Enums(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]]));
var makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) => {
  var _a106;
  return _a106 = class extends make113(ast) {
    static annotations(annotations4) {
      return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "enums", {
    ...enums
  }), _a106;
};
var Enums2 = (enums) => makeEnumsClass(enums);
var TemplateLiteral2 = (...[head13, ...tail5]) => {
  const spans = [];
  let h2 = "";
  let ts = tail5;
  if (isSchema(head13)) {
    if (isLiteral(head13.ast)) {
      h2 = String(head13.ast.literal);
    } else {
      ts = [head13, ...ts];
    }
  } else {
    h2 = String(head13);
  }
  for (let i = 0; i < ts.length; i++) {
    const item = ts[i];
    if (isSchema(item)) {
      if (i < ts.length - 1) {
        const next6 = ts[i + 1];
        if (isSchema(next6)) {
          if (isLiteral(next6.ast)) {
            spans.push(new TemplateLiteralSpan(item.ast, String(next6.ast.literal)));
            i++;
            continue;
          }
        } else {
          spans.push(new TemplateLiteralSpan(item.ast, String(next6)));
          i++;
          continue;
        }
      }
      spans.push(new TemplateLiteralSpan(item.ast, ""));
    } else {
      spans.push(new TemplateLiteralSpan(new Literal(item), ""));
    }
  }
  if (isNonEmptyArray2(spans)) {
    return make113(new TemplateLiteral(h2, spans));
  } else {
    return make113(new TemplateLiteral("", [new TemplateLiteralSpan(new Literal(h2), "")]));
  }
};
function getTemplateLiteralParserCoercedElement(encoded, schema) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal": {
      const literal3 = ast.literal;
      if (!isString(literal3)) {
        const s = String(literal3);
        return transform3(Literal2(s), schema, {
          strict: true,
          decode: () => literal3,
          encode: () => s
        });
      }
      break;
    }
    case "NumberKeyword":
      return compose6(NumberFromString, schema);
    case "Union": {
      const members = [];
      let hasCoercions = false;
      for (const member of ast.types) {
        const schema2 = make113(member);
        const encoded2 = encodedSchema(schema2);
        const coerced = getTemplateLiteralParserCoercedElement(encoded2, schema2);
        if (coerced) {
          hasCoercions = true;
        }
        members.push(coerced ?? schema2);
      }
      return hasCoercions ? compose6(Union2(...members), schema) : schema;
    }
  }
}
var TemplateLiteralParser = (...params) => {
  var _a106;
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    const schema = isSchema(param) ? param : Literal2(param);
    schemas.push(schema);
    const encoded = encodedSchema(schema);
    encodedSchemas.push(encoded);
    const element2 = getTemplateLiteralParserCoercedElement(encoded, schema);
    if (element2) {
      elements.push(element2);
      coerced = true;
    } else {
      elements.push(schema);
    }
  }
  const from29 = TemplateLiteral2(...encodedSchemas);
  const re = getTemplateLiteralCapturingRegExp(from29.ast);
  let to3 = Tuple(...elements);
  if (coerced) {
    to3 = to3.annotations({
      [AutoTitleAnnotationId]: format7(Tuple(...schemas))
    });
  }
  return _a106 = class extends transformOrFail(from29, to3, {
    strict: false,
    decode: (i, _, ast) => {
      const match43 = re.exec(i);
      return match43 ? succeed24(match43.slice(1, params.length + 1)) : fail23(new Type2(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
    },
    encode: (tuple7) => succeed24(tuple7.join(""))
  }) {
  }, __publicField(_a106, "params", params.slice()), _a106;
};
var declareConstructor = (typeParameters, options, annotations4) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make113)), (...typeParameters2) => options.encode(...typeParameters2.map(make113)), toASTAnnotations(annotations4)));
var declarePrimitive = (is4, annotations4) => {
  const decodeUnknown4 = () => (input, _, ast) => is4(input) ? succeed24(input) : fail23(new Type2(ast, input));
  const encodeUnknown3 = decodeUnknown4;
  return makeDeclareClass([], new Declaration([], decodeUnknown4, encodeUnknown3, toASTAnnotations(annotations4)));
};
function makeDeclareClass(typeParameters, ast) {
  var _a106;
  return _a106 = class extends make113(ast) {
    static annotations(annotations4) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "typeParameters", [...typeParameters]), _a106;
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations5 = arguments[2];
    return declareConstructor(typeParameters, options, annotations5);
  }
  const is4 = arguments[0];
  const annotations4 = arguments[1];
  return declarePrimitive(is4, annotations4);
};
var BrandSchemaId = Symbol.for("effect/SchemaId/Brand");
var fromBrand = (constructor, annotations4) => (self) => {
  const out = makeBrandClass(self, new Refinement(self.ast, function predicate(a, _, ast) {
    const either14 = constructor.either(a);
    return isLeft2(either14) ? some3(new Type2(ast, a, either14.left.map((v) => v.message).join(", "))) : none2();
  }, toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations4
  })));
  return out;
};
var InstanceOfSchemaId = Symbol.for("effect/SchemaId/InstanceOf");
var instanceOf3 = (constructor, annotations4) => declare((u) => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations4
});
var Undefined = class extends make113(undefinedKeyword) {
};
var Void = class extends make113(voidKeyword) {
};
var Null = class extends make113($null) {
};
var Never = class extends make113(neverKeyword) {
};
var Unknown = class extends make113(unknownKeyword) {
};
var Any = class extends make113(anyKeyword) {
};
var BigIntFromSelf = class extends make113(bigIntKeyword) {
};
var SymbolFromSelf = class extends make113(symbolKeyword) {
};
var String$ = class extends make113(stringKeyword) {
};
var Number$ = class extends make113(numberKeyword) {
};
var Boolean$ = class extends make113(booleanKeyword) {
};
var Object$ = class extends make113(objectKeyword) {
};
var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  var _a106;
  return _a106 = class extends make113(ast) {
    static annotations(annotations4) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "members", [...members]), _a106;
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var NullOr = (self) => Union2(self, Null);
var UndefinedOr = (self) => Union2(self, Undefined);
var NullishOr = (self) => Union2(self, Null, Undefined);
var keyof2 = (self) => make113(keyof(self.ast));
var element = (self) => new ElementImpl(new OptionalType(self.ast, false), self);
var optionalElement = (self) => new ElementImpl(new OptionalType(self.ast, true), self);
var _a81;
_a81 = TypeId39;
var _ElementImpl = class _ElementImpl {
  constructor(ast, from29) {
    __publicField(this, "ast");
    __publicField(this, "from");
    __publicField(this, _a81);
    __publicField(this, "_Token");
    this.ast = ast;
    this.from = from29;
  }
  annotations(annotations4) {
    return new _ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations4)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
};
var ElementImpl = _ElementImpl;
var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  var _a106;
  return _a106 = class extends make113(ast) {
    static annotations(annotations4) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "elements", [...elements]), __publicField(_a106, "rest", [...rest]), _a106;
}
function Tuple(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
function makeArrayClass(value10, ast) {
  var _a106;
  return _a106 = class extends makeTupleTypeClass([], [value10], ast) {
    static annotations(annotations4) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "value", value10), _a106;
}
var Array$ = (value10) => makeArrayClass(value10);
function makeNonEmptyArrayClass(value10, ast) {
  var _a106;
  return _a106 = class extends makeTupleTypeClass([value10], [value10], ast) {
    static annotations(annotations4) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "value", value10), _a106;
}
var NonEmptyArray = (value10) => makeNonEmptyArrayClass(value10);
function ArrayEnsure(value10) {
  return transform3(Union2(value10, Array$(value10)), Array$(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => ensure(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
function NonEmptyArrayEnsure(value10) {
  return transform3(Union2(value10, NonEmptyArray(value10)), NonEmptyArray(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => isNonEmptyReadonlyArray(i) ? i : of2(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';
var PropertySignatureDeclaration = class extends OptionalType {
  constructor(type8, isOptional, isReadonly, annotations4, defaultValue) {
    super(type8, isOptional, annotations4);
    __publicField(this, "isReadonly");
    __publicField(this, "defaultValue");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "PropertySignatureDeclaration");
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type8 = String(this.type);
    return `PropertySignature<${token}, ${type8}, never, ${token}, ${type8}>`;
  }
};
var FromPropertySignature = class extends OptionalType {
  constructor(type8, isOptional, isReadonly, annotations4, fromKey2) {
    super(type8, isOptional, annotations4);
    __publicField(this, "isReadonly");
    __publicField(this, "fromKey");
    this.isReadonly = isReadonly;
    this.fromKey = fromKey2;
  }
};
var ToPropertySignature = class extends OptionalType {
  constructor(type8, isOptional, isReadonly, annotations4, defaultValue) {
    super(type8, isOptional, annotations4);
    __publicField(this, "isReadonly");
    __publicField(this, "defaultValue");
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
var formatPropertyKey2 = (p) => {
  if (p === void 0) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
var PropertySignatureTransformation2 = class {
  constructor(from29, to3, decode11, encode16) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "decode");
    __publicField(this, "encode");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "PropertySignatureTransformation");
    this.from = from29;
    this.to = to3;
    this.decode = decode11;
    this.encode = encode16;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
};
var mergeSignatureAnnotations = (ast, annotations4) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations4
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations4
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = Symbol.for("effect/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var _a82, _b28;
_b28 = TypeId39, _a82 = PropertySignatureTypeId;
var _PropertySignatureImpl = class _PropertySignatureImpl {
  constructor(ast) {
    __publicField(this, "ast");
    __publicField(this, _b28);
    __publicField(this, _a82, null);
    __publicField(this, "_TypeToken");
    __publicField(this, "_Key");
    __publicField(this, "_EncodedToken");
    __publicField(this, "_HasDefault");
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations4) {
    return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations4)));
  }
  toString() {
    return String(this.ast);
  }
};
var PropertySignatureImpl = _PropertySignatureImpl;
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);
var PropertySignatureWithFromImpl = class _PropertySignatureWithFromImpl extends PropertySignatureImpl {
  constructor(ast, from29) {
    super(ast);
    __publicField(this, "from");
    this.from = from29;
  }
  annotations(annotations4) {
    return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations4)), this.from);
  }
};
var propertySignature = (self) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, void 0), self);
var withConstructorDefault = dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue = (o, defaultValue) => match2(o, {
  onNone: () => some3(defaultValue()),
  onSome: (value10) => some3(value10 === void 0 ? defaultValue() : value10)
});
var pruneUndefined3 = (ast) => pruneUndefined(ast, pruneUndefined3, (ast2) => {
  const pruned = pruneUndefined3(ast2.to);
  if (pruned) {
    return new Transformation(ast2.from, pruned, ast2.transformation);
  }
});
var withDecodingDefault = dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      const to3 = typeAST(ast.type);
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined3(to3) ?? to3, false, true, {}, ast.defaultValue), (o) => applyDefaultValue(o, defaultValue), identity));
    }
    case "PropertySignatureTransformation": {
      const to3 = ast.to.type;
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(pruneUndefined3(to3) ?? to3, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
    }
  }
});
var withDefaults = dual(2, (self, defaults) => self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
var fromKey = dual(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired = (from29, to3, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from29.ast, true, true, {}, void 0), new ToPropertySignature(to3.ast, false, true, {}, void 0), (o) => some3(options.decode(o)), flatMap2(options.encode)));
var requiredToOptional = (from29, to3, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from29.ast, false, true, {}, void 0), new ToPropertySignature(to3.ast, true, true, {}, void 0), flatMap2(options.decode), (o) => some3(options.encode(o))));
var optionalToOptional = (from29, to3, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from29.ast, true, true, {}, void 0), new ToPropertySignature(to3.ast, true, true, {}, void 0), options.decode, options.encode));
var optionalPropertySignatureAST = (self, options) => {
  const isExact = options == null ? void 0 : options.exact;
  const defaultValue = options == null ? void 0 : options.default;
  const isNullable2 = options == null ? void 0 : options.nullable;
  const asOption = (options == null ? void 0 : options.as) == "Option";
  const asOptionEncode = (options == null ? void 0 : options.onNoneEncoding) ? orElse2(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === null ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(self, typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some3
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(self, OptionFromSelf(typeSchema(self)), {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullOr(self), typeSchema(self), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(self.ast, true, true, {}, void 0);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullishOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a == null ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === void 0 ? defaultValue() : a
          }),
          encode: some3
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullishOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullishOr(self), UndefinedOr(typeSchema(self)), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, void 0);
      }
    }
  }
};
var optional = (self) => {
  const ast = self.ast === undefinedKeyword || self.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self);
};
var optionalWith = dual((args2) => isSchema(args2[0]), (self, options) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self);
});
var preserveMissingMessageAnnotation = pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys2 = ownKeys(fields);
  const pss = [];
  if (ownKeys2.length > 0) {
    const from29 = [];
    const to3 = [];
    const transformations = [];
    for (let i = 0; i < ownKeys2.length; i++) {
      const key = ownKeys2[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type8 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from29.push(new PropertySignature(key, type8, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to3.push(new PropertySignature(key, typeAST(type8), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type8, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey2 = ast.from.fromKey ?? key;
            from29.push(new PropertySignature(fromKey2, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to3.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey2, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from29.push(new PropertySignature(key, field.ast, false, true));
        to3.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from29.push(ps);
          to3.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature(is4.parameter, typeAST(is4.type), is4.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from29, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to3, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record2(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys2 = ownKeys(fields);
  for (const key of ownKeys2) {
    const field = fields[key];
    if (out[key] === void 0 && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  var _a106;
  return _a106 = class extends make113(ast) {
    static annotations(annotations4) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations4));
    }
    static pick(...keys15) {
      return Struct(pick4(fields, ...keys15));
    }
    static omit(...keys15) {
      return Struct(omit4(fields, ...keys15));
    }
  }, __publicField(_a106, "fields", {
    ...fields
  }), __publicField(_a106, "records", [...records]), __publicField(_a106, "make", (props, options) => {
    const propsWithDefaults = lazilyMergeDefaults(fields, {
      ...props
    });
    return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(_a106)(propsWithDefaults);
  }), _a106;
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
var tag4 = (tag5) => Literal2(tag5).pipe(propertySignature, withConstructorDefault(() => tag5));
var TaggedStruct = (value10, fields) => Struct({
  _tag: tag4(value10),
  ...fields
});
function makeRecordClass(key, value10, ast) {
  var _a106;
  return _a106 = class extends makeTypeLiteralClass({}, [{
    key,
    value: value10
  }], ast) {
    static annotations(annotations4) {
      return makeRecordClass(key, value10, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "key", key), __publicField(_a106, "value", value10), _a106;
}
var Record = (options) => makeRecordClass(options.key, options.value);
var pick5 = (...keys15) => (self) => make113(pick(self.ast, keys15));
var omit5 = (...keys15) => (self) => make113(omit(self.ast, keys15));
var pluck = dual(2, (schema, key) => {
  const ps = getPropertyKeyIndexedAccess(typeAST(schema.ast), key);
  const value10 = make113(ps.isOptional ? orUndefined(ps.type) : ps.type);
  const out = transform3(schema.pipe(pick5(key)), value10, {
    strict: true,
    decode: (i) => i[key],
    encode: (a) => ps.isOptional && a === void 0 ? {} : {
      [key]: a
    }
  });
  return out;
});
function makeBrandClass(from29, ast) {
  var _a106;
  return _a106 = class extends make113(ast) {
    static annotations(annotations4) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "make", (a, options) => {
    return getDisableValidationMakeOption(options) ? a : validateSync(_a106)(a);
  }), __publicField(_a106, "from", from29), _a106;
}
var brand = (brand2, annotations4) => (self) => {
  const annotation = match2(getBrandAnnotation(self.ast), {
    onNone: () => [brand2],
    onSome: (brands) => [...brands, brand2]
  });
  const ast = annotations(self.ast, toASTAnnotations({
    [BrandAnnotationId]: annotation,
    ...annotations4
  }));
  return makeBrandClass(self, ast);
};
var partial2 = (self) => make113(partial(self.ast));
var partialWith = dual((args2) => isSchema(args2[0]), (self, options) => make113(partial(self.ast, options)));
var required2 = (self) => make113(required(self.ast));
var mutable2 = (schema) => make113(mutable(schema.ast));
var intersectTypeLiterals = (x, y, path2) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type8
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type8, ps.type, path2.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path2));
};
var preserveRefinementAnnotations = omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path2) => Union.make(intersectUnionMembers([x], [y], path2));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path2) => flatMap4(xs, (x) => flatMap4(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path2);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path2))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path2));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path2);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path2))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path2));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path2)];
        case "Transformation": {
          const transformation = x.transformation;
          const from29 = intersectTypeLiterals(x.from, y, path2);
          const to3 = intersectTypeLiterals(x.to, typeAST(y), path2);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from29, to3, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from29, to3, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from29, to3, new FinalTransformation((fromA, options, ast, fromI) => map37(transformation.decode(fromA, options, ast, fromI), (partial3) => ({
                ...fromA,
                ...partial3
              })), (toI, options, ast, toA) => map37(transformation.encode(toI, options, ast, toA), (partial3) => ({
                ...toI,
                ...partial3
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path2), intersectTypeLiterals(x.to, y.to, path2), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path2);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path2));
}));
var extend4 = dual(2, (self, that) => make113(extendAST(self.ast, that.ast, [])));
var compose6 = dual((args2) => isSchema(args2[1]), (from29, to3) => makeTransformationClass(from29, to3, compose3(from29.ast, to3.ast)));
var suspend15 = (f2) => make113(new Suspend(() => f2().ast));
var RefineSchemaId = Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from29, filter26, ast) {
  var _a106, _b32, _c7;
  return _c7 = class extends (_b32 = make113(ast), _a106 = RefineSchemaId, _b32) {
    static annotations(annotations4) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_c7, _a106, from29), __publicField(_c7, "from", from29), __publicField(_c7, "filter", filter26), __publicField(_c7, "make", (a, options) => {
    return getDisableValidationMakeOption(options) ? a : validateSync(_c7)(a);
  }), _c7;
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some3(new Type2(ast, input));
  }
  if (isString(item)) {
    return some3(new Type2(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some3(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some3(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap4(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some3(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter22(predicate, annotations4) {
  return (self) => {
    function filter26(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement(self.ast, filter26, toASTAnnotations(annotations4));
    return makeRefineClass(self, filter26, ast);
  };
}
var filterEffect2 = dual(2, (self, f2) => transformOrFail(self, typeSchema(self), {
  strict: true,
  decode: (i, options, ast) => flatMap25(f2(i, options, ast), (filterReturnType) => match2(toFilterParseIssue(filterReturnType, ast, i), {
    onNone: () => succeed24(i),
    onSome: fail23
  })),
  encode: (a) => succeed24(a)
}));
function makeTransformationClass(from29, to3, ast) {
  var _a106;
  return _a106 = class extends make113(ast) {
    static annotations(annotations4) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations4));
    }
  }, __publicField(_a106, "from", from29), __publicField(_a106, "to", to3), _a106;
}
var transformOrFail = dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from29, to3, options) => makeTransformationClass(from29, to3, new Transformation(from29.ast, to3.ast, new FinalTransformation(options.decode, options.encode))));
var transform3 = dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from29, to3, options) => transformOrFail(from29, to3, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed24(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed24(options.encode(toI, toA))
}));
function transformLiteral(from29, to3) {
  return transform3(Literal2(from29), Literal2(to3), {
    strict: true,
    decode: () => to3,
    encode: () => from29
  });
}
function transformLiterals(...pairs) {
  return Union2(...pairs.map(([from29, to3]) => transformLiteral(from29, to3)));
}
var attachPropertySignature = dual((args2) => isSchema(args2[0]), (schema, key, value10, annotations4) => {
  const ast = extend4(typeSchema(schema), Struct({
    [key]: isSymbol(value10) ? UniqueSymbolFromSelf(value10) : Literal2(value10)
  })).ast;
  return make113(new Transformation(schema.ast, annotations4 ? mergeSchemaAnnotations(ast, annotations4) : ast, new TypeLiteralTransformation([new PropertySignatureTransformation(key, key, () => some3(value10), () => none2())])));
});
var annotations2 = dual(2, (self, annotations4) => self.annotations(annotations4));
var rename2 = dual(2, (self, mapping) => make113(rename(self.ast, mapping)));
var TrimmedSchemaId = Symbol.for("effect/SchemaId/Trimmed");
var trimmed = (annotations4) => (self) => self.pipe(filter22((a) => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations4
}));
var MaxLengthSchemaId2 = MaxLengthSchemaId;
var maxLength = (maxLength2, annotations4) => (self) => self.pipe(filter22((a) => a.length <= maxLength2, {
  schemaId: MaxLengthSchemaId2,
  title: `maxLength(${maxLength2})`,
  description: `a string at most ${maxLength2} character(s) long`,
  jsonSchema: {
    maxLength: maxLength2
  },
  ...annotations4
}));
var MinLengthSchemaId2 = MinLengthSchemaId;
var minLength = (minLength2, annotations4) => (self) => self.pipe(filter22((a) => a.length >= minLength2, {
  schemaId: MinLengthSchemaId2,
  title: `minLength(${minLength2})`,
  description: `a string at least ${minLength2} character(s) long`,
  jsonSchema: {
    minLength: minLength2
  },
  ...annotations4
}));
var LengthSchemaId2 = LengthSchemaId;
var length5 = (length6, annotations4) => (self) => {
  const minLength2 = isObject(length6) ? Math.max(0, Math.floor(length6.min)) : Math.max(0, Math.floor(length6));
  const maxLength2 = isObject(length6) ? Math.max(minLength2, Math.floor(length6.max)) : minLength2;
  if (minLength2 !== maxLength2) {
    return self.pipe(filter22((a) => a.length >= minLength2 && a.length <= maxLength2, {
      schemaId: LengthSchemaId2,
      title: `length({ min: ${minLength2}, max: ${maxLength2})`,
      description: `a string at least ${minLength2} character(s) and at most ${maxLength2} character(s) long`,
      jsonSchema: {
        minLength: minLength2,
        maxLength: maxLength2
      },
      ...annotations4
    }));
  }
  return self.pipe(filter22((a) => a.length === minLength2, {
    schemaId: LengthSchemaId2,
    title: `length(${minLength2})`,
    description: minLength2 === 1 ? `a single character` : `a string ${minLength2} character(s) long`,
    jsonSchema: {
      minLength: minLength2,
      maxLength: minLength2
    },
    ...annotations4
  }));
};
var PatternSchemaId = Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations4) => (self) => {
  const source = regex.source;
  return self.pipe(filter22((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations4
  }));
};
var StartsWithSchemaId = Symbol.for("effect/SchemaId/StartsWith");
var startsWith2 = (startsWith3, annotations4) => (self) => {
  const formatted = JSON.stringify(startsWith3);
  return self.pipe(filter22((a) => a.startsWith(startsWith3), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith: startsWith3
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith3}`
    },
    ...annotations4
  }));
};
var EndsWithSchemaId = Symbol.for("effect/SchemaId/EndsWith");
var endsWith2 = (endsWith3, annotations4) => (self) => {
  const formatted = JSON.stringify(endsWith3);
  return self.pipe(filter22((a) => a.endsWith(endsWith3), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith: endsWith3
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith3}$`
    },
    ...annotations4
  }));
};
var IncludesSchemaId = Symbol.for("effect/SchemaId/Includes");
var includes3 = (searchString, annotations4) => (self) => {
  const formatted = JSON.stringify(searchString);
  return self.pipe(filter22((a) => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations4
  }));
};
var LowercasedSchemaId = Symbol.for("effect/SchemaId/Lowercased");
var lowercased = (annotations4) => (self) => self.pipe(filter22((a) => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations4
}));
var Lowercased = class extends String$.pipe(lowercased({
  identifier: "Lowercased"
})) {
};
var UppercasedSchemaId = Symbol.for("effect/SchemaId/Uppercased");
var uppercased = (annotations4) => (self) => self.pipe(filter22((a) => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations4
}));
var Uppercased = class extends String$.pipe(uppercased({
  identifier: "Uppercased"
})) {
};
var CapitalizedSchemaId = Symbol.for("effect/SchemaId/Capitalized");
var capitalized = (annotations4) => (self) => self.pipe(filter22((a) => {
  var _a106;
  return ((_a106 = a[0]) == null ? void 0 : _a106.toUpperCase()) === a[0];
}, {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations4
}));
var Capitalized = class extends String$.pipe(capitalized({
  identifier: "Capitalized"
})) {
};
var UncapitalizedSchemaId = Symbol.for("effect/SchemaId/Uncapitalized");
var uncapitalized = (annotations4) => (self) => self.pipe(filter22((a) => {
  var _a106;
  return ((_a106 = a[0]) == null ? void 0 : _a106.toLowerCase()) === a[0];
}, {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations4
}));
var Uncapitalized = class extends String$.pipe(uncapitalized({
  identifier: "Uncapitalized"
})) {
};
var Char = class extends String$.pipe(length5(1, {
  identifier: "Char"
})) {
};
var nonEmptyString5 = (annotations4) => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations4
});
var Lowercase = class extends transform3(String$.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased, {
  strict: true,
  decode: (i) => i.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
}) {
};
var Uppercase = class extends transform3(String$.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased, {
  strict: true,
  decode: (i) => i.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
}) {
};
var Capitalize = class extends transform3(String$.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized, {
  strict: true,
  decode: (i) => capitalize(i),
  encode: identity
}).annotations({
  identifier: "Capitalize"
}) {
};
var Uncapitalize = class extends transform3(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
  strict: true,
  decode: (i) => uncapitalize(i),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
}) {
};
var Trimmed = class extends String$.pipe(trimmed({
  identifier: "Trimmed"
})) {
};
var NonEmptyTrimmedString = class extends Trimmed.pipe(nonEmptyString5({
  identifier: "NonEmptyTrimmedString"
})) {
};
var Trim = class extends transform3(String$.annotations({
  description: "a string that will be trimmed"
}), Trimmed, {
  strict: true,
  decode: (i) => i.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
}) {
};
var split5 = (separator) => transform3(String$.annotations({
  description: "a string that will be split"
}), Array$(String$), {
  strict: true,
  decode: (i) => i.split(separator),
  encode: (a) => a.join(separator)
});
var getErrorMessage2 = (e) => e instanceof Error ? e.message : String(e);
var getParseJsonTransformation = (options) => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => JSON.parse(i, options == null ? void 0 : options.reviver),
    catch: (e) => new Type2(ast, i, getErrorMessage2(e))
  }),
  encode: (a, _, ast) => _try({
    try: () => JSON.stringify(a, options == null ? void 0 : options.replacer, options == null ? void 0 : options.space),
    catch: (e) => new Type2(ast, a, getErrorMessage2(e))
  })
}).annotations({
  title: "parseJson",
  schemaId: ParseJsonSchemaId
});
var parseJson = (schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose6(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
var NonEmptyString = class extends String$.pipe(nonEmptyString5({
  identifier: "NonEmptyString"
})) {
};
var UUIDSchemaId = Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var UUID = class extends String$.pipe(pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
})) {
};
var ULIDSchemaId = Symbol.for("effect/SchemaId/ULID");
var ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
var ULID = class extends String$.pipe(pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => (fc) => fc.ulid()
})) {
};
var URLFromSelf = class extends instanceOf3(URL, {
  identifier: "URLFromSelf",
  arbitrary: () => (fc) => fc.webUrl().map((s) => new URL(s)),
  pretty: () => (url3) => url3.toString()
}) {
};
var URL$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
}), URLFromSelf, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => new URL(i),
    catch: (e) => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage2(e)}`)
  }),
  encode: (a) => succeed24(a.toString())
}).annotations({
  identifier: "URL",
  pretty: () => (url3) => url3.toString()
}) {
};
var FiniteSchemaId2 = FiniteSchemaId;
var finite = (annotations4) => (self) => self.pipe(filter22(Number.isFinite, {
  schemaId: FiniteSchemaId2,
  title: "finite",
  description: "a finite number",
  jsonSchema: {
    "type": "number"
  },
  ...annotations4
}));
var GreaterThanSchemaId2 = GreaterThanSchemaId;
var greaterThan11 = (exclusiveMinimum, annotations4) => (self) => self.pipe(filter22((a) => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId2,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations4
}));
var GreaterThanOrEqualToSchemaId2 = GreaterThanOrEqualToSchemaId;
var greaterThanOrEqualTo8 = (minimum, annotations4) => (self) => self.pipe(filter22((a) => a >= minimum, {
  schemaId: GreaterThanOrEqualToSchemaId2,
  title: `greaterThanOrEqualTo(${minimum})`,
  description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
  jsonSchema: {
    minimum
  },
  ...annotations4
}));
var MultipleOfSchemaId = Symbol.for("effect/SchemaId/MultipleOf");
var multipleOf = (divisor, annotations4) => (self) => {
  const positiveDivisor = Math.abs(divisor);
  return self.pipe(filter22((a) => remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations4
  }));
};
var IntSchemaId2 = IntSchemaId;
var int = (annotations4) => (self) => self.pipe(filter22((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations4
}));
var LessThanSchemaId2 = LessThanSchemaId;
var lessThan15 = (exclusiveMaximum, annotations4) => (self) => self.pipe(filter22((a) => a < exclusiveMaximum, {
  schemaId: LessThanSchemaId2,
  title: `lessThan(${exclusiveMaximum})`,
  description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
  jsonSchema: {
    exclusiveMaximum
  },
  ...annotations4
}));
var LessThanOrEqualToSchemaId2 = LessThanOrEqualToSchemaId;
var lessThanOrEqualTo8 = (maximum, annotations4) => (self) => self.pipe(filter22((a) => a <= maximum, {
  schemaId: LessThanOrEqualToSchemaId2,
  title: `lessThanOrEqualTo(${maximum})`,
  description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
  jsonSchema: {
    maximum
  },
  ...annotations4
}));
var BetweenSchemaId2 = BetweenSchemaId;
var between8 = (minimum, maximum, annotations4) => (self) => self.pipe(filter22((a) => a >= minimum && a <= maximum, {
  schemaId: BetweenSchemaId2,
  title: `between(${minimum}, ${maximum})`,
  description: `a number between ${minimum} and ${maximum}`,
  jsonSchema: {
    minimum,
    maximum
  },
  ...annotations4
}));
var NonNaNSchemaId2 = NonNaNSchemaId;
var nonNaN = (annotations4) => (self) => self.pipe(filter22((a) => !Number.isNaN(a), {
  schemaId: NonNaNSchemaId2,
  title: "nonNaN",
  description: "a number excluding NaN",
  ...annotations4
}));
var positive = (annotations4) => greaterThan11(0, {
  title: "positive",
  ...annotations4
});
var negative = (annotations4) => lessThan15(0, {
  title: "negative",
  ...annotations4
});
var nonPositive = (annotations4) => lessThanOrEqualTo8(0, {
  title: "nonPositive",
  ...annotations4
});
var nonNegative = (annotations4) => greaterThanOrEqualTo8(0, {
  title: "nonNegative",
  ...annotations4
});
var clamp9 = (minimum, maximum) => (self) => {
  return transform3(self, typeSchema(self).pipe(between8(minimum, maximum)), {
    strict: false,
    decode: (i) => clamp3(i, {
      minimum,
      maximum
    }),
    encode: identity
  });
};
function parseNumber(self) {
  return transformOrFail(self, Number$, {
    strict: false,
    decode: (i, _, ast) => fromOption9(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed24(String(a))
  });
}
var NumberFromString = class extends parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
}) {
};
var Finite = class extends Number$.pipe(finite({
  identifier: "Finite"
})) {
};
var Int = class extends Number$.pipe(int({
  identifier: "Int"
})) {
};
var NonNaN = class extends Number$.pipe(nonNaN({
  identifier: "NonNaN"
})) {
};
var Positive = class extends Number$.pipe(positive({
  identifier: "Positive"
})) {
};
var Negative = class extends Number$.pipe(negative({
  identifier: "Negative"
})) {
};
var NonPositive = class extends Number$.pipe(nonPositive({
  identifier: "NonPositive"
})) {
};
var NonNegative = class extends Number$.pipe(nonNegative({
  identifier: "NonNegative"
})) {
};
var JsonNumberSchemaId2 = JsonNumberSchemaId;
var JsonNumber = class extends Number$.pipe(finite({
  schemaId: JsonNumberSchemaId2,
  identifier: "JsonNumber"
})) {
};
var Not = class extends transform3(Boolean$.annotations({
  description: "a boolean that will be negated"
}), Boolean$, {
  strict: true,
  decode: (i) => not2(i),
  encode: (a) => not2(a)
}) {
};
var encodeSymbol2 = (sym, ast) => {
  const key = Symbol.keyFor(sym);
  return key === void 0 ? fail23(new Type2(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : succeed24(key);
};
var decodeSymbol = (s) => succeed24(Symbol.for(s));
var Symbol$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: (i) => decodeSymbol(i),
  encode: (a, _, ast) => encodeSymbol2(a, ast)
}).annotations({
  identifier: "Symbol"
}) {
};
var GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
var greaterThanBigInt = (min11, annotations4) => (self) => self.pipe(filter22((a) => a > min11, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min: min11
  },
  title: `greaterThanBigInt(${min11})`,
  description: min11 === 0n ? "a positive bigint" : `a bigint greater than ${min11}n`,
  ...annotations4
}));
var GreaterThanOrEqualToBigIntSchemaId2 = GreaterThanOrEqualToBigIntSchemaId;
var greaterThanOrEqualToBigInt = (min11, annotations4) => (self) => self.pipe(filter22((a) => a >= min11, {
  schemaId: GreaterThanOrEqualToBigIntSchemaId2,
  [GreaterThanOrEqualToBigIntSchemaId2]: {
    min: min11
  },
  title: `greaterThanOrEqualToBigInt(${min11})`,
  description: min11 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min11}n`,
  ...annotations4
}));
var LessThanBigIntSchemaId2 = LessThanBigIntSchemaId;
var lessThanBigInt = (max14, annotations4) => (self) => self.pipe(filter22((a) => a < max14, {
  schemaId: LessThanBigIntSchemaId2,
  [LessThanBigIntSchemaId2]: {
    max: max14
  },
  title: `lessThanBigInt(${max14})`,
  description: max14 === 0n ? "a negative bigint" : `a bigint less than ${max14}n`,
  ...annotations4
}));
var LessThanOrEqualToBigIntSchemaId2 = LessThanOrEqualToBigIntSchemaId;
var lessThanOrEqualToBigInt = (max14, annotations4) => (self) => self.pipe(filter22((a) => a <= max14, {
  schemaId: LessThanOrEqualToBigIntSchemaId2,
  [LessThanOrEqualToBigIntSchemaId2]: {
    max: max14
  },
  title: `lessThanOrEqualToBigInt(${max14})`,
  description: max14 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max14}n`,
  ...annotations4
}));
var BetweenBigIntSchemaId = BetweenBigintSchemaId;
var betweenBigInt = (min11, max14, annotations4) => (self) => self.pipe(filter22((a) => a >= min11 && a <= max14, {
  schemaId: BetweenBigIntSchemaId,
  [BetweenBigIntSchemaId]: {
    min: min11,
    max: max14
  },
  title: `betweenBigInt(${min11}, ${max14})`,
  description: `a bigint between ${min11}n and ${max14}n`,
  ...annotations4
}));
var positiveBigInt = (annotations4) => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations4
});
var negativeBigInt = (annotations4) => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations4
});
var nonNegativeBigInt = (annotations4) => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations4
});
var nonPositiveBigInt = (annotations4) => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations4
});
var clampBigInt = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp5(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var BigInt$ = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromOption9(fromString4(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)),
  encode: (a) => succeed24(String(a))
}).annotations({
  identifier: "BigInt"
}) {
};
var PositiveBigIntFromSelf = BigIntFromSelf.pipe(positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
var PositiveBigInt = BigInt$.pipe(positiveBigInt({
  identifier: "PositiveBigint"
}));
var NegativeBigIntFromSelf = BigIntFromSelf.pipe(negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
var NegativeBigInt = BigInt$.pipe(negativeBigInt({
  identifier: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf = BigIntFromSelf.pipe(nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt = BigInt$.pipe(nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf = BigIntFromSelf.pipe(nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt = BigInt$.pipe(nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));
var BigIntFromNumber = class extends transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: (i, _, ast) => fromOption9(fromNumber4(i), () => new Type2(ast, i, `Unable to decode ${i} into a bigint`)),
  encode: (a, _, ast) => fromOption9(toNumber3(a), () => new Type2(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
  identifier: "BigIntFromNumber"
}) {
};
var redactedArbitrary = (value10) => (fc) => value10(fc).map(make108);
var toComposite = (eff, onSuccess, ast, actual) => mapBoth10(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
});
var redactedParse = (decodeUnknown4) => (u, options, ast) => isRedacted2(u) ? toComposite(decodeUnknown4(value8(u), options), make108, ast, u) : fail23(new Type2(ast, u));
var RedactedFromSelf = (value10) => declare([value10], {
  decode: (value11) => redactedParse(decodeUnknown2(value11)),
  encode: (value11) => redactedParse(encodeUnknown(value11))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: getEquivalence9
});
function Redacted(value10) {
  return transform3(value10, RedactedFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => make108(i),
    encode: (a) => value8(a)
  });
}
var DurationFromSelf = class extends declare(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
    min: 0n
  }).map((_) => nanos(_)), fc.maxSafeNat().map((_) => millis(_))),
  equivalence: () => Equivalence5
}) {
};
var DurationFromNanos = class extends transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter22((duration5) => isFinite(duration5), {
  description: "a finite duration"
})), {
  strict: true,
  decode: (i) => succeed24(nanos(i)),
  encode: (a, _, ast) => match2(toNanos(a), {
    onNone: () => fail23(new Type2(ast, a, `Unable to encode ${a} into a bigint`)),
    onSome: (nanos2) => succeed24(nanos2)
  })
}).annotations({
  identifier: "DurationFromNanos"
}) {
};
var NonNegativeInt = NonNegative.pipe(int()).annotations({
  identifier: "NonNegativeInt"
});
var DurationFromMillis = class extends transform3(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: (i) => millis(i),
  encode: (a) => toMillis(a)
}).annotations({
  identifier: "DurationFromMillis"
}) {
};
var DurationValueMillis = TaggedStruct("Millis", {
  millis: NonNegativeInt
});
var DurationValueNanos = TaggedStruct("Nanos", {
  nanos: BigInt$
});
var DurationValueInfinity = TaggedStruct("Infinity", {});
var durationValueInfinity = DurationValueInfinity.make({});
var DurationValue = Union2(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
var FiniteHRTime = Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
var InfiniteHRTime = Tuple(Literal2(-1), Literal2(0)).annotations({
  identifier: "InfiniteHRTime"
});
var HRTime = Union2(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
var isDurationValue = (u) => typeof u === "object";
var Duration = class extends transform3(Union2(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: (i) => {
    if (isDurationValue(i)) {
      switch (i._tag) {
        case "Millis":
          return millis(i.millis);
        case "Nanos":
          return nanos(i.nanos);
        case "Infinity":
          return infinity;
      }
    }
    const [seconds2, nanos2] = i;
    return seconds2 === -1 ? infinity : nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2));
  },
  encode: (a) => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }
}).annotations({
  identifier: "Duration"
}) {
};
var clampDuration = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp6(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var LessThanDurationSchemaId = Symbol.for("effect/SchemaId/LessThanDuration");
var lessThanDuration = (max14, annotations4) => (self) => self.pipe(filter22((a) => lessThan5(a, max14), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max14
  },
  title: `lessThanDuration(${max14})`,
  description: `a Duration less than ${decode(max14)}`,
  ...annotations4
}));
var LessThanOrEqualToDurationSchemaId = Symbol.for("effect/schema/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration = (max14, annotations4) => (self) => self.pipe(filter22((a) => lessThanOrEqualTo5(a, max14), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max14
  },
  title: `lessThanOrEqualToDuration(${max14})`,
  description: `a Duration less than or equal to ${decode(max14)}`,
  ...annotations4
}));
var GreaterThanDurationSchemaId = Symbol.for("effect/SchemaId/GreaterThanDuration");
var greaterThanDuration = (min11, annotations4) => (self) => self.pipe(filter22((a) => greaterThan5(a, min11), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min: min11
  },
  title: `greaterThanDuration(${min11})`,
  description: `a Duration greater than ${decode(min11)}`,
  ...annotations4
}));
var GreaterThanOrEqualToDurationSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration = (min11, annotations4) => (self) => self.pipe(filter22((a) => greaterThanOrEqualTo5(a, min11), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min: min11
  },
  title: `greaterThanOrEqualToDuration(${min11})`,
  description: `a Duration greater than or equal to ${decode(min11)}`,
  ...annotations4
}));
var BetweenDurationSchemaId = Symbol.for("effect/SchemaId/BetweenDuration");
var betweenDuration = (minimum, maximum, annotations4) => (self) => self.pipe(filter22((a) => between5(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations4
}));
var Uint8ArrayFromSelf = class extends declare(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => (fc) => fc.uint8Array(),
  equivalence: () => getEquivalence5(equals)
}) {
};
var Uint8 = class extends Number$.pipe(between8(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
})) {
};
var Uint8Array$ = class extends transform3(Array$(Uint8).annotations({
  description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i) => Uint8Array.from(i),
  encode: (a) => Array.from(a)
}).annotations({
  identifier: "Uint8Array"
}) {
};
var makeUint8ArrayTransformation = (id3, decode11, encode16) => transformOrFail(String$.annotations({
  description: "a string to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode11(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed24(encode16(a))
}).annotations({
  identifier: id3
});
var Uint8ArrayFromBase64 = makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
var Uint8ArrayFromBase64Url = makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
var Uint8ArrayFromHex = makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
var makeEncodingTransformation = (id3, decode11, encode16) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id3}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode11(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed24(encode16(a))
}).annotations({
  identifier: `StringFrom${id3}`
});
var StringFromBase64 = makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
var StringFromBase64Url = makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
var StringFromHex = makeEncodingTransformation("Hex", decodeHexString, encodeHex);
var StringFromUriComponent = transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decodeUriComponent(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a, _, ast) => mapLeft(encodeUriComponent(a), (encodeException) => new Type2(ast, a, encodeException.message))
}).annotations({
  identifier: `StringFromUriComponent`
});
var MinItemsSchemaId2 = MinItemsSchemaId;
var minItems = (n, annotations4) => (self) => {
  const minItems2 = Math.floor(n);
  if (minItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter22((a) => a.length >= minItems2, {
    schemaId: MinItemsSchemaId2,
    title: `minItems(${minItems2})`,
    description: `an array of at least ${minItems2} item(s)`,
    jsonSchema: {
      minItems: minItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations4
  }));
};
var MaxItemsSchemaId2 = MaxItemsSchemaId;
var maxItems = (n, annotations4) => (self) => {
  const maxItems2 = Math.floor(n);
  if (maxItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter22((a) => a.length <= maxItems2, {
    schemaId: MaxItemsSchemaId2,
    title: `maxItems(${maxItems2})`,
    description: `an array of at most ${maxItems2} item(s)`,
    jsonSchema: {
      maxItems: maxItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations4
  }));
};
var ItemsCountSchemaId2 = ItemsCountSchemaId;
var itemsCount = (n, annotations4) => (self) => {
  const itemsCount2 = Math.floor(n);
  if (itemsCount2 < 0) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
  }
  return self.pipe(filter22((a) => a.length === itemsCount2, {
    schemaId: ItemsCountSchemaId2,
    title: `itemsCount(${itemsCount2})`,
    description: `an array of exactly ${itemsCount2} item(s)`,
    jsonSchema: {
      minItems: itemsCount2,
      maxItems: itemsCount2
    },
    [StableFilterAnnotationId]: true,
    ...annotations4
  }));
};
var getNumberIndexedAccess2 = (self) => make113(getNumberIndexedAccess(self.ast));
function head11(self) {
  return transform3(self, OptionFromSelf(getNumberIndexedAccess2(typeSchema(self))), {
    strict: false,
    decode: (i) => head2(i),
    encode: (a) => match2(a, {
      onNone: () => [],
      onSome: of2
    })
  });
}
function headNonEmpty3(self) {
  return transform3(self, getNumberIndexedAccess2(typeSchema(self)), {
    strict: false,
    decode: (i) => headNonEmpty(i),
    encode: (a) => of2(a)
  });
}
var headOrElse = dual((args2) => isSchema(args2[0]), (self, fallback3) => transformOrFail(self, getNumberIndexedAccess2(typeSchema(self)), {
  strict: true,
  decode: (i, _, ast) => i.length > 0 ? succeed24(i[0]) : fallback3 ? succeed24(fallback3()) : fail23(new Type2(ast, i, "Unable to retrieve the first element of an empty array")),
  encode: (a) => succeed24(of2(a))
}));
var ValidDateSchemaId = Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations4) => (self) => self.pipe(filter22((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations4
}));
var LessThanDateSchemaId = Symbol.for("effect/SchemaId/LessThanDate");
var lessThanDate = (max14, annotations4) => (self) => self.pipe(filter22((a) => a < max14, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max14
  },
  title: `lessThanDate(${formatDate(max14)})`,
  description: `a date before ${formatDate(max14)}`,
  ...annotations4
}));
var LessThanOrEqualToDateSchemaId = Symbol.for("effect/schema/LessThanOrEqualToDate");
var lessThanOrEqualToDate = (max14, annotations4) => (self) => self.pipe(filter22((a) => a <= max14, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max14
  },
  title: `lessThanOrEqualToDate(${formatDate(max14)})`,
  description: `a date before or equal to ${formatDate(max14)}`,
  ...annotations4
}));
var GreaterThanDateSchemaId = Symbol.for("effect/SchemaId/GreaterThanDate");
var greaterThanDate = (min11, annotations4) => (self) => self.pipe(filter22((a) => a > min11, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min: min11
  },
  title: `greaterThanDate(${formatDate(min11)})`,
  description: `a date after ${formatDate(min11)}`,
  ...annotations4
}));
var GreaterThanOrEqualToDateSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToDate");
var greaterThanOrEqualToDate = (min11, annotations4) => (self) => self.pipe(filter22((a) => a >= min11, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min: min11
  },
  title: `greaterThanOrEqualToDate(${formatDate(min11)})`,
  description: `a date after or equal to ${formatDate(min11)}`,
  ...annotations4
}));
var BetweenDateSchemaId = Symbol.for("effect/SchemaId/BetweenDate");
var betweenDate = (min11, max14, annotations4) => (self) => self.pipe(filter22((a) => a <= max14 && a >= min11, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max: max14,
    min: min11
  },
  title: `betweenDate(${formatDate(min11)}, ${formatDate(max14)})`,
  description: `a date between ${formatDate(min11)} and ${formatDate(max14)}`,
  ...annotations4
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;
var DateFromSelf = class extends declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date5) => `new Date(${JSON.stringify(date5)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
}) {
};
var ValidDateFromSelf = class extends DateFromSelf.pipe(validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
})) {
};
var DateFromString = class extends transform3(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
}) {
};
var Date$ = class extends DateFromString.pipe(validDate({
  identifier: "Date"
})) {
};
var DateFromNumber = class extends transform3(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => a.getTime()
}).annotations({
  identifier: "DateFromNumber"
}) {
};
var DateTimeUtcFromSelf = class extends declare((u) => isDateTime2(u) && isUtc2(u), {
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: true
  }).map((date5) => unsafeFromDate2(date5)),
  equivalence: () => Equivalence9
}) {
};
var decodeDateTimeUtc = (input, ast) => _try({
  try: () => unsafeMake14(input),
  catch: () => new Type2(ast, input, `Unable to decode ${formatUnknown(input)} into a DateTime.Utc`)
});
var DateTimeUtcFromNumber = class extends transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed24(toEpochMillis2(a))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
}) {
};
var DateTimeUtcFromDate = class extends transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed24(toDateUtc2(a))
}).annotations({
  identifier: "DateTimeUtcFromDate"
}) {
};
var DateTimeUtc = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed24(formatIso3(a))
}).annotations({
  identifier: "DateTimeUtc"
}) {
};
var timeZoneOffsetArbitrary = () => (fc) => fc.integer({
  min: -12 * 60 * 60 * 1e3,
  max: 14 * 60 * 60 * 1e3
}).map(zoneMakeOffset2);
var TimeZoneOffsetFromSelf = class extends declare(isTimeZoneOffset2, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary
}) {
};
var TimeZoneOffset = class extends transform3(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
  strict: true,
  decode: (i) => zoneMakeOffset2(i),
  encode: (a) => a.offset
}).annotations({
  identifier: "TimeZoneOffset"
}) {
};
var timeZoneNamedArbitrary = () => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2);
var TimeZoneNamedFromSelf = class extends declare(isTimeZoneNamed2, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneNamedArbitrary
}) {
};
var TimeZoneNamed = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => zoneUnsafeMakeNamed2(i),
    catch: () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)
  }),
  encode: (a) => succeed24(a.id)
}).annotations({
  identifier: "TimeZoneNamed"
}) {
};
var TimeZoneFromSelf = class extends Union2(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf) {
};
var TimeZone = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
  strict: true,
  decode: (i, _, ast) => match2(zoneFromString2(i), {
    onNone: () => fail23(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),
    onSome: succeed24
  }),
  encode: (a) => succeed24(zoneToString2(a))
}).annotations({
  identifier: "TimeZone"
}) {
};
var timeZoneArbitrary = (fc) => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc));
var DateTimeZonedFromSelf = class extends declare((u) => isDateTime2(u) && isZoned2(u), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.tuple(fc.integer({
    // time zone db supports +/- 1000 years or so
    min: -31536e9,
    max: 31536e9
  }), timeZoneArbitrary(fc)).map(([millis2, timeZone]) => unsafeMakeZoned2(millis2, {
    timeZone
  })),
  equivalence: () => Equivalence9
}) {
};
var DateTimeZoned = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
  strict: true,
  decode: (i, _, ast) => match2(makeZonedFromString2(i), {
    onNone: () => fail23(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),
    onSome: succeed24
  }),
  encode: (a) => succeed24(formatIsoZoned2(a))
}).annotations({
  identifier: "DateTimeZoned"
}) {
};
var OptionNoneEncoded = Struct({
  _tag: Literal2("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded = (value10) => Struct({
  _tag: Literal2("Some"),
  value: value10
}).annotations({
  description: `SomeEncoded<${format7(value10)}>`
});
var optionEncoded = (value10) => Union2(OptionNoneEncoded, optionSomeEncoded(value10)).annotations({
  description: `OptionEncoded<${format7(value10)}>`
});
var optionDecode = (input) => input._tag === "None" ? none2() : some3(input.value);
var optionArbitrary = (value10, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value10(fc)
})).map(optionDecode);
var optionPretty = (value10) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value10(a)})`
});
var optionParse = (decodeUnknown4) => (u, options, ast) => isOption2(u) ? isNone2(u) ? succeed24(none2()) : toComposite(decodeUnknown4(u.value, options), some3, ast, u) : fail23(new Type2(ast, u));
var OptionFromSelf = (value10) => {
  return declare([value10], {
    decode: (value11) => optionParse(decodeUnknown2(value11)),
    encode: (value11) => optionParse(encodeUnknown(value11))
  }, {
    description: `Option<${format7(value10)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence2
  });
};
var makeNoneEncoded = {
  _tag: "None"
};
var makeSomeEncoded = (value10) => ({
  _tag: "Some",
  value: value10
});
function Option(value10) {
  const value_ = asSchema(value10);
  const out = transform3(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (i) => optionDecode(i),
    encode: (a) => match2(a, {
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
  return out;
}
function OptionFromNullOr(value10) {
  return transform3(NullOr(value10), OptionFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: (a) => getOrNull2(a)
  });
}
function OptionFromNullishOr(value10, onNoneEncoding) {
  return transform3(NullishOr(value10), OptionFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: onNoneEncoding === null ? (a) => getOrNull2(a) : (a) => getOrUndefined2(a)
  });
}
function OptionFromUndefinedOr(value10) {
  return transform3(UndefinedOr(value10), OptionFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromNullable2(i),
    encode: (a) => getOrUndefined2(a)
  });
}
var OptionFromNonEmptyTrimmedString = class extends transform3(String$, OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: (i) => filter(some3(i.trim()), isNonEmpty7),
  encode: (a) => getOrElse2(a, () => "")
}) {
};
var rightEncoded = (right3) => Struct({
  _tag: Literal2("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format7(right3)}>`
});
var leftEncoded = (left3) => Struct({
  _tag: Literal2("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format7(left3)}>`
});
var eitherEncoded = (right3, left3) => Union2(rightEncoded(right3), leftEncoded(left3)).annotations({
  description: `EitherEncoded<${format7(left3)}, ${format7(right3)}>`
});
var eitherDecode = (input) => input._tag === "Left" ? left2(input.left) : right2(input.right);
var eitherArbitrary = (right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode);
var eitherPretty = (right3, left3) => match({
  onLeft: (e) => `left(${left3(e)})`,
  onRight: (a) => `right(${right3(a)})`
});
var eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => isEither2(u) ? match(u, {
  onLeft: (left3) => toComposite(decodeUnknownLeft(left3, options), left2, ast, u),
  onRight: (right3) => toComposite(parseRight(right3, options), right2, ast, u)
}) : fail23(new Type2(ast, u));
var EitherFromSelf = ({
  left: left3,
  right: right3
}) => {
  return declare([right3, left3], {
    decode: (right4, left4) => eitherParse(decodeUnknown2(right4), decodeUnknown2(left4)),
    encode: (right4, left4) => eitherParse(encodeUnknown(right4), encodeUnknown(left4))
  }, {
    description: `Either<${format7(right3)}, ${format7(left3)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right4, left4) => getEquivalence({
      left: left4,
      right: right4
    })
  });
};
var makeLeftEncoded = (left3) => ({
  _tag: "Left",
  left: left3
});
var makeRightEncoded = (right3) => ({
  _tag: "Right",
  right: right3
});
var Either3 = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const out = transform3(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: (i) => eitherDecode(i),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
var EitherFromUnion = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform3(right_, rightEncoded(toright), {
    strict: true,
    decode: (i) => makeRightEncoded(i),
    encode: (a) => a.right
  });
  const fromLeft = transform3(left_, leftEncoded(toleft), {
    strict: true,
    decode: (i) => makeLeftEncoded(i),
    encode: (a) => a.left
  });
  const out = transform3(Union2(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: (i) => i._tag === "Left" ? left2(i.left) : right2(i.right),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
var mapArbitrary = (key, value10, ctx) => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value10(fc)));
    return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as18) => new Map(as18));
  };
};
var readonlyMapPretty = (key, value10) => (map49) => `new Map([${Array.from(map49.entries()).map(([k, v]) => `[${key(k)}, ${value10(v)}]`).join(", ")}])`;
var readonlyMapEquivalence = (key, value10) => {
  const arrayEquivalence = getEquivalence5(make(([ka, va], [kb, vb]) => key(ka, kb) && value10(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
var readonlyMapParse = (decodeUnknown4) => (u, options, ast) => isMap(u) ? toComposite(decodeUnknown4(Array.from(u.entries()), options), (as18) => new Map(as18), ast, u) : fail23(new Type2(ast, u));
var mapFromSelf_ = (key, value10, description) => declare([key, value10], {
  decode: (Key2, Value4) => readonlyMapParse(decodeUnknown2(Array$(Tuple(Key2, Value4)))),
  encode: (Key2, Value4) => readonlyMapParse(encodeUnknown(Array$(Tuple(Key2, Value4))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
var ReadonlyMapFromSelf = ({
  key,
  value: value10
}) => mapFromSelf_(key, value10, `ReadonlyMap<${format7(key)}, ${format7(value10)}>`);
var MapFromSelf = ({
  key,
  value: value10
}) => mapFromSelf_(key, value10, `Map<${format7(key)}, ${format7(value10)}>`);
function ReadonlyMap({
  key,
  value: value10
}) {
  return transform3(Array$(Tuple(key, value10)), ReadonlyMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value10))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
function map41({
  key,
  value: value10
}) {
  return transform3(Array$(Tuple(key, value10)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value10))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
var ReadonlyMapFromRecord = ({
  key,
  value: value10
}) => transform3(Record({
  key: encodedBoundSchema(key),
  value: value10
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value10)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
});
var MapFromRecord = ({
  key,
  value: value10
}) => transform3(Record({
  key: encodedBoundSchema(key),
  value: value10
}).annotations({
  description: "a record to be decoded into a Map"
}), MapFromSelf({
  key,
  value: typeSchema(value10)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
});
var setArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as18) => new Set(as18));
};
var readonlySetPretty = (item) => (set26) => `new Set([${Array.from(set26.values()).map((a) => item(a)).join(", ")}])`;
var readonlySetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence5(item);
  return make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
var readonlySetParse = (decodeUnknown4) => (u, options, ast) => isSet(u) ? toComposite(decodeUnknown4(Array.from(u.values()), options), (as18) => new Set(as18), ast, u) : fail23(new Type2(ast, u));
var setFromSelf_ = (value10, description) => declare([value10], {
  decode: (item) => readonlySetParse(decodeUnknown2(Array$(item))),
  encode: (item) => readonlySetParse(encodeUnknown(Array$(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
var ReadonlySetFromSelf = (value10) => setFromSelf_(value10, `ReadonlySet<${format7(value10)}>`);
var SetFromSelf = (value10) => setFromSelf_(value10, `Set<${format7(value10)}>`);
function ReadonlySet(value10) {
  return transform3(Array$(value10), ReadonlySetFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
function set15(value10) {
  return transform3(Array$(value10), SetFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
var bigDecimalPretty = () => (val) => `BigDecimal(${format2(normalize(val))})`;
var bigDecimalArbitrary = () => (fc) => fc.tuple(fc.bigInt(), fc.integer({
  min: 0,
  max: 18
})).map(([value10, scale2]) => make6(value10, scale2));
var BigDecimalFromSelf = class extends declare(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => Equivalence2
}) {
};
var BigDecimal = class extends transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromString3(i).pipe(match2({
    onNone: () => fail23(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),
    onSome: (val) => succeed24(normalize(val))
  })),
  encode: (a) => succeed24(format2(normalize(a)))
}).annotations({
  identifier: "BigDecimal"
}) {
};
var BigDecimalFromNumber = class extends transform3(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i) => unsafeFromNumber(i),
  encode: (a) => unsafeToNumber(a)
}).annotations({
  identifier: "BigDecimalFromNumber"
}) {
};
var GreaterThanBigDecimalSchemaId = Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
var greaterThanBigDecimal = (min11, annotations4) => (self) => {
  const formatted = format2(min11);
  return self.pipe(filter22((a) => greaterThan3(a, min11), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min: min11
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations4
  }));
};
var GreaterThanOrEqualToBigDecimalSchemaId = Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal = (min11, annotations4) => (self) => {
  const formatted = format2(min11);
  return self.pipe(filter22((a) => greaterThanOrEqualTo3(a, min11), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min: min11
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations4
  }));
};
var LessThanBigDecimalSchemaId = Symbol.for("effect/SchemaId/LessThanBigDecimal");
var lessThanBigDecimal = (max14, annotations4) => (self) => {
  const formatted = format2(max14);
  return self.pipe(filter22((a) => lessThan3(a, max14), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max: max14
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations4
  }));
};
var LessThanOrEqualToBigDecimalSchemaId = Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal = (max14, annotations4) => (self) => {
  const formatted = format2(max14);
  return self.pipe(filter22((a) => lessThanOrEqualTo3(a, max14), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max: max14
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations4
  }));
};
var PositiveBigDecimalSchemaId = Symbol.for("effect/schema/PositiveBigDecimal");
var positiveBigDecimal = (annotations4) => (self) => self.pipe(filter22((a) => isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations4
}));
var PositiveBigDecimalFromSelf = BigDecimalFromSelf.pipe(positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalSchemaId = Symbol.for("effect/schema/NonNegativeBigDecimal");
var nonNegativeBigDecimal = (annotations4) => (self) => self.pipe(filter22((a) => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations4
}));
var NonNegativeBigDecimalFromSelf = BigDecimalFromSelf.pipe(nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalSchemaId = Symbol.for("effect/schema/NegativeBigDecimal");
var negativeBigDecimal = (annotations4) => (self) => self.pipe(filter22((a) => isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations4
}));
var NegativeBigDecimalFromSelf = BigDecimalFromSelf.pipe(negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalSchemaId = Symbol.for("effect/schema/NonPositiveBigDecimal");
var nonPositiveBigDecimal = (annotations4) => (self) => self.pipe(filter22((a) => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations4
}));
var NonPositiveBigDecimalFromSelf = BigDecimalFromSelf.pipe(nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalSchemaId = Symbol.for("effect/SchemaId/BetweenBigDecimal");
var betweenBigDecimal = (minimum, maximum, annotations4) => (self) => {
  const formattedMinimum = format2(minimum);
  const formattedMaximum = format2(maximum);
  return self.pipe(filter22((a) => between3(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations4
  }));
};
var clampBigDecimal = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp4(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var chunkArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable3);
};
var chunkPretty = (item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`;
var chunkParse = (decodeUnknown4) => (u, options, ast) => isChunk(u) ? isEmpty2(u) ? succeed24(empty7()) : toComposite(decodeUnknown4(toReadonlyArray(u), options), fromIterable3, ast, u) : fail23(new Type2(ast, u));
var ChunkFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => chunkParse(decodeUnknown2(Array$(item))),
    encode: (item) => chunkParse(encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format7(value10)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence6
  });
};
function Chunk(value10) {
  return transform3(Array$(value10), ChunkFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => i.length === 0 ? empty7() : fromIterable3(i),
    encode: (a) => toReadonlyArray(a)
  });
}
var nonEmptyChunkArbitrary = (item) => (fc) => array4(item(fc), {
  minLength: 1
}).map((as18) => unsafeFromNonEmptyArray(as18));
var nonEmptyChunkPretty = (item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`;
var nonEmptyChunkParse = (decodeUnknown4) => (u, options, ast) => isChunk(u) && isNonEmpty2(u) ? toComposite(decodeUnknown4(toReadonlyArray(u), options), unsafeFromNonEmptyArray, ast, u) : fail23(new Type2(ast, u));
var NonEmptyChunkFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => nonEmptyChunkParse(decodeUnknown2(NonEmptyArray(item))),
    encode: (item) => nonEmptyChunkParse(encodeUnknown(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format7(value10)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: getEquivalence6
  });
};
function NonEmptyChunk(value10) {
  return transform3(NonEmptyArray(value10), NonEmptyChunkFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => unsafeFromNonEmptyArray(i),
    encode: (a) => toReadonlyArray(a)
  });
}
var decodeData = (a) => Array.isArray(a) ? array5(a) : struct5(a);
var dataArbitrary = (item) => (fc) => item(fc).map(decodeData);
var dataPretty = (item) => (d) => `Data(${item(d)})`;
var dataParse = (decodeUnknown4) => (u, options, ast) => isEqual2(u) ? toComposite(decodeUnknown4(u, options), decodeData, ast, u) : fail23(new Type2(ast, u));
var DataFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => dataParse(decodeUnknown2(item)),
    encode: (item) => dataParse(encodeUnknown(item))
  }, {
    description: `Data<${format7(value10)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
var Data = (value10) => {
  return transform3(value10, DataFromSelf(typeSchema(value10)), {
    strict: false,
    decode: (i) => decodeData(i),
    encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
  });
};
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var Class7 = (identifier2) => (fieldsOr, annotations4) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class5,
  annotations: annotations4
});
var getClassTag = (tag5) => withConstructorDefault(propertySignature(Literal2(tag5)), () => tag5);
var TaggedClass4 = (identifier2) => (tag5, fieldsOr, annotations4) => {
  var _a106;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag5)
  };
  const taggedFields = extendFields(newFields, fields);
  return _a106 = class extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag5,
    schema: extend4(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Class5,
    annotations: annotations4
  }) {
  }, __publicField(_a106, "_tag", tag5), _a106;
};
var TaggedError3 = (identifier2) => (tag5, fieldsOr, annotations4) => {
  class Base4 extends Error4 {
  }
  ;
  Base4.prototype.name = tag5;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag5)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag5,
    schema: extend4(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base4,
    annotations: annotations4,
    disableToString: true
  }) {
  }
  __publicField(TaggedErrorClass, "_tag", tag5);
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
};
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : (options == null ? void 0 : options.disableValidation) ?? false;
}
var astCache = globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = (annotations4) => {
  if (annotations4 === void 0) {
    return [];
  } else if (Array.isArray(annotations4)) {
    return annotations4;
  } else {
    return [annotations4];
  }
};
var makeClass = ({
  Base: Base4,
  annotations: annotations4,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  var _a106, _b32;
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations4);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    [JSONIdentifierAnnotationId]: identifier2,
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
  const klass = (_b32 = class extends Base4 {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed24(input) : fail23(new Type2(ast, input)),
        encode: () => (input, options) => input instanceof this ? succeed24(input) : map37(encodeUnknown(typeSide)(input, options), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty6) => (self) => `${identifier2}(${pretty6(self)})`,
        // @ts-expect-error
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform3(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations5) {
      return make113(this.ast).annotations(annotations5);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args2) {
      return new this(...args2);
    }
    static extend(identifier3) {
      return (newFieldsOr, annotations5) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend4(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options, annotations5) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options, annotations5) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [(_a106 = TypeId39, classSymbol)]() {
      return classSymbol;
    }
  }, // ----------------
  // Schema interface
  // ----------------
  __publicField(_b32, _a106, variance11), __publicField(_b32, "fields", {
    ...fields
  }), __publicField(_b32, "identifier", identifier2), _b32);
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = Struct({
  _tag: Literal2("Composite"),
  left: suspend15(() => FiberIdEncoded),
  right: suspend15(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId5) => {
  switch (fiberId5._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId5.id}, ${fiberId5.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId5.right)}, ${fiberIdPretty(fiberId5.left)})`;
  }
};
var FiberIdFromSelf = class extends declare(isFiberId2, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
}) {
};
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var fiberIdEncode = (input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
var FiberId = class extends transform3(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: (i) => fiberIdDecode(i),
  encode: (a) => fiberIdEncode(a)
}).annotations({
  identifier: "FiberId"
}) {
};
var causeDieEncoded = (defect) => Struct({
  _tag: Literal2("Die"),
  defect
});
var CauseEmptyEncoded = Struct({
  _tag: Literal2("Empty")
});
var causeFailEncoded = (error4) => Struct({
  _tag: Literal2("Fail"),
  error: error4
});
var CauseInterruptEncoded = Struct({
  _tag: Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = (error4, defect) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const suspended3 = suspend15(() => out);
  const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format7(error4)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
};
var causeArbitrary = (error4, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error4(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error4) => (cause3) => {
  const f2 = (cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error4(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty3(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f2(cause4.left)}, ${f2(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f2(cause4.left)}, ${f2(cause4.right)})`;
    }
  };
  return f2(cause3);
};
var causeParse = (decodeUnknown4) => (u, options, ast) => isCause2(u) ? toComposite(decodeUnknown4(causeEncode(u), options), causeDecode, ast, u) : fail23(new Type2(ast, u));
var CauseFromSelf = ({
  defect,
  error: error4
}) => {
  return declare([error4, defect], {
    decode: (error5, defect2) => causeParse(decodeUnknown2(causeEncoded(error5, defect2))),
    encode: (error5, defect2) => causeParse(encodeUnknown(causeEncoded(error5, defect2)))
  }, {
    title: `Cause<${error4.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty35;
    case "Fail":
      return fail8(cause3.error);
    case "Die":
      return die6(cause3.defect);
    case "Interrupt":
      return interrupt6(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
var Cause = ({
  defect,
  error: error4
}) => {
  const error_ = asSchema(error4);
  const defect_ = asSchema(defect);
  const out = transform3(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => causeDecode(i),
    encode: (a) => causeEncode(a)
  });
  return out;
};
var Defect = class extends transform3(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err2 = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err2.name = i.name;
      }
      err2.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err2;
    }
    return String(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
}) {
};
var exitFailureEncoded = (error4, defect) => Struct({
  _tag: Literal2("Failure"),
  cause: causeEncoded(error4, defect)
});
var exitSuccessEncoded = (value10) => Struct({
  _tag: Literal2("Success"),
  value: value10
});
var exitEncoded = (value10, error4, defect) => {
  return Union2(exitFailureEncoded(error4, defect), exitSuccessEncoded(value10)).annotations({
    title: `ExitEncoded<${format7(value10)}, ${format7(error4)}, ${format7(defect)}>`
  });
};
var exitDecode = (input) => {
  switch (input._tag) {
    case "Failure":
      return failCause3(causeDecode(input.cause));
    case "Success":
      return succeed3(input.value);
  }
};
var exitArbitrary = (value10, error4, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error4, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value10(fc)
})).map(exitDecode);
var exitPretty = (value10, error4) => (exit4) => exit4._tag === "Failure" ? `Exit.failCause(${causePretty(error4)(exit4.cause)})` : `Exit.succeed(${value10(exit4.value)})`;
var exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => isExit(u) ? match7(u, {
  onFailure: (cause3) => toComposite(decodeUnknownCause(cause3, options), failCause3, ast, u),
  onSuccess: (value10) => toComposite(decodeUnknownValue(value10, options), succeed3, ast, u)
}) : fail23(new Type2(ast, u));
var ExitFromSelf = ({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse(decodeUnknown2(success2), decodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse(encodeUnknown(success2), encodeUnknown(CauseFromSelf({
    error: failure2,
    defect: defect2
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
var Exit = ({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out = transform3(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => exitDecode(i),
    encode: (a) => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }
  });
  return out;
};
var hashSetArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
};
var hashSetPretty = (item) => (set26) => `HashSet(${Array.from(set26).map((a) => item(a)).join(", ")})`;
var hashSetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence5(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashSetParse = (decodeUnknown4) => (u, options, ast) => isHashSet2(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable6, ast, u) : fail23(new Type2(ast, u));
var HashSetFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => hashSetParse(decodeUnknown2(Array$(item))),
    encode: (item) => hashSetParse(encodeUnknown(Array$(item)))
  }, {
    description: `HashSet<${format7(value10)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
function HashSet(value10) {
  return transform3(Array$(value10), HashSetFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromIterable6(i),
    encode: (a) => Array.from(a)
  });
}
var hashMapArbitrary = (key, value10, ctx) => (fc) => {
  const items = fc.array(fc.tuple(key(fc), value10(fc)));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
};
var hashMapPretty = (key, value10) => (map49) => `HashMap([${Array.from(map49).map(([k, v]) => `[${key(k)}, ${value10(v)}]`).join(", ")}])`;
var hashMapEquivalence = (key, value10) => {
  const arrayEquivalence = getEquivalence5(make(([ka, va], [kb, vb]) => key(ka, kb) && value10(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashMapParse = (decodeUnknown4) => (u, options, ast) => isHashMap2(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable7, ast, u) : fail23(new Type2(ast, u));
var HashMapFromSelf = ({
  key,
  value: value10
}) => {
  return declare([key, value10], {
    decode: (key2, value11) => hashMapParse(decodeUnknown2(Array$(Tuple(key2, value11)))),
    encode: (key2, value11) => hashMapParse(encodeUnknown(Array$(Tuple(key2, value11))))
  }, {
    description: `HashMap<${format7(key)}, ${format7(value10)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
var HashMap = ({
  key,
  value: value10
}) => {
  return transform3(Array$(Tuple(key, value10)), HashMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value10))
  }), {
    strict: true,
    decode: (i) => fromIterable7(i),
    encode: (a) => Array.from(a)
  });
};
var listArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable8);
};
var listPretty = (item) => (set26) => `List(${Array.from(set26).map((a) => item(a)).join(", ")})`;
var listEquivalence = (item) => {
  const arrayEquivalence = getEquivalence5(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var listParse = (decodeUnknown4) => (u, options, ast) => isList(u) ? toComposite(decodeUnknown4(Array.from(u), options), fromIterable8, ast, u) : fail23(new Type2(ast, u));
var ListFromSelf = (value10) => {
  return declare([value10], {
    decode: (item) => listParse(decodeUnknown2(Array$(item))),
    encode: (item) => listParse(encodeUnknown(Array$(item)))
  }, {
    description: `List<${format7(value10)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
function List(value10) {
  return transform3(Array$(value10), ListFromSelf(typeSchema(asSchema(value10))), {
    strict: true,
    decode: (i) => fromIterable8(i),
    encode: (a) => Array.from(a)
  });
}
var sortedSetArbitrary = (item, ord, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as18) => fromIterable14(as18, ord));
};
var sortedSetPretty = (item) => (set26) => `new SortedSet([${Array.from(values9(set26)).map((a) => item(a)).join(", ")}])`;
var sortedSetParse = (decodeUnknown4, ord) => (u, options, ast) => isSortedSet(u) ? toComposite(decodeUnknown4(Array.from(values9(u)), options), (as18) => fromIterable14(as18, ord), ast, u) : fail23(new Type2(ast, u));
var SortedSetFromSelf = (value10, ordA, ordI) => {
  return declare([value10], {
    decode: (item) => sortedSetParse(decodeUnknown2(Array$(item)), ordA),
    encode: (item) => sortedSetParse(encodeUnknown(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format7(value10)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
    equivalence: () => getEquivalence8()
  });
};
function SortedSet(value10, ordA) {
  const to3 = typeSchema(asSchema(value10));
  return transform3(Array$(value10), SortedSetFromSelf(to3, ordA, ordA), {
    strict: true,
    decode: (i) => fromIterable14(i, ordA),
    encode: (a) => Array.from(values9(a))
  });
}
var BooleanFromUnknown = class extends transform3(Unknown, Boolean$, {
  strict: true,
  decode: (i) => isTruthy(i),
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
}) {
};
var BooleanFromString = class extends transform3(Literal2("true", "false").annotations({
  description: "a string to be decoded into a boolean"
}), Boolean$, {
  strict: true,
  decode: (i) => i === "true",
  encode: (a) => a ? "true" : "false"
}).annotations({
  identifier: "BooleanFromString"
}) {
};
var Config = (name, schema) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema);
  return string6(name).pipe(mapOrFail2((s) => decodeUnknownEither3(s).pipe(mapLeft((error4) => InvalidData2([], TreeFormatter.formatIssueSync(error4))))));
};
var symbolSerializable = Symbol.for("effect/Schema/Serializable/symbol");
var asSerializable = (serializable) => serializable;
var serializableSchema = (self) => self[symbolSerializable];
var serialize = (self) => encodeUnknown2(self[symbolSerializable])(self);
var deserialize = dual(2, (self, value10) => decodeUnknown3(self[symbolSerializable])(value10));
var symbolWithResult = Symbol.for("effect/Schema/Serializable/symbolResult");
var asWithResult = (withExit) => withExit;
var failureSchema = (self) => self[symbolWithResult].failure;
var successSchema = (self) => self[symbolWithResult].success;
var exitSchemaCache = globalValue("effect/Schema/Serializable/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
var exitSchema = (self) => {
  const proto16 = Object.getPrototypeOf(self);
  if (!(symbolWithResult in proto16)) {
    return Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
  }
  let schema = exitSchemaCache.get(proto16);
  if (schema === void 0) {
    schema = Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
    exitSchemaCache.set(proto16, schema);
  }
  return schema;
};
var serializeFailure = dual(2, (self, value10) => encode5(self[symbolWithResult].failure)(value10));
var deserializeFailure = dual(2, (self, value10) => decodeUnknown3(self[symbolWithResult].failure)(value10));
var serializeSuccess = dual(2, (self, value10) => encode5(self[symbolWithResult].success)(value10));
var deserializeSuccess = dual(2, (self, value10) => decodeUnknown3(self[symbolWithResult].success)(value10));
var serializeExit = dual(2, (self, value10) => encode5(exitSchema(self))(value10));
var deserializeExit = dual(2, (self, value10) => decodeUnknown3(exitSchema(self))(value10));
var asSerializableWithResult = (procedure) => procedure;
var TaggedRequest = (identifier2) => (tag5, options, annotations4) => {
  var _a106;
  const taggedFields = extendFields({
    _tag: getClassTag(tag5)
  }, options.payload);
  return _a106 = class extends makeClass({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag5,
    schema: Struct(taggedFields),
    fields: taggedFields,
    Base: Class6,
    annotations: annotations4
  }) {
    get [symbolSerializable]() {
      return this.constructor;
    }
    get [symbolWithResult]() {
      return {
        failure: options.failure,
        success: options.success
      };
    }
  }, __publicField(_a106, "_tag", tag5), __publicField(_a106, "success", options.success), __publicField(_a106, "failure", options.failure), _a106;
};
var equivalence2 = (schema) => go4(schema.ast, []);
var getEquivalenceAnnotation = getAnnotation(EquivalenceAnnotationId);
var go4 = (ast, path2) => {
  const hook = getEquivalenceAnnotation(ast);
  if (isSome2(hook)) {
    switch (ast._tag) {
      case "Declaration":
        return hook.value(...ast.typeParameters.map((tp) => go4(tp, path2)));
      case "Refinement":
        return hook.value(go4(ast.from, path2));
      default:
        return hook.value();
    }
  }
  switch (ast._tag) {
    case "NeverKeyword":
      throw new Error(getEquivalenceUnsupportedErrorMessage(ast, path2));
    case "Transformation":
      return go4(ast.to, path2);
    case "Declaration":
    case "Literal":
    case "StringKeyword":
    case "TemplateLiteral":
    case "UniqueSymbol":
    case "SymbolKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "Enums":
    case "ObjectKeyword":
      return equals;
    case "Refinement":
      return go4(ast.from, path2);
    case "Suspend": {
      const get48 = memoizeThunk(() => go4(ast.f(), path2));
      return (a, b) => get48()(a, b);
    }
    case "TupleType": {
      const elements = ast.elements.map((element2, i) => go4(element2.type, path2.concat(i)));
      const rest = ast.rest.map((annotatedAST) => go4(annotatedAST.type, path2));
      return make((a, b) => {
        if (!Array.isArray(a) || !Array.isArray(b)) {
          return false;
        }
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        let i = 0;
        for (; i < Math.min(len, ast.elements.length); i++) {
          if (!elements[i](a[i], b[i])) {
            return false;
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head13, ...tail5] = rest;
          for (; i < len - tail5.length; i++) {
            if (!head13(a[i], b[i])) {
              return false;
            }
          }
          for (let j = 0; j < tail5.length; j++) {
            i += j;
            if (!tail5[j](a[i], b[i])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return equals;
      }
      const propertySignatures = ast.propertySignatures.map((ps) => go4(ps.type, path2.concat(ps.name)));
      const indexSignatures = ast.indexSignatures.map((is4) => go4(is4.type, path2));
      return make((a, b) => {
        if (!isRecord(a) || !isRecord(b)) {
          return false;
        }
        const aStringKeys = Object.keys(a);
        const aSymbolKeys = Object.getOwnPropertySymbols(a);
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = ast.propertySignatures[i];
          const name = ps.name;
          const aHas = Object.prototype.hasOwnProperty.call(a, name);
          const bHas = Object.prototype.hasOwnProperty.call(b, name);
          if (ps.isOptional) {
            if (aHas !== bHas) {
              return false;
            }
          }
          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {
            return false;
          }
        }
        let bSymbolKeys;
        let bStringKeys;
        for (let i = 0; i < indexSignatures.length; i++) {
          const is4 = ast.indexSignatures[i];
          const encodedParameter = getEncodedParameter(is4.parameter);
          const isSymbol3 = isSymbolKeyword(encodedParameter);
          if (isSymbol3) {
            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b);
            if (aSymbolKeys.length !== bSymbolKeys.length) {
              return false;
            }
          } else {
            bStringKeys = bStringKeys || Object.keys(b);
            if (aStringKeys.length !== bStringKeys.length) {
              return false;
            }
          }
          const aKeys = isSymbol3 ? aSymbolKeys : aStringKeys;
          for (let j = 0; j < aKeys.length; j++) {
            const key = aKeys[j];
            if (!Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, true);
      const ownKeys2 = ownKeys(searchTree.keys);
      const len = ownKeys2.length;
      return make((a, b) => {
        let candidates = [];
        if (len > 0 && isRecordOrArray(a)) {
          for (let i = 0; i < len; i++) {
            const name = ownKeys2[i];
            const buckets = searchTree.keys[name].buckets;
            if (Object.prototype.hasOwnProperty.call(a, name)) {
              const literal3 = String(a[name]);
              if (Object.prototype.hasOwnProperty.call(buckets, literal3)) {
                candidates = candidates.concat(buckets[literal3]);
              }
            }
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        const tuples = candidates.map((ast2) => [go4(ast2, path2), is({
          ast: ast2
        })]);
        for (let i = 0; i < tuples.length; i++) {
          const [equivalence3, is4] = tuples[i];
          if (is4(a) && is4(b)) {
            if (equivalence3(a, b)) {
              return true;
            }
          }
        }
        return false;
      });
    }
  }
};
var SymbolStruct = TaggedStruct("symbol", {
  key: String$
}).annotations({
  description: "an object to be decoded into a globally shared symbol"
});
var SymbolFromStruct = transformOrFail(SymbolStruct, SymbolFromSelf, {
  strict: true,
  decode: (i) => decodeSymbol(i.key),
  encode: (a, _, ast) => map37(encodeSymbol2(a, ast), (key) => SymbolStruct.make({
    key
  }))
});
var PropertyKey$ = class extends Union2(String$, Number$, SymbolFromStruct).annotations({
  identifier: "PropertyKey"
}) {
};
var ArrayFormatterIssue = class extends Struct({
  _tag: propertySignature(Literal2("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
    description: "The tag identifying the type of parse issue"
  }),
  path: propertySignature(Array$(PropertyKey$)).annotations({
    description: "The path to the property where the issue occurred"
  }),
  message: propertySignature(String$).annotations({
    description: "A descriptive message explaining the issue"
  })
}).annotations({
  identifier: "ArrayFormatterIssue",
  description: "Represents an issue returned by the ArrayFormatter formatter"
}) {
};

// node_modules/effect/dist/esm/ScopedCache.js
var ScopedCache_exports = {};
__export(ScopedCache_exports, {
  ScopedCacheTypeId: () => ScopedCacheTypeId2,
  make: () => make115,
  makeWith: () => makeWith8
});

// node_modules/effect/dist/esm/internal/scopedCache.js
var makeCacheState2 = (map49, keys15, accesses, updating, hits, misses) => ({
  map: map49,
  keys: keys15,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState2 = () => makeCacheState2(empty23(), makeKeySet(), unbounded(), make15(false), 0, 0);
var complete5 = (key, exit4, ownerCount, entryStats, timeToLive) => struct5({
  _tag: "Complete",
  key,
  exit: exit4,
  ownerCount,
  entryStats,
  timeToLive
});
var pending3 = (key, scoped10) => struct5({
  _tag: "Pending",
  key,
  scoped: scoped10
});
var refreshing2 = (scoped10, complete6) => struct5({
  _tag: "Refreshing",
  scoped: scoped10,
  complete: complete6
});
var toScoped = (self) => matchEffect2(self.exit, {
  onFailure: (cause3) => failCause(cause3),
  onSuccess: ([value10]) => acquireRelease2(as3(sync(() => incrementAndGet(self.ownerCount)), value10), () => releaseOwner(self))
});
var releaseOwner = (self) => matchEffect2(self.exit, {
  onFailure: () => void_3,
  onSuccess: ([, finalizer3]) => flatMap12(sync(() => decrementAndGet(self.ownerCount)), (numOwner) => when(finalizer3(void_4), () => numOwner === 0))
});
var ScopedCacheSymbolKey = "effect/ScopedCache";
var ScopedCacheTypeId = Symbol.for(ScopedCacheSymbolKey);
var scopedCacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var _a83;
_a83 = ScopedCacheTypeId;
var ScopedCacheImpl = class {
  constructor(capacity10, scopedLookup, clock3, timeToLive, context15) {
    __publicField(this, "capacity");
    __publicField(this, "scopedLookup");
    __publicField(this, "clock");
    __publicField(this, "timeToLive");
    __publicField(this, "context");
    __publicField(this, _a83, scopedCacheVariance);
    __publicField(this, "cacheState");
    this.capacity = capacity10;
    this.scopedLookup = scopedLookup;
    this.clock = clock3;
    this.timeToLive = timeToLive;
    this.context = context15;
    this.cacheState = initialCacheState2();
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size13(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value10) => flatten8(this.resolveMapValue(value10))
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get9(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value10) => flatten8(this.resolveMapValue(value10, true))
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const value10 = getOrUndefined2(get9(this.cacheState.map, key));
      if (value10 === void 0) {
        return none2();
      }
      switch (value10._tag) {
        case "Complete": {
          return some3(makeEntryStats(value10.entryStats.loadedMillis));
        }
        case "Pending": {
          return none2();
        }
        case "Refreshing": {
          return some3(makeEntryStats(value10.complete.entryStats.loadedMillis));
        }
      }
    });
  }
  get(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap12((lookupValue) => suspend(() => {
      let k = void 0;
      let value10 = getOrUndefined2(get9(this.cacheState.map, key));
      if (value10 === void 0) {
        k = makeMapKey(key);
        if (has6(this.cacheState.map, key)) {
          value10 = getOrUndefined2(get9(this.cacheState.map, key));
        } else {
          set5(this.cacheState.map, key, pending3(k, lookupValue));
        }
      }
      if (value10 === void 0) {
        this.trackMiss();
        return zipRight2(this.ensureMapSizeNotExceeded(k), lookupValue);
      }
      return map14(this.resolveMapValue(value10), flatMap12(match2({
        onNone: () => {
          const val = value10;
          const current2 = getOrUndefined2(get9(this.cacheState.map, key));
          if (equals(current2, value10)) {
            remove8(this.cacheState.map, key);
          }
          return pipe(this.ensureMapSizeNotExceeded(val.key), zipRight2(releaseOwner(val)), zipRight2(this.get(key)));
        },
        onSome: succeed
      })));
    })), flatten8);
  }
  invalidate(key) {
    return suspend(() => {
      if (has6(this.cacheState.map, key)) {
        const mapValue = getOrUndefined2(get9(this.cacheState.map, key));
        remove8(this.cacheState.map, key);
        switch (mapValue._tag) {
          case "Complete": {
            return releaseOwner(mapValue);
          }
          case "Pending": {
            return void_3;
          }
          case "Refreshing": {
            return releaseOwner(mapValue.complete);
          }
        }
      }
      return void_3;
    });
  }
  get invalidateAll() {
    return forEachConcurrentDiscard(fromIterable6(Array.from(this.cacheState.map).map(([key]) => key)), (key) => this.invalidate(key), false, false);
  }
  refresh(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap12((scoped10) => {
      let value10 = getOrUndefined2(get9(this.cacheState.map, key));
      let newKey = void 0;
      if (value10 === void 0) {
        newKey = makeMapKey(key);
        if (has6(this.cacheState.map, key)) {
          value10 = getOrUndefined2(get9(this.cacheState.map, key));
        } else {
          set5(this.cacheState.map, key, pending3(newKey, scoped10));
        }
      }
      let finalScoped;
      if (value10 === void 0) {
        finalScoped = zipRight2(this.ensureMapSizeNotExceeded(newKey), scoped10);
      } else {
        switch (value10._tag) {
          case "Complete": {
            if (this.hasExpired(value10.timeToLive)) {
              finalScoped = succeed(this.get(key));
            } else {
              const current2 = getOrUndefined2(get9(this.cacheState.map, key));
              if (equals(current2, value10)) {
                const mapValue = refreshing2(scoped10, value10);
                set5(this.cacheState.map, key, mapValue);
                finalScoped = scoped10;
              } else {
                finalScoped = succeed(this.get(key));
              }
            }
            break;
          }
          case "Pending": {
            finalScoped = value10.scoped;
            break;
          }
          case "Refreshing": {
            finalScoped = value10.scoped;
            break;
          }
        }
      }
      return flatMap12(finalScoped, (s) => scopedEffect(asVoid2(s)));
    }));
  }
  get size() {
    return sync(() => size13(this.cacheState.map));
  }
  resolveMapValue(value10, ignorePending = false) {
    switch (value10._tag) {
      case "Complete": {
        this.trackHit();
        if (this.hasExpired(value10.timeToLive)) {
          return succeed(succeedNone);
        }
        return as3(this.ensureMapSizeNotExceeded(value10.key), asSome(toScoped(value10)));
      }
      case "Pending": {
        this.trackHit();
        if (ignorePending) {
          return succeed(succeedNone);
        }
        return zipRight2(this.ensureMapSizeNotExceeded(value10.key), map14(value10.scoped, asSome));
      }
      case "Refreshing": {
        this.trackHit();
        if (this.hasExpired(value10.complete.timeToLive)) {
          if (ignorePending) {
            return succeed(succeedNone);
          }
          return zipRight2(this.ensureMapSizeNotExceeded(value10.complete.key), map14(value10.scoped, asSome));
        }
        return as3(this.ensureMapSizeNotExceeded(value10.complete.key), asSome(toScoped(value10.complete)));
      }
    }
  }
  lookupValueOf(key) {
    return pipe(onInterrupt(flatMap12(make55(), (scope6) => pipe(this.scopedLookup(key), provideContext(pipe(this.context, add3(Scope, scope6))), exit, map14((exit4) => [exit4, (exit5) => close(scope6, exit5)]))), () => sync(() => remove8(this.cacheState.map, key))), flatMap12(([exit4, release4]) => {
      const now3 = this.clock.unsafeCurrentTimeMillis();
      const expiredAt = now3 + toMillis(this.timeToLive(exit4));
      switch (exit4._tag) {
        case "Success": {
          const exitWithFinalizer = succeed3([exit4.value, release4]);
          const completedResult = complete5(makeMapKey(key), exitWithFinalizer, make15(1), makeEntryStats(now3), expiredAt);
          let previousValue = void 0;
          if (has6(this.cacheState.map, key)) {
            previousValue = getOrUndefined2(get9(this.cacheState.map, key));
          }
          set5(this.cacheState.map, key, completedResult);
          return sync(() => flatten8(as3(this.cleanMapValue(previousValue), toScoped(completedResult))));
        }
        case "Failure": {
          const completedResult = complete5(makeMapKey(key), exit4, make15(0), makeEntryStats(now3), expiredAt);
          let previousValue = void 0;
          if (has6(this.cacheState.map, key)) {
            previousValue = getOrUndefined2(get9(this.cacheState.map, key));
          }
          set5(this.cacheState.map, key, completedResult);
          return zipRight2(release4(exit4), sync(() => flatten8(as3(this.cleanMapValue(previousValue), toScoped(completedResult)))));
        }
      }
    }), memoize, flatten8);
  }
  hasExpired(timeToLive) {
    return this.clock.unsafeCurrentTimeMillis() > timeToLive;
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    const cleanedKeys = [];
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size45 = size13(this.cacheState.map);
      loop5 = size45 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 === void 0) {
          loop5 = false;
        } else {
          if (has6(this.cacheState.map, key2.current)) {
            const removed = getOrUndefined2(get9(this.cacheState.map, key2.current));
            remove8(this.cacheState.map, key2.current);
            size45 = size45 - 1;
            cleanedKeys.push(removed);
            loop5 = size45 > this.capacity;
          }
        }
      }
      set3(this.cacheState.updating, false);
    }
    return cleanedKeys;
  }
  cleanMapValue(mapValue) {
    if (mapValue === void 0) {
      return void_3;
    }
    switch (mapValue._tag) {
      case "Complete": {
        return releaseOwner(mapValue);
      }
      case "Pending": {
        return void_3;
      }
      case "Refreshing": {
        return releaseOwner(mapValue.complete);
      }
    }
  }
  ensureMapSizeNotExceeded(key) {
    return forEachConcurrentDiscard(this.trackAccess(key), (cleanedMapValue) => this.cleanMapValue(cleanedMapValue), false, false);
  }
};
var make114 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeWith7({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
var makeWith7 = (options) => flatMap12(clock, (clock3) => buildWith(options.capacity, options.lookup, clock3, (exit4) => decode(options.timeToLive(exit4))));
var buildWith = (capacity10, scopedLookup, clock3, timeToLive) => acquireRelease2(flatMap12(context2(), (context15) => sync(() => new ScopedCacheImpl(capacity10, scopedLookup, clock3, timeToLive, context15))), (cache) => cache.invalidateAll);

// node_modules/effect/dist/esm/ScopedCache.js
var ScopedCacheTypeId2 = ScopedCacheTypeId;
var make115 = make114;
var makeWith8 = makeWith7;

// node_modules/effect/dist/esm/ScopedRef.js
var ScopedRef_exports = {};
__export(ScopedRef_exports, {
  ScopedRefTypeId: () => ScopedRefTypeId2,
  fromAcquire: () => fromAcquire2,
  get: () => get32,
  make: () => make116,
  set: () => set16
});
var ScopedRefTypeId2 = ScopedRefTypeId;
var fromAcquire2 = fromAcquire;
var get32 = get26;
var make116 = make109;
var set16 = set14;

// node_modules/effect/dist/esm/Secret.js
var Secret_exports = {};
__export(Secret_exports, {
  SecretTypeId: () => SecretTypeId2,
  fromIterable: () => fromIterable21,
  fromString: () => fromString6,
  isSecret: () => isSecret2,
  make: () => make117,
  unsafeWipe: () => unsafeWipe4,
  value: () => value9
});
var SecretTypeId2 = SecretTypeId;
var isSecret2 = isSecret;
var make117 = make75;
var fromIterable21 = fromIterable18;
var fromString6 = fromString5;
var value9 = value3;
var unsafeWipe4 = unsafeWipe2;

// node_modules/effect/dist/esm/SingleProducerAsyncInput.js
var SingleProducerAsyncInput_exports = {};
__export(SingleProducerAsyncInput_exports, {
  make: () => make118
});
var make118 = make63;

// node_modules/effect/dist/esm/Sink.js
var Sink_exports = {};
__export(Sink_exports, {
  SinkTypeId: () => SinkTypeId4,
  as: () => as16,
  collectAll: () => collectAll4,
  collectAllFrom: () => collectAllFrom2,
  collectAllN: () => collectAllN2,
  collectAllToMap: () => collectAllToMap2,
  collectAllToMapN: () => collectAllToMapN2,
  collectAllToSet: () => collectAllToSet2,
  collectAllToSetN: () => collectAllToSetN2,
  collectAllUntil: () => collectAllUntil2,
  collectAllUntilEffect: () => collectAllUntilEffect2,
  collectAllWhile: () => collectAllWhile2,
  collectAllWhileEffect: () => collectAllWhileEffect2,
  collectAllWhileWith: () => collectAllWhileWith2,
  collectLeftover: () => collectLeftover2,
  context: () => context13,
  contextWith: () => contextWith9,
  contextWithEffect: () => contextWithEffect7,
  contextWithSink: () => contextWithSink2,
  count: () => count6,
  die: () => die16,
  dieMessage: () => dieMessage8,
  dieSync: () => dieSync10,
  dimap: () => dimap2,
  dimapChunks: () => dimapChunks2,
  dimapChunksEffect: () => dimapChunksEffect2,
  dimapEffect: () => dimapEffect2,
  drain: () => drain5,
  drop: () => drop7,
  dropUntil: () => dropUntil5,
  dropUntilEffect: () => dropUntilEffect3,
  dropWhile: () => dropWhile7,
  dropWhileEffect: () => dropWhileEffect3,
  ensuring: () => ensuring12,
  ensuringWith: () => ensuringWith5,
  every: () => every17,
  fail: () => fail25,
  failCause: () => failCause18,
  failCauseSync: () => failCauseSync11,
  failSync: () => failSync13,
  filterInput: () => filterInput2,
  filterInputEffect: () => filterInputEffect2,
  findEffect: () => findEffect3,
  flatMap: () => flatMap27,
  fold: () => fold2,
  foldChunks: () => foldChunks2,
  foldChunksEffect: () => foldChunksEffect2,
  foldEffect: () => foldEffect2,
  foldLeft: () => foldLeft2,
  foldLeftChunks: () => foldLeftChunks2,
  foldLeftChunksEffect: () => foldLeftChunksEffect2,
  foldLeftEffect: () => foldLeftEffect2,
  foldSink: () => foldSink2,
  foldUntil: () => foldUntil2,
  foldUntilEffect: () => foldUntilEffect2,
  foldWeighted: () => foldWeighted2,
  foldWeightedDecompose: () => foldWeightedDecompose2,
  foldWeightedDecomposeEffect: () => foldWeightedDecomposeEffect2,
  foldWeightedEffect: () => foldWeightedEffect2,
  forEach: () => forEach20,
  forEachChunk: () => forEachChunk2,
  forEachChunkWhile: () => forEachChunkWhile2,
  forEachWhile: () => forEachWhile2,
  fromChannel: () => fromChannel3,
  fromEffect: () => fromEffect13,
  fromPubSub: () => fromPubSub5,
  fromPush: () => fromPush2,
  fromQueue: () => fromQueue5,
  head: () => head12,
  ignoreLeftover: () => ignoreLeftover2,
  last: () => last7,
  leftover: () => leftover2,
  map: () => map42,
  mapEffect: () => mapEffect9,
  mapError: () => mapError14,
  mapInput: () => mapInput13,
  mapInputChunks: () => mapInputChunks2,
  mapInputChunksEffect: () => mapInputChunksEffect2,
  mapInputEffect: () => mapInputEffect6,
  mapLeftover: () => mapLeftover2,
  mkString: () => mkString3,
  never: () => never12,
  orElse: () => orElse22,
  provideContext: () => provideContext13,
  race: () => race8,
  raceBoth: () => raceBoth2,
  raceWith: () => raceWith4,
  refineOrDie: () => refineOrDie5,
  refineOrDieWith: () => refineOrDieWith5,
  some: () => some19,
  splitWhere: () => splitWhere4,
  succeed: () => succeed28,
  sum: () => sum6,
  summarized: () => summarized6,
  suspend: () => suspend16,
  sync: () => sync21,
  take: () => take12,
  timed: () => timed4,
  toChannel: () => toChannel5,
  unwrap: () => unwrap8,
  unwrapScoped: () => unwrapScoped7,
  unwrapScopedWith: () => unwrapScopedWith5,
  withDuration: () => withDuration2,
  zip: () => zip25,
  zipLeft: () => zipLeft16,
  zipRight: () => zipRight16,
  zipWith: () => zipWith21
});
var SinkTypeId4 = SinkTypeId3;
var as16 = as10;
var collectAll4 = collectAll;
var collectAllN2 = collectAllN;
var collectAllFrom2 = collectAllFrom;
var collectAllToMap2 = collectAllToMap;
var collectAllToMapN2 = collectAllToMapN;
var collectAllToSet2 = collectAllToSet;
var collectAllToSetN2 = collectAllToSetN;
var collectAllUntil2 = collectAllUntil;
var collectAllUntilEffect2 = collectAllUntilEffect;
var collectAllWhile2 = collectAllWhile;
var collectAllWhileEffect2 = collectAllWhileEffect;
var collectAllWhileWith2 = collectAllWhileWith;
var collectLeftover2 = collectLeftover;
var mapInput13 = mapInput8;
var mapInputEffect6 = mapInputEffect3;
var mapInputChunks2 = mapInputChunks;
var mapInputChunksEffect2 = mapInputChunksEffect;
var count6 = count3;
var die16 = die10;
var dieMessage8 = dieMessage3;
var dieSync10 = dieSync6;
var dimap2 = dimap;
var dimapEffect2 = dimapEffect;
var dimapChunks2 = dimapChunks;
var dimapChunksEffect2 = dimapChunksEffect;
var drain5 = drain2;
var drop7 = drop5;
var dropUntil5 = dropUntil3;
var dropUntilEffect3 = dropUntilEffect;
var dropWhile7 = dropWhile5;
var dropWhileEffect3 = dropWhileEffect;
var ensuring12 = ensuring6;
var ensuringWith5 = ensuringWith2;
var context13 = context8;
var contextWith9 = contextWith4;
var contextWithEffect7 = contextWithEffect4;
var contextWithSink2 = contextWithSink;
var every17 = every14;
var fail25 = fail15;
var failSync13 = failSync8;
var failCause18 = failCause13;
var failCauseSync11 = failCauseSync8;
var filterInput2 = filterInput;
var filterInputEffect2 = filterInputEffect;
var findEffect3 = findEffect;
var fold2 = fold;
var foldSink2 = foldSink;
var foldChunks2 = foldChunks;
var foldChunksEffect2 = foldChunksEffect;
var foldEffect2 = foldEffect;
var foldLeft2 = foldLeft;
var foldLeftChunks2 = foldLeftChunks;
var foldLeftChunksEffect2 = foldLeftChunksEffect;
var foldLeftEffect2 = foldLeftEffect;
var foldUntil2 = foldUntil;
var foldUntilEffect2 = foldUntilEffect;
var foldWeighted2 = foldWeighted;
var foldWeightedDecompose2 = foldWeightedDecompose;
var foldWeightedDecomposeEffect2 = foldWeightedDecomposeEffect;
var foldWeightedEffect2 = foldWeightedEffect;
var forEach20 = forEach17;
var forEachChunk2 = forEachChunk;
var forEachChunkWhile2 = forEachChunkWhile;
var forEachWhile2 = forEachWhile;
var flatMap27 = flatMap21;
var fromChannel3 = fromChannel;
var toChannel5 = toChannel;
var fromEffect13 = fromEffect7;
var fromPubSub5 = fromPubSub2;
var fromPush2 = fromPush;
var fromQueue5 = fromQueue2;
var head12 = head8;
var ignoreLeftover2 = ignoreLeftover;
var last7 = last6;
var leftover2 = leftover;
var map42 = map29;
var mapEffect9 = mapEffect6;
var mapError14 = mapError8;
var mapLeftover2 = mapLeftover;
var mkString3 = mkString;
var never12 = never7;
var orElse22 = orElse11;
var provideContext13 = provideContext5;
var race8 = race4;
var raceBoth2 = raceBoth;
var raceWith4 = raceWith3;
var refineOrDie5 = refineOrDie;
var refineOrDieWith5 = refineOrDieWith;
var some19 = some15;
var splitWhere4 = splitWhere3;
var succeed28 = succeed16;
var sum6 = sum5;
var summarized6 = summarized3;
var suspend16 = suspend7;
var sync21 = sync11;
var take12 = take7;
var timed4 = timed3;
var unwrap8 = unwrap3;
var unwrapScoped7 = unwrapScoped4;
var unwrapScopedWith5 = unwrapScopedWith2;
var withDuration2 = withDuration;
var zip25 = zip14;
var zipLeft16 = zipLeft9;
var zipRight16 = zipRight9;
var zipWith21 = zipWith14;

// node_modules/effect/dist/esm/SortedMap.js
var SortedMap_exports = {};
__export(SortedMap_exports, {
  empty: () => empty48,
  entries: () => entries3,
  fromIterable: () => fromIterable22,
  get: () => get33,
  getOrder: () => getOrder7,
  has: () => has12,
  headOption: () => headOption,
  isEmpty: () => isEmpty23,
  isNonEmpty: () => isNonEmpty8,
  isSortedMap: () => isSortedMap,
  keys: () => keys10,
  lastOption: () => lastOption,
  make: () => make119,
  map: () => map43,
  partition: () => partition13,
  reduce: () => reduce22,
  remove: () => remove14,
  set: () => set17,
  size: () => size31,
  values: () => values10
});
var TypeId40 = Symbol.for("effect/SortedMap");
var SortedMapProto = {
  [TypeId40]: {
    _K: (_) => _,
    _V: (_) => _
  },
  [symbol2]() {
    return pipe(hash(this.tree), combine2(hash("effect/SortedMap")), cached(this));
  },
  [symbol3](that) {
    return isSortedMap(that) && equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl5 = (tree) => {
  const self = Object.create(SortedMapProto);
  self.tree = tree;
  return self;
};
var isSortedMap = (u) => hasProperty(u, TypeId40);
var empty48 = (ord) => makeImpl5(empty31(ord));
var fromIterable22 = dual(2, (iterable, ord) => makeImpl5(fromIterable13(iterable, ord)));
var make119 = (ord) => (...entries6) => fromIterable22(ord)(entries6);
var isEmpty23 = (self) => size31(self) === 0;
var isNonEmpty8 = (self) => size31(self) > 0;
var get33 = dual(2, (self, key) => findFirst10(self.tree, key));
var getOrder7 = (self) => getOrder5(self.tree);
var has12 = dual(2, (self, key) => isSome2(get33(self, key)));
var headOption = (self) => first2(self.tree);
var map43 = dual(2, (self, f2) => reduce22(self, empty48(getOrder5(self.tree)), (acc, v, k) => set17(acc, k, f2(v, k))));
var reduce22 = dual(3, (self, zero3, f2) => reduce14(self.tree, zero3, f2));
var remove14 = dual(2, (self, key) => makeImpl5(removeFirst2(self.tree, key)));
var set17 = dual(3, (self, key, value10) => has8(self.tree, key) ? makeImpl5(insert2(removeFirst2(self.tree, key), key, value10)) : makeImpl5(insert2(self.tree, key, value10)));
var size31 = (self) => size15(self.tree);
var keys10 = (self) => keys6(self.tree);
var values10 = (self) => values8(self.tree);
var entries3 = (self) => {
  const iterator = self.tree[Symbol.iterator]();
  iterator[Symbol.iterator] = () => entries3(self);
  return iterator;
};
var lastOption = (self) => last5(self.tree);
var partition13 = dual(2, (self, predicate) => {
  const ord = getOrder5(self.tree);
  let right3 = empty48(ord);
  let left3 = empty48(ord);
  for (const value10 of self) {
    if (predicate(value10[0])) {
      right3 = set17(right3, value10[0], value10[1]);
    } else {
      left3 = set17(left3, value10[0], value10[1]);
    }
  }
  return [left3, right3];
});

// node_modules/effect/dist/esm/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do9,
  StreamTypeId: () => StreamTypeId4,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease5,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as17,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind11,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo11,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer4,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll11,
  catchAllCause: () => catchAllCause9,
  catchSome: () => catchSome6,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag7,
  catchTags: () => catchTags6,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine18,
  combineChunks: () => combineChunks2,
  concat: () => concat7,
  concatAll: () => concatAll4,
  context: () => context14,
  contextWith: () => contextWith10,
  contextWithEffect: () => contextWithEffect8,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die17,
  dieMessage: () => dieMessage9,
  dieSync: () => dieSync11,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain6,
  drainFork: () => drainFork2,
  drop: () => drop8,
  dropRight: () => dropRight4,
  dropUntil: () => dropUntil6,
  dropUntilEffect: () => dropUntilEffect4,
  dropWhile: () => dropWhile8,
  dropWhileEffect: () => dropWhileEffect4,
  either: () => either13,
  empty: () => empty49,
  encodeText: () => encodeText2,
  ensuring: () => ensuring13,
  ensuringWith: () => ensuringWith6,
  execute: () => execute2,
  fail: () => fail26,
  failCause: () => failCause19,
  failCauseSync: () => failCauseSync12,
  failSync: () => failSync14,
  filter: () => filter23,
  filterEffect: () => filterEffect3,
  filterMap: () => filterMap13,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile5,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find4,
  findEffect: () => findEffect4,
  flatMap: () => flatMap28,
  flatten: () => flatten20,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever7,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel4,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect14,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable23,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub6,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue6,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy4,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity6,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter3,
  interruptWhen: () => interruptWhen4,
  interruptWhenDeferred: () => interruptWhenDeferred4,
  intersperse: () => intersperse4,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate6,
  let: () => let_11,
  make: () => make120,
  map: () => map44,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth12,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect10,
  mapError: () => mapError15,
  mapErrorCause: () => mapErrorCause8,
  mapInputContext: () => mapInputContext12,
  merge: () => merge13,
  mergeAll: () => mergeAll12,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith5,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString4,
  never: () => never13,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError5,
  onStart: () => onStart2,
  orDie: () => orDie11,
  orDieWith: () => orDieWith8,
  orElse: () => orElse23,
  orElseEither: () => orElseEither9,
  orElseFail: () => orElseFail6,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed7,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition14,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend7,
  provideContext: () => provideContext14,
  provideLayer: () => provideLayer4,
  provideService: () => provideService13,
  provideServiceEffect: () => provideServiceEffect5,
  provideServiceStream: () => provideServiceStream2,
  provideSomeContext: () => provideSomeContext5,
  provideSomeLayer: () => provideSomeLayer5,
  race: () => race9,
  raceAll: () => raceAll5,
  range: () => range5,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie6,
  refineOrDieWith: () => refineOrDieWith6,
  repeat: () => repeat7,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry11,
  run: () => run9,
  runCollect: () => runCollect4,
  runCount: () => runCount2,
  runDrain: () => runDrain4,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped4,
  runSum: () => runSum2,
  scan: () => scan4,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped9,
  scopedWith: () => scopedWith6,
  share: () => share2,
  sliding: () => sliding10,
  slidingSize: () => slidingSize2,
  some: () => some20,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split6,
  splitLines: () => splitLines4,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed29,
  suspend: () => suspend17,
  sync: () => sync22,
  take: () => take13,
  takeRight: () => takeRight5,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile7,
  tap: () => tap11,
  tapBoth: () => tapBoth6,
  tapError: () => tapError9,
  tapErrorCause: () => tapErrorCause7,
  tapSink: () => tapSink2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout5,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toAsyncIterable: () => toAsyncIterable2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toChannel: () => toChannel6,
  toPubSub: () => toPubSub4,
  toPull: () => toPull4,
  toQueue: () => toQueue4,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold6,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap9,
  unwrapScoped: () => unwrapScoped8,
  unwrapScopedWith: () => unwrapScopedWith6,
  updateService: () => updateService8,
  void: () => void_14,
  when: () => when9,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withExecutionPlan: () => withExecutionPlan4,
  withSpan: () => withSpan8,
  zip: () => zip26,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten3,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft17,
  zipRight: () => zipRight17,
  zipWith: () => zipWith22,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});
var StreamTypeId4 = StreamTypeId3;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease5 = acquireRelease4;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as17 = as13;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncPush2 = asyncPush;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var share2 = share;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer4 = buffer2;
var bufferChunks2 = bufferChunks;
var catchAll11 = catchAll8;
var catchAllCause9 = catchAllCause7;
var catchSome6 = catchSome4;
var catchTag7 = catchTag5;
var catchTags6 = catchTags4;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine18 = combine16;
var combineChunks2 = combineChunks;
var concat7 = concat6;
var concatAll4 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die17 = die14;
var dieSync11 = dieSync8;
var dieMessage9 = dieMessage6;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain6 = drain3;
var drainFork2 = drainFork;
var drop8 = drop6;
var dropRight4 = dropRight3;
var dropUntil6 = dropUntil4;
var dropUntilEffect4 = dropUntilEffect2;
var dropWhile8 = dropWhile6;
var dropWhileEffect4 = dropWhileEffect2;
var either13 = either9;
var empty49 = empty43;
var ensuring13 = ensuring9;
var ensuringWith6 = ensuringWith3;
var context14 = context10;
var contextWith10 = contextWith6;
var contextWithEffect8 = contextWithEffect5;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail26 = fail19;
var failSync14 = failSync10;
var failCause19 = failCause16;
var failCauseSync12 = failCauseSync9;
var filter23 = filter18;
var filterEffect3 = filterEffect;
var filterMap13 = filterMap12;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile5 = filterMapWhile4;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find4 = find3;
var findEffect4 = findEffect2;
var flatMap28 = flatMap23;
var flatten20 = flatten17;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever7 = forever6;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel4 = fromChannel2;
var toChannel6 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect14 = fromEffect9;
var fromEffectOption2 = fromEffectOption;
var fromPubSub6 = fromPubSub3;
var fromTPubSub2 = fromTPubSub;
var fromIterable23 = fromIterable17;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue6 = fromQueue3;
var fromTQueue2 = fromTQueue;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy4 = groupBy3;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity6 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse4 = intersperse3;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter3 = interruptAfter2;
var interruptWhen4 = interruptWhen2;
var interruptWhenDeferred4 = interruptWhenDeferred2;
var iterate6 = iterate4;
var make120 = make73;
var map44 = map33;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth12 = mapBoth9;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect10 = mapEffectOptions;
var mapError15 = mapError10;
var mapErrorCause8 = mapErrorCause6;
var merge13 = merge10;
var mergeAll12 = mergeAll9;
var mergeWithTag2 = mergeWithTag;
var mergeWith5 = mergeWith3;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString4 = mkString2;
var never13 = never8;
var onEnd2 = onEnd;
var onError5 = onError4;
var onDone2 = onDone;
var onStart2 = onStart;
var orDie11 = orDie8;
var orDieWith8 = orDieWith5;
var orElse23 = orElse13;
var orElseEither9 = orElseEither7;
var orElseFail6 = orElseFail4;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed7 = orElseSucceed5;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition14 = partition11;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend7 = prepend6;
var provideContext14 = provideContext8;
var provideSomeContext5 = provideSomeContext3;
var provideLayer4 = provideLayer2;
var provideService13 = provideService10;
var provideServiceEffect5 = provideServiceEffect4;
var provideServiceStream2 = provideServiceStream;
var mapInputContext12 = mapInputContext7;
var provideSomeLayer5 = provideSomeLayer3;
var race9 = race5;
var raceAll5 = raceAll4;
var range5 = range4;
var rechunk2 = rechunk;
var refineOrDie6 = refineOrDie3;
var refineOrDieWith6 = refineOrDieWith3;
var repeat7 = repeat4;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry11 = retry7;
var withExecutionPlan4 = withExecutionPlan3;
var run9 = run4;
var runCollect4 = runCollect2;
var runCount2 = runCount;
var runDrain4 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped4 = runScoped2;
var runSum2 = runSum;
var scan4 = scan3;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped9 = scoped7;
var scopedWith6 = scopedWith4;
var sliding10 = sliding9;
var slidingSize2 = slidingSize;
var some20 = some17;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split6 = split4;
var splitOnChunk2 = splitOnChunk;
var splitLines4 = splitLines2;
var succeed29 = succeed20;
var sync22 = sync14;
var suspend17 = suspend10;
var take13 = take11;
var takeRight5 = takeRight4;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile7 = takeWhile6;
var tap11 = tap9;
var tapBoth6 = tapBoth4;
var tapError9 = tapError7;
var tapErrorCause7 = tapErrorCause6;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout5 = timeout4;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub4 = toPubSub2;
var toPull4 = toPull2;
var toQueue4 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var toReadableStreamEffect2 = toReadableStreamEffect;
var toReadableStreamRuntime2 = toReadableStreamRuntime;
var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
var toAsyncIterableEffect2 = toAsyncIterableEffect;
var toAsyncIterable2 = toAsyncIterable;
var transduce2 = transduce;
var unfold6 = unfold5;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_14 = void_11;
var unwrap9 = unwrap4;
var unwrapScoped8 = unwrapScoped5;
var unwrapScopedWith6 = unwrapScopedWith3;
var updateService8 = updateService6;
var when9 = when5;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan8 = withSpan6;
var zip26 = zip16;
var zipFlatten3 = zipFlatten2;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestAll2 = zipLatestAll;
var zipLatestWith2 = zipLatestWith;
var zipLeft17 = zipLeft12;
var zipRight17 = zipRight12;
var zipWith22 = zipWith17;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do9 = Do7;
var bind11 = bind9;
var bindEffect2 = bindEffect;
var bindTo11 = bindTo9;
var let_11 = let_9;
var decodeText2 = decodeText;
var encodeText2 = encodeText;
var fromEventListener2 = fromEventListener;

// node_modules/effect/dist/esm/StreamEmit.js
var StreamEmit_exports = {};

// node_modules/effect/dist/esm/Streamable.js
var Streamable_exports = {};
__export(Streamable_exports, {
  Class: () => Class8
});
var streamVariance2 = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var _a84;
_a84 = StreamTypeId4;
var Class8 = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, _a84, streamVariance2);
  }
  /**
   * @since 2.0.0
   */
  pipe() {
    return pipeArguments(this, arguments);
  }
  /**
   * @internal
   */
  get channel() {
    return toChannel6(this.toStream());
  }
};

// node_modules/effect/dist/esm/Subscribable.js
var Subscribable_exports = {};
__export(Subscribable_exports, {
  TypeId: () => TypeId41,
  isSubscribable: () => isSubscribable,
  make: () => make121,
  map: () => map45,
  mapEffect: () => mapEffect11,
  unwrap: () => unwrap10
});
var TypeId41 = Symbol.for("effect/Subscribable");
var isSubscribable = (u) => hasProperty(u, TypeId41);
var Proto7 = {
  [TypeId15]: TypeId15,
  [TypeId41]: TypeId41,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make121 = (options) => Object.assign(Object.create(Proto7), options);
var map45 = dual(2, (self, f2) => make121({
  get: map26(self.get, f2),
  changes: map44(self.changes, f2)
}));
var mapEffect11 = dual(2, (self, f2) => make121({
  get: flatMap18(self.get, f2),
  changes: mapEffect10(self.changes, f2)
}));
var unwrap10 = (effect4) => make121({
  get: flatMap18(effect4, (s) => s.get),
  changes: unwrap9(map26(effect4, (s) => s.changes))
});

// node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRef_exports = {};
__export(SubscriptionRef_exports, {
  SubscriptionRefTypeId: () => SubscriptionRefTypeId2,
  get: () => get36,
  getAndSet: () => getAndSet7,
  getAndUpdate: () => getAndUpdate7,
  getAndUpdateEffect: () => getAndUpdateEffect3,
  getAndUpdateSome: () => getAndUpdateSome6,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect3,
  make: () => make124,
  modify: () => modify16,
  modifyEffect: () => modifyEffect4,
  modifySome: () => modifySome6,
  modifySomeEffect: () => modifySomeEffect3,
  set: () => set20,
  setAndGet: () => setAndGet6,
  update: () => update11,
  updateAndGet: () => updateAndGet7,
  updateAndGetEffect: () => updateAndGetEffect3,
  updateEffect: () => updateEffect3,
  updateSome: () => updateSome6,
  updateSomeAndGet: () => updateSomeAndGet6,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect2,
  updateSomeEffect: () => updateSomeEffect3
});

// node_modules/effect/dist/esm/SynchronizedRef.js
var SynchronizedRef_exports = {};
__export(SynchronizedRef_exports, {
  SynchronizedRefTypeId: () => SynchronizedRefTypeId,
  get: () => get34,
  getAndSet: () => getAndSet6,
  getAndUpdate: () => getAndUpdate6,
  getAndUpdateEffect: () => getAndUpdateEffect2,
  getAndUpdateSome: () => getAndUpdateSome5,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect2,
  make: () => make122,
  modify: () => modify14,
  modifyEffect: () => modifyEffect2,
  modifySome: () => modifySome5,
  modifySomeEffect: () => modifySomeEffect2,
  set: () => set18,
  setAndGet: () => setAndGet5,
  unsafeMake: () => unsafeMake19,
  update: () => update10,
  updateAndGet: () => updateAndGet6,
  updateAndGetEffect: () => updateAndGetEffect2,
  updateEffect: () => updateEffect2,
  updateSome: () => updateSome5,
  updateSomeAndGet: () => updateSomeAndGet5,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect,
  updateSomeEffect: () => updateSomeEffect2
});
var SynchronizedRefTypeId = SynchronizedTypeId;
var make122 = makeSynchronized;
var get34 = get12;
var getAndSet6 = getAndSet2;
var getAndUpdate6 = getAndUpdate2;
var getAndUpdateEffect2 = getAndUpdateEffect;
var getAndUpdateSome5 = getAndUpdateSome;
var getAndUpdateSomeEffect2 = getAndUpdateSomeEffect;
var modify14 = modify10;
var modifyEffect2 = modifyEffect;
var modifySome5 = modifySome;
var modifySomeEffect2 = modifySomeEffect;
var set18 = set6;
var setAndGet5 = setAndGet2;
var update10 = update3;
var updateEffect2 = updateEffect;
var updateAndGet6 = updateAndGet2;
var updateAndGetEffect2 = updateAndGetEffect;
var updateSome5 = updateSome;
var updateSomeEffect2 = updateSomeEffect;
var updateSomeAndGet5 = updateSomeAndGet;
var updateSomeAndGetEffect = updateSomeAndGetEffectSynchronized;
var unsafeMake19 = unsafeMakeSynchronized;

// node_modules/effect/dist/esm/internal/subscriptionRef.js
var SubscriptionRefSymbolKey = "effect/SubscriptionRef";
var SubscriptionRefTypeId = Symbol.for(SubscriptionRefSymbolKey);
var subscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a85, _b29, _c6, _d3, _e, _f;
var SubscriptionRefImpl = class extends (_f = Class3, _e = TypeId15, _d3 = TypeId41, _c6 = RefTypeId2, _b29 = SynchronizedRefTypeId, _a85 = SubscriptionRefTypeId, _f) {
  constructor(ref, pubsub, semaphore) {
    super();
    __publicField(this, "ref");
    __publicField(this, "pubsub");
    __publicField(this, "semaphore");
    __publicField(this, _e, TypeId15);
    __publicField(this, _d3, TypeId41);
    __publicField(this, _c6, refVariance);
    __publicField(this, _b29, synchronizedVariance);
    __publicField(this, _a85, subscriptionRefVariance);
    __publicField(this, "get");
    this.ref = ref;
    this.pubsub = pubsub;
    this.semaphore = semaphore;
    this.get = get13(this.ref);
  }
  commit() {
    return this.get;
  }
  get changes() {
    return pipe(get13(this.ref), flatMap18((a) => map26(fromPubSub3(this.pubsub, {
      scoped: true
    }), (s) => concat6(make73(a), s))), this.semaphore.withPermits(1), unwrapScoped5);
  }
  modify(f2) {
    return this.modifyEffect((a) => succeed13(f2(a)));
  }
  modifyEffect(f2) {
    return pipe(get13(this.ref), flatMap18(f2), flatMap18(([b, a]) => pipe(set7(this.ref, a), as8(b), zipLeft7(publish2(this.pubsub, a)))), this.semaphore.withPermits(1));
  }
};
var get35 = (self) => get13(self.ref);
var make123 = (value10) => pipe(all11([unbounded4(), make37(value10), makeSemaphore2(1)]), map26(([pubsub, ref, semaphore]) => new SubscriptionRefImpl(ref, pubsub, semaphore)));
var modify15 = dual(2, (self, f2) => self.modify(f2));
var modifyEffect3 = dual(2, (self, f2) => self.modifyEffect(f2));
var set19 = dual(2, (self, value10) => pipe(set7(self.ref, value10), zipLeft7(publish2(self.pubsub, value10)), self.semaphore.withPermits(1)));

// node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRefTypeId2 = SubscriptionRefTypeId;
var get36 = get35;
var getAndSet7 = getAndSet3;
var getAndUpdate7 = getAndUpdate3;
var getAndUpdateEffect3 = getAndUpdateEffect2;
var getAndUpdateSome6 = getAndUpdateSome2;
var getAndUpdateSomeEffect3 = getAndUpdateSomeEffect2;
var make124 = make123;
var modify16 = modify15;
var modifyEffect4 = modifyEffect3;
var modifySome6 = modifySome2;
var modifySomeEffect3 = modifySomeEffect2;
var set20 = set19;
var setAndGet6 = setAndGet3;
var update11 = update4;
var updateEffect3 = updateEffect2;
var updateAndGet7 = updateAndGet3;
var updateAndGetEffect3 = updateAndGetEffect2;
var updateSome6 = updateSome2;
var updateSomeEffect3 = updateSomeEffect2;
var updateSomeAndGet6 = updateSomeAndGet2;
var updateSomeAndGetEffect2 = updateSomeAndGetEffect;

// node_modules/effect/dist/esm/Supervisor.js
var Supervisor_exports = {};
__export(Supervisor_exports, {
  AbstractSupervisor: () => AbstractSupervisor,
  SupervisorTypeId: () => SupervisorTypeId2,
  addSupervisor: () => addSupervisor2,
  fibersIn: () => fibersIn2,
  fromEffect: () => fromEffect15,
  none: () => none14,
  track: () => track2,
  unsafeTrack: () => unsafeTrack2
});
var SupervisorTypeId2 = SupervisorTypeId;
var addSupervisor2 = addSupervisor;
var fibersIn2 = fibersIn;
var fromEffect15 = fromEffect2;
var none14 = none8;
var track2 = track;
var unsafeTrack2 = unsafeTrack;
var _a86;
_a86 = SupervisorTypeId2;
var AbstractSupervisor = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, _a86, supervisorVariance);
  }
  /**
   * @since 2.0.0
   */
  onStart(_context, _effect, _parent, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEnd(_value2, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEffect(_fiber, _effect) {
  }
  /**
   * @since 2.0.0
   */
  onSuspend(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  onResume(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  map(f2) {
    return new ProxySupervisor(this, map14(this.value, f2));
  }
  /**
   * @since 2.0.0
   */
  zip(right3) {
    return new Zip(this, right3);
  }
  /**
   * @since 2.0.0
   */
  onRun(execution, _fiber) {
    return execution();
  }
};

// node_modules/effect/dist/esm/Symbol.js
var Symbol_exports = {};
__export(Symbol_exports, {
  Equivalence: () => Equivalence10,
  isSymbol: () => isSymbol2
});
var isSymbol2 = isSymbol;
var Equivalence10 = symbol;

// node_modules/effect/dist/esm/TArray.js
var TArray_exports = {};
__export(TArray_exports, {
  TArrayTypeId: () => TArrayTypeId2,
  collectFirst: () => collectFirst2,
  collectFirstSTM: () => collectFirstSTM2,
  contains: () => contains8,
  count: () => count8,
  countSTM: () => countSTM2,
  empty: () => empty51,
  every: () => every19,
  everySTM: () => everySTM2,
  findFirst: () => findFirst13,
  findFirstIndex: () => findFirstIndex4,
  findFirstIndexFrom: () => findFirstIndexFrom2,
  findFirstIndexWhere: () => findFirstIndexWhere2,
  findFirstIndexWhereFrom: () => findFirstIndexWhereFrom2,
  findFirstIndexWhereFromSTM: () => findFirstIndexWhereFromSTM2,
  findFirstIndexWhereSTM: () => findFirstIndexWhereSTM2,
  findFirstSTM: () => findFirstSTM2,
  findLast: () => findLast5,
  findLastIndex: () => findLastIndex4,
  findLastIndexFrom: () => findLastIndexFrom2,
  findLastSTM: () => findLastSTM2,
  forEach: () => forEach22,
  fromIterable: () => fromIterable25,
  get: () => get38,
  headOption: () => headOption3,
  lastOption: () => lastOption3,
  make: () => make126,
  maxOption: () => maxOption2,
  minOption: () => minOption2,
  reduce: () => reduce24,
  reduceOption: () => reduceOption2,
  reduceOptionSTM: () => reduceOptionSTM2,
  reduceSTM: () => reduceSTM2,
  size: () => size33,
  some: () => some22,
  someSTM: () => someSTM2,
  toArray: () => toArray5,
  transform: () => transform5,
  transformSTM: () => transformSTM2,
  update: () => update13,
  updateSTM: () => updateSTM2
});

// node_modules/effect/dist/esm/internal/stm/tArray.js
var TArraySymbolKey = "effect/TArray";
var TArrayTypeId = Symbol.for(TArraySymbolKey);
var tArrayVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a87;
_a87 = TArrayTypeId;
var TArrayImpl = class {
  constructor(chunk7) {
    __publicField(this, "chunk");
    __publicField(this, _a87, tArrayVariance);
    this.chunk = chunk7;
  }
};
var collectFirst = dual(2, (self, pf) => collectFirstSTM(self, (a) => pipe(pf(a), map2(succeed19))));
var collectFirstSTM = dual(2, (self, pf) => withSTMRuntime((runtime8) => {
  let index3 = 0;
  let result = none2();
  while (isNone2(result) && index3 < self.chunk.length) {
    const element2 = pipe(self.chunk[index3], unsafeGet9(runtime8.journal));
    const option11 = pf(element2);
    if (isSome2(option11)) {
      result = option11;
    }
    index3 = index3 + 1;
  }
  return pipe(result, match2({
    onNone: () => succeedNone4,
    onSome: map31(some3)
  }));
}));
var contains7 = dual(2, (self, value10) => some21(self, (a) => equals(a)(value10)));
var count7 = dual(2, (self, predicate) => reduce23(self, 0, (n, a) => predicate(a) ? n + 1 : n));
var countSTM = dual(2, (self, predicate) => reduceSTM(self, 0, (n, a) => map31(predicate(a), (bool) => bool ? n + 1 : n)));
var empty50 = () => fromIterable24([]);
var every18 = dual(2, (self, predicate) => negate5(some21(self, (a) => !predicate(a))));
var everySTM = dual(2, (self, predicate) => map31(countSTM(self, predicate), (count9) => count9 === self.chunk.length));
var findFirst12 = dual(2, (self, predicate) => collectFirst(self, (a) => predicate(a) ? some3(a) : none2()));
var findFirstIndex3 = dual(2, (self, value10) => findFirstIndexFrom(self, value10, 0));
var findFirstIndexFrom = dual(3, (self, value10, from29) => findFirstIndexWhereFrom(self, (a) => equals(a)(value10), from29));
var findFirstIndexWhere = dual(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0));
var findFirstIndexWhereFrom = dual(3, (self, predicate, from29) => {
  if (from29 < 0) {
    return succeedNone4;
  }
  return effect3((journal) => {
    let index3 = from29;
    let found = false;
    while (!found && index3 < self.chunk.length) {
      const element2 = unsafeGet9(self.chunk[index3], journal);
      found = predicate(element2);
      index3 = index3 + 1;
    }
    if (found) {
      return some3(index3 - 1);
    }
    return none2();
  });
});
var findFirstIndexWhereSTM = dual(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0));
var findFirstIndexWhereFromSTM = dual(3, (self, predicate, from29) => {
  const forIndex = (index3) => index3 < self.chunk.length ? pipe(get17(self.chunk[index3]), flatMap22(predicate), flatMap22((bool) => bool ? succeed19(some3(index3)) : forIndex(index3 + 1))) : succeedNone4;
  return from29 < 0 ? succeedNone4 : forIndex(from29);
});
var findFirstSTM = dual(2, (self, predicate) => {
  const init3 = [none2(), 0];
  const cont = (state) => isNone2(state[0]) && state[1] < self.chunk.length - 1;
  return map31(iterate3(init3, {
    while: cont,
    body: (state) => {
      const index3 = state[1];
      return pipe(get17(self.chunk[index3]), flatMap22((value10) => map31(predicate(value10), (bool) => [bool ? some3(value10) : none2(), index3 + 1])));
    }
  }), (state) => state[0]);
});
var findLast4 = dual(2, (self, predicate) => effect3((journal) => {
  let index3 = self.chunk.length - 1;
  let result = none2();
  while (isNone2(result) && index3 >= 0) {
    const element2 = unsafeGet9(self.chunk[index3], journal);
    if (predicate(element2)) {
      result = some3(element2);
    }
    index3 = index3 - 1;
  }
  return result;
}));
var findLastIndex3 = dual(2, (self, value10) => findLastIndexFrom(self, value10, self.chunk.length - 1));
var findLastIndexFrom = dual(3, (self, value10, end7) => {
  if (end7 >= self.chunk.length) {
    return succeedNone4;
  }
  return effect3((journal) => {
    let index3 = end7;
    let found = false;
    while (!found && index3 >= 0) {
      const element2 = unsafeGet9(self.chunk[index3], journal);
      found = equals(element2)(value10);
      index3 = index3 - 1;
    }
    if (found) {
      return some3(index3 + 1);
    }
    return none2();
  });
});
var findLastSTM = dual(2, (self, predicate) => {
  const init3 = [none2(), self.chunk.length - 1];
  const cont = (state) => isNone2(state[0]) && state[1] >= 0;
  return map31(iterate3(init3, {
    while: cont,
    body: (state) => {
      const index3 = state[1];
      return pipe(get17(self.chunk[index3]), flatMap22((value10) => map31(predicate(value10), (bool) => [bool ? some3(value10) : none2(), index3 - 1])));
    }
  }), (state) => state[0]);
});
var forEach21 = dual(2, (self, f2) => reduceSTM(self, void 0, (_, a) => f2(a)));
var fromIterable24 = (iterable) => map31(forEach18(iterable, make69), (chunk7) => new TArrayImpl(chunk7));
var get37 = dual(2, (self, index3) => {
  if (index3 < 0 || index3 >= self.chunk.length) {
    return dieMessage4("Index out of bounds");
  }
  return get17(self.chunk[index3]);
});
var headOption2 = (self) => self.chunk.length === 0 ? succeed19(none2()) : map31(get17(self.chunk[0]), some3);
var lastOption2 = (self) => self.chunk.length === 0 ? succeedNone4 : map31(get17(self.chunk[self.chunk.length - 1]), some3);
var make125 = (...elements) => fromIterable24(elements);
var maxOption = dual(2, (self, order) => {
  const greaterThan12 = greaterThan(order);
  return reduceOption(self, (acc, curr) => greaterThan12(acc)(curr) ? curr : acc);
});
var minOption = dual(2, (self, order) => {
  const lessThan16 = lessThan(order);
  return reduceOption(self, (acc, curr) => lessThan16(acc)(curr) ? curr : acc);
});
var reduce23 = dual(3, (self, zero3, f2) => effect3((journal) => {
  let index3 = 0;
  let result = zero3;
  while (index3 < self.chunk.length) {
    const element2 = unsafeGet9(self.chunk[index3], journal);
    result = f2(result, element2);
    index3 = index3 + 1;
  }
  return result;
}));
var reduceOption = dual(2, (self, f2) => effect3((journal) => {
  let index3 = 0;
  let result = void 0;
  while (index3 < self.chunk.length) {
    const element2 = unsafeGet9(self.chunk[index3], journal);
    result = result === void 0 ? element2 : f2(result, element2);
    index3 = index3 + 1;
  }
  return fromNullable2(result);
}));
var reduceOptionSTM = dual(2, (self, f2) => reduceSTM(self, none2(), (acc, curr) => isSome2(acc) ? map31(f2(acc.value, curr), some3) : succeedSome4(curr)));
var reduceSTM = dual(3, (self, zero3, f2) => flatMap22(toArray4(self), reduce19(zero3, f2)));
var size32 = (self) => self.chunk.length;
var some21 = dual(2, (self, predicate) => map31(findFirst12(self, predicate), isSome2));
var someSTM = dual(2, (self, predicate) => map31(countSTM(self, predicate), (n) => n > 0));
var toArray4 = (self) => forEach18(self.chunk, get17);
var transform4 = dual(2, (self, f2) => effect3((journal) => {
  let index3 = 0;
  while (index3 < self.chunk.length) {
    const ref = self.chunk[index3];
    unsafeSet2(ref, f2(unsafeGet9(ref, journal)), journal);
    index3 = index3 + 1;
  }
  return void 0;
}));
var transformSTM = dual(2, (self, f2) => flatMap22(forEach18(self.chunk, (ref) => flatMap22(get17(ref), f2)), (chunk7) => effect3((journal) => {
  const iterator = chunk7[Symbol.iterator]();
  let index3 = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    unsafeSet2(self.chunk[index3], next6.value, journal);
    index3 = index3 + 1;
  }
  return void 0;
})));
var update12 = dual(3, (self, index3, f2) => {
  if (index3 < 0 || index3 >= self.chunk.length) {
    return dieMessage4("Index out of bounds");
  }
  return update8(self.chunk[index3], f2);
});
var updateSTM = dual(3, (self, index3, f2) => {
  if (index3 < 0 || index3 >= self.chunk.length) {
    return dieMessage4("Index out of bounds");
  }
  return pipe(get17(self.chunk[index3]), flatMap22(f2), flatMap22((updated) => set10(self.chunk[index3], updated)));
});

// node_modules/effect/dist/esm/TArray.js
var TArrayTypeId2 = TArrayTypeId;
var collectFirst2 = collectFirst;
var collectFirstSTM2 = collectFirstSTM;
var contains8 = contains7;
var count8 = count7;
var countSTM2 = countSTM;
var empty51 = empty50;
var every19 = every18;
var everySTM2 = everySTM;
var findFirst13 = findFirst12;
var findFirstIndex4 = findFirstIndex3;
var findFirstIndexFrom2 = findFirstIndexFrom;
var findFirstIndexWhere2 = findFirstIndexWhere;
var findFirstIndexWhereFrom2 = findFirstIndexWhereFrom;
var findFirstIndexWhereSTM2 = findFirstIndexWhereSTM;
var findFirstIndexWhereFromSTM2 = findFirstIndexWhereFromSTM;
var findFirstSTM2 = findFirstSTM;
var findLast5 = findLast4;
var findLastIndex4 = findLastIndex3;
var findLastIndexFrom2 = findLastIndexFrom;
var findLastSTM2 = findLastSTM;
var forEach22 = forEach21;
var fromIterable25 = fromIterable24;
var get38 = get37;
var headOption3 = headOption2;
var lastOption3 = lastOption2;
var make126 = make125;
var maxOption2 = maxOption;
var minOption2 = minOption;
var reduce24 = reduce23;
var reduceOption2 = reduceOption;
var reduceOptionSTM2 = reduceOptionSTM;
var reduceSTM2 = reduceSTM;
var size33 = size32;
var some22 = some21;
var someSTM2 = someSTM;
var toArray5 = toArray4;
var transform5 = transform4;
var transformSTM2 = transformSTM;
var update13 = update12;
var updateSTM2 = updateSTM;

// node_modules/effect/dist/esm/TDeferred.js
var TDeferred_exports = {};
__export(TDeferred_exports, {
  TDeferredTypeId: () => TDeferredTypeId2,
  await: () => _await5,
  done: () => done13,
  fail: () => fail28,
  make: () => make128,
  poll: () => poll12,
  succeed: () => succeed31
});

// node_modules/effect/dist/esm/internal/stm/tDeferred.js
var TDeferredSymbolKey = "effect/TDeferred";
var TDeferredTypeId = Symbol.for(TDeferredSymbolKey);
var tDeferredVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var _a88;
_a88 = TDeferredTypeId;
var TDeferredImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a88, tDeferredVariance);
    this.ref = ref;
  }
};
var _await4 = (self) => flatten16(collect3(get17(self.ref), (option11) => isSome2(option11) ? some3(fromEither4(option11.value)) : none2()));
var done12 = dual(2, (self, either14) => flatMap22(get17(self.ref), match2({
  onNone: () => zipRight11(set10(self.ref, some3(either14)), succeed19(true)),
  onSome: () => succeed19(false)
})));
var fail27 = dual(2, (self, error4) => done12(self, left2(error4)));
var make127 = () => map31(make69(none2()), (ref) => new TDeferredImpl(ref));
var poll11 = (self) => get17(self.ref);
var succeed30 = dual(2, (self, value10) => done12(self, right2(value10)));

// node_modules/effect/dist/esm/TDeferred.js
var TDeferredTypeId2 = TDeferredTypeId;
var _await5 = _await4;
var done13 = done12;
var fail28 = fail27;
var make128 = make127;
var poll12 = poll11;
var succeed31 = succeed30;

// node_modules/effect/dist/esm/TMap.js
var TMap_exports = {};
__export(TMap_exports, {
  TMapTypeId: () => TMapTypeId2,
  empty: () => empty53,
  find: () => find6,
  findAll: () => findAll4,
  findAllSTM: () => findAllSTM2,
  findSTM: () => findSTM2,
  forEach: () => forEach24,
  fromIterable: () => fromIterable27,
  get: () => get40,
  getOrElse: () => getOrElse9,
  has: () => has14,
  isEmpty: () => isEmpty25,
  keys: () => keys12,
  make: () => make130,
  merge: () => merge15,
  reduce: () => reduce26,
  reduceSTM: () => reduceSTM4,
  remove: () => remove16,
  removeAll: () => removeAll2,
  removeIf: () => removeIf2,
  retainIf: () => retainIf2,
  set: () => set22,
  setIfAbsent: () => setIfAbsent2,
  size: () => size35,
  takeFirst: () => takeFirst2,
  takeFirstSTM: () => takeFirstSTM2,
  takeSome: () => takeSome2,
  takeSomeSTM: () => takeSomeSTM2,
  toArray: () => toArray7,
  toChunk: () => toChunk3,
  toHashMap: () => toHashMap2,
  toMap: () => toMap2,
  transform: () => transform7,
  transformSTM: () => transformSTM4,
  transformValues: () => transformValues2,
  transformValuesSTM: () => transformValuesSTM2,
  updateWith: () => updateWith4,
  values: () => values12
});

// node_modules/effect/dist/esm/internal/stm/tMap.js
var TMapSymbolKey = "effect/TMap";
var TMapTypeId = Symbol.for(TMapSymbolKey);
var tMapVariance = {
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var _a89;
_a89 = TMapTypeId;
var TMapImpl = class {
  constructor(tBuckets, tSize) {
    __publicField(this, "tBuckets");
    __publicField(this, "tSize");
    __publicField(this, _a89, tMapVariance);
    this.tBuckets = tBuckets;
    this.tSize = tSize;
  }
};
var isTMap = (u) => hasProperty(u, TMapTypeId);
var InitialCapacity = 16;
var LoadFactor = 0.75;
var nextPowerOfTwo = (size45) => {
  const n = -1 >>> Math.clz32(size45 - 1);
  return n < 0 ? 1 : n + 1;
};
var hash3 = (key) => {
  const h2 = hash(key);
  return h2 ^ h2 >>> 16;
};
var indexOf2 = (k, capacity10) => hash3(k) & capacity10 - 1;
var allocate2 = (capacity10, data) => {
  const buckets = Array.from({
    length: capacity10
  }, () => empty7());
  const distinct = new Map(data);
  let size45 = 0;
  for (const entry of distinct) {
    const index3 = indexOf2(entry[0], capacity10);
    buckets[index3] = pipe(buckets[index3], prepend3(entry));
    size45 = size45 + 1;
  }
  return pipe(fromIterable24(buckets), flatMap22((buckets2) => pipe(make69(buckets2), flatMap22((tBuckets) => pipe(make69(size45), map31((tSize) => new TMapImpl(tBuckets, tSize)))))));
};
var empty52 = () => fromIterable26([]);
var find5 = dual(2, (self, pf) => findSTM(self, (key, value10) => {
  const option11 = pf(key, value10);
  if (isSome2(option11)) {
    return succeed19(option11.value);
  }
  return fail17(none2());
}));
var findSTM = dual(2, (self, f2) => reduceSTM3(self, none2(), (acc, value10, key) => isNone2(acc) ? matchSTM(f2(key, value10), {
  onFailure: match2({
    onNone: () => succeedNone4,
    onSome: fail17
  }),
  onSuccess: succeedSome4
}) : succeed27(acc)));
var findAll3 = dual(2, (self, pf) => findAllSTM(self, (key, value10) => {
  const option11 = pf(key, value10);
  if (isSome2(option11)) {
    return succeed19(option11.value);
  }
  return fail17(none2());
}));
var findAllSTM = dual(2, (self, pf) => map31(reduceSTM3(self, empty7(), (acc, value10, key) => matchSTM(pf(key, value10), {
  onFailure: match2({
    onNone: () => succeed19(acc),
    onSome: fail17
  }),
  onSuccess: (a) => succeed19(append3(acc, a))
})), (a) => Array.from(a)));
var forEach23 = dual(2, (self, f2) => reduceSTM3(self, void 0, (_, value10, key) => asVoid9(f2(key, value10))));
var fromIterable26 = (iterable) => suspend9(() => {
  const data = fromIterable3(iterable);
  const capacity10 = data.length < InitialCapacity ? InitialCapacity : nextPowerOfTwo(data.length);
  return allocate2(capacity10, data);
});
var get39 = dual(2, (self, key) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const index3 = indexOf2(key, buckets.chunk.length);
  const bucket = unsafeGet9(buckets.chunk[index3], journal);
  return pipe(findFirst4(bucket, (entry) => equals(entry[0])(key)), map2((entry) => entry[1]));
}));
var getOrElse8 = dual(3, (self, key, fallback3) => map31(get39(self, key), getOrElse2(fallback3)));
var has13 = dual(2, (self, key) => map31(get39(self, key), isSome2));
var isEmpty24 = (self) => map31(get17(self.tSize), (size45) => size45 === 0);
var keys11 = (self) => map31(toReadonlyArray2(self), map6((entry) => entry[0]));
var make129 = (...entries6) => fromIterable26(entries6);
var merge14 = dual(4, (self, key, value10, f2) => flatMap22(get39(self, key), match2({
  onNone: () => as12(set21(self, key, value10), value10),
  onSome: (v0) => {
    const v1 = f2(v0, value10);
    return as12(set21(self, key, v1), v1);
  }
})));
var reduce25 = dual(3, (self, zero3, f2) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  let result = zero3;
  let index3 = 0;
  while (index3 < buckets.chunk.length) {
    const bucket = buckets.chunk[index3];
    const items = unsafeGet9(bucket, journal);
    result = reduce4(items, result, (acc, entry) => f2(acc, entry[1], entry[0]));
    index3 = index3 + 1;
  }
  return result;
}));
var reduceSTM3 = dual(3, (self, zero3, f2) => flatMap22(toReadonlyArray2(self), reduce19(zero3, (acc, entry) => f2(acc, entry[1], entry[0]))));
var remove15 = dual(2, (self, key) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const index3 = indexOf2(key, buckets.chunk.length);
  const bucket = unsafeGet9(buckets.chunk[index3], journal);
  const [toRemove, toRetain] = partition3(bucket, (entry) => equals(entry[1], key));
  if (isNonEmpty2(toRemove)) {
    const currentSize = unsafeGet9(self.tSize, journal);
    unsafeSet2(buckets.chunk[index3], toRetain, journal);
    unsafeSet2(self.tSize, currentSize - 1, journal);
  }
}));
var removeAll = dual(2, (self, keys15) => effect3((journal) => {
  const iterator = keys15[Symbol.iterator]();
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const buckets = unsafeGet9(self.tBuckets, journal);
    const index3 = indexOf2(next6.value, buckets.chunk.length);
    const bucket = unsafeGet9(buckets.chunk[index3], journal);
    const [toRemove, toRetain] = partition3(bucket, (entry) => equals(next6.value)(entry[0]));
    if (isNonEmpty2(toRemove)) {
      const currentSize = unsafeGet9(self.tSize, journal);
      unsafeSet2(buckets.chunk[index3], toRetain, journal);
      unsafeSet2(self.tSize, currentSize - 1, journal);
    }
  }
}));
var removeIf = dual((args2) => isTMap(args2[0]), (self, predicate, options) => effect3((journal) => {
  const discard3 = (options == null ? void 0 : options.discard) === true;
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const removed = [];
  let index3 = 0;
  let newSize = 0;
  while (index3 < capacity10) {
    const bucket = unsafeGet9(buckets.chunk[index3], journal);
    const iterator = bucket[Symbol.iterator]();
    let next6;
    let newBucket = empty7();
    while ((next6 = iterator.next()) && !next6.done) {
      const [k, v] = next6.value;
      if (!predicate(k, v)) {
        newBucket = prepend3(newBucket, next6.value);
        newSize = newSize + 1;
      } else {
        if (!discard3) {
          removed.push([k, v]);
        }
      }
    }
    unsafeSet2(buckets.chunk[index3], newBucket, journal);
    index3 = index3 + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
  if (!discard3) {
    return removed;
  }
}));
var retainIf = dual((args2) => isTMap(args2[0]), (self, predicate, options) => removeIf(self, (key, value10) => !predicate(key, value10), options));
var set21 = dual(3, (self, key, value10) => {
  const resize = (journal, buckets) => {
    const capacity10 = buckets.chunk.length;
    const newCapacity = capacity10 << 1;
    const newBuckets = Array.from({
      length: newCapacity
    }, () => empty7());
    let index3 = 0;
    while (index3 < capacity10) {
      const pairs = unsafeGet9(buckets.chunk[index3], journal);
      const iterator = pairs[Symbol.iterator]();
      let next6;
      while ((next6 = iterator.next()) && !next6.done) {
        const newIndex2 = indexOf2(next6.value[0], newCapacity);
        newBuckets[newIndex2] = prepend3(newBuckets[newIndex2], next6.value);
      }
      index3 = index3 + 1;
    }
    const newIndex = indexOf2(key, newCapacity);
    newBuckets[newIndex] = prepend3(newBuckets[newIndex], [key, value10]);
    const newArray = [];
    index3 = 0;
    while (index3 < newCapacity) {
      newArray[index3] = new TRefImpl(newBuckets[index3]);
      index3 = index3 + 1;
    }
    const newTArray = new TArrayImpl(newArray);
    unsafeSet2(self.tBuckets, newTArray, journal);
  };
  return effect3((journal) => {
    const buckets = unsafeGet9(self.tBuckets, journal);
    const capacity10 = buckets.chunk.length;
    const index3 = indexOf2(key, capacity10);
    const bucket = unsafeGet9(buckets.chunk[index3], journal);
    const shouldUpdate = some8(bucket, (entry) => equals(key)(entry[0]));
    if (shouldUpdate) {
      const newBucket = map7(bucket, (entry) => equals(key)(entry[0]) ? [key, value10] : entry);
      unsafeSet2(buckets.chunk[index3], newBucket, journal);
    } else {
      const newSize = unsafeGet9(self.tSize, journal) + 1;
      unsafeSet2(self.tSize, newSize, journal);
      if (capacity10 * LoadFactor < newSize) {
        resize(journal, buckets);
      } else {
        const newBucket = prepend3(bucket, [key, value10]);
        unsafeSet2(buckets.chunk[index3], newBucket, journal);
      }
    }
  });
});
var setIfAbsent = dual(3, (self, key, value10) => flatMap22(get39(self, key), match2({
  onNone: () => set21(self, key, value10),
  onSome: () => void_10
})));
var size34 = (self) => get17(self.tSize);
var takeFirst = dual(2, (self, pf) => pipe(effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const size45 = unsafeGet9(self.tSize, journal);
  let result = none2();
  let index3 = 0;
  while (index3 < capacity10 && isNone2(result)) {
    const bucket = unsafeGet9(buckets.chunk[index3], journal);
    const recreate = some8(bucket, (entry) => isSome2(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty7();
      let next6;
      while ((next6 = iterator.next()) && !next6.done && isNone2(result)) {
        const option11 = pf(next6.value[0], next6.value[1]);
        if (isSome2(option11) && isNone2(result)) {
          result = option11;
        } else {
          newBucket = prepend3(newBucket, next6.value);
        }
      }
      unsafeSet2(buckets.chunk[index3], newBucket, journal);
    }
    index3 = index3 + 1;
  }
  if (isSome2(result)) {
    unsafeSet2(self.tSize, size45 - 1, journal);
  }
  return result;
}), collect3((option11) => isSome2(option11) ? some3(option11.value) : none2())));
var takeFirstSTM = dual(2, (self, pf) => pipe(findSTM(self, (key, value10) => map31(pf(key, value10), (a) => [key, a])), collect3((option11) => isSome2(option11) ? some3(option11.value) : none2()), flatMap22((entry) => as12(remove15(self, entry[0]), entry[1]))));
var takeSome = dual(2, (self, pf) => pipe(effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const builder = [];
  let newSize = 0;
  let index3 = 0;
  while (index3 < capacity10) {
    const bucket = unsafeGet9(buckets.chunk[index3], journal);
    const recreate = some8(bucket, (entry) => isSome2(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty7();
      let next6;
      while ((next6 = iterator.next()) && !next6.done) {
        const option11 = pf(next6.value[0], next6.value[1]);
        if (isSome2(option11)) {
          builder.push(option11.value);
        } else {
          newBucket = prepend3(newBucket, next6.value);
          newSize = newSize + 1;
        }
      }
      unsafeSet2(buckets.chunk[index3], newBucket, journal);
    } else {
      newSize = newSize + bucket.length;
    }
    index3 = index3 + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
  if (builder.length > 0) {
    return some3(builder);
  }
  return none2();
}), collect3((option11) => isSome2(option11) ? some3(option11.value) : none2())));
var takeSomeSTM = dual(2, (self, pf) => pipe(findAllSTM(self, (key, value10) => map31(pf(key, value10), (a) => [key, a])), map31((chunk7) => isNonEmptyArray2(chunk7) ? some3(chunk7) : none2()), collect3((option11) => isSome2(option11) ? some3(option11.value) : none2()), flatMap22((entries6) => as12(removeAll(self, entries6.map((entry) => entry[0])), map6(entries6, (entry) => entry[1])))));
var toReadonlyArray2 = (self) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const builder = [];
  let index3 = 0;
  while (index3 < capacity10) {
    const bucket = buckets.chunk[index3];
    for (const entry of unsafeGet9(bucket, journal)) {
      builder.push(entry);
    }
    index3 = index3 + 1;
  }
  return builder;
});
var toChunk2 = (self) => reduce25(self, empty7(), (acc, value10, key) => append3(acc, [key, value10]));
var toHashMap = (self) => reduce25(self, empty11(), (acc, value10, key) => pipe(acc, set4(key, value10)));
var toArray6 = (self) => reduce25(self, [], (acc, value10, key) => {
  acc.unshift([key, value10]);
  return acc;
});
var toMap = (self) => reduce25(self, /* @__PURE__ */ new Map(), (acc, value10, key) => acc.set(key, value10));
var transform6 = dual(2, (self, f2) => effect3((journal) => {
  const buckets = pipe(self.tBuckets, unsafeGet9(journal));
  const capacity10 = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity10
  }, () => empty7());
  let newSize = 0;
  let index3 = 0;
  while (index3 < capacity10) {
    const bucket = buckets.chunk[index3];
    const pairs = unsafeGet9(bucket, journal);
    const iterator = pairs[Symbol.iterator]();
    let next6;
    while ((next6 = iterator.next()) && !next6.done) {
      const newPair = f2(next6.value[0], next6.value[1]);
      const index4 = indexOf2(newPair[0], capacity10);
      const newBucket = newBuckets[index4];
      if (!some8(newBucket, (entry) => equals(entry[0], newPair[0]))) {
        newBuckets[index4] = prepend3(newBucket, newPair);
        newSize = newSize + 1;
      }
    }
    index3 = index3 + 1;
  }
  index3 = 0;
  while (index3 < capacity10) {
    unsafeSet2(buckets.chunk[index3], newBuckets[index3], journal);
    index3 = index3 + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
}));
var transformSTM3 = dual(2, (self, f2) => pipe(flatMap22(toReadonlyArray2(self), forEach18((entry) => f2(entry[0], entry[1]))), flatMap22((newData) => effect3((journal) => {
  const buckets = unsafeGet9(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity10
  }, () => empty7());
  const iterator = newData[Symbol.iterator]();
  let newSize = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const index4 = indexOf2(next6.value[0], capacity10);
    const newBucket = newBuckets[index4];
    if (!some8(newBucket, (entry) => equals(entry[0])(next6.value[0]))) {
      newBuckets[index4] = prepend3(newBucket, next6.value);
      newSize = newSize + 1;
    }
  }
  let index3 = 0;
  while (index3 < capacity10) {
    unsafeSet2(buckets.chunk[index3], newBuckets[index3], journal);
    index3 = index3 + 1;
  }
  unsafeSet2(self.tSize, newSize, journal);
}))));
var transformValues = dual(2, (self, f2) => transform6(self, (key, value10) => [key, f2(value10)]));
var transformValuesSTM = dual(2, (self, f2) => transformSTM3(self, (key, value10) => map31(f2(value10), (value11) => [key, value11])));
var updateWith3 = dual(3, (self, key, f2) => flatMap22(get39(self, key), (option11) => match2(f2(option11), {
  onNone: () => as12(remove15(self, key), none2()),
  onSome: (value10) => as12(set21(self, key, value10), some3(value10))
})));
var values11 = (self) => map31(toReadonlyArray2(self), map6((entry) => entry[1]));

// node_modules/effect/dist/esm/TMap.js
var TMapTypeId2 = TMapTypeId;
var empty53 = empty52;
var find6 = find5;
var findSTM2 = findSTM;
var findAll4 = findAll3;
var findAllSTM2 = findAllSTM;
var forEach24 = forEach23;
var fromIterable27 = fromIterable26;
var get40 = get39;
var getOrElse9 = getOrElse8;
var has14 = has13;
var isEmpty25 = isEmpty24;
var keys12 = keys11;
var make130 = make129;
var merge15 = merge14;
var reduce26 = reduce25;
var reduceSTM4 = reduceSTM3;
var remove16 = remove15;
var removeAll2 = removeAll;
var removeIf2 = removeIf;
var retainIf2 = retainIf;
var set22 = set21;
var setIfAbsent2 = setIfAbsent;
var size35 = size34;
var takeFirst2 = takeFirst;
var takeFirstSTM2 = takeFirstSTM;
var takeSome2 = takeSome;
var takeSomeSTM2 = takeSomeSTM;
var toChunk3 = toChunk2;
var toHashMap2 = toHashMap;
var toArray7 = toArray6;
var toMap2 = toMap;
var transform7 = transform6;
var transformSTM4 = transformSTM3;
var transformValues2 = transformValues;
var transformValuesSTM2 = transformValuesSTM;
var updateWith4 = updateWith3;
var values12 = values11;

// node_modules/effect/dist/esm/TPriorityQueue.js
var TPriorityQueue_exports = {};
__export(TPriorityQueue_exports, {
  TPriorityQueueTypeId: () => TPriorityQueueTypeId2,
  empty: () => empty55,
  fromIterable: () => fromIterable29,
  isEmpty: () => isEmpty27,
  isNonEmpty: () => isNonEmpty10,
  make: () => make132,
  offer: () => offer8,
  offerAll: () => offerAll7,
  peek: () => peek4,
  peekOption: () => peekOption4,
  removeIf: () => removeIf4,
  retainIf: () => retainIf4,
  size: () => size37,
  take: () => take15,
  takeAll: () => takeAll6,
  takeOption: () => takeOption2,
  takeUpTo: () => takeUpTo6,
  toArray: () => toArray9,
  toChunk: () => toChunk5
});

// node_modules/effect/dist/esm/internal/stm/tPriorityQueue.js
var TPriorityQueueSymbolKey = "effect/TPriorityQueue";
var TPriorityQueueTypeId = Symbol.for(TPriorityQueueSymbolKey);
var tPriorityQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a90;
_a90 = TPriorityQueueTypeId;
var TPriorityQueueImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a90, tPriorityQueueVariance);
    this.ref = ref;
  }
};
var empty54 = (order) => pipe(make69(empty48(order)), map31((ref) => new TPriorityQueueImpl(ref)));
var fromIterable28 = (order) => (iterable) => pipe(make69(fromIterable2(iterable).reduce((map49, value10) => pipe(map49, set17(value10, pipe(map49, get33(value10), match2({
  onNone: () => of2(value10),
  onSome: prepend2(value10)
})))), empty48(order))), map31((ref) => new TPriorityQueueImpl(ref)));
var isEmpty26 = (self) => map31(get17(self.ref), isEmpty23);
var isNonEmpty9 = (self) => map31(get17(self.ref), isNonEmpty8);
var make131 = (order) => (...elements) => fromIterable28(order)(elements);
var offer7 = dual(2, (self, value10) => update8(self.ref, (map49) => set17(map49, value10, match2(get33(map49, value10), {
  onNone: () => of2(value10),
  onSome: prepend2(value10)
}))));
var offerAll6 = dual(2, (self, values15) => update8(self.ref, (map49) => fromIterable2(values15).reduce((map50, value10) => set17(map50, value10, match2(get33(map50, value10), {
  onNone: () => of2(value10),
  onSome: prepend2(value10)
})), map49)));
var peek3 = (self) => withSTMRuntime((runtime8) => {
  const map49 = unsafeGet9(self.ref, runtime8.journal);
  return match2(headOption(map49), {
    onNone: () => retry6,
    onSome: (elements) => succeed19(elements[0])
  });
});
var peekOption3 = (self) => modify12(self.ref, (map49) => [map2(headOption(map49), (elements) => elements[0]), map49]);
var removeIf3 = dual(2, (self, predicate) => retainIf3(self, (a) => !predicate(a)));
var retainIf3 = dual(2, (self, predicate) => update8(self.ref, (map49) => reduce22(map49, empty48(getOrder7(map49)), (map50, value10, key) => {
  const filtered = filter4(value10, predicate);
  return filtered.length > 0 ? set17(map50, key, filtered) : remove14(map50, key);
})));
var size36 = (self) => modify12(self.ref, (map49) => [reduce22(map49, 0, (n, as18) => n + as18.length), map49]);
var take14 = (self) => withSTMRuntime((runtime8) => {
  const map49 = unsafeGet9(self.ref, runtime8.journal);
  return match2(headOption(map49), {
    onNone: () => retry6,
    onSome: (values15) => {
      const head13 = values15[1][0];
      const tail5 = values15[1].slice(1);
      unsafeSet2(self.ref, tail5.length > 0 ? set17(map49, head13, tail5) : remove14(map49, head13), runtime8.journal);
      return succeed19(head13);
    }
  });
});
var takeAll5 = (self) => modify12(self.ref, (map49) => {
  const builder = [];
  for (const entry of map49) {
    for (const value10 of entry[1]) {
      builder.push(value10);
    }
  }
  return [builder, empty48(getOrder7(map49))];
});
var takeOption = (self) => effect3((journal) => {
  const map49 = pipe(self.ref, unsafeGet9(journal));
  return match2(headOption(map49), {
    onNone: () => none2(),
    onSome: ([key, value10]) => {
      const tail5 = value10.slice(1);
      unsafeSet2(self.ref, tail5.length > 0 ? set17(map49, key, tail5) : remove14(map49, key), journal);
      return some3(value10[0]);
    }
  });
});
var takeUpTo5 = dual(2, (self, n) => modify12(self.ref, (map49) => {
  const builder = [];
  const iterator = map49[Symbol.iterator]();
  let updated = map49;
  let index3 = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done && index3 < n) {
    const [key, value10] = next6.value;
    const [left3, right3] = pipe(value10, splitAt(n - index3));
    for (const value11 of left3) {
      builder.push(value11);
    }
    if (right3.length > 0) {
      updated = set17(updated, key, right3);
    } else {
      updated = remove14(updated, key);
    }
    index3 = index3 + left3.length;
  }
  return [builder, updated];
}));
var toChunk4 = (self) => modify12(self.ref, (map49) => {
  const builder = [];
  for (const entry of map49) {
    for (const value10 of entry[1]) {
      builder.push(value10);
    }
  }
  return [unsafeFromArray(builder), map49];
});
var toArray8 = (self) => modify12(self.ref, (map49) => {
  const builder = [];
  for (const entry of map49) {
    for (const value10 of entry[1]) {
      builder.push(value10);
    }
  }
  return [builder, map49];
});

// node_modules/effect/dist/esm/TPriorityQueue.js
var TPriorityQueueTypeId2 = TPriorityQueueTypeId;
var empty55 = empty54;
var fromIterable29 = fromIterable28;
var isEmpty27 = isEmpty26;
var isNonEmpty10 = isNonEmpty9;
var make132 = make131;
var offer8 = offer7;
var offerAll7 = offerAll6;
var peek4 = peek3;
var peekOption4 = peekOption3;
var removeIf4 = removeIf3;
var retainIf4 = retainIf3;
var size37 = size36;
var take15 = take14;
var takeAll6 = takeAll5;
var takeOption2 = takeOption;
var takeUpTo6 = takeUpTo5;
var toChunk5 = toChunk4;
var toArray9 = toArray8;

// node_modules/effect/dist/esm/TRandom.js
var TRandom_exports = {};
__export(TRandom_exports, {
  TRandomTypeId: () => TRandomTypeId2,
  Tag: () => Tag5,
  live: () => live2,
  next: () => next5,
  nextBoolean: () => nextBoolean4,
  nextInt: () => nextInt4,
  nextIntBetween: () => nextIntBetween4,
  nextRange: () => nextRange4,
  shuffle: () => shuffle4
});

// node_modules/effect/dist/esm/internal/stm/tRandom.js
var TRandomSymbolKey = "effect/TRandom";
var TRandomTypeId = Symbol.for(TRandomSymbolKey);
var randomInteger = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.integer(0), prng.getState()];
};
var randomIntegerBetween = (low, high) => {
  return (state) => {
    const prng = new PCGRandom();
    prng.setState(state);
    return [prng.integer(high - low) + low, prng.getState()];
  };
};
var randomNumber = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.number(), prng.getState()];
};
var withState = (state, f2) => {
  return pipe(state, modify12(f2));
};
var shuffleWith2 = (iterable, nextIntBounded) => {
  const swap4 = (buffer7, index1, index22) => pipe(buffer7, get37(index1), flatMap22((tmp) => pipe(buffer7, updateSTM(index1, () => pipe(buffer7, get37(index22))), zipRight11(pipe(buffer7, update12(index22, () => tmp))))));
  return pipe(fromIterable24(iterable), flatMap22((buffer7) => {
    const array8 = [];
    for (let i = array8.length; i >= 2; i = i - 1) {
      array8.push(i);
    }
    return pipe(array8, forEach18((n) => pipe(nextIntBounded(n), flatMap22((k) => swap4(buffer7, n - 1, k))), {
      discard: true
    }), zipRight11(toArray4(buffer7)));
  }));
};
var Tag4 = GenericTag("effect/TRandom");
var _a91;
_a91 = TRandomTypeId;
var TRandomImpl = class {
  constructor(state) {
    __publicField(this, "state");
    __publicField(this, _a91, TRandomTypeId);
    __publicField(this, "next");
    __publicField(this, "nextBoolean");
    __publicField(this, "nextInt");
    this.state = state;
    this.next = withState(this.state, randomNumber);
    this.nextBoolean = flatMap22(this.next, (n) => succeed19(n > 0.5));
    this.nextInt = withState(this.state, randomInteger);
  }
  nextRange(min11, max14) {
    return flatMap22(this.next, (n) => succeed19((max14 - min11) * n + min11));
  }
  nextIntBetween(low, high) {
    return withState(this.state, randomIntegerBetween(low, high));
  }
  shuffle(elements) {
    return shuffleWith2(elements, (n) => this.nextIntBetween(0, n));
  }
};
var live = effect(Tag4, pipe(make69(new PCGRandom(Math.random() * 4294967296 >>> 0).getState()), map31((seed) => new TRandomImpl(seed)), commit2));
var next4 = flatMap22(Tag4, (random6) => random6.next);
var nextBoolean3 = flatMap22(Tag4, (random6) => random6.nextBoolean);
var nextInt3 = flatMap22(Tag4, (random6) => random6.nextInt);
var nextIntBetween3 = (low, high) => flatMap22(Tag4, (random6) => random6.nextIntBetween(low, high));
var nextRange3 = (min11, max14) => flatMap22(Tag4, (random6) => random6.nextRange(min11, max14));
var shuffle3 = (elements) => flatMap22(Tag4, (random6) => random6.shuffle(elements));

// node_modules/effect/dist/esm/TRandom.js
var TRandomTypeId2 = TRandomTypeId;
var Tag5 = Tag4;
var live2 = live;
var next5 = next4;
var nextBoolean4 = nextBoolean3;
var nextInt4 = nextInt3;
var nextIntBetween4 = nextIntBetween3;
var nextRange4 = nextRange3;
var shuffle4 = shuffle3;

// node_modules/effect/dist/esm/TReentrantLock.js
var TReentrantLock_exports = {};
__export(TReentrantLock_exports, {
  TReentrantLockTypeId: () => TReentrantLockTypeId2,
  acquireRead: () => acquireRead2,
  acquireWrite: () => acquireWrite2,
  fiberReadLocks: () => fiberReadLocks2,
  fiberWriteLocks: () => fiberWriteLocks2,
  lock: () => lock2,
  locked: () => locked2,
  make: () => make134,
  readLock: () => readLock2,
  readLocked: () => readLocked2,
  readLocks: () => readLocks2,
  releaseRead: () => releaseRead2,
  releaseWrite: () => releaseWrite2,
  withLock: () => withLock2,
  withReadLock: () => withReadLock2,
  withWriteLock: () => withWriteLock2,
  writeLock: () => writeLock2,
  writeLocked: () => writeLocked2,
  writeLocks: () => writeLocks2
});

// node_modules/effect/dist/esm/internal/stm/tReentrantLock.js
var TReentrantLockSymbolKey = "effect/TReentrantLock";
var TReentrantLockTypeId = Symbol.for(TReentrantLockSymbolKey);
var WriteLockTypeId = Symbol.for("effect/TReentrantLock/WriteLock");
var ReadLockTypeId = Symbol.for("effect/TReentrantLock/ReadLock");
var _a92;
_a92 = TReentrantLockTypeId;
var TReentranLockImpl = class {
  constructor(state) {
    __publicField(this, "state");
    __publicField(this, _a92, TReentrantLockTypeId);
    this.state = state;
  }
};
var _a93;
_a93 = ReadLockTypeId;
var ReadLock = class {
  constructor(readers) {
    __publicField(this, "readers");
    __publicField(this, _a93, ReadLockTypeId);
    this.readers = readers;
  }
  get readLocks() {
    return Array.from(this.readers).reduce((acc, curr) => acc + curr[1], 0);
  }
  get writeLocks() {
    return 0;
  }
  readLocksHeld(fiberId5) {
    return getOrElse2(get8(this.readers, fiberId5), () => 0);
  }
  writeLocksHeld(_fiberId) {
    return 0;
  }
};
var _a94;
_a94 = WriteLockTypeId;
var WriteLock = class {
  constructor(readLocks3, writeLocks3, fiberId5) {
    __publicField(this, "readLocks");
    __publicField(this, "writeLocks");
    __publicField(this, "fiberId");
    __publicField(this, _a94, WriteLockTypeId);
    this.readLocks = readLocks3;
    this.writeLocks = writeLocks3;
    this.fiberId = fiberId5;
  }
  readLocksHeld(fiberId5) {
    return equals(fiberId5)(this.fiberId) ? this.readLocks : 0;
  }
  writeLocksHeld(fiberId5) {
    return equals(fiberId5)(this.fiberId) ? this.writeLocks : 0;
  }
};
var isReadLock = (lock3) => {
  return ReadLockTypeId in lock3;
};
var isWriteLock = (lock3) => {
  return WriteLockTypeId in lock3;
};
var emptyReadLock = new ReadLock(empty11());
var makeReadLock = (fiberId5, count9) => {
  if (count9 <= 0) {
    return emptyReadLock;
  }
  return new ReadLock(make18([fiberId5, count9]));
};
var noOtherHolder = (readLock3, fiberId5) => {
  return isEmpty4(readLock3.readers) || size10(readLock3.readers) === 1 && has5(readLock3.readers, fiberId5);
};
var adjustReadLock = (readLock3, fiberId5, adjustment) => {
  const total = readLock3.readLocksHeld(fiberId5);
  const newTotal = total + adjustment;
  if (newTotal < 0) {
    throw new Error("BUG - TReentrantLock.ReadLock.adjust - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  if (newTotal === 0) {
    return new ReadLock(remove7(readLock3.readers, fiberId5));
  }
  return new ReadLock(set4(readLock3.readers, fiberId5, newTotal));
};
var adjustRead = (self, delta) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet9(self.state, runtime8.journal);
  if (isReadLock(lock3)) {
    const result = adjustReadLock(lock3, runtime8.fiberId, delta);
    unsafeSet2(self.state, result, runtime8.journal);
    return succeed19(result.readLocksHeld(runtime8.fiberId));
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    const newTotal = lock3.readLocks + delta;
    if (newTotal < 0) {
      throw new Error(`Defect: Fiber ${threadName2(runtime8.fiberId)} releasing read locks it does not hold, newTotal: ${newTotal}`);
    }
    unsafeSet2(self.state, new WriteLock(newTotal, lock3.writeLocks, runtime8.fiberId), runtime8.journal);
    return succeed19(newTotal);
  }
  return retry6;
});
var acquireRead = (self) => adjustRead(self, 1);
var acquireWrite = (self) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet9(self.state, runtime8.journal);
  if (isReadLock(lock3) && noOtherHolder(lock3, runtime8.fiberId)) {
    unsafeSet2(self.state, new WriteLock(lock3.readLocksHeld(runtime8.fiberId), 1, runtime8.fiberId), runtime8.journal);
    return succeed19(1);
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    unsafeSet2(self.state, new WriteLock(lock3.readLocks, lock3.writeLocks + 1, runtime8.fiberId), runtime8.journal);
    return succeed19(lock3.writeLocks + 1);
  }
  return retry6;
});
var fiberReadLocks = (self) => effect3((journal, fiberId5) => unsafeGet9(self.state, journal).readLocksHeld(fiberId5));
var fiberWriteLocks = (self) => effect3((journal, fiberId5) => unsafeGet9(self.state, journal).writeLocksHeld(fiberId5));
var lock = (self) => writeLock(self);
var locked = (self) => zipWith16(readLocked(self), writeLocked(self), (x, y) => x || y);
var make133 = map31(make69(emptyReadLock), (readLock3) => new TReentranLockImpl(readLock3));
var readLock = (self) => acquireRelease3(commit2(acquireRead(self)), () => commit2(releaseRead(self)));
var readLocks = (self) => map31(get17(self.state), (state) => state.readLocks);
var readLocked = (self) => map31(get17(self.state), (state) => state.readLocks > 0);
var releaseRead = (self) => adjustRead(self, -1);
var releaseWrite = (self) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet9(self.state, runtime8.journal);
  if (isWriteLock(lock3) && lock3.writeLocks === 1 && equals(runtime8.fiberId)(lock3.fiberId)) {
    const result = makeReadLock(lock3.fiberId, lock3.readLocks);
    unsafeSet2(self.state, result, runtime8.journal);
    return succeed19(result.writeLocksHeld(runtime8.fiberId));
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    const result = new WriteLock(lock3.readLocks, lock3.writeLocks - 1, runtime8.fiberId);
    unsafeSet2(self.state, result, runtime8.journal);
    return succeed19(result.writeLocksHeld(runtime8.fiberId));
  }
  throw new Error(`Defect: Fiber ${threadName2(runtime8.fiberId)} releasing write lock it does not hold`);
});
var withLock = dual(2, (effect4, self) => withWriteLock(effect4, self));
var withReadLock = dual(2, (effect4, self) => uninterruptibleMask3((restore) => zipRight7(restore(commit2(acquireRead(self))), ensuring4(effect4, commit2(releaseRead(self))))));
var withWriteLock = dual(2, (effect4, self) => uninterruptibleMask3((restore) => zipRight7(restore(commit2(acquireWrite(self))), ensuring4(effect4, commit2(releaseWrite(self))))));
var writeLock = (self) => acquireRelease3(commit2(acquireWrite(self)), () => commit2(releaseWrite(self)));
var writeLocked = (self) => map31(get17(self.state), (state) => state.writeLocks > 0);
var writeLocks = (self) => map31(get17(self.state), (state) => state.writeLocks);

// node_modules/effect/dist/esm/TReentrantLock.js
var TReentrantLockTypeId2 = TReentrantLockTypeId;
var acquireRead2 = acquireRead;
var acquireWrite2 = acquireWrite;
var fiberReadLocks2 = fiberReadLocks;
var fiberWriteLocks2 = fiberWriteLocks;
var lock2 = lock;
var locked2 = locked;
var make134 = make133;
var readLock2 = readLock;
var readLocks2 = readLocks;
var readLocked2 = readLocked;
var releaseRead2 = releaseRead;
var releaseWrite2 = releaseWrite;
var withLock2 = withLock;
var withReadLock2 = withReadLock;
var withWriteLock2 = withWriteLock;
var writeLock2 = writeLock;
var writeLocked2 = writeLocked;
var writeLocks2 = writeLocks;

// node_modules/effect/dist/esm/TRef.js
var TRef_exports = {};
__export(TRef_exports, {
  TRefTypeId: () => TRefTypeId2,
  get: () => get41,
  getAndSet: () => getAndSet8,
  getAndUpdate: () => getAndUpdate8,
  getAndUpdateSome: () => getAndUpdateSome7,
  make: () => make135,
  modify: () => modify17,
  modifySome: () => modifySome7,
  set: () => set23,
  setAndGet: () => setAndGet7,
  update: () => update14,
  updateAndGet: () => updateAndGet8,
  updateSome: () => updateSome7,
  updateSomeAndGet: () => updateSomeAndGet7
});
var TRefTypeId2 = TRefTypeId;
var get41 = get17;
var getAndSet8 = getAndSet5;
var getAndUpdate8 = getAndUpdate5;
var getAndUpdateSome7 = getAndUpdateSome4;
var make135 = make69;
var modify17 = modify12;
var modifySome7 = modifySome4;
var set23 = set10;
var setAndGet7 = setAndGet4;
var update14 = update8;
var updateAndGet8 = updateAndGet5;
var updateSome7 = updateSome4;
var updateSomeAndGet7 = updateSomeAndGet4;

// node_modules/effect/dist/esm/TSemaphore.js
var TSemaphore_exports = {};
__export(TSemaphore_exports, {
  TSemaphoreTypeId: () => TSemaphoreTypeId2,
  acquire: () => acquire3,
  acquireN: () => acquireN2,
  available: () => available2,
  make: () => make137,
  release: () => release3,
  releaseN: () => releaseN2,
  unsafeMake: () => unsafeMake20,
  withPermit: () => withPermit2,
  withPermitScoped: () => withPermitScoped2,
  withPermits: () => withPermits2,
  withPermitsScoped: () => withPermitsScoped2
});

// node_modules/effect/dist/esm/internal/stm/tSemaphore.js
var TSemaphoreSymbolKey = "effect/TSemaphore";
var TSemaphoreTypeId = Symbol.for(TSemaphoreSymbolKey);
var _a95;
_a95 = TSemaphoreTypeId;
var TSemaphoreImpl = class {
  constructor(permits) {
    __publicField(this, "permits");
    __publicField(this, _a95, TSemaphoreTypeId);
    this.permits = permits;
  }
};
var make136 = (permits) => map40(make69(permits), (permits2) => new TSemaphoreImpl(permits2));
var acquire2 = (self) => acquireN(self, 1);
var acquireN = dual(2, (self, n) => withSTMRuntime((driver3) => {
  if (n < 0) {
    throw new IllegalArgumentException2(`Unexpected negative value ${n} passed to Semaphore.acquireN`);
  }
  const value10 = unsafeGet9(self.permits, driver3.journal);
  if (value10 < n) {
    return retry10;
  } else {
    return succeed27(unsafeSet2(self.permits, value10 - n, driver3.journal));
  }
}));
var available = (self) => get17(self.permits);
var release2 = (self) => releaseN(self, 1);
var releaseN = dual(2, (self, n) => withSTMRuntime((driver3) => {
  if (n < 0) {
    throw new IllegalArgumentException2(`Unexpected negative value ${n} passed to Semaphore.releaseN`);
  }
  const current2 = unsafeGet9(self.permits, driver3.journal);
  return succeed27(unsafeSet2(self.permits, current2 + n, driver3.journal));
}));
var withPermit = dual(2, (self, semaphore) => withPermits(self, semaphore, 1));
var withPermits = dual(3, (self, semaphore, permits) => uninterruptibleMask3((restore) => zipRight7(restore(commit2(acquireN(permits)(semaphore))), ensuring4(self, commit2(releaseN(permits)(semaphore))))));
var withPermitScoped = (self) => withPermitsScoped(self, 1);
var withPermitsScoped = dual(2, (self, permits) => acquireReleaseInterruptible2(commit2(acquireN(self, permits)), () => commit2(releaseN(self, permits))));
var unsafeMakeSemaphore3 = (permits) => {
  return new TSemaphoreImpl(new TRefImpl(permits));
};

// node_modules/effect/dist/esm/TSemaphore.js
var TSemaphoreTypeId2 = TSemaphoreTypeId;
var acquire3 = acquire2;
var acquireN2 = acquireN;
var available2 = available;
var make137 = make136;
var release3 = release2;
var releaseN2 = releaseN;
var withPermit2 = withPermit;
var withPermits2 = withPermits;
var withPermitScoped2 = withPermitScoped;
var withPermitsScoped2 = withPermitsScoped;
var unsafeMake20 = unsafeMakeSemaphore3;

// node_modules/effect/dist/esm/TSet.js
var TSet_exports = {};
__export(TSet_exports, {
  TSetTypeId: () => TSetTypeId2,
  add: () => add13,
  difference: () => difference8,
  empty: () => empty57,
  forEach: () => forEach26,
  fromIterable: () => fromIterable31,
  has: () => has16,
  intersection: () => intersection9,
  isEmpty: () => isEmpty29,
  make: () => make139,
  reduce: () => reduce28,
  reduceSTM: () => reduceSTM6,
  remove: () => remove18,
  removeAll: () => removeAll4,
  removeIf: () => removeIf6,
  retainIf: () => retainIf6,
  size: () => size39,
  takeFirst: () => takeFirst4,
  takeFirstSTM: () => takeFirstSTM4,
  takeSome: () => takeSome4,
  takeSomeSTM: () => takeSomeSTM4,
  toArray: () => toArray11,
  toChunk: () => toChunk7,
  toHashSet: () => toHashSet2,
  toReadonlySet: () => toReadonlySet2,
  transform: () => transform9,
  transformSTM: () => transformSTM6,
  union: () => union16
});

// node_modules/effect/dist/esm/internal/stm/tSet.js
var TSetSymbolKey = "effect/TSet";
var TSetTypeId = Symbol.for(TSetSymbolKey);
var tSetVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a96;
_a96 = TSetTypeId;
var TSetImpl = class {
  constructor(tMap) {
    __publicField(this, "tMap");
    __publicField(this, _a96, tSetVariance);
    this.tMap = tMap;
  }
};
var isTSet = (u) => hasProperty(u, TSetTypeId);
var add12 = dual(2, (self, value10) => set21(self.tMap, value10, void 0));
var difference7 = dual(2, (self, other) => flatMap22(toHashSet(other), (values15) => removeIf5(self, (value10) => has4(values15, value10), {
  discard: true
})));
var empty56 = () => fromIterable30([]);
var forEach25 = dual(2, (self, f2) => reduceSTM5(self, void 0, (_, value10) => f2(value10)));
var fromIterable30 = (iterable) => map31(fromIterable26(Array.from(iterable).map((a) => [a, void 0])), (tMap) => new TSetImpl(tMap));
var has15 = dual(2, (self, value10) => has13(self.tMap, value10));
var intersection8 = dual(2, (self, other) => flatMap22(toHashSet(other), (values15) => pipe(self, retainIf5((value10) => pipe(values15, has4(value10)), {
  discard: true
}))));
var isEmpty28 = (self) => isEmpty24(self.tMap);
var make138 = (...elements) => fromIterable30(elements);
var reduce27 = dual(3, (self, zero3, f2) => reduce25(self.tMap, zero3, (acc, _, key) => f2(acc, key)));
var reduceSTM5 = dual(3, (self, zero3, f2) => reduceSTM3(self.tMap, zero3, (acc, _, key) => f2(acc, key)));
var remove17 = dual(2, (self, value10) => remove15(self.tMap, value10));
var removeAll3 = dual(2, (self, iterable) => removeAll(self.tMap, iterable));
var removeIf5 = dual((args2) => isTSet(args2[0]), (self, predicate, options) => (options == null ? void 0 : options.discard) === true ? removeIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(removeIf(self.tMap, (key) => predicate(key)), map31(map6((entry) => entry[0]))));
var retainIf5 = dual((args2) => isTSet(args2[0]), (self, predicate, options) => (options == null ? void 0 : options.discard) === true ? retainIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(retainIf(self.tMap, (key) => predicate(key)), map31(map6((entry) => entry[0]))));
var size38 = (self) => map31(toChunk6(self), (chunk7) => chunk7.length);
var takeFirst3 = dual(2, (self, pf) => takeFirst(self.tMap, (key) => pf(key)));
var takeFirstSTM3 = dual(2, (self, pf) => takeFirstSTM(self.tMap, (key) => pf(key)));
var takeSome3 = dual(2, (self, pf) => takeSome(self.tMap, (key) => pf(key)));
var takeSomeSTM3 = dual(2, (self, pf) => takeSomeSTM(self.tMap, (key) => pf(key)));
var toChunk6 = (self) => keys11(self.tMap).pipe(map40(unsafeFromArray));
var toHashSet = (self) => reduce27(self, empty10(), (acc, value10) => pipe(acc, add5(value10)));
var toArray10 = (self) => reduce27(self, [], (acc, value10) => [...acc, value10]);
var toReadonlySet = (self) => map31(toArray10(self), (values15) => new Set(values15));
var transform8 = dual(2, (self, f2) => transform6(self.tMap, (key, value10) => [f2(key), value10]));
var transformSTM5 = dual(2, (self, f2) => transformSTM3(self.tMap, (key, value10) => map31(f2(key), (a) => [a, value10])));
var union15 = dual(2, (self, other) => forEach25(other, (value10) => add12(self, value10)));

// node_modules/effect/dist/esm/TSet.js
var TSetTypeId2 = TSetTypeId;
var add13 = add12;
var difference8 = difference7;
var empty57 = empty56;
var forEach26 = forEach25;
var fromIterable31 = fromIterable30;
var has16 = has15;
var intersection9 = intersection8;
var isEmpty29 = isEmpty28;
var make139 = make138;
var reduce28 = reduce27;
var reduceSTM6 = reduceSTM5;
var remove18 = remove17;
var removeAll4 = removeAll3;
var removeIf6 = removeIf5;
var retainIf6 = retainIf5;
var size39 = size38;
var takeFirst4 = takeFirst3;
var takeFirstSTM4 = takeFirstSTM3;
var takeSome4 = takeSome3;
var takeSomeSTM4 = takeSomeSTM3;
var toChunk7 = toChunk6;
var toHashSet2 = toHashSet;
var toArray11 = toArray10;
var toReadonlySet2 = toReadonlySet;
var transform9 = transform8;
var transformSTM6 = transformSTM5;
var union16 = union15;

// node_modules/effect/dist/esm/TSubscriptionRef.js
var TSubscriptionRef_exports = {};
__export(TSubscriptionRef_exports, {
  TSubscriptionRefTypeId: () => TSubscriptionRefTypeId2,
  changes: () => changes3,
  changesScoped: () => changesScoped2,
  changesStream: () => changesStream2,
  get: () => get43,
  getAndSet: () => getAndSet10,
  getAndUpdate: () => getAndUpdate10,
  getAndUpdateSome: () => getAndUpdateSome9,
  make: () => make141,
  modify: () => modify19,
  modifySome: () => modifySome9,
  set: () => set25,
  setAndGet: () => setAndGet9,
  update: () => update16,
  updateAndGet: () => updateAndGet10,
  updateSome: () => updateSome9,
  updateSomeAndGet: () => updateSomeAndGet9
});

// node_modules/effect/dist/esm/internal/stm/tSubscriptionRef.js
var TSubscriptionRefSymbolKey = "effect/TSubscriptionRef";
var TSubscriptionRefTypeId = Symbol.for(TSubscriptionRefSymbolKey);
var TSubscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a97;
_a97 = TDequeueTypeId2;
var TDequeueMerge = class {
  constructor(first5, second) {
    __publicField(this, "first");
    __publicField(this, "second");
    __publicField(this, _a97, tDequeueVariance);
    __publicField(this, "peek", gen8(this, function* () {
      const first5 = yield* this.peekOption;
      if (first5._tag === "Some") {
        return first5.value;
      }
      return yield* retry10;
    }));
    __publicField(this, "peekOption", gen8(this, function* () {
      const first5 = yield* this.first.peekOption;
      if (first5._tag === "Some") {
        return first5;
      }
      const second = yield* this.second.peekOption;
      if (second._tag === "Some") {
        return second;
      }
      return none2();
    }));
    __publicField(this, "take", gen8(this, function* () {
      if (!(yield* this.first.isEmpty)) {
        return yield* this.first.take;
      }
      if (!(yield* this.second.isEmpty)) {
        return yield* this.second.take;
      }
      return yield* retry10;
    }));
    __publicField(this, "takeAll", gen8(this, function* () {
      return [...yield* this.first.takeAll, ...yield* this.second.takeAll];
    }));
    __publicField(this, "size", gen8(this, function* () {
      return (yield* this.first.size) + (yield* this.second.size);
    }));
    __publicField(this, "isFull", gen8(this, function* () {
      return (yield* this.first.isFull) && (yield* this.second.isFull);
    }));
    __publicField(this, "isEmpty", gen8(this, function* () {
      return (yield* this.first.isEmpty) && (yield* this.second.isEmpty);
    }));
    __publicField(this, "shutdown", gen8(this, function* () {
      yield* this.first.shutdown;
      yield* this.second.shutdown;
    }));
    __publicField(this, "isShutdown", gen8(this, function* () {
      return (yield* this.first.isShutdown) && (yield* this.second.isShutdown);
    }));
    __publicField(this, "awaitShutdown", gen8(this, function* () {
      yield* this.first.awaitShutdown;
      yield* this.second.awaitShutdown;
    }));
    this.first = first5;
    this.second = second;
  }
  takeUpTo(max14) {
    return gen8(this, function* () {
      const first5 = yield* this.first.takeUpTo(max14);
      if (first5.length >= max14) {
        return first5;
      }
      return [...first5, ...yield* this.second.takeUpTo(max14 - first5.length)];
    });
  }
  capacity() {
    return this.first.capacity() + this.second.capacity();
  }
};
var _a98, _b30;
_b30 = TSubscriptionRefTypeId, _a98 = TRefTypeId2;
var TSubscriptionRefImpl = class {
  constructor(ref, pubsub) {
    __publicField(this, "ref");
    __publicField(this, "pubsub");
    __publicField(this, _b30, TSubscriptionRefVariance);
    __publicField(this, _a98, tRefVariance);
    this.ref = ref;
    this.pubsub = pubsub;
  }
  get todos() {
    return this.ref.todos;
  }
  get versioned() {
    return this.ref.versioned;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get changes() {
    return gen8(this, function* () {
      const first5 = yield* unbounded9();
      yield* offer5(first5, yield* get41(this.ref));
      return new TDequeueMerge(first5, yield* subscribe4(this.pubsub));
    });
  }
  modify(f2) {
    return pipe(get41(this.ref), map40(f2), flatMap26(([b, a]) => pipe(set23(this.ref, a), as15(b), zipLeft15(publish4(this.pubsub, a)))));
  }
};
var make140 = (value10) => pipe(all15([unbounded8(), make135(value10)]), map40(([pubsub, ref]) => new TSubscriptionRefImpl(ref, pubsub)));
var get42 = (self) => get41(self.ref);
var set24 = dual(2, (self, value10) => self.modify(() => [void 0, value10]));
var getAndSet9 = dual(2, (self, value10) => self.modify((a) => [a, value10]));
var getAndUpdate9 = dual(2, (self, f2) => self.modify((a) => [a, f2(a)]));
var getAndUpdateSome8 = dual(2, (self, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [a, a],
  onSome: (b) => [a, b]
})));
var setAndGet8 = dual(2, (self, value10) => self.modify(() => [value10, value10]));
var modify18 = dual(2, (self, f2) => self.modify(f2));
var modifySome8 = dual(3, (self, fallback3, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [fallback3, a],
  onSome: (b) => b
})));
var update15 = dual(2, (self, f2) => self.modify((a) => [void 0, f2(a)]));
var updateAndGet9 = dual(2, (self, f2) => self.modify((a) => {
  const b = f2(a);
  return [b, b];
}));
var updateSome8 = dual(2, (self, f2) => self.modify((a) => [void 0, match2(f2(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet8 = dual(2, (self, f2) => self.modify((a) => match2(f2(a), {
  onNone: () => [a, a],
  onSome: (b) => [b, b]
})));
var changesScoped = (self) => acquireRelease3(self.changes, shutdown8);
var changesStream = (self) => unwrap4(map26(self.changes, fromTQueue));

// node_modules/effect/dist/esm/TSubscriptionRef.js
var TSubscriptionRefTypeId2 = TSubscriptionRefTypeId;
var get43 = get42;
var getAndSet10 = getAndSet9;
var getAndUpdate10 = getAndUpdate9;
var getAndUpdateSome9 = getAndUpdateSome8;
var make141 = make140;
var modify19 = modify18;
var modifySome9 = modifySome8;
var set25 = set24;
var setAndGet9 = setAndGet8;
var update16 = update15;
var updateAndGet10 = updateAndGet9;
var updateSome9 = updateSome8;
var updateSomeAndGet9 = updateSomeAndGet8;
var changesScoped2 = changesScoped;
var changesStream2 = changesStream;
var changes3 = (self) => self.changes;

// node_modules/effect/dist/esm/Take.js
var Take_exports = {};
__export(Take_exports, {
  TakeTypeId: () => TakeTypeId2,
  chunk: () => chunk6,
  die: () => die18,
  dieMessage: () => dieMessage10,
  done: () => done14,
  end: () => end6,
  fail: () => fail29,
  failCause: () => failCause20,
  fromEffect: () => fromEffect16,
  fromExit: () => fromExit2,
  fromPull: () => fromPull4,
  isDone: () => isDone8,
  isFailure: () => isFailure9,
  isSuccess: () => isSuccess8,
  make: () => make142,
  map: () => map46,
  match: () => match40,
  matchEffect: () => matchEffect6,
  of: () => of8,
  tap: () => tap12
});
var TakeTypeId2 = TakeTypeId;
var chunk6 = chunk3;
var die18 = die13;
var dieMessage10 = dieMessage5;
var done14 = done11;
var end6 = end4;
var fail29 = fail18;
var failCause20 = failCause14;
var fromEffect16 = fromEffect8;
var fromExit2 = fromExit;
var fromPull4 = fromPull;
var isDone8 = isDone7;
var isFailure9 = isFailure7;
var isSuccess8 = isSuccess6;
var make142 = make72;
var map46 = map32;
var match40 = match32;
var matchEffect6 = matchEffect5;
var of8 = of7;
var tap12 = tap8;

// node_modules/effect/dist/esm/TestAnnotation.js
var TestAnnotation_exports = {};
__export(TestAnnotation_exports, {
  TestAnnotationTypeId: () => TestAnnotationTypeId,
  compose: () => compose7,
  fibers: () => fibers,
  ignored: () => ignored,
  isTestAnnotation: () => isTestAnnotation,
  make: () => make143,
  repeated: () => repeated3,
  retried: () => retried,
  tagged: () => tagged8
});
var TestAnnotationSymbolKey = "effect/TestAnnotation";
var TestAnnotationTypeId = Symbol.for(TestAnnotationSymbolKey);
var _a99;
var TestAnnotationImpl = class {
  constructor(identifier2, initial, combine20) {
    __publicField(this, "identifier");
    __publicField(this, "initial");
    __publicField(this, "combine");
    __publicField(this, _a99, {
      _A: (_) => _
    });
    this.identifier = identifier2;
    this.initial = initial;
    this.combine = combine20;
  }
  [(_a99 = TestAnnotationTypeId, symbol2)]() {
    return pipe(hash(TestAnnotationSymbolKey), combine2(hash(this.identifier)), cached(this));
  }
  [symbol3](that) {
    return isTestAnnotation(that) && this.identifier === that.identifier;
  }
};
var isTestAnnotation = (u) => hasProperty(u, TestAnnotationTypeId);
var make143 = (identifier2, initial, combine20) => {
  return new TestAnnotationImpl(identifier2, initial, combine20);
};
var compose7 = (left3, right3) => {
  if (isLeft2(left3) && isLeft2(right3)) {
    return left2(left3.left + right3.left);
  }
  if (isRight2(left3) && isRight2(right3)) {
    return right2(pipe(left3.right, appendAll3(right3.right)));
  }
  if (isRight2(left3) && isLeft2(right3)) {
    return right3;
  }
  if (isLeft2(left3) && isRight2(right3)) {
    return right3;
  }
  throw new Error(getBugErrorMessage("TestAnnotation.compose"));
};
var fibers = make143("fibers", left2(0), compose7);
var ignored = make143("ignored", 0, (a, b) => a + b);
var repeated3 = make143("repeated", 0, (a, b) => a + b);
var retried = make143("retried", 0, (a, b) => a + b);
var tagged8 = make143("tagged", empty10(), (a, b) => pipe(a, union6(b)));

// node_modules/effect/dist/esm/TestAnnotationMap.js
var TestAnnotationMap_exports = {};
__export(TestAnnotationMap_exports, {
  TestAnnotationMapTypeId: () => TestAnnotationMapTypeId,
  annotate: () => annotate,
  combine: () => combine19,
  empty: () => empty58,
  get: () => get44,
  isTestAnnotationMap: () => isTestAnnotationMap,
  make: () => make144,
  overwrite: () => overwrite,
  update: () => update17
});
var TestAnnotationMapTypeId = Symbol.for("effect/TestAnnotationMap");
var _a100;
_a100 = TestAnnotationMapTypeId;
var TestAnnotationMapImpl = class {
  constructor(map49) {
    __publicField(this, "map");
    __publicField(this, _a100, TestAnnotationMapTypeId);
    this.map = map49;
  }
};
var isTestAnnotationMap = (u) => hasProperty(u, TestAnnotationMapTypeId);
var empty58 = () => new TestAnnotationMapImpl(empty11());
var make144 = (map49) => {
  return new TestAnnotationMapImpl(map49);
};
var overwrite = dual(3, (self, key, value10) => make144(set4(self.map, key, value10)));
var update17 = dual(3, (self, key, f2) => {
  let value10 = key.initial;
  if (has5(self.map, key)) {
    value10 = unsafeGet6(self.map, key);
  }
  return overwrite(self, key, f2(value10));
});
var get44 = dual(2, (self, key) => {
  if (has5(self.map, key)) {
    return unsafeGet6(self.map, key);
  }
  return key.initial;
});
var annotate = dual(3, (self, key, value10) => update17(self, key, (_) => key.combine(_, value10)));
var combine19 = dual(2, (self, that) => {
  let result = self.map;
  for (const entry of that.map) {
    if (has5(result, entry[0])) {
      const value10 = get8(result, entry[0]);
      result = set4(result, entry[0], entry[0].combine(value10, entry[1]));
    } else {
      result = set4(result, entry[0], entry[1]);
    }
  }
  return make144(result);
});

// node_modules/effect/dist/esm/TestAnnotations.js
var TestAnnotations_exports = {};
__export(TestAnnotations_exports, {
  TestAnnotations: () => TestAnnotations,
  TestAnnotationsTypeId: () => TestAnnotationsTypeId,
  isTestAnnotations: () => isTestAnnotations,
  make: () => make145
});
var TestAnnotationsTypeId = Symbol.for("effect/TestAnnotations");
var _a101;
_a101 = TestAnnotationsTypeId;
var AnnotationsImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a101, TestAnnotationsTypeId);
    this.ref = ref;
  }
  get(key) {
    return map14(get13(this.ref), get44(key));
  }
  annotate(key, value10) {
    return update4(this.ref, annotate(key, value10));
  }
  get supervisedFibers() {
    return descriptorWith((descriptor3) => flatMap12(this.get(fibers), (either14) => {
      switch (either14._tag) {
        case "Left": {
          return succeed(empty32(Order7));
        }
        case "Right": {
          return pipe(either14.right, forEachSequential((ref) => sync(() => get7(ref))), map14(reduce3(empty32(Order7), (a, b) => union8(a, b))), map14(filter13((fiber) => !equals(fiber.id(), descriptor3.id))));
        }
      }
    }));
  }
};
var TestAnnotations = GenericTag("effect/Annotations");
var isTestAnnotations = (u) => hasProperty(u, TestAnnotationsTypeId);
var make145 = (ref) => new AnnotationsImpl(ref);

// node_modules/effect/dist/esm/TestClock.js
var TestClock_exports = {};
__export(TestClock_exports, {
  TestClock: () => TestClock,
  TestClockImpl: () => TestClockImpl,
  adjust: () => adjust,
  adjustWith: () => adjustWith,
  currentTimeMillis: () => currentTimeMillis3,
  defaultTestClock: () => defaultTestClock,
  live: () => live3,
  makeData: () => makeData,
  save: () => save,
  setTime: () => setTime,
  sleep: () => sleep6,
  sleeps: () => sleeps,
  testClock: () => testClock,
  testClockWith: () => testClockWith
});

// node_modules/effect/dist/esm/internal/testing/suspendedWarningData.js
var OP_SUSPENDED_WARNING_DATA_START = "Start";
var OP_SUSPENDED_WARNING_DATA_PENDING = "Pending";
var OP_SUSPENDED_WARNING_DATA_DONE = "Done";
var start3 = {
  _tag: OP_SUSPENDED_WARNING_DATA_START
};
var pending4 = (fiber) => {
  return {
    _tag: OP_SUSPENDED_WARNING_DATA_PENDING,
    fiber
  };
};
var done15 = {
  _tag: OP_SUSPENDED_WARNING_DATA_DONE
};
var isStart = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_START;
};
var isPending2 = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_PENDING;
};

// node_modules/effect/dist/esm/internal/testing/warningData.js
var OP_WARNING_DATA_START = "Start";
var OP_WARNING_DATA_PENDING = "Pending";
var OP_WARNING_DATA_DONE = "Done";
var start4 = {
  _tag: OP_WARNING_DATA_START
};
var pending5 = (fiber) => {
  return {
    _tag: OP_WARNING_DATA_PENDING,
    fiber
  };
};
var done16 = {
  _tag: OP_WARNING_DATA_DONE
};
var isStart2 = (self) => {
  return self._tag === OP_WARNING_DATA_START;
};
var isPending3 = (self) => {
  return self._tag === OP_WARNING_DATA_PENDING;
};

// node_modules/effect/dist/esm/TestLive.js
var TestLive_exports = {};
__export(TestLive_exports, {
  TestLive: () => TestLive,
  TestLiveTypeId: () => TestLiveTypeId,
  make: () => make146
});
var TestLiveTypeId = Symbol.for("effect/TestLive");
var TestLive = GenericTag("effect/TestLive");
var _a102;
_a102 = TestLiveTypeId;
var LiveImpl = class {
  constructor(services) {
    __publicField(this, "services");
    __publicField(this, _a102, TestLiveTypeId);
    this.services = services;
  }
  provide(effect4) {
    return fiberRefLocallyWith(currentServices, merge3(this.services))(effect4);
  }
};
var make146 = (services) => new LiveImpl(services);

// node_modules/effect/dist/esm/TestClock.js
var makeData = (instant, sleeps2) => ({
  instant,
  sleeps: sleeps2
});
var TestClock = GenericTag("effect/TestClock");
var warning = "Warning: A test is using time, but is not advancing the test clock, which may result in the test hanging. Use TestClock.adjust to manually advance the time.";
var suspendedWarning = "Warning: A test is advancing the test clock, but a fiber is not suspending, which may result in the test hanging. Use TestAspect.diagnose to identity the fiber that is not suspending.";
var _a103;
_a103 = ClockTypeId;
var TestClockImpl = class {
  constructor(clockState, live6, annotations4, warningState, suspendedWarningState) {
    __publicField(this, "clockState");
    __publicField(this, "live");
    __publicField(this, "annotations");
    __publicField(this, "warningState");
    __publicField(this, "suspendedWarningState");
    __publicField(this, _a103, ClockTypeId);
    /**
     * Returns the current clock time in milliseconds.
     */
    __publicField(this, "currentTimeMillis");
    /**
     * Returns the current clock time in nanoseconds.
     */
    __publicField(this, "currentTimeNanos");
    __publicField(this, "yieldTimer", async_((resume2) => {
      const timer4 = setTimeout(() => {
        resume2(void_3);
      }, 0);
      return sync(() => clearTimeout(timer4));
    }));
    this.clockState = clockState;
    this.live = live6;
    this.annotations = annotations4;
    this.warningState = warningState;
    this.suspendedWarningState = suspendedWarningState;
    this.currentTimeMillis = map14(get12(this.clockState), (data) => data.instant);
    this.currentTimeNanos = map14(get12(this.clockState), (data) => BigInt(data.instant * 1e6));
  }
  /**
   * Unsafely returns the current time in milliseconds.
   */
  unsafeCurrentTimeMillis() {
    return unsafeGet7(this.clockState).instant;
  }
  /**
   * Unsafely returns the current time in nanoseconds.
   */
  unsafeCurrentTimeNanos() {
    return BigInt(unsafeGet7(this.clockState).instant * 1e6);
  }
  /**
   * Saves the `TestClock`'s current state in an effect which, when run, will
   * restore the `TestClock` state to the saved state.
   */
  get save() {
    return map14(get12(this.clockState), (data) => set6(this.clockState, data));
  }
  /**
   * Sets the current clock time to the specified instant. Any effects that
   * were scheduled to occur on or before the new time will be run in order.
   */
  setTime(instant) {
    return zipRight2(this.warningDone(), this.run(() => instant));
  }
  /**
   * Semantically blocks the current fiber until the clock time is equal to or
   * greater than the specified duration. Once the clock time is adjusted to
   * on or after the duration, the fiber will automatically be resumed.
   */
  sleep(durationInput) {
    const duration5 = decode(durationInput);
    return flatMap12(deferredMake(), (deferred) => pipe(modify7(this.clockState, (data) => {
      const end7 = data.instant + toMillis(duration5);
      if (end7 > data.instant) {
        return [true, makeData(data.instant, pipe(data.sleeps, prepend3([end7, deferred])))];
      }
      return [false, data];
    }), flatMap12((shouldAwait) => shouldAwait ? pipe(this.warningStart(), zipRight2(deferredAwait(deferred))) : pipe(deferredSucceed(deferred, void 0), asVoid2))));
  }
  /**
   * Returns a list of the times at which all queued effects are scheduled to
   * resume.
   */
  get sleeps() {
    return map14(get12(this.clockState), (data) => map7(data.sleeps, (_) => _[0]));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjust(durationInput) {
    const duration5 = decode(durationInput);
    return zipRight2(this.warningDone(), this.run((n) => n + toMillis(duration5)));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjustWith(durationInput) {
    const duration5 = decode(durationInput);
    return (effect4) => zipLeftOptions(effect4, this.adjust(duration5), {
      concurrent: true
    });
  }
  /**
   * Returns a set of all fibers in this test.
   */
  supervisedFibers() {
    return this.annotations.supervisedFibers;
  }
  /**
   * Captures a "snapshot" of the identifier and status of all fibers in this
   * test other than the current fiber. Fails with the `void` value if any of
   * these fibers are not done or suspended. Note that because we cannot
   * synchronize on the status of multiple fibers at the same time this
   * snapshot may not be fully consistent.
   */
  freeze() {
    return flatMap12(this.supervisedFibers(), (fibers2) => pipe(fibers2, reduce12(empty11(), (map49, fiber) => pipe(fiber.status, flatMap12((status3) => {
      if (isDone3(status3)) {
        return succeed(set4(map49, fiber.id(), status3));
      }
      if (isSuspended2(status3)) {
        return succeed(set4(map49, fiber.id(), status3));
      }
      return fail2(void 0);
    })))));
  }
  /**
   * Forks a fiber that will display a warning message if a test is using time
   * but is not advancing the `TestClock`.
   */
  warningStart() {
    return updateSomeEffect(this.warningState, (data) => isStart2(data) ? some3(pipe(this.live.provide(pipe(logWarning(warning), delay(seconds(5)))), interruptible2, fork2, map14((fiber) => pending5(fiber)))) : none2());
  }
  /**
   * Cancels the warning message that is displayed if a test is using time but
   * is not advancing the `TestClock`.
   */
  warningDone() {
    return updateSomeEffect(this.warningState, (warningData) => {
      if (isStart2(warningData)) {
        return some3(succeed(done16));
      }
      if (isPending3(warningData)) {
        return some3(pipe(interruptFiber(warningData.fiber), as3(done16)));
      }
      return none2();
    });
  }
  /**
   * Returns whether all descendants of this fiber are done or suspended.
   */
  suspended() {
    return pipe(this.freeze(), zip5(pipe(this.yieldTimer, zipRight2(this.freeze()))), flatMap12(([first5, last8]) => equals(first5, last8) ? succeed(first5) : fail2(void 0)));
  }
  /**
   * Polls until all descendants of this fiber are done or suspended.
   */
  awaitSuspended() {
    return pipe(this.suspendedWarningStart(), zipRight2(pipe(this.suspended(), zipWith6(pipe(this.yieldTimer, zipRight2(this.suspended())), equals), filterOrFail(identity, constVoid), eventually)), zipRight2(this.suspendedWarningDone()));
  }
  /**
   * Forks a fiber that will display a warning message if a test is advancing
   * the `TestClock` but a fiber is not suspending.
   */
  suspendedWarningStart() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isStart(suspendedWarningData)) {
        return some3(pipe(this.live.provide(pipe(logWarning(suspendedWarning), zipRight2(set6(this.suspendedWarningState, done15)), delay(seconds(5)))), interruptible2, fork2, map14((fiber) => pending4(fiber))));
      }
      return none2();
    });
  }
  /**
   * Cancels the warning message that is displayed if a test is advancing the
   * `TestClock` but a fiber is not suspending.
   */
  suspendedWarningDone() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isPending2(suspendedWarningData)) {
        return some3(pipe(interruptFiber(suspendedWarningData.fiber), as3(start3)));
      }
      return none2();
    });
  }
  /**
   * Runs all effects scheduled to occur on or before the specified instant,
   * which may depend on the current time, in order.
   */
  run(f2) {
    return pipe(this.awaitSuspended(), zipRight2(pipe(modify7(this.clockState, (data) => {
      const end7 = f2(data.instant);
      const sorted = pipe(data.sleeps, sort2(pipe(Order, mapInput3((_) => _[0]))));
      if (isNonEmpty2(sorted)) {
        const [instant, deferred] = headNonEmpty2(sorted);
        if (instant <= end7) {
          return [some3([end7, deferred]), makeData(instant, tailNonEmpty2(sorted))];
        }
      }
      return [none2(), makeData(end7, data.sleeps)];
    }), flatMap12((option11) => {
      switch (option11._tag) {
        case "None": {
          return void_3;
        }
        case "Some": {
          const [end7, deferred] = option11.value;
          return pipe(deferredSucceed(deferred, void 0), zipRight2(yieldNow()), zipRight2(this.run(() => end7)));
        }
      }
    }))));
  }
};
var live3 = (data) => scoped3(TestClock, gen4(function* ($) {
  const live6 = yield* $(TestLive);
  const annotations4 = yield* $(TestAnnotations);
  const clockState = yield* $(sync(() => unsafeMake7(data)));
  const warningState = yield* $(makeSynchronized(start4));
  const suspendedWarningState = yield* $(makeSynchronized(start3));
  const testClock2 = new TestClockImpl(clockState, live6, annotations4, warningState, suspendedWarningState);
  yield* $(withClockScoped(testClock2));
  yield* $(addFinalizer2(() => zipRight2(testClock2.warningDone(), testClock2.suspendedWarningDone())));
  return testClock2;
}));
var defaultTestClock = live3(makeData((/* @__PURE__ */ new Date(0)).getTime(), empty7()));
var adjust = (durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.adjust(duration5));
};
var adjustWith = dual(2, (effect4, durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.adjustWith(duration5)(effect4));
});
var save = () => testClockWith((testClock2) => testClock2.save);
var setTime = (input) => testClockWith((testClock2) => testClock2.setTime(typeof input === "number" ? input : unsafeMake14(input).epochMillis));
var sleep6 = (durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.sleep(duration5));
};
var sleeps = () => testClockWith((testClock2) => testClock2.sleeps);
var testClock = () => testClockWith(succeed);
var testClockWith = (f2) => fiberRefGetWith(currentServices, (services) => f2(pipe(services, get4(clockTag))));
var currentTimeMillis3 = testClockWith((testClock2) => testClock2.currentTimeMillis);

// node_modules/effect/dist/esm/TestConfig.js
var TestConfig_exports = {};
__export(TestConfig_exports, {
  TestConfig: () => TestConfig,
  make: () => make147
});
var TestConfig = GenericTag("effect/TestConfig");
var make147 = (params) => params;

// node_modules/effect/dist/esm/TestContext.js
var TestContext_exports = {};
__export(TestContext_exports, {
  LiveContext: () => LiveContext,
  TestContext: () => TestContext,
  live: () => live5
});

// node_modules/effect/dist/esm/TestServices.js
var TestServices_exports = {};
__export(TestServices_exports, {
  annotate: () => annotate2,
  annotations: () => annotations3,
  annotationsLayer: () => annotationsLayer,
  annotationsWith: () => annotationsWith,
  currentServices: () => currentServices3,
  get: () => get45,
  live: () => live4,
  liveLayer: () => liveLayer,
  liveServices: () => liveServices3,
  liveWith: () => liveWith,
  provideLive: () => provideLive,
  provideWithLive: () => provideWithLive,
  repeats: () => repeats,
  retries: () => retries,
  samples: () => samples,
  shrinks: () => shrinks,
  size: () => size40,
  sized: () => sized,
  sizedLayer: () => sizedLayer,
  sizedWith: () => sizedWith,
  supervisedFibers: () => supervisedFibers,
  testConfig: () => testConfig,
  testConfigLayer: () => testConfigLayer,
  testConfigWith: () => testConfigWith,
  withAnnotations: () => withAnnotations,
  withAnnotationsScoped: () => withAnnotationsScoped,
  withLive: () => withLive,
  withLiveScoped: () => withLiveScoped,
  withSize: () => withSize,
  withSized: () => withSized,
  withSizedScoped: () => withSizedScoped,
  withTestConfig: () => withTestConfig,
  withTestConfigScoped: () => withTestConfigScoped
});

// node_modules/effect/dist/esm/TestSized.js
var TestSized_exports = {};
__export(TestSized_exports, {
  TestSized: () => TestSized,
  TestSizedTypeId: () => TestSizedTypeId,
  fromFiberRef: () => fromFiberRef,
  make: () => make148
});
var TestSizedTypeId = Symbol.for("effect/TestSized");
var TestSized = GenericTag("effect/TestSized");
var _a104;
_a104 = TestSizedTypeId;
var SizedImpl = class {
  constructor(fiberRef) {
    __publicField(this, "fiberRef");
    __publicField(this, _a104, TestSizedTypeId);
    this.fiberRef = fiberRef;
  }
  get size() {
    return fiberRefGet(this.fiberRef);
  }
  withSize(size45) {
    return (effect4) => fiberRefLocally(this.fiberRef, size45)(effect4);
  }
};
var make148 = (size45) => new SizedImpl(fiberRefUnsafeMake(size45));
var fromFiberRef = (fiberRef) => new SizedImpl(fiberRef);

// node_modules/effect/dist/esm/TestServices.js
var liveServices3 = pipe(make8(TestAnnotations, make145(unsafeMake7(empty58()))), add3(TestLive, make146(liveServices)), add3(TestSized, make148(100)), add3(TestConfig, make147({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var currentServices3 = fiberRefUnsafeMakeContext(liveServices3);
var annotations3 = () => annotationsWith(succeed);
var annotationsWith = (f2) => fiberRefGetWith(currentServices3, (services) => f2(get4(services, TestAnnotations)));
var withAnnotations = dual(2, (effect4, annotations4) => fiberRefLocallyWith(currentServices3, add3(TestAnnotations, annotations4))(effect4));
var withAnnotationsScoped = (annotations4) => fiberRefLocallyScopedWith(currentServices3, add3(TestAnnotations, annotations4));
var annotationsLayer = () => scoped3(TestAnnotations, pipe(sync(() => unsafeMake7(empty58())), map14(make145), tap2(withAnnotationsScoped)));
var get45 = (key) => annotationsWith((annotations4) => annotations4.get(key));
var annotate2 = (key, value10) => annotationsWith((annotations4) => annotations4.annotate(key, value10));
var supervisedFibers = () => annotationsWith((annotations4) => annotations4.supervisedFibers);
var liveWith = (f2) => fiberRefGetWith(currentServices3, (services) => f2(get4(services, TestLive)));
var live4 = liveWith(succeed);
var withLive = dual(2, (effect4, live6) => fiberRefLocallyWith(currentServices3, add3(TestLive, live6))(effect4));
var withLiveScoped = (live6) => fiberRefLocallyScopedWith(currentServices3, add3(TestLive, live6));
var liveLayer = () => scoped3(TestLive, pipe(context2(), map14(make146), tap2(withLiveScoped)));
var provideLive = (effect4) => liveWith((live6) => live6.provide(effect4));
var provideWithLive = dual(2, (self, f2) => fiberRefGetWith(currentServices, (services) => provideLive(f2(fiberRefLocally(currentServices, services)(self)))));
var sizedWith = (f2) => fiberRefGetWith(currentServices3, (services) => f2(get4(services, TestSized)));
var sized = sizedWith(succeed);
var withSized = dual(2, (effect4, sized2) => fiberRefLocallyWith(currentServices3, add3(TestSized, sized2))(effect4));
var withSizedScoped = (sized2) => fiberRefLocallyScopedWith(currentServices3, add3(TestSized, sized2));
var sizedLayer = (size45) => scoped3(TestSized, pipe(fiberRefMake(size45), map14(fromFiberRef), tap2(withSizedScoped)));
var size40 = sizedWith((sized2) => sized2.size);
var withSize = dual(2, (effect4, size45) => sizedWith((sized2) => sized2.withSize(size45)(effect4)));
var testConfigWith = (f2) => fiberRefGetWith(currentServices3, (services) => f2(get4(services, TestConfig)));
var testConfig = testConfigWith(succeed);
var withTestConfig = dual(2, (effect4, config2) => fiberRefLocallyWith(currentServices3, add3(TestConfig, config2))(effect4));
var withTestConfigScoped = (config2) => fiberRefLocallyScopedWith(currentServices3, add3(TestConfig, config2));
var testConfigLayer = (params) => scoped3(TestConfig, suspend4(() => {
  const testConfig2 = make147(params);
  return pipe(withTestConfigScoped(testConfig2), as3(testConfig2));
}));
var repeats = testConfigWith((config2) => succeed(config2.repeats));
var retries = testConfigWith((config2) => succeed(config2.retries));
var samples = testConfigWith((config2) => succeed(config2.samples));
var shrinks = testConfigWith((config2) => succeed(config2.shrinks));

// node_modules/effect/dist/esm/TestContext.js
var live5 = pipe(annotationsLayer(), merge6(liveLayer()), merge6(sizedLayer(100)), merge6(pipe(defaultTestClock, provideMerge(merge6(liveLayer(), annotationsLayer())))), merge6(testConfigLayer({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var LiveContext = syncContext(() => liveServices);
var TestContext = provideMerge(live5, LiveContext);

// node_modules/effect/dist/esm/Trie.js
var Trie_exports = {};
__export(Trie_exports, {
  compact: () => compact6,
  empty: () => empty60,
  entries: () => entries5,
  entriesWithPrefix: () => entriesWithPrefix2,
  filter: () => filter25,
  filterMap: () => filterMap15,
  forEach: () => forEach28,
  fromIterable: () => fromIterable33,
  get: () => get47,
  has: () => has18,
  insert: () => insert4,
  insertMany: () => insertMany2,
  isEmpty: () => isEmpty31,
  keys: () => keys14,
  keysWithPrefix: () => keysWithPrefix2,
  longestPrefixOf: () => longestPrefixOf2,
  make: () => make150,
  map: () => map48,
  modify: () => modify21,
  reduce: () => reduce30,
  remove: () => remove20,
  removeMany: () => removeMany4,
  size: () => size42,
  toEntries: () => toEntries3,
  toEntriesWithPrefix: () => toEntriesWithPrefix2,
  unsafeGet: () => unsafeGet13,
  values: () => values14,
  valuesWithPrefix: () => valuesWithPrefix2
});

// node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie";
var TrieTypeId = Symbol.for(TrieSymbolKey);
var trieVariance = {
  /* c8 ignore next */
  _Value: (_) => _
};
var TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k, v) => [k, v], () => true);
  },
  [symbol2]() {
    let hash11 = hash(TrieSymbolKey);
    for (const item of this) {
      hash11 ^= pipe(hash(item[0]), combine2(hash(item[1])));
    }
    return cached(this, hash11);
  },
  [symbol3](that) {
    if (isTrie(that)) {
      const entries6 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries6[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl6 = (root) => {
  const trie = Object.create(TrieProto);
  trie._root = root;
  trie._count = (root == null ? void 0 : root.count) ?? 0;
  return trie;
};
var TrieIterator = class _TrieIterator {
  constructor(trie, f2, filter26) {
    __publicField(this, "trie");
    __publicField(this, "f");
    __publicField(this, "filter");
    __publicField(this, "stack", []);
    this.trie = trie;
    this.f = f2;
    this.filter = filter26;
    const root = trie._root !== void 0 ? trie._root : void 0;
    if (root !== void 0) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value10 = node.value;
        if (value10 !== void 0) {
          const key = keyString + node.key;
          if (this.filter(key, value10)) {
            return {
              done: false,
              value: this.f(key, value10)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: void 0
    };
  }
  addToStack(node, keyString) {
    if (node.right !== void 0) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== void 0) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== void 0) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new _TrieIterator(this.trie, this.f, this.filter);
  }
};
var isTrie = (u) => hasProperty(u, TrieTypeId);
var empty59 = () => makeImpl6(void 0);
var fromIterable32 = (entries6) => {
  let trie = empty59();
  for (const [key, value10] of entries6) {
    trie = insert3(trie, key, value10);
  }
  return trie;
};
var make149 = (...entries6) => {
  return fromIterable32(entries6);
};
var insert3 = dual(3, (self, key, value10) => {
  if (key.length === 0) return self;
  const dStack = [];
  const nStack = [];
  let n = self._root ?? {
    key: key[0],
    count: 0
  };
  const count9 = n.count + 1;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    nStack.push(n);
    if (c > n.key) {
      dStack.push(1);
      if (n.right === void 0) {
        n = {
          key: c,
          count: count9
        };
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      dStack.push(-1);
      if (n.left === void 0) {
        n = {
          key: c,
          count: count9
        };
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        n.value = value10;
      } else if (n.mid === void 0) {
        dStack.push(0);
        n = {
          key: key[cIndex + 1],
          count: count9
        };
      } else {
        dStack.push(0);
        n = n.mid;
      }
      cIndex += 1;
    }
  }
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: nStack[s + 1],
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nStack[s + 1]
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: nStack[s + 1],
        right: n2.right
      };
    }
  }
  nStack[0].count = count9;
  return makeImpl6(nStack[0]);
});
var size41 = (self) => {
  var _a106;
  return ((_a106 = self._root) == null ? void 0 : _a106.count) ?? 0;
};
var isEmpty30 = (self) => size41(self) === 0;
var keys13 = (self) => new TrieIterator(self, (key) => key, () => true);
var values13 = (self) => new TrieIterator(self, (_, value10) => value10, () => true);
var entries4 = (self) => new TrieIterator(self, (key, value10) => [key, value10], () => true);
var reduce29 = dual(3, (self, zero3, f2) => {
  let accumulator = zero3;
  for (const entry of self) {
    accumulator = f2(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var map47 = dual(2, (self, f2) => reduce29(self, empty59(), (trie, value10, key) => insert3(trie, key, f2(value10, key))));
var filter24 = dual(2, (self, f2) => reduce29(self, empty59(), (trie, value10, key) => f2(value10, key) ? insert3(trie, key, value10) : trie));
var filterMap14 = dual(2, (self, f2) => reduce29(self, empty59(), (trie, value10, key) => {
  const option11 = f2(value10, key);
  return isSome2(option11) ? insert3(trie, key, option11.value) : trie;
}));
var compact5 = (self) => filterMap14(self, identity);
var forEach27 = dual(2, (self, f2) => reduce29(self, void 0, (_, value10, key) => f2(value10, key)));
var keysWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key) => key, (key) => key.startsWith(prefix)));
var valuesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (_, value10) => value10, (key) => key.startsWith(prefix)));
var entriesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key, value10) => [key, value10], (key) => key.startsWith(prefix)));
var toEntriesWithPrefix = dual(2, (self, prefix) => Array.from(entriesWithPrefix(self, prefix)));
var get46 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return none2();
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return none2();
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return none2();
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        return fromNullable2(n.value);
      } else {
        if (n.mid === void 0) {
          return none2();
        } else {
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  return none2();
});
var has17 = dual(2, (self, key) => isSome2(get46(self, key)));
var unsafeGet12 = dual(2, (self, key) => {
  const element2 = get46(self, key);
  if (isNone2(element2)) {
    throw new Error("Expected trie to contain key");
  }
  return element2.value;
});
var remove19 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return self;
  const count9 = n.count - 1;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const removeNode = nStack[nStack.length - 1];
  nStack[nStack.length - 1] = {
    key: removeNode.key,
    count: count9,
    left: removeNode.left,
    mid: removeNode.mid,
    right: removeNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    const nc = child.left === void 0 && child.mid === void 0 && child.right === void 0 ? void 0 : child;
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: nc,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nc
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: nc,
        right: n2.right
      };
    }
  }
  nStack[0].count = count9;
  return makeImpl6(nStack[0]);
});
var removeMany3 = dual(2, (self, keys15) => {
  let trie = self;
  for (const key of keys15) {
    trie = remove19(key)(trie);
  }
  return trie;
});
var insertMany = dual(2, (self, iter) => {
  let trie = self;
  for (const [key, value10] of iter) {
    trie = insert3(key, value10)(trie);
  }
  return trie;
});
var modify20 = dual(3, (self, key, f2) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return self;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const updateNode = nStack[nStack.length - 1];
  if (updateNode.value === void 0) {
    return self;
  }
  nStack[nStack.length - 1] = {
    key: updateNode.key,
    count: updateNode.count,
    value: f2(updateNode.value),
    // Update
    left: updateNode.left,
    mid: updateNode.mid,
    right: updateNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: child,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: child
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: child,
        right: n2.right
      };
    }
  }
  return makeImpl6(nStack[0]);
});
var longestPrefixOf = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return none2();
  let longestPrefixNode = void 0;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (n.value !== void 0) {
      longestPrefixNode = [key.slice(0, cIndex + 1), n.value];
    }
    if (c > n.key) {
      if (n.right === void 0) {
        break;
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        break;
      } else {
        n = n.left;
      }
    } else {
      if (n.mid === void 0) {
        break;
      } else {
        n = n.mid;
        cIndex += 1;
      }
    }
  }
  return fromNullable2(longestPrefixNode);
});

// node_modules/effect/dist/esm/Trie.js
var empty60 = empty59;
var fromIterable33 = fromIterable32;
var make150 = make149;
var insert4 = insert3;
var keys14 = keys13;
var values14 = values13;
var entries5 = entries4;
var toEntries3 = (self) => Array.from(entries5(self));
var keysWithPrefix2 = keysWithPrefix;
var valuesWithPrefix2 = valuesWithPrefix;
var entriesWithPrefix2 = entriesWithPrefix;
var toEntriesWithPrefix2 = toEntriesWithPrefix;
var longestPrefixOf2 = longestPrefixOf;
var size42 = size41;
var get47 = get46;
var has18 = has17;
var isEmpty31 = isEmpty30;
var unsafeGet13 = unsafeGet12;
var remove20 = remove19;
var reduce30 = reduce29;
var map48 = map47;
var filter25 = filter24;
var filterMap15 = filterMap14;
var compact6 = compact5;
var forEach28 = forEach27;
var modify21 = modify20;
var removeMany4 = removeMany3;
var insertMany2 = insertMany;

// node_modules/effect/dist/esm/Types.js
var Types_exports = {};

// node_modules/effect/dist/esm/Unify.js
var Unify_exports = {};
__export(Unify_exports, {
  unify: () => unify2
});
var unify2 = identity;

// node_modules/effect/dist/esm/UpstreamPullRequest.js
var UpstreamPullRequest_exports = {};
__export(UpstreamPullRequest_exports, {
  NoUpstream: () => NoUpstream2,
  Pulled: () => Pulled2,
  UpstreamPullRequestTypeId: () => UpstreamPullRequestTypeId2,
  isNoUpstream: () => isNoUpstream2,
  isPulled: () => isPulled2,
  isUpstreamPullRequest: () => isUpstreamPullRequest2,
  match: () => match41
});
var UpstreamPullRequestTypeId2 = UpstreamPullRequestTypeId;
var Pulled2 = Pulled;
var NoUpstream2 = NoUpstream;
var isUpstreamPullRequest2 = isUpstreamPullRequest;
var isPulled2 = isPulled;
var isNoUpstream2 = isNoUpstream;
var match41 = match24;

// node_modules/effect/dist/esm/UpstreamPullStrategy.js
var UpstreamPullStrategy_exports = {};
__export(UpstreamPullStrategy_exports, {
  PullAfterAllEnqueued: () => PullAfterAllEnqueued2,
  PullAfterNext: () => PullAfterNext2,
  UpstreamPullStrategyTypeId: () => UpstreamPullStrategyTypeId2,
  isPullAfterAllEnqueued: () => isPullAfterAllEnqueued2,
  isPullAfterNext: () => isPullAfterNext2,
  isUpstreamPullStrategy: () => isUpstreamPullStrategy2,
  match: () => match42
});
var UpstreamPullStrategyTypeId2 = UpstreamPullStrategyTypeId;
var PullAfterNext2 = PullAfterNext;
var PullAfterAllEnqueued2 = PullAfterAllEnqueued;
var isUpstreamPullStrategy2 = isUpstreamPullStrategy;
var isPullAfterNext2 = isPullAfterNext;
var isPullAfterAllEnqueued2 = isPullAfterAllEnqueued;
var match42 = match23;

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate9(uuid2) {
  return typeof uuid2 === "string" && regex_default.test(uuid2);
}
var validate_default = validate9;

// node_modules/uuid/dist/esm-browser/parse.js
function parse3(uuid2) {
  if (!validate_default(uuid2)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  return Uint8Array.of((v = parseInt(uuid2.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
}
var parse_default = parse3;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify5(arr, offset = 0) {
  const uuid2 = unsafeStringify(arr, offset);
  if (!validate_default(uuid2)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid2;
}
var stringify_default = stringify5;

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  const words = uint8ToUint32(bytes);
  const md5Bytes = wordsToMd5(words, bytes.length * 8);
  return uint32ToUint8(md5Bytes);
}
function uint32ToUint8(input) {
  const bytes = new Uint8Array(input.length * 4);
  for (let i = 0; i < input.length * 4; i++) {
    bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
  }
  return bytes;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  const xpad = new Uint32Array(getOutputLength(len)).fill(0);
  xpad.set(x);
  xpad[len >> 5] |= 128 << len % 32;
  xpad[xpad.length - 1] = len;
  x = xpad;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd2(a, olda);
    b = safeAdd2(b, oldb);
    c = safeAdd2(c, oldc);
    d = safeAdd2(d, oldd);
  }
  return Uint32Array.of(a, b, c, d);
}
function uint8ToUint32(input) {
  if (input.length === 0) {
    return new Uint32Array();
  }
  const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
  for (let i = 0; i < input.length; i++) {
    output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
  }
  return output;
}
function safeAdd2(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd2(bitRotateLeft(safeAdd2(safeAdd2(a, q), safeAdd2(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes2(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; ++i) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(version, hash11, value10, namespace, buf, offset) {
  const valueBytes = typeof value10 === "string" ? stringToBytes2(value10) : value10;
  const namespaceBytes = typeof namespace === "string" ? parse_default(namespace) : namespace;
  if (typeof namespace === "string") {
    namespace = parse_default(namespace);
  }
  if ((namespace == null ? void 0 : namespace.length) !== 16) {
    throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
  }
  let bytes = new Uint8Array(16 + valueBytes.length);
  bytes.set(namespaceBytes);
  bytes.set(valueBytes, namespaceBytes.length);
  bytes = hash11(bytes);
  bytes[6] = bytes[6] & 15 | version;
  bytes[8] = bytes[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}

// node_modules/uuid/dist/esm-browser/v3.js
function v3(value10, namespace, buf, offset) {
  return v35(48, md5_default, value10, namespace, buf, offset);
}
v3.DNS = DNS;
v3.URL = URL2;

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  var _a106;
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? ((_a106 = options.rng) == null ? void 0 : _a106.call(options)) ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  const newBytes = new Uint8Array(bytes.length + 1);
  newBytes.set(bytes);
  newBytes[bytes.length] = 128;
  bytes = newBytes;
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K2[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
function v5(value10, namespace, buf, offset) {
  return v35(80, sha1_default, value10, namespace, buf, offset);
}
v5.DNS = DNS;
v5.URL = URL2;

// node_modules/@graphprotocol/grc-20/dist/src/id.js
var Id = Brand_exports.refined((id3) => isValid2(id3), (id3) => Brand_exports.error(`Expected ${id3} to be a valid Id`));
var IdBase64 = Brand_exports.refined((id3) => isValidBase64(id3), (id3) => Brand_exports.error(`Expected ${id3} to be a valid IdBase64`));
function generate() {
  const uuid2 = v4_default();
  return Id(uuid2);
}
function isValid2(id3) {
  return validate_default(id3);
}
function isValidBase64(id3) {
  try {
    const uuid2 = fromBase64(id3);
    return isValid2(uuid2);
  } catch (error4) {
    return false;
  }
}
function assertValid(id3, sourceHint) {
  if (!isValid2(id3)) {
    throw new Error(`Invalid id: "${id3}"${sourceHint ? ` for ${sourceHint}` : ""}`);
  }
}
function toBytes4(id3) {
  return parse_default(id3);
}
function fromBytes2(bytes) {
  return Id(stringify_default(bytes));
}
var base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function toBase64(id3) {
  const bytes = toBytes4(id3);
  let result = "";
  let i;
  for (i = 0; i < bytes.length; i += 3) {
    const a = bytes[i];
    const b = bytes[i + 1] ?? 0;
    const c = bytes[i + 2] ?? 0;
    const triple = a << 16 | b << 8 | c;
    result += base64Chars[triple >> 18 & 63];
    result += base64Chars[triple >> 12 & 63];
    result += i + 1 < bytes.length ? base64Chars[triple >> 6 & 63] : "=";
    result += i + 2 < bytes.length ? base64Chars[triple & 63] : "=";
  }
  return IdBase64(result);
}
function fromBase64(id3) {
  const bytes = [];
  for (let i = 0; i < id3.length; i += 4) {
    const c1 = base64Chars.indexOf(id3[i]);
    const c2 = base64Chars.indexOf(id3[i + 1]);
    const c3 = base64Chars.indexOf(id3[i + 2]);
    const c4 = base64Chars.indexOf(id3[i + 3]);
    const triple = c1 << 18 | c2 << 12 | (c3 & 63) << 6 | c4 & 63;
    bytes.push(triple >> 16 & 255);
    if (c3 !== -1 && c3 !== 64)
      bytes.push(triple >> 8 & 255);
    if (c4 !== -1 && c4 !== 64)
      bytes.push(triple & 255);
  }
  return fromBytes2(new Uint8Array(bytes));
}

// node_modules/viem/_esm/utils/getAction.js
function getAction(client, actionFn, name) {
  const action_implicit = client[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client, params);
}

// node_modules/viem/_esm/errors/log.js
var FilterTypeNotSupportedError = class extends BaseError {
  constructor(type8) {
    super(`Filter type "${type8}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
};

// node_modules/viem/_esm/utils/abi/encodeEventTopics.js
var docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  var _a106;
  const { abi: abi11, eventName, args: args2 } = parameters;
  let abiItem = abi11[0];
  if (eventName) {
    const item = getAbiItem({ abi: abi11, name: eventName });
    if (!item)
      throw new AbiEventNotFoundError(eventName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath });
  const definition = formatAbiItem2(abiItem);
  const signature = toEventSelector(definition);
  let topics = [];
  if (args2 && "inputs" in abiItem) {
    const indexedInputs = (_a106 = abiItem.inputs) == null ? void 0 : _a106.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args2) ? args2 : Object.values(args2).length > 0 ? (indexedInputs == null ? void 0 : indexedInputs.map((x) => args2[x.name])) ?? [] : [];
    if (args_.length > 0) {
      topics = (indexedInputs == null ? void 0 : indexedInputs.map((param, i) => {
        if (Array.isArray(args_[i]))
          return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));
        return typeof args_[i] !== "undefined" && args_[i] !== null ? encodeArg({ param, value: args_[i] }) : null;
      })) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArg({ param, value: value10 }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value10));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value10]);
}

// node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
function createFilterRequestScope(client, { method }) {
  var _a106, _b32;
  const requestMap = {};
  if (client.transport.type === "fallback")
    (_b32 = (_a106 = client.transport).onResponse) == null ? void 0 : _b32.call(_a106, ({ method: method_, response: id3, status: status3, transport }) => {
      if (status3 === "success" && method === method_)
        requestMap[id3] = transport.request;
    });
  return (id3) => requestMap[id3] || client.request;
}

// node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, parameters) {
  const { address, abi: abi11, args: args2, eventName, fromBlock, strict: strict2, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi: abi11,
    args: args2,
    eventName
  }) : void 0;
  const id3 = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi: abi11,
    args: args2,
    eventName,
    id: id3,
    request: getRequest(id3),
    strict: Boolean(strict2),
    type: "event"
  };
}

// node_modules/viem/_esm/utils/errors/getContractError.js
var EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err2, { abi: abi11, address, args: args2, docsPath: docsPath3, functionName, sender }) {
  const error4 = err2 instanceof RawContractError ? err2 : err2 instanceof BaseError ? err2.walk((err3) => "data" in err3) || err2.walk() : {};
  const { code, data, details, message, shortMessage } = error4;
  const cause3 = (() => {
    if (err2 instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || details || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi: abi11,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: error4 instanceof RpcRequestError ? details : shortMessage ?? message
      });
    }
    return err2;
  })();
  return new ContractFunctionExecutionError(cause3, {
    abi: abi11,
    args: args2,
    contractAddress: address,
    docsPath: docsPath3,
    functionName,
    sender
  });
}

// node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash: hash11, signature }) {
  const hashHex = isHex(hash11) ? hash11 : toHex(hash11);
  const { secp256k1: secp256k12 } = await import("./secp256k1-QLZDF4TE.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r, s, v, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    if (size(signatureHex) !== 65)
      throw new Error("invalid signature length");
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash: hash11, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash: hash11, signature }));
}

// node_modules/viem/_esm/utils/encoding/toRlp.js
function toRlp(bytes, to3 = "hex") {
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to3 === "hex")
    return bytesToHex(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x) => getEncodable(x)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length6 = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length: length6,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode: encode16 } of list) {
        encode16(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length6 = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length: length6,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length6) {
  if (length6 < 2 ** 8)
    return 1;
  if (length6 < 2 ** 16)
    return 2;
  if (length6 < 2 ** 24)
    return 3;
  if (length6 < 2 ** 32)
    return 4;
  throw new BaseError("Length is too large.");
}

// node_modules/viem/_esm/utils/authorization/hashAuthorization.js
function hashAuthorization(parameters) {
  const { chainId, nonce, to: to3 } = parameters;
  const address = parameters.contractAddress ?? parameters.address;
  const hash11 = keccak256(concatHex([
    "0x05",
    toRlp([
      chainId ? numberToHex(chainId) : "0x",
      address,
      nonce ? numberToHex(nonce) : "0x"
    ])
  ]));
  if (to3 === "bytes")
    return hexToBytes(hash11);
  return hash11;
}

// node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js
async function recoverAuthorizationAddress(parameters) {
  const { authorization, signature } = parameters;
  return recoverAddress({
    hash: hashAuthorization(authorization),
    signature: signature ?? authorization
  });
}

// node_modules/viem/_esm/errors/estimateGas.js
var EstimateGasExecutionError = class extends BaseError {
  constructor(cause3, { account, docsPath: docsPath3, chain: chain2, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to3, value: value10 }) {
    var _a106;
    const prettyArgs = prettyPrint({
      from: account == null ? void 0 : account.address,
      to: to3,
      value: typeof value10 !== "undefined" && `${formatEther(value10)} ${((_a106 = chain2 == null ? void 0 : chain2.nativeCurrency) == null ? void 0 : _a106.symbol) || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause3.shortMessage, {
      cause: cause3,
      docsPath: docsPath3,
      metaMessages: [
        ...cause3.metaMessages ? [...cause3.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause3;
  }
};

// node_modules/viem/_esm/utils/errors/getEstimateGasError.js
function getEstimateGasError(err2, { docsPath: docsPath3, ...args2 }) {
  const cause3 = (() => {
    const cause4 = getNodeError(err2, args2);
    if (cause4 instanceof UnknownNodeError)
      return err2;
    return cause4;
  })();
  return new EstimateGasExecutionError(cause3, {
    docsPath: docsPath3,
    ...args2
  });
}

// node_modules/viem/_esm/errors/fee.js
var BaseFeeScalarError = class extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
};
var Eip1559FeesNotSupportedError = class extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
};
var MaxFeePerGasTooLowError = class extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
};

// node_modules/viem/_esm/errors/block.js
var BlockNotFoundError = class extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier2 = "Block";
    if (blockHash)
      identifier2 = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier2 = `Block at number "${blockNumber}"`;
    super(`${identifier2} could not be found.`, { name: "BlockNotFoundError" });
  }
};

// node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  var _a106, _b32, _c7;
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    }, { dedupe: true });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format16 = ((_c7 = (_b32 = (_a106 = client.chain) == null ? void 0 : _a106.formatters) == null ? void 0 : _b32.block) == null ? void 0 : _c7.format) || formatBlock;
  return format16(block);
}

// node_modules/viem/_esm/actions/public/getGasPrice.js
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function estimateMaxPriorityFeePerGas(client, args2) {
  return internal_estimateMaxPriorityFeePerGas(client, args2);
}
async function internal_estimateMaxPriorityFeePerGas(client, args2) {
  var _a106, _b32;
  const { block: block_, chain: chain2 = client.chain, request: request2 } = args2 || {};
  try {
    const maxPriorityFeePerGas = ((_a106 = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _a106.maxPriorityFeePerGas) ?? ((_b32 = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _b32.defaultPriorityFee);
    if (typeof maxPriorityFeePerGas === "function") {
      const block = block_ || await getAction(client, getBlock, "getBlock")({});
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client,
        request: request2
      });
      if (maxPriorityFeePerGas_ === null)
        throw new Error();
      return maxPriorityFeePerGas_;
    }
    if (typeof maxPriorityFeePerGas !== "undefined")
      return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function estimateFeesPerGas(client, args2) {
  return internal_estimateFeesPerGas(client, args2);
}
async function internal_estimateFeesPerGas(client, args2) {
  var _a106, _b32;
  const { block: block_, chain: chain2 = client.chain, request: request2, type: type8 = "eip1559" } = args2 || {};
  const baseFeeMultiplier = await (async () => {
    var _a107, _b33;
    if (typeof ((_a107 = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _a107.baseFeeMultiplier) === "function")
      return chain2.fees.baseFeeMultiplier({
        block: block_,
        client,
        request: request2
      });
    return ((_b33 = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _b33.baseFeeMultiplier) ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = ((_a106 = baseFeeMultiplier.toString().split(".")[1]) == null ? void 0 : _a106.length) ?? 0;
  const denominator = 10 ** decimals;
  const multiply4 = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof ((_b32 = chain2 == null ? void 0 : chain2.fees) == null ? void 0 : _b32.estimateFeesPerGas) === "function") {
    const fees = await chain2.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply: multiply4,
      request: request2,
      type: type8
    });
    if (fees !== null)
      return fees;
  }
  if (type8 === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = typeof (request2 == null ? void 0 : request2.maxPriorityFeePerGas) === "bigint" ? request2.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain: chain2,
      request: request2
    });
    const baseFeePerGas = multiply4(block.baseFeePerGas);
    const maxFeePerGas = (request2 == null ? void 0 : request2.maxFeePerGas) ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = (request2 == null ? void 0 : request2.gasPrice) ?? multiply4(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count9 = await client.request({
    method: "eth_getTransactionCount",
    params: [
      address,
      typeof blockNumber === "bigint" ? numberToHex(blockNumber) : blockTag
    ]
  }, {
    dedupe: Boolean(blockNumber)
  });
  return hexToNumber(count9);
}

// node_modules/viem/_esm/utils/blob/blobsToCommitments.js
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to3 = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to3 === "bytes" ? commitments : commitments.map((x) => bytesToHex(x));
}

// node_modules/viem/_esm/utils/blob/blobsToProofs.js
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to3 = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to3 === "bytes" ? proofs : proofs.map((x) => bytesToHex(x));
}

// node_modules/@noble/hashes/esm/sha256.js
var sha2562 = sha256;

// node_modules/viem/_esm/utils/hash/sha256.js
function sha2563(value10, to_) {
  const to3 = to_ || "hex";
  const bytes = sha2562(isHex(value10, { strict: false }) ? toBytes(value10) : value10);
  if (to3 === "bytes")
    return bytes;
  return toHex(bytes);
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
function commitmentToVersionedHash(parameters) {
  const { commitment, version = 1 } = parameters;
  const to3 = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha2563(commitment, "bytes");
  versionedHash.set([version], 0);
  return to3 === "bytes" ? versionedHash : bytesToHex(versionedHash);
}

// node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version } = parameters;
  const to3 = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to: to3,
      version
    }));
  }
  return hashes;
}

// node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/viem/_esm/constants/kzg.js
var versionedHashVersionKzg = 1;

// node_modules/viem/_esm/errors/blob.js
var BlobSizeTooLargeError = class extends BaseError {
  constructor({ maxSize, size: size45 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size45} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError = class extends BaseError {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
};
var InvalidVersionedHashSizeError = class extends BaseError {
  constructor({ hash: hash11, size: size45 }) {
    super(`Versioned hash "${hash11}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size45}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
};
var InvalidVersionedHashVersionError = class extends BaseError {
  constructor({ hash: hash11, version }) {
    super(`Versioned hash "${hash11}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${version}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
};

// node_modules/viem/_esm/utils/blob/toBlobs.js
function toBlobs(parameters) {
  const to3 = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active2 = true;
  let position = 0;
  while (active2) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size45 = 0;
    while (size45 < fieldElementsPerBlob) {
      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active2 = false;
        break;
      }
      size45++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to3 === "bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex(x.bytes));
}

// node_modules/viem/_esm/utils/blob/toBlobSidecars.js
function toBlobSidecars(parameters) {
  const { data, kzg, to: to3 } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to: to3 });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to: to3 });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to: to3 });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}

// node_modules/viem/_esm/utils/transaction/getTransactionType.js
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// node_modules/viem/_esm/actions/public/getChainId.js
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  }, { dedupe: true });
  return hexToNumber(chainIdHex);
}

// node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
var defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
var eip1559NetworkCache = /* @__PURE__ */ new Map();
async function prepareTransactionRequest(client, args2) {
  const { account: account_ = client.account, blobs, chain: chain2, gas, kzg, nonce, nonceManager: nonceManager2, parameters = defaultParameters, type: type8 } = args2;
  const account = account_ ? parseAccount(account_) : account_;
  const request2 = { ...args2, ...account ? { from: account == null ? void 0 : account.address } : {} };
  let block;
  async function getBlock2() {
    if (block)
      return block;
    block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (chain2)
      return chain2.id;
    if (typeof args2.chainId !== "undefined")
      return args2.chainId;
    const chainId_ = await getAction(client, getChainId, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account) {
    if (nonceManager2) {
      const chainId2 = await getChainId2();
      request2.nonce = await nonceManager2.consume({
        address: account.address,
        chainId: chainId2,
        client
      });
    } else {
      request2.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
    }
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request2.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request2.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId"))
    request2.chainId = await getChainId2();
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type8 === "undefined") {
    try {
      request2.type = getTransactionType(request2);
    } catch {
      let isEip1559Network = eip1559NetworkCache.get(client.uid);
      if (typeof isEip1559Network === "undefined") {
        const block2 = await getBlock2();
        isEip1559Network = typeof (block2 == null ? void 0 : block2.baseFeePerGas) === "bigint";
        eip1559NetworkCache.set(client.uid, isEip1559Network);
      }
      request2.type = isEip1559Network ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request2.type !== "legacy" && request2.type !== "eip2930") {
      if (typeof request2.maxFeePerGas === "undefined" || typeof request2.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock2();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain: chain2,
          request: request2
        });
        if (typeof args2.maxPriorityFeePerGas === "undefined" && args2.maxFeePerGas && args2.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request2.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request2.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args2.maxFeePerGas !== "undefined" || typeof args2.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError();
      if (typeof args2.gasPrice === "undefined") {
        const block2 = await getBlock2();
        const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain: chain2,
          request: request2,
          type: "legacy"
        });
        request2.gasPrice = gasPrice_;
      }
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request2.gas = await getAction(client, estimateGas, "estimateGas")({
      ...request2,
      account: account ? { address: account.address, type: "json-rpc" } : account
    });
  assertRequest(request2);
  delete request2.parameters;
  return request2;
}

// node_modules/viem/_esm/actions/public/getBalance.js
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, args2) {
  var _a106, _b32, _c7;
  const { account: account_ = client.account } = args2;
  const account = account_ ? parseAccount(account_) : void 0;
  try {
    let estimateGas_rpc = function(parameters) {
      const { block: block2, request: request3, rpcStateOverride: rpcStateOverride2 } = parameters;
      return client.request({
        method: "eth_estimateGas",
        params: rpcStateOverride2 ? [request3, block2 ?? "latest", rpcStateOverride2] : block2 ? [request3, block2] : [request3]
      });
    };
    const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value: value10, stateOverride, ...rest } = await prepareTransactionRequest(client, {
      ...args2,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (account == null ? void 0 : account.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    });
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to3 = await (async () => {
      if (rest.to)
        return rest.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError("`to` is required. Could not infer from `authorizationList`");
        });
      return void 0;
    })();
    assertRequest(args2);
    const chainFormat = (_c7 = (_b32 = (_a106 = client.chain) == null ? void 0 : _a106.formatters) == null ? void 0 : _b32.transactionRequest) == null ? void 0 : _c7.format;
    const format16 = chainFormat || formatTransactionRequest;
    const request2 = format16({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account == null ? void 0 : account.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: to3,
      value: value10
    });
    let estimate = BigInt(await estimateGas_rpc({ block, request: request2, rpcStateOverride }));
    if (authorizationList) {
      const value11 = await getBalance(client, { address: request2.from });
      const estimates = await Promise.all(authorizationList.map(async (authorization) => {
        const { address } = authorization;
        const estimate2 = await estimateGas_rpc({
          block,
          request: {
            authorizationList: void 0,
            data,
            from: account == null ? void 0 : account.address,
            to: address,
            value: numberToHex(value11)
          },
          rpcStateOverride
        }).catch(() => 100000n);
        return 2n * BigInt(estimate2);
      }));
      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
    }
    return estimate;
  } catch (err2) {
    throw getEstimateGasError(err2, {
      ...args2,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, parameters) {
  const { abi: abi11, address, args: args2, functionName, dataSuffix, ...request2 } = parameters;
  const data = encodeFunctionData({
    abi: abi11,
    args: args2,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas, "estimateGas")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...request2
    });
    return gas;
  } catch (error4) {
    const account = request2.account ? parseAccount(request2.account) : void 0;
    throw getContractError(error4, {
      abi: abi11,
      address,
      args: args2,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/viem/_esm/utils/abi/decodeEventLog.js
var docsPath2 = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi: abi11, data, strict: strict_, topics } = parameters;
  const strict2 = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath2 });
  const abiItem = abi11.find((x) => x.type === "event" && signature === toEventSelector(formatAbiItem2(x)));
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath2 });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs == null ? void 0 : inputs.some((x) => !("name" in x && x.name));
  const args2 = isUnnamed ? [] : {};
  const indexedInputs = inputs.map((x, i) => [x, i]).filter(([x]) => "indexed" in x && x.indexed);
  for (let i = 0; i < indexedInputs.length; i++) {
    const [param, argIndex] = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args2[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({
      param,
      value: topic
    });
  }
  const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            for (let i = 0; i < inputs.length; i++)
              args2[i] = args2[i] ?? decodedData.shift();
          else
            for (let i = 0; i < nonIndexedInputs.length; i++)
              args2[nonIndexedInputs[i].name] = decodedData[i];
        }
      } catch (err2) {
        if (strict2) {
          if (err2 instanceof AbiDecodingDataSizeTooSmallError || err2 instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size(data)
            });
          throw err2;
        }
      }
    } else if (strict2) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args2).length > 0 ? args2 : void 0
  };
}
function decodeTopic({ param, value: value10 }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value10;
  const decodedArg = decodeAbiParameters([param], value10) || [];
  return decodedArg[0];
}

// node_modules/viem/_esm/utils/abi/parseEventLogs.js
function parseEventLogs(parameters) {
  const { abi: abi11, args: args2, logs, strict: strict2 = true } = parameters;
  const eventName = (() => {
    if (!parameters.eventName)
      return void 0;
    if (Array.isArray(parameters.eventName))
      return parameters.eventName;
    return [parameters.eventName];
  })();
  return logs.map((log5) => {
    var _a106;
    try {
      const abiItem = abi11.find((abiItem2) => abiItem2.type === "event" && log5.topics[0] === toEventSelector(abiItem2));
      if (!abiItem)
        return null;
      const event = decodeEventLog({
        ...log5,
        abi: [abiItem],
        strict: strict2
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      if (!includesArgs({
        args: event.args,
        inputs: abiItem.inputs,
        matchArgs: args2
      }))
        return null;
      return { ...event, ...log5 };
    } catch (err2) {
      let eventName2;
      let isUnnamed;
      if (err2 instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err2 instanceof DecodeLogDataMismatch || err2 instanceof DecodeLogTopicsMismatch) {
        if (strict2)
          return null;
        eventName2 = err2.abiItem.name;
        isUnnamed = (_a106 = err2.abiItem.inputs) == null ? void 0 : _a106.some((x) => !("name" in x && x.name));
      }
      return { ...log5, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}
function includesArgs(parameters) {
  const { args: args2, inputs, matchArgs } = parameters;
  if (!matchArgs)
    return true;
  if (!args2)
    return false;
  function isEqual4(input, value10, arg) {
    try {
      if (input.type === "address")
        return isAddressEqual(value10, arg);
      if (input.type === "string" || input.type === "bytes")
        return keccak256(toBytes(value10)) === arg;
      return value10 === arg;
    } catch {
      return false;
    }
  }
  if (Array.isArray(args2) && Array.isArray(matchArgs)) {
    return matchArgs.every((value10, index3) => {
      if (value10 === null || value10 === void 0)
        return true;
      const input = inputs[index3];
      if (!input)
        return false;
      const value_ = Array.isArray(value10) ? value10 : [value10];
      return value_.some((value11) => isEqual4(input, value11, args2[index3]));
    });
  }
  if (typeof args2 === "object" && !Array.isArray(args2) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    return Object.entries(matchArgs).every(([key, value10]) => {
      if (value10 === null || value10 === void 0)
        return true;
      const input = inputs.find((input2) => input2.name === key);
      if (!input)
        return false;
      const value_ = Array.isArray(value10) ? value10 : [value10];
      return value_.some((value11) => isEqual4(input, value11, args2[key]));
    });
  return false;
}

// node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log5, { args: args2, eventName } = {}) {
  return {
    ...log5,
    blockHash: log5.blockHash ? log5.blockHash : null,
    blockNumber: log5.blockNumber ? BigInt(log5.blockNumber) : null,
    logIndex: log5.logIndex ? Number(log5.logIndex) : null,
    transactionHash: log5.transactionHash ? log5.transactionHash : null,
    transactionIndex: log5.transactionIndex ? Number(log5.transactionIndex) : null,
    ...eventName ? { args: args2, eventName } : {}
  };
}

// node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args: args2, strict: strict_ } = {}) {
  const strict2 = strict_ ?? false;
  const events = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args: events_ ? void 0 : args2
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log5) => formatLog(log5));
  if (!events)
    return formattedLogs;
  return parseEventLogs({
    abi: events,
    args: args2,
    logs: formattedLogs,
    strict: strict2
  });
}

// node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, parameters) {
  const { abi: abi11, address, args: args2, blockHash, eventName, fromBlock, toBlock, strict: strict2 } = parameters;
  const event = eventName ? getAbiItem({ abi: abi11, name: eventName }) : void 0;
  const events = !event ? abi11.filter((x) => x.type === "event") : void 0;
  return getAction(client, getLogs, "getLogs")({
    address,
    args: args2,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict: strict2
  });
}

// node_modules/viem/_esm/actions/public/readContract.js
async function readContract(client, parameters) {
  const { abi: abi11, address, args: args2, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi: abi11,
    args: args2,
    functionName
  });
  try {
    const { data } = await getAction(client, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi: abi11,
      args: args2,
      functionName,
      data: data || "0x"
    });
  } catch (error4) {
    throw getContractError(error4, {
      abi: abi11,
      address,
      args: args2,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// node_modules/viem/_esm/actions/public/simulateContract.js
async function simulateContract(client, parameters) {
  const { abi: abi11, address, args: args2, dataSuffix, functionName, ...callRequest } = parameters;
  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
  const calldata = encodeFunctionData({ abi: abi11, args: args2, functionName });
  try {
    const { data } = await getAction(client, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account
    });
    const result = decodeFunctionResult({
      abi: abi11,
      args: args2,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi11.filter((abiItem) => "name" in abiItem && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args: args2,
        dataSuffix,
        functionName,
        ...callRequest,
        account
      }
    };
  } catch (error4) {
    throw getContractError(error4, {
      abi: abi11,
      address,
      args: args2,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/viem/_esm/utils/observe.js
var listenersCache = /* @__PURE__ */ new Map();
var cleanupCache = /* @__PURE__ */ new Map();
var callbackCount = 0;
function observe(observerId, callbacks, fn2) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const listeners2 = getListeners();
    if (!listeners2.some((cb) => cb.id === callbackId))
      return;
    const cleanup2 = cleanupCache.get(observerId);
    if (listeners2.length === 1 && cleanup2) {
      const p = cleanup2();
      if (p instanceof Promise)
        p.catch(() => {
        });
    }
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit2 = {};
  for (const key in callbacks) {
    emit2[key] = (...args2) => {
      var _a106, _b32;
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        (_b32 = (_a106 = listener.fns)[key]) == null ? void 0 : _b32.call(_a106, ...args2);
    };
  }
  const cleanup = fn2(emit2);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// node_modules/viem/_esm/utils/wait.js
async function wait(time3) {
  return new Promise((res) => setTimeout(res, time3));
}

// node_modules/viem/_esm/utils/poll.js
function poll13(fn2, { emitOnBegin, initialWaitTime, interval }) {
  let active2 = true;
  const unwatch = () => active2 = false;
  const watch = async () => {
    let data = void 0;
    if (emitOnBegin)
      data = await fn2({ unpoll: unwatch });
    const initialWait = await (initialWaitTime == null ? void 0 : initialWaitTime(data)) ?? interval;
    await wait(initialWait);
    const poll14 = async () => {
      if (!active2)
        return;
      await fn2({ unpoll: unwatch });
      await wait(interval);
      poll14();
    };
    poll14();
  };
  watch();
  return unwatch;
}

// node_modules/viem/_esm/utils/promise/withCache.js
var promiseCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data) => cache.set(cacheKey3, data)
  });
  const promise4 = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise4.clear();
      response.clear();
    },
    promise: promise4,
    response
  };
}
async function withCache(fn2, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise4 = cache.promise.get();
  if (!promise4) {
    promise4 = fn2();
    cache.promise.set(promise4);
  }
  try {
    const data = await promise4;
    cache.response.set({ created: /* @__PURE__ */ new Date(), data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// node_modules/viem/_esm/actions/public/getBlockNumber.js
var cacheKey = (id3) => `blockNumber.${id3}`;
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime });
  return BigInt(blockNumberHex);
}

// node_modules/viem/_esm/actions/public/getFilterChanges.js
async function getFilterChanges(_client, { filter: filter26 }) {
  const strict2 = "strict" in filter26 && filter26.strict;
  const logs = await filter26.request({
    method: "eth_getFilterChanges",
    params: [filter26.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log5) => formatLog(log5));
  if (!("abi" in filter26) || !filter26.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter26.abi,
    logs: formattedLogs,
    strict: strict2
  });
}

// node_modules/viem/_esm/actions/public/uninstallFilter.js
async function uninstallFilter(_client, { filter: filter26 }) {
  return filter26.request({
    method: "eth_uninstallFilter",
    params: [filter26.id]
  });
}

// node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, parameters) {
  const { abi: abi11, address, args: args2, batch = true, eventName, fromBlock, onError: onError6, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket" || client.transport.type === "ipc")
      return false;
    if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
      return false;
    return true;
  })();
  const pollContractEvent = () => {
    const strict2 = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args2,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict2,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError: onError6 }, (emit2) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter26;
      let initialized = false;
      const unwatch = poll13(async () => {
        var _a106;
        if (!initialized) {
          try {
            filter26 = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi: abi11,
              address,
              args: args2,
              eventName,
              strict: strict2,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter26) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter: filter26 });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber < blockNumber) {
              logs = await getAction(client, getContractEvents, "getContractEvents")({
                abi: abi11,
                address,
                args: args2,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict: strict2
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit2.onLogs(logs);
          else
            for (const log5 of logs)
              emit2.onLogs([log5]);
        } catch (err2) {
          if (filter26 && err2 instanceof InvalidInputRpcError)
            initialized = false;
          (_a106 = emit2.onError) == null ? void 0 : _a106.call(emit2, err2);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter26)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter: filter26 });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict2 = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args2,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict2
    ]);
    let active2 = true;
    let unsubscribe = () => active2 = false;
    return observe(observerId, { onLogs, onError: onError6 }, (emit2) => {
      ;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const topics = eventName ? encodeEventTopics({
            abi: abi11,
            eventName,
            args: args2
          }) : [];
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              var _a106;
              if (!active2)
                return;
              const log5 = data.result;
              try {
                const { eventName: eventName2, args: args3 } = decodeEventLog({
                  abi: abi11,
                  data: log5.data,
                  topics: log5.topics,
                  strict: strict_
                });
                const formatted = formatLog(log5, {
                  args: args3,
                  eventName: eventName2
                });
                emit2.onLogs([formatted]);
              } catch (err2) {
                let eventName2;
                let isUnnamed;
                if (err2 instanceof DecodeLogDataMismatch || err2 instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err2.abiItem.name;
                  isUnnamed = (_a106 = err2.abiItem.inputs) == null ? void 0 : _a106.some((x) => !("name" in x && x.name));
                }
                const formatted = formatLog(log5, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit2.onLogs([formatted]);
              }
            },
            onError(error4) {
              var _a106;
              (_a106 = emit2.onError) == null ? void 0 : _a106.call(emit2, error4);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active2)
            unsubscribe();
        } catch (err2) {
          onError6 == null ? void 0 : onError6(err2);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

// node_modules/viem/_esm/errors/account.js
var AccountNotFoundError = class extends BaseError {
  constructor({ docsPath: docsPath3 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join("\n"), {
      docsPath: docsPath3,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
};
var AccountTypeNotSupportedError = class extends BaseError {
  constructor({ docsPath: docsPath3, metaMessages, type: type8 }) {
    super(`Account type "${type8}" is not supported.`, {
      docsPath: docsPath3,
      metaMessages,
      name: "AccountTypeNotSupportedError"
    });
  }
};

// node_modules/viem/_esm/utils/chain/assertCurrentChain.js
function assertCurrentChain({ chain: chain2, currentChainId }) {
  if (!chain2)
    throw new ChainNotFoundError();
  if (currentChainId !== chain2.id)
    throw new ChainMismatchError({ chain: chain2, currentChainId });
}

// node_modules/viem/_esm/utils/errors/getTransactionError.js
function getTransactionError(err2, { docsPath: docsPath3, ...args2 }) {
  const cause3 = (() => {
    const cause4 = getNodeError(err2, args2);
    if (cause4 instanceof UnknownNodeError)
      return err2;
    return cause4;
  })();
  return new TransactionExecutionError(cause3, {
    docsPath: docsPath3,
    ...args2
  });
}

// node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);
async function sendTransaction(client, parameters) {
  var _a106, _b32, _c7, _d4;
  const { account: account_ = client.account, chain: chain2 = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, type: type8, value: value10, ...rest } = parameters;
  if (typeof account_ === "undefined")
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = account_ ? parseAccount(account_) : null;
  try {
    assertRequest(parameters);
    const to3 = await (async () => {
      if (parameters.to)
        return parameters.to;
      if (parameters.to === null)
        return void 0;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError("`to` is required. Could not infer from `authorizationList`.");
        });
      return void 0;
    })();
    if ((account == null ? void 0 : account.type) === "json-rpc" || account === null) {
      let chainId;
      if (chain2 !== null) {
        chainId = await getAction(client, getChainId, "getChainId")({});
        assertCurrentChain({
          currentChainId: chainId,
          chain: chain2
        });
      }
      const chainFormat = (_c7 = (_b32 = (_a106 = client.chain) == null ? void 0 : _a106.formatters) == null ? void 0 : _b32.transactionRequest) == null ? void 0 : _c7.format;
      const format16 = chainFormat || formatTransactionRequest;
      const request2 = format16({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        accessList,
        authorizationList,
        blobs,
        chainId,
        data,
        from: account == null ? void 0 : account.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to: to3,
        type: type8,
        value: value10
      });
      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);
      const method = isWalletNamespaceSupported ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await client.request({
          method,
          params: [request2]
        }, { retryCount: 0 });
      } catch (e) {
        if (isWalletNamespaceSupported === false)
          throw e;
        const error4 = e;
        if (error4.name === "InvalidInputRpcError" || error4.name === "InvalidParamsRpcError" || error4.name === "MethodNotFoundRpcError" || error4.name === "MethodNotSupportedRpcError") {
          return await client.request({
            method: "wallet_sendTransaction",
            params: [request2]
          }, { retryCount: 0 }).then((hash11) => {
            supportsWalletNamespace.set(client.uid, true);
            return hash11;
          }).catch((e2) => {
            const walletNamespaceError = e2;
            if (walletNamespaceError.name === "MethodNotFoundRpcError" || walletNamespaceError.name === "MethodNotSupportedRpcError") {
              supportsWalletNamespace.set(client.uid, false);
              throw error4;
            }
            throw walletNamespaceError;
          });
        }
        throw error4;
      }
    }
    if ((account == null ? void 0 : account.type) === "local") {
      const request2 = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
        account,
        accessList,
        authorizationList,
        blobs,
        chain: chain2,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        nonceManager: account.nonceManager,
        parameters: [...defaultParameters, "sidecars"],
        type: type8,
        value: value10,
        ...rest,
        to: to3
      });
      const serializer = (_d4 = chain2 == null ? void 0 : chain2.serializers) == null ? void 0 : _d4.transaction;
      const serializedTransaction = await account.signTransaction(request2, {
        serializer
      });
      return await getAction(client, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    if ((account == null ? void 0 : account.type) === "smart")
      throw new AccountTypeNotSupportedError({
        metaMessages: [
          "Consider using the `sendUserOperation` Action instead."
        ],
        docsPath: "/docs/actions/bundler/sendUserOperation",
        type: "smart"
      });
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: account == null ? void 0 : account.type
    });
  } catch (err2) {
    if (err2 instanceof AccountTypeNotSupportedError)
      throw err2;
    throw getTransactionError(err2, {
      ...parameters,
      account,
      chain: parameters.chain || void 0
    });
  }
}

// node_modules/viem/_esm/actions/wallet/writeContract.js
async function writeContract(client, parameters) {
  const { abi: abi11, account: account_ = client.account, address, args: args2, dataSuffix, functionName, ...request2 } = parameters;
  if (typeof account_ === "undefined")
    throw new AccountNotFoundError({
      docsPath: "/docs/contract/writeContract"
    });
  const account = account_ ? parseAccount(account_) : null;
  const data = encodeFunctionData({
    abi: abi11,
    args: args2,
    functionName
  });
  try {
    return await getAction(client, sendTransaction, "sendTransaction")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      account,
      ...request2
    });
  } catch (error4) {
    throw getContractError(error4, {
      abi: abi11,
      address,
      args: args2,
      docsPath: "/docs/contract/writeContract",
      functionName,
      sender: account == null ? void 0 : account.address
    });
  }
}

// node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log5) => formatLog(log5)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/viem/_esm/actions/wallet/sendCalls.js
var fallbackMagicIdentifier = "0x5792579257925792579257925792579257925792579257925792579257925792";
var fallbackTransactionErrorMagicIdentifier = numberToHex(0, {
  size: 32
});
async function sendCalls(client, parameters) {
  const { account: account_ = client.account, capabilities, chain: chain2 = client.chain, experimental_fallback, experimental_fallbackDelay = 32, forceAtomic = false, id: id3, version = "2.0.0" } = parameters;
  const account = account_ ? parseAccount(account_) : null;
  const calls = parameters.calls.map((call_) => {
    const call2 = call_;
    const data = call2.abi ? encodeFunctionData({
      abi: call2.abi,
      functionName: call2.functionName,
      args: call2.args
    }) : call2.data;
    return {
      data: call2.dataSuffix && data ? concat([data, call2.dataSuffix]) : data,
      to: call2.to,
      value: call2.value ? numberToHex(call2.value) : void 0
    };
  });
  try {
    const response = await client.request({
      method: "wallet_sendCalls",
      params: [
        {
          atomicRequired: forceAtomic,
          calls,
          capabilities,
          chainId: numberToHex(chain2.id),
          from: account == null ? void 0 : account.address,
          id: id3,
          version
        }
      ]
    }, { retryCount: 0 });
    if (typeof response === "string")
      return { id: response };
    return response;
  } catch (err2) {
    const error4 = err2;
    if (experimental_fallback && (error4.name === "MethodNotFoundRpcError" || error4.name === "MethodNotSupportedRpcError" || error4.name === "UnknownRpcError" || error4.details.toLowerCase().includes("does not exist / is not available") || error4.details.toLowerCase().includes("missing or invalid. request()") || error4.details.toLowerCase().includes("did not match any variant of untagged enum") || error4.details.toLowerCase().includes("account upgraded to unsupported contract") || error4.details.toLowerCase().includes("eip-7702 not supported") || error4.details.toLowerCase().includes("unsupported wc_ method"))) {
      if (capabilities) {
        const hasNonOptionalCapability = Object.values(capabilities).some((capability) => !capability.optional);
        if (hasNonOptionalCapability) {
          const message = "non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";
          throw new UnsupportedNonOptionalCapabilityError(new BaseError(message, {
            details: message
          }));
        }
      }
      if (forceAtomic && calls.length > 1) {
        const message = "`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";
        throw new AtomicityNotSupportedError(new BaseError(message, {
          details: message
        }));
      }
      const promises = [];
      for (const call2 of calls) {
        const promise4 = sendTransaction(client, {
          account,
          chain: chain2,
          data: call2.data,
          to: call2.to,
          value: call2.value ? hexToBigInt(call2.value) : void 0
        });
        promises.push(promise4);
        if (experimental_fallbackDelay > 0)
          await new Promise((resolve) => setTimeout(resolve, experimental_fallbackDelay));
      }
      const results = await Promise.allSettled(promises);
      if (results.every((r) => r.status === "rejected"))
        throw results[0].reason;
      const hashes = results.map((result) => {
        if (result.status === "fulfilled")
          return result.value;
        return fallbackTransactionErrorMagicIdentifier;
      });
      return {
        id: concat([
          ...hashes,
          numberToHex(chain2.id, { size: 32 }),
          fallbackMagicIdentifier
        ])
      };
    }
    throw getTransactionError(err2, {
      ...parameters,
      account,
      chain: parameters.chain
    });
  }
}

// node_modules/viem/_esm/actions/wallet/getCallsStatus.js
async function getCallsStatus(client, parameters) {
  async function getStatus(id3) {
    const isTransactions = id3.endsWith(fallbackMagicIdentifier.slice(2));
    if (isTransactions) {
      const chainId2 = trim(sliceHex(id3, -64, -32));
      const hashes = sliceHex(id3, 0, -64).slice(2).match(/.{1,64}/g);
      const receipts2 = await Promise.all(hashes.map((hash11) => fallbackTransactionErrorMagicIdentifier.slice(2) !== hash11 ? client.request({
        method: "eth_getTransactionReceipt",
        params: [`0x${hash11}`]
      }, { dedupe: true }) : void 0));
      const status4 = (() => {
        if (receipts2.some((r) => r === null))
          return 100;
        if (receipts2.every((r) => (r == null ? void 0 : r.status) === "0x1"))
          return 200;
        if (receipts2.every((r) => (r == null ? void 0 : r.status) === "0x0"))
          return 500;
        return 600;
      })();
      return {
        atomic: false,
        chainId: hexToNumber(chainId2),
        receipts: receipts2.filter(Boolean),
        status: status4,
        version: "2.0.0"
      };
    }
    return client.request({
      method: "wallet_getCallsStatus",
      params: [id3]
    });
  }
  const { atomic = false, chainId, receipts, version = "2.0.0", ...response } = await getStatus(parameters.id);
  const [status3, statusCode] = (() => {
    const statusCode2 = response.status;
    if (statusCode2 >= 100 && statusCode2 < 200)
      return ["pending", statusCode2];
    if (statusCode2 >= 200 && statusCode2 < 300)
      return ["success", statusCode2];
    if (statusCode2 >= 300 && statusCode2 < 700)
      return ["failure", statusCode2];
    if (statusCode2 === "CONFIRMED")
      return ["success", 200];
    if (statusCode2 === "PENDING")
      return ["pending", 100];
    return [void 0, statusCode2];
  })();
  return {
    ...response,
    atomic,
    // @ts-expect-error: for backwards compatibility
    chainId: chainId ? hexToNumber(chainId) : void 0,
    receipts: (receipts == null ? void 0 : receipts.map((receipt) => ({
      ...receipt,
      blockNumber: hexToBigInt(receipt.blockNumber),
      gasUsed: hexToBigInt(receipt.gasUsed),
      status: receiptStatuses[receipt.status]
    }))) ?? [],
    statusCode,
    status: status3,
    version
  };
}

// node_modules/viem/_esm/actions/wallet/waitForCallsStatus.js
async function waitForCallsStatus(client, parameters) {
  const { id: id3, pollingInterval = client.pollingInterval, status: status3 = ({ statusCode }) => statusCode >= 200, timeout: timeout6 = 6e4 } = parameters;
  const observerId = stringify(["waitForCallsStatus", client.uid, id3]);
  const { promise: promise4, resolve, reject: reject3 } = withResolvers();
  let timer4 = void 0;
  const unobserve = observe(observerId, { resolve, reject: reject3 }, (emit2) => {
    const unpoll = poll13(async () => {
      const done17 = (fn2) => {
        clearTimeout(timer4);
        unpoll();
        fn2();
        unobserve();
      };
      try {
        const result = await getCallsStatus(client, { id: id3 });
        if (!status3(result))
          return;
        done17(() => emit2.resolve(result));
      } catch (error4) {
        done17(() => emit2.reject(error4));
      }
    }, {
      interval: pollingInterval,
      emitOnBegin: true
    });
    return unpoll;
  });
  timer4 = timeout6 ? setTimeout(() => {
    unobserve();
    clearTimeout(timer4);
    reject3(new WaitForCallsStatusTimeoutError({ id: id3 }));
  }, timeout6) : void 0;
  return await promise4;
}
var WaitForCallsStatusTimeoutError = class extends BaseError {
  constructor({ id: id3 }) {
    super(`Timed out while waiting for call bundle with id "${id3}" to be confirmed.`, { name: "WaitForCallsStatusTimeoutError" });
  }
};

// node_modules/viem/_esm/utils/uid.js
var size43 = 256;
var index = size43;
var buffer5;
function uid(length6 = 11) {
  if (!buffer5 || index + length6 > size43 * 2) {
    buffer5 = "";
    index = 0;
    for (let i = 0; i < size43; i++) {
      buffer5 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer5.substring(index, index++ + length6);
}

// node_modules/viem/_esm/clients/createClient.js
function createClient(parameters) {
  const { batch, chain: chain2, ccipRead, key = "base", name = "Base Client", type: type8 = "base" } = parameters;
  const blockTime = (chain2 == null ? void 0 : chain2.blockTime) ?? 12e3;
  const defaultPollingInterval = Math.min(Math.max(Math.floor(blockTime / 2), 500), 4e3);
  const pollingInterval = parameters.pollingInterval ?? defaultPollingInterval;
  const cacheTime = parameters.cacheTime ?? pollingInterval;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  const { config: config2, request: request2, value: value10 } = parameters.transport({
    chain: chain2,
    pollingInterval
  });
  const transport = { ...config2, ...value10 };
  const client = {
    account,
    batch,
    cacheTime,
    ccipRead,
    chain: chain2,
    key,
    name,
    pollingInterval,
    request: request2,
    transport,
    type: type8,
    uid: uid()
  };
  function extend5(base) {
    return (extendFn) => {
      const extended = extendFn(base);
      for (const key2 in client)
        delete extended[key2];
      const combined = { ...base, ...extended };
      return Object.assign(combined, { extend: extend5(combined) });
    };
  }
  return Object.assign(client, { extend: extend5(client) });
}

// node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache2 = new LruMap(8192);
function withDedupe(fn2, { enabled: enabled2 = true, id: id3 }) {
  if (!enabled2 || !id3)
    return fn2();
  if (promiseCache2.get(id3))
    return promiseCache2.get(id3);
  const promise4 = fn2().finally(() => promiseCache2.delete(id3));
  promiseCache2.set(id3, promise4);
  return promise4;
}

// node_modules/viem/_esm/utils/promise/withRetry.js
function withRetry(fn2, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {
  return new Promise((resolve, reject3) => {
    const attemptRetry = async ({ count: count9 = 0 } = {}) => {
      const retry12 = async ({ error: error4 }) => {
        const delay4 = typeof delay_ === "function" ? delay_({ count: count9, error: error4 }) : delay_;
        if (delay4)
          await wait(delay4);
        attemptRetry({ count: count9 + 1 });
      };
      try {
        const data = await fn2();
        resolve(data);
      } catch (err2) {
        if (count9 < retryCount && await shouldRetry2({ count: count9, error: err2 }))
          return retry12({ error: err2 });
        reject3(err2);
      }
    };
    attemptRetry();
  });
}

// node_modules/viem/_esm/utils/buildRequest.js
function buildRequest(request2, options = {}) {
  return async (args2, overrideOptions = {}) => {
    var _a106;
    const { dedupe: dedupe3 = false, methods: methods2, retryDelay = 150, retryCount = 3, uid: uid3 } = {
      ...options,
      ...overrideOptions
    };
    const { method } = args2;
    if ((_a106 = methods2 == null ? void 0 : methods2.exclude) == null ? void 0 : _a106.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    if ((methods2 == null ? void 0 : methods2.include) && !methods2.include.includes(method))
      throw new MethodNotSupportedRpcError(new Error("method not supported"), {
        method
      });
    const requestId = dedupe3 ? stringToHex(`${uid3}.${stringify(args2)}`) : void 0;
    return withDedupe(() => withRetry(async () => {
      try {
        return await request2(args2);
      } catch (err_) {
        const err2 = err_;
        switch (err2.code) {
          // -32700
          case ParseRpcError.code:
            throw new ParseRpcError(err2);
          // -32600
          case InvalidRequestRpcError.code:
            throw new InvalidRequestRpcError(err2);
          // -32601
          case MethodNotFoundRpcError.code:
            throw new MethodNotFoundRpcError(err2, { method: args2.method });
          // -32602
          case InvalidParamsRpcError.code:
            throw new InvalidParamsRpcError(err2);
          // -32603
          case InternalRpcError.code:
            throw new InternalRpcError(err2);
          // -32000
          case InvalidInputRpcError.code:
            throw new InvalidInputRpcError(err2);
          // -32001
          case ResourceNotFoundRpcError.code:
            throw new ResourceNotFoundRpcError(err2);
          // -32002
          case ResourceUnavailableRpcError.code:
            throw new ResourceUnavailableRpcError(err2);
          // -32003
          case TransactionRejectedRpcError.code:
            throw new TransactionRejectedRpcError(err2);
          // -32004
          case MethodNotSupportedRpcError.code:
            throw new MethodNotSupportedRpcError(err2, {
              method: args2.method
            });
          // -32005
          case LimitExceededRpcError.code:
            throw new LimitExceededRpcError(err2);
          // -32006
          case JsonRpcVersionUnsupportedError.code:
            throw new JsonRpcVersionUnsupportedError(err2);
          // 4001
          case UserRejectedRequestError.code:
            throw new UserRejectedRequestError(err2);
          // 4100
          case UnauthorizedProviderError.code:
            throw new UnauthorizedProviderError(err2);
          // 4200
          case UnsupportedProviderMethodError.code:
            throw new UnsupportedProviderMethodError(err2);
          // 4900
          case ProviderDisconnectedError.code:
            throw new ProviderDisconnectedError(err2);
          // 4901
          case ChainDisconnectedError.code:
            throw new ChainDisconnectedError(err2);
          // 4902
          case SwitchChainError.code:
            throw new SwitchChainError(err2);
          // 5700
          case UnsupportedNonOptionalCapabilityError.code:
            throw new UnsupportedNonOptionalCapabilityError(err2);
          // 5710
          case UnsupportedChainIdError.code:
            throw new UnsupportedChainIdError(err2);
          // 5720
          case DuplicateIdError.code:
            throw new DuplicateIdError(err2);
          // 5730
          case UnknownBundleIdError.code:
            throw new UnknownBundleIdError(err2);
          // 5740
          case BundleTooLargeError.code:
            throw new BundleTooLargeError(err2);
          // 5750
          case AtomicReadyWalletRejectedUpgradeError.code:
            throw new AtomicReadyWalletRejectedUpgradeError(err2);
          // 5760
          case AtomicityNotSupportedError.code:
            throw new AtomicityNotSupportedError(err2);
          // CAIP-25: User Rejected Error
          // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
          case 5e3:
            throw new UserRejectedRequestError(err2);
          default:
            if (err_ instanceof BaseError)
              throw err_;
            throw new UnknownRpcError(err2);
        }
      }
    }, {
      delay: ({ count: count9, error: error4 }) => {
        var _a107;
        if (error4 && error4 instanceof HttpRequestError) {
          const retryAfter = (_a107 = error4 == null ? void 0 : error4.headers) == null ? void 0 : _a107.get("Retry-After");
          if (retryAfter == null ? void 0 : retryAfter.match(/\d/))
            return Number.parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count9) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error: error4 }) => shouldRetry(error4)
    }), { enabled: dedupe3, id: requestId });
  };
}
function shouldRetry(error4) {
  if ("code" in error4 && typeof error4.code === "number") {
    if (error4.code === -1)
      return true;
    if (error4.code === LimitExceededRpcError.code)
      return true;
    if (error4.code === InternalRpcError.code)
      return true;
    return false;
  }
  if (error4 instanceof HttpRequestError && error4.status) {
    if (error4.status === 403)
      return true;
    if (error4.status === 408)
      return true;
    if (error4.status === 413)
      return true;
    if (error4.status === 429)
      return true;
    if (error4.status === 500)
      return true;
    if (error4.status === 502)
      return true;
    if (error4.status === 503)
      return true;
    if (error4.status === 504)
      return true;
    return false;
  }
  return true;
}

// node_modules/viem/_esm/clients/transports/createTransport.js
function createTransport({ key, methods: methods2, name, request: request2, retryCount = 3, retryDelay = 150, timeout: timeout6, type: type8 }, value10) {
  const uid3 = uid();
  return {
    config: {
      key,
      methods: methods2,
      name,
      request: request2,
      retryCount,
      retryDelay,
      timeout: timeout6,
      type: type8
    },
    request: buildRequest(request2, { methods: methods2, retryCount, retryDelay, uid: uid3 }),
    value: value10
  };
}

// node_modules/viem/_esm/clients/transports/custom.js
function custom3(provider, config2 = {}) {
  const { key = "custom", methods: methods2, name = "Custom Provider", retryDelay } = config2;
  return ({ retryCount: defaultRetryCount }) => createTransport({
    key,
    methods: methods2,
    name,
    request: provider.request.bind(provider),
    retryCount: config2.retryCount ?? defaultRetryCount,
    retryDelay,
    type: "custom"
  });
}

// node_modules/viem/_esm/errors/transport.js
var UrlRequiredError = class extends BaseError {
  constructor() {
    super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
      docsPath: "/docs/clients/intro",
      name: "UrlRequiredError"
    });
  }
};

// node_modules/viem/_esm/utils/promise/withTimeout.js
function withTimeout(fn2, { errorInstance = new Error("timed out"), timeout: timeout6, signal }) {
  return new Promise((resolve, reject3) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout6 > 0) {
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject3(errorInstance);
            }
          }, timeout6);
        }
        resolve(await fn2({ signal: (controller == null ? void 0 : controller.signal) || null }));
      } catch (err2) {
        if ((err2 == null ? void 0 : err2.name) === "AbortError")
          reject3(errorInstance);
        reject3(err2);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}

// node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/viem/_esm/utils/rpc/http.js
function getHttpRpcClient(url3, options = {}) {
  return {
    async request(params) {
      var _a106;
      const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout: timeout6 = options.timeout ?? 1e4 } = params;
      const fetchOptions = {
        ...options.fetchOptions ?? {},
        ...params.fetchOptions ?? {}
      };
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await withTimeout(async ({ signal }) => {
          const init3 = {
            ...fetchOptions,
            body: Array.isArray(body) ? stringify(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? idCache.take(),
              ...body2
            }))) : stringify({
              jsonrpc: "2.0",
              id: body.id ?? idCache.take(),
              ...body
            }),
            headers: {
              "Content-Type": "application/json",
              ...headers
            },
            method: method || "POST",
            signal: signal_ || (timeout6 > 0 ? signal : null)
          };
          const request2 = new Request(url3, init3);
          const args2 = await (onRequest == null ? void 0 : onRequest(request2, init3)) ?? { ...init3, url: url3 };
          const response2 = await fetch(args2.url ?? url3, args2);
          return response2;
        }, {
          errorInstance: new TimeoutError({ body, url: url3 }),
          timeout: timeout6,
          signal: true
        });
        if (onResponse)
          await onResponse(response);
        let data;
        if ((_a106 = response.headers.get("Content-Type")) == null ? void 0 : _a106.startsWith("application/json"))
          data = await response.json();
        else {
          data = await response.text();
          try {
            data = JSON.parse(data || "{}");
          } catch (err2) {
            if (response.ok)
              throw err2;
            data = { error: data };
          }
        }
        if (!response.ok) {
          throw new HttpRequestError({
            body,
            details: stringify(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url: url3
          });
        }
        return data;
      } catch (err2) {
        if (err2 instanceof HttpRequestError)
          throw err2;
        if (err2 instanceof TimeoutError)
          throw err2;
        throw new HttpRequestError({
          body,
          cause: err2,
          url: url3
        });
      }
    }
  };
}

// node_modules/viem/_esm/clients/transports/http.js
function http(url3, config2 = {}) {
  const { batch, fetchOptions, key = "http", methods: methods2, name = "HTTP JSON-RPC", onFetchRequest, onFetchResponse, retryDelay, raw } = config2;
  return ({ chain: chain2, retryCount: retryCount_, timeout: timeout_ }) => {
    const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === "object" ? batch : {};
    const retryCount = config2.retryCount ?? retryCount_;
    const timeout6 = timeout_ ?? config2.timeout ?? 1e4;
    const url_ = url3 || (chain2 == null ? void 0 : chain2.rpcUrls.default.http[0]);
    if (!url_)
      throw new UrlRequiredError();
    const rpcClient = getHttpRpcClient(url_, {
      fetchOptions,
      onRequest: onFetchRequest,
      onResponse: onFetchResponse,
      timeout: timeout6
    });
    return createTransport({
      key,
      methods: methods2,
      name,
      async request({ method, params }) {
        const body = { method, params };
        const { schedule: schedule4 } = createBatchScheduler({
          id: url_,
          wait: wait2,
          shouldSplitBatch(requests) {
            return requests.length > batchSize;
          },
          fn: (body2) => rpcClient.request({
            body: body2
          }),
          sort: (a, b) => a.id - b.id
        });
        const fn2 = async (body2) => batch ? schedule4(body2) : [
          await rpcClient.request({
            body: body2
          })
        ];
        const [{ error: error4, result }] = await fn2(body);
        if (raw)
          return { error: error4, result };
        if (error4)
          throw new RpcRequestError({
            body,
            error: error4,
            url: url_
          });
        return result;
      },
      retryCount,
      retryDelay,
      timeout: timeout6,
      type: "http"
    }, {
      fetchOptions,
      url: url_
    });
  };
}

// node_modules/viem/_esm/utils/ens/errors.js
function isNullUniversalResolverError(err2, callType) {
  var _a106, _b32, _c7, _d4, _e2, _f2;
  if (!(err2 instanceof BaseError))
    return false;
  const cause3 = err2.walk((e) => e instanceof ContractFunctionRevertedError);
  if (!(cause3 instanceof ContractFunctionRevertedError))
    return false;
  if (((_a106 = cause3.data) == null ? void 0 : _a106.errorName) === "ResolverNotFound")
    return true;
  if (((_b32 = cause3.data) == null ? void 0 : _b32.errorName) === "ResolverWildcardNotSupported")
    return true;
  if (((_c7 = cause3.data) == null ? void 0 : _c7.errorName) === "ResolverNotContract")
    return true;
  if (((_d4 = cause3.data) == null ? void 0 : _d4.errorName) === "ResolverError")
    return true;
  if (((_e2 = cause3.data) == null ? void 0 : _e2.errorName) === "HttpError")
    return true;
  if ((_f2 = cause3.reason) == null ? void 0 : _f2.includes("Wildcard on non-extended resolvers is not supported"))
    return true;
  if (callType === "reverse" && cause3.reason === panicReasons[50])
    return true;
  return false;
}

// node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
function encodedLabelToLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash11 = `0x${label.slice(1, 65)}`;
  if (!isHex(hash11))
    return null;
  return hash11;
}

// node_modules/viem/_esm/utils/ens/namehash.js
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return bytesToHex(result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), "bytes");
    result = keccak256(concat([result, hashed]), "bytes");
  }
  return bytesToHex(result);
}

// node_modules/viem/_esm/utils/ens/encodeLabelhash.js
function encodeLabelhash(hash11) {
  return `[${hash11.slice(2)}]`;
}

// node_modules/viem/_esm/utils/ens/labelhash.js
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return bytesToHex(result);
  return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));
}

// node_modules/viem/_esm/utils/ens/packetToBytes.js
function packetToBytes(packet) {
  const value10 = packet.replace(/^\.|\.$/gm, "");
  if (value10.length === 0)
    return new Uint8Array(1);
  const bytes = new Uint8Array(stringToBytes(value10).byteLength + 2);
  let offset = 0;
  const list = value10.split(".");
  for (let i = 0; i < list.length; i++) {
    let encoded = stringToBytes(list[i]);
    if (encoded.byteLength > 255)
      encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));
    bytes[offset] = encoded.length;
    bytes.set(encoded, offset + 1);
    offset += encoded.length + 1;
  }
  if (bytes.byteLength !== offset + 1)
    return bytes.slice(0, offset + 1);
  return bytes;
}

// node_modules/viem/_esm/actions/ens/getEnsAddress.js
async function getEnsAddress(client, parameters) {
  const { blockNumber, blockTag, coinType, name, gatewayUrls, strict: strict2 } = parameters;
  const { chain: chain2 } = client;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain2)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain: chain2,
      contract: "ensUniversalResolver"
    });
  })();
  const tlds = chain2 == null ? void 0 : chain2.ensTlds;
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    return null;
  try {
    const functionData = encodeFunctionData({
      abi: addressResolverAbi,
      functionName: "addr",
      ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }
    });
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        functionData,
        gatewayUrls ?? [localBatchGatewayUrl]
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: addressResolverAbi,
      args: coinType != null ? [namehash(name), BigInt(coinType)] : void 0,
      functionName: "addr",
      data: res[0]
    });
    if (address === "0x")
      return null;
    if (trim(address) === "0x00")
      return null;
    return address;
  } catch (err2) {
    if (strict2)
      throw err2;
    if (isNullUniversalResolverError(err2, "resolve"))
      return null;
    throw err2;
  }
}

// node_modules/viem/_esm/errors/ens.js
var EnsAvatarInvalidMetadataError = class extends BaseError {
  constructor({ data }) {
    super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
      metaMessages: [
        "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
        "",
        `Provided data: ${JSON.stringify(data)}`
      ],
      name: "EnsAvatarInvalidMetadataError"
    });
  }
};
var EnsAvatarInvalidNftUriError = class extends BaseError {
  constructor({ reason }) {
    super(`ENS NFT avatar URI is invalid. ${reason}`, {
      name: "EnsAvatarInvalidNftUriError"
    });
  }
};
var EnsAvatarUriResolutionError = class extends BaseError {
  constructor({ uri }) {
    super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: "EnsAvatarUriResolutionError" });
  }
};
var EnsAvatarUnsupportedNamespaceError = class extends BaseError {
  constructor({ namespace }) {
    super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: "EnsAvatarUnsupportedNamespaceError" });
  }
};

// node_modules/viem/_esm/utils/ens/avatar/utils.js
var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
  try {
    const res = await fetch(uri, { method: "HEAD" });
    if (res.status === 200) {
      const contentType = res.headers.get("content-type");
      return contentType == null ? void 0 : contentType.startsWith("image/");
    }
    return false;
  } catch (error4) {
    if (typeof error4 === "object" && typeof error4.response !== "undefined") {
      return false;
    }
    if (!globalThis.hasOwnProperty("Image"))
      return false;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve(true);
      };
      img.onerror = () => {
        resolve(false);
      };
      img.src = uri;
    });
  }
}
function getGateway(custom4, defaultGateway) {
  if (!custom4)
    return defaultGateway;
  if (custom4.endsWith("/"))
    return custom4.slice(0, -1);
  return custom4;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
  const isEncoded = base64Regex.test(uri);
  if (isEncoded)
    return { uri, isOnChain: true, isEncoded };
  const ipfsGateway = getGateway(gatewayUrls == null ? void 0 : gatewayUrls.ipfs, "https://ipfs.io");
  const arweaveGateway = getGateway(gatewayUrls == null ? void 0 : gatewayUrls.arweave, "https://arweave.net");
  const networkRegexMatch = uri.match(networkRegex);
  const { protocol, subpath, target, subtarget = "" } = (networkRegexMatch == null ? void 0 : networkRegexMatch.groups) || {};
  const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
  const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
  if (uri.startsWith("http") && !isIPNS && !isIPFS) {
    let replacedUri = uri;
    if (gatewayUrls == null ? void 0 : gatewayUrls.arweave)
      replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls == null ? void 0 : gatewayUrls.arweave);
    return { uri: replacedUri, isOnChain: false, isEncoded: false };
  }
  if ((isIPNS || isIPFS) && target) {
    return {
      uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  if (protocol === "ar:/" && target) {
    return {
      uri: `${arweaveGateway}/${target}${subtarget || ""}`,
      isOnChain: false,
      isEncoded: false
    };
  }
  let parsedUri = uri.replace(dataURIRegex, "");
  if (parsedUri.startsWith("<svg")) {
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
  }
  if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
    return {
      uri: parsedUri,
      isOnChain: true,
      isEncoded: false
    };
  }
  throw new EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
  if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
    throw new EnsAvatarInvalidMetadataError({ data });
  }
  return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
  try {
    const res = await fetch(uri).then((res2) => res2.json());
    const image = await parseAvatarUri({
      gatewayUrls,
      uri: getJsonImage(res)
    });
    return image;
  } catch {
    throw new EnsAvatarUriResolutionError({ uri });
  }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
  const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
  if (isOnChain)
    return resolvedURI;
  const isImage = await isImageUri(resolvedURI);
  if (isImage)
    return resolvedURI;
  throw new EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
  let uri = uri_;
  if (uri.startsWith("did:nft:")) {
    uri = uri.replace("did:nft:", "").replace(/_/g, "/");
  }
  const [reference, asset_namespace, tokenID] = uri.split("/");
  const [eip_namespace, chainID] = reference.split(":");
  const [erc_namespace, contractAddress] = asset_namespace.split(":");
  if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
    throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
  if (!chainID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
  if (!contractAddress)
    throw new EnsAvatarInvalidNftUriError({
      reason: "Contract address not found"
    });
  if (!tokenID)
    throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
  if (!erc_namespace)
    throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
  return {
    chainID: Number.parseInt(chainID),
    namespace: erc_namespace.toLowerCase(),
    contractAddress,
    tokenID
  };
}
async function getNftTokenUri(client, { nft }) {
  if (nft.namespace === "erc721") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "tokenURI",
      args: [BigInt(nft.tokenID)]
    });
  }
  if (nft.namespace === "erc1155") {
    return readContract(client, {
      address: nft.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }]
        }
      ],
      functionName: "uri",
      args: [BigInt(nft.tokenID)]
    });
  }
  throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}

// node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
async function parseAvatarRecord(client, { gatewayUrls, record: record4 }) {
  if (/eip155:/i.test(record4))
    return parseNftAvatarUri(client, { gatewayUrls, record: record4 });
  return parseAvatarUri({ uri: record4, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record: record4 }) {
  const nft = parseNftUri(record4);
  const nftUri = await getNftTokenUri(client, { nft });
  const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
  if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
    const encodedJson = isEncoded ? (
      // if it is encoded, decode it
      atob(resolvedNftUri.replace("data:application/json;base64,", ""))
    ) : (
      // if it isn't encoded assume it is a JSON string, but it could be anything (it will error if it is)
      resolvedNftUri
    );
    const decoded = JSON.parse(encodedJson);
    return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
  }
  let uriTokenId = nft.tokenID;
  if (nft.namespace === "erc1155")
    uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
  return getMetadataAvatarUri({
    gatewayUrls,
    uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
  });
}

// node_modules/viem/_esm/actions/ens/getEnsText.js
async function getEnsText(client, parameters) {
  const { blockNumber, blockTag, key, name, gatewayUrls, strict: strict2 } = parameters;
  const { chain: chain2 } = client;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain2)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain: chain2,
      contract: "ensUniversalResolver"
    });
  })();
  const tlds = chain2 == null ? void 0 : chain2.ensTlds;
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    return null;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverResolveAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name), key]
        }),
        gatewayUrls ?? [localBatchGatewayUrl]
      ],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const res = await readContractAction(readContractParameters);
    if (res[0] === "0x")
      return null;
    const record4 = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record4 === "" ? null : record4;
  } catch (err2) {
    if (strict2)
      throw err2;
    if (isNullUniversalResolverError(err2, "resolve"))
      return null;
    throw err2;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsAvatar.js
async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict: strict2, universalResolverAddress }) {
  const record4 = await getAction(client, getEnsText, "getEnsText")({
    blockNumber,
    blockTag,
    key: "avatar",
    name,
    universalResolverAddress,
    gatewayUrls,
    strict: strict2
  });
  if (!record4)
    return null;
  try {
    return await parseAvatarRecord(client, {
      record: record4,
      gatewayUrls: assetGatewayUrls
    });
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsName.js
async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict: strict2, universalResolverAddress: universalResolverAddress_ }) {
  let universalResolverAddress = universalResolverAddress_;
  if (!universalResolverAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    universalResolverAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "ensUniversalResolver"
    });
  }
  const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const readContractParameters = {
      address: universalResolverAddress,
      abi: universalResolverReverseAbi,
      functionName: "reverse",
      args: [toHex(packetToBytes(reverseNode))],
      blockNumber,
      blockTag
    };
    const readContractAction = getAction(client, readContract, "readContract");
    const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
      ...readContractParameters,
      args: [...readContractParameters.args, gatewayUrls]
    }) : await readContractAction(readContractParameters);
    if (address.toLowerCase() !== resolvedAddress.toLowerCase())
      return null;
    return name;
  } catch (err2) {
    if (strict2)
      throw err2;
    if (isNullUniversalResolverError(err2, "reverse"))
      return null;
    throw err2;
  }
}

// node_modules/viem/_esm/actions/ens/getEnsResolver.js
async function getEnsResolver(client, parameters) {
  const { blockNumber, blockTag, name } = parameters;
  const { chain: chain2 } = client;
  const universalResolverAddress = (() => {
    if (parameters.universalResolverAddress)
      return parameters.universalResolverAddress;
    if (!chain2)
      throw new Error("client chain not configured. universalResolverAddress is required.");
    return getChainContractAddress({
      blockNumber,
      chain: chain2,
      contract: "ensUniversalResolver"
    });
  })();
  const tlds = chain2 == null ? void 0 : chain2.ensTlds;
  if (tlds && !tlds.some((tld) => name.endsWith(tld)))
    throw new Error(`${name} is not a valid ENS TLD (${tlds == null ? void 0 : tlds.join(", ")}) for chain "${chain2.name}" (id: ${chain2.id}).`);
  const [resolverAddress] = await getAction(client, readContract, "readContract")({
    address: universalResolverAddress,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "findResolver",
    args: [toHex(packetToBytes(name))],
    blockNumber,
    blockTag
  });
  return resolverAddress;
}

// node_modules/viem/_esm/actions/public/createAccessList.js
async function createAccessList(client, args2) {
  var _a106, _b32, _c7;
  const { account: account_ = client.account, blockNumber, blockTag = "latest", blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to: to3, value: value10, ...rest } = args2;
  const account = account_ ? parseAccount(account_) : void 0;
  try {
    assertRequest(args2);
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const chainFormat = (_c7 = (_b32 = (_a106 = client.chain) == null ? void 0 : _a106.formatters) == null ? void 0 : _b32.transactionRequest) == null ? void 0 : _c7.format;
    const format16 = chainFormat || formatTransactionRequest;
    const request2 = format16({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account == null ? void 0 : account.address,
      blobs,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      to: to3,
      value: value10
    });
    const response = await client.request({
      method: "eth_createAccessList",
      params: [request2, block]
    });
    return {
      accessList: response.accessList,
      gasUsed: BigInt(response.gasUsed)
    };
  } catch (err2) {
    throw getCallError(err2, {
      ...args2,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/actions/public/createBlockFilter.js
async function createBlockFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newBlockFilter"
  });
  const id3 = await client.request({
    method: "eth_newBlockFilter"
  });
  return { id: id3, request: getRequest(id3), type: "block" };
}

// node_modules/viem/_esm/actions/public/createEventFilter.js
async function createEventFilter(client, { address, args: args2, event, events: events_, fromBlock, strict: strict2, toBlock } = {}) {
  const events = events_ ?? (event ? [event] : void 0);
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args: args2
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  const id3 = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        ...topics.length ? { topics } : {}
      }
    ]
  });
  return {
    abi: events,
    args: args2,
    eventName: event ? event.name : void 0,
    fromBlock,
    id: id3,
    request: getRequest(id3),
    strict: Boolean(strict2),
    toBlock,
    type: "event"
  };
}

// node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
async function createPendingTransactionFilter(client) {
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newPendingTransactionFilter"
  });
  const id3 = await client.request({
    method: "eth_newPendingTransactionFilter"
  });
  return { id: id3, request: getRequest(id3), type: "transaction" };
}

// node_modules/viem/_esm/actions/public/getBlobBaseFee.js
async function getBlobBaseFee(client) {
  const baseFee = await client.request({
    method: "eth_blobBaseFee"
  });
  return BigInt(baseFee);
}

// node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let count9;
  if (blockHash) {
    count9 = await client.request({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    }, { dedupe: true });
  } else {
    count9 = await client.request({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumberHex || blockTag]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  return hexToNumber(count9);
}

// node_modules/viem/_esm/actions/public/getCode.js
async function getCode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex2 = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  }, { dedupe: Boolean(blockNumberHex) });
  if (hex2 === "0x")
    return void 0;
  return hex2;
}

// node_modules/viem/_esm/errors/eip712.js
var Eip712DomainNotFoundError = class extends BaseError {
  constructor({ address }) {
    super(`No EIP-712 domain found on contract "${address}".`, {
      metaMessages: [
        "Ensure that:",
        `- The contract is deployed at the address "${address}".`,
        "- `eip712Domain()` function exists on the contract.",
        "- `eip712Domain()` function matches signature to ERC-5267 specification."
      ],
      name: "Eip712DomainNotFoundError"
    });
  }
};

// node_modules/viem/_esm/actions/public/getEip712Domain.js
async function getEip712Domain(client, parameters) {
  const { address, factory, factoryData } = parameters;
  try {
    const [fields, name, version, chainId, verifyingContract, salt, extensions] = await getAction(client, readContract, "readContract")({
      abi,
      address,
      functionName: "eip712Domain",
      factory,
      factoryData
    });
    return {
      domain: {
        name,
        version,
        chainId: Number(chainId),
        verifyingContract,
        salt
      },
      extensions,
      fields
    };
  } catch (e) {
    const error4 = e;
    if (error4.name === "ContractFunctionExecutionError" && error4.cause.name === "ContractFunctionZeroDataError") {
      throw new Eip712DomainNotFoundError({ address });
    }
    throw error4;
  }
}
var abi = [
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      { name: "fields", type: "bytes1" },
      { name: "name", type: "string" },
      { name: "version", type: "string" },
      { name: "chainId", type: "uint256" },
      { name: "verifyingContract", type: "address" },
      { name: "salt", type: "bytes32" },
      { name: "extensions", type: "uint256[]" }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/viem/_esm/utils/formatters/feeHistory.js
function formatFeeHistory(feeHistory) {
  var _a106;
  return {
    baseFeePerGas: feeHistory.baseFeePerGas.map((value10) => BigInt(value10)),
    gasUsedRatio: feeHistory.gasUsedRatio,
    oldestBlock: BigInt(feeHistory.oldestBlock),
    reward: (_a106 = feeHistory.reward) == null ? void 0 : _a106.map((reward) => reward.map((value10) => BigInt(value10)))
  };
}

// node_modules/viem/_esm/actions/public/getFeeHistory.js
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
  const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
  const feeHistory = await client.request({
    method: "eth_feeHistory",
    params: [
      numberToHex(blockCount),
      blockNumberHex || blockTag,
      rewardPercentiles
    ]
  }, { dedupe: Boolean(blockNumberHex) });
  return formatFeeHistory(feeHistory);
}

// node_modules/viem/_esm/actions/public/getFilterLogs.js
async function getFilterLogs(_client, { filter: filter26 }) {
  const strict2 = filter26.strict ?? false;
  const logs = await filter26.request({
    method: "eth_getFilterLogs",
    params: [filter26.id]
  });
  const formattedLogs = logs.map((log5) => formatLog(log5));
  if (!filter26.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter26.abi,
    logs: formattedLogs,
    strict: strict2
  });
}

// node_modules/viem/_esm/errors/typedData.js
var InvalidDomainError = class extends BaseError {
  constructor({ domain: domain2 }) {
    super(`Invalid domain "${stringify(domain2)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
};
var InvalidPrimaryTypeError = class extends BaseError {
  constructor({ primaryType, types: types3 }) {
    super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types3))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
};
var InvalidStructTypeError = class extends BaseError {
  constructor({ type: type8 }) {
    super(`Struct type "${type8}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
};

// node_modules/viem/_esm/utils/signature/hashTypedData.js
function hashTypedData(parameters) {
  const { domain: domain2 = {}, message, primaryType } = parameters;
  const types3 = {
    EIP712Domain: getTypesForEIP712Domain({ domain: domain2 }),
    ...parameters.types
  };
  validateTypedData({
    domain: domain2,
    message,
    primaryType,
    types: types3
  });
  const parts2 = ["0x1901"];
  if (domain2)
    parts2.push(hashDomain({
      domain: domain2,
      types: types3
    }));
  if (primaryType !== "EIP712Domain")
    parts2.push(hashStruct({
      data: message,
      primaryType,
      types: types3
    }));
  return keccak256(concat(parts2));
}
function hashDomain({ domain: domain2, types: types3 }) {
  return hashStruct({
    data: domain2,
    primaryType: "EIP712Domain",
    types: types3
  });
}
function hashStruct({ data, primaryType, types: types3 }) {
  const encoded = encodeData({
    data,
    primaryType,
    types: types3
  });
  return keccak256(encoded);
}
function encodeData({ data, primaryType, types: types3 }) {
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types: types3 })];
  for (const field of types3[primaryType]) {
    const [type8, value10] = encodeField({
      types: types3,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type8);
    encodedValues.push(value10);
  }
  return encodeAbiParameters(encodedTypes, encodedValues);
}
function hashType({ primaryType, types: types3 }) {
  const encodedHashType = toHex(encodeType({ primaryType, types: types3 }));
  return keccak256(encodedHashType);
}
function encodeType({ primaryType, types: types3 }) {
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types: types3 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type8 of deps) {
    result += `${type8}(${types3[type8].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function findTypeDependencies({ primaryType: primaryType_, types: types3 }, results = /* @__PURE__ */ new Set()) {
  const match43 = primaryType_.match(/^\w*/u);
  const primaryType = match43 == null ? void 0 : match43[0];
  if (results.has(primaryType) || types3[primaryType] === void 0) {
    return results;
  }
  results.add(primaryType);
  for (const field of types3[primaryType]) {
    findTypeDependencies({ primaryType: field.type, types: types3 }, results);
  }
  return results;
}
function encodeField({ types: types3, name, type: type8, value: value10 }) {
  if (types3[type8] !== void 0) {
    return [
      { type: "bytes32" },
      keccak256(encodeData({ data: value10, primaryType: type8, types: types3 }))
    ];
  }
  if (type8 === "bytes") {
    const prepend8 = value10.length % 2 ? "0" : "";
    value10 = `0x${prepend8 + value10.slice(2)}`;
    return [{ type: "bytes32" }, keccak256(value10)];
  }
  if (type8 === "string")
    return [{ type: "bytes32" }, keccak256(toHex(value10))];
  if (type8.lastIndexOf("]") === type8.length - 1) {
    const parsedType = type8.slice(0, type8.lastIndexOf("["));
    const typeValuePairs = value10.map((item) => encodeField({
      name,
      type: parsedType,
      types: types3,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type: type8 }, value10];
}

// node_modules/viem/_esm/utils/typedData.js
function serializeTypedData(parameters) {
  const { domain: domain_, message: message_, primaryType, types: types3 } = parameters;
  const normalizeData = (struct7, data_) => {
    const data = { ...data_ };
    for (const param of struct7) {
      const { name, type: type8 } = param;
      if (type8 === "address")
        data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain2 = (() => {
    if (!types3.EIP712Domain)
      return {};
    if (!domain_)
      return {};
    return normalizeData(types3.EIP712Domain, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return void 0;
    return normalizeData(types3[primaryType], message_);
  })();
  return stringify({ domain: domain2, message, primaryType, types: types3 });
}
function validateTypedData(parameters) {
  const { domain: domain2, message, primaryType, types: types3 } = parameters;
  const validateData = (struct7, data) => {
    for (const param of struct7) {
      const { name, type: type8 } = param;
      const value10 = data[name];
      const integerMatch = type8.match(integerRegex);
      if (integerMatch && (typeof value10 === "number" || typeof value10 === "bigint")) {
        const [_type, base, size_] = integerMatch;
        numberToHex(value10, {
          signed: base === "int",
          size: Number.parseInt(size_) / 8
        });
      }
      if (type8 === "address" && typeof value10 === "string" && !isAddress(value10))
        throw new InvalidAddressError({ address: value10 });
      const bytesMatch = type8.match(bytesRegex);
      if (bytesMatch) {
        const [_type, size_] = bytesMatch;
        if (size_ && size(value10) !== Number.parseInt(size_))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size_),
            givenSize: size(value10)
          });
      }
      const struct8 = types3[type8];
      if (struct8) {
        validateReference(type8);
        validateData(struct8, value10);
      }
    }
  };
  if (types3.EIP712Domain && domain2) {
    if (typeof domain2 !== "object")
      throw new InvalidDomainError({ domain: domain2 });
    validateData(types3.EIP712Domain, domain2);
  }
  if (primaryType !== "EIP712Domain") {
    if (types3[primaryType])
      validateData(types3[primaryType], message);
    else
      throw new InvalidPrimaryTypeError({ primaryType, types: types3 });
  }
}
function getTypesForEIP712Domain({ domain: domain2 }) {
  return [
    typeof (domain2 == null ? void 0 : domain2.name) === "string" && { name: "name", type: "string" },
    (domain2 == null ? void 0 : domain2.version) && { name: "version", type: "string" },
    (typeof (domain2 == null ? void 0 : domain2.chainId) === "number" || typeof (domain2 == null ? void 0 : domain2.chainId) === "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    (domain2 == null ? void 0 : domain2.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (domain2 == null ? void 0 : domain2.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function validateReference(type8) {
  if (type8 === "address" || type8 === "bool" || type8 === "string" || type8.startsWith("bytes") || type8.startsWith("uint") || type8.startsWith("int"))
    throw new InvalidStructTypeError({ type: type8 });
}

// node_modules/viem/_esm/utils/abi/encodePacked.js
function encodePacked(types3, values15) {
  if (types3.length !== values15.length)
    throw new AbiEncodingLengthMismatchError({
      expectedLength: types3.length,
      givenLength: values15.length
    });
  const data = [];
  for (let i = 0; i < types3.length; i++) {
    const type8 = types3[i];
    const value10 = values15[i];
    data.push(encode6(type8, value10));
  }
  return concatHex(data);
}
function encode6(type8, value10, isArray2 = false) {
  if (type8 === "address") {
    const address = value10;
    if (!isAddress(address))
      throw new InvalidAddressError({ address });
    return pad(address.toLowerCase(), {
      size: isArray2 ? 32 : null
    });
  }
  if (type8 === "string")
    return stringToHex(value10);
  if (type8 === "bytes")
    return value10;
  if (type8 === "bool")
    return pad(boolToHex(value10), { size: isArray2 ? 32 : 1 });
  const intMatch = type8.match(integerRegex);
  if (intMatch) {
    const [_type, baseType, bits2 = "256"] = intMatch;
    const size45 = Number.parseInt(bits2) / 8;
    return numberToHex(value10, {
      size: isArray2 ? 32 : size45,
      signed: baseType === "int"
    });
  }
  const bytesMatch = type8.match(bytesRegex);
  if (bytesMatch) {
    const [_type, size45] = bytesMatch;
    if (Number.parseInt(size45) !== (value10.length - 2) / 2)
      throw new BytesSizeMismatchError({
        expectedSize: Number.parseInt(size45),
        givenSize: (value10.length - 2) / 2
      });
    return pad(value10, { dir: "right", size: isArray2 ? 32 : null });
  }
  const arrayMatch = type8.match(arrayRegex);
  if (arrayMatch && Array.isArray(value10)) {
    const [_type, childType] = arrayMatch;
    const data = [];
    for (let i = 0; i < value10.length; i++) {
      data.push(encode6(childType, value10[i], true));
    }
    if (data.length === 0)
      return "0x";
    return concatHex(data);
  }
  throw new UnsupportedPackedAbiType(type8);
}

// node_modules/viem/_esm/utils/transaction/assertTransaction.js
function assertTransactionEIP7702(transaction) {
  const { authorizationList } = transaction;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { chainId } = authorization;
      const address = authorization.address;
      if (!isAddress(address))
        throw new InvalidAddressError({ address });
      if (chainId < 0)
        throw new InvalidChainIdError({ chainId });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
  const { blobVersionedHashes } = transaction;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobError();
    for (const hash11 of blobVersionedHashes) {
      const size_ = size(hash11);
      const version = hexToNumber(slice(hash11, 0, 1));
      if (size_ !== 32)
        throw new InvalidVersionedHashSizeError({ hash: hash11, size: size_ });
      if (version !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({
          hash: hash11,
          version
        });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to: to3 } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to3 && !isAddress(to3))
    throw new InvalidAddressError({ address: to3 });
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
function assertTransactionEIP2930(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to3 } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to3 && !isAddress(to3))
    throw new InvalidAddressError({ address: to3 });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
function assertTransactionLegacy(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to3 } = transaction;
  if (to3 && !isAddress(to3))
    throw new InvalidAddressError({ address: to3 });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}

// node_modules/viem/_esm/utils/transaction/serializeAccessList.js
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const serializedAccessList = [];
  for (let i = 0; i < accessList.length; i++) {
    const { address, storageKeys } = accessList[i];
    for (let j = 0; j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
      }
    }
    if (!isAddress(address, { strict: false })) {
      throw new InvalidAddressError({ address });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}

// node_modules/viem/_esm/utils/transaction/serializeTransaction.js
function serializeTransaction(transaction, signature) {
  const type8 = getTransactionType(transaction);
  if (type8 === "eip1559")
    return serializeTransactionEIP1559(transaction, signature);
  if (type8 === "eip2930")
    return serializeTransactionEIP2930(transaction, signature);
  if (type8 === "eip4844")
    return serializeTransactionEIP4844(transaction, signature);
  if (type8 === "eip7702")
    return serializeTransactionEIP7702(transaction, signature);
  return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
  const { authorizationList, chainId, gas, nonce, to: to3, value: value10, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP7702(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
  return concatHex([
    "0x04",
    toRlp([
      numberToHex(chainId),
      nonce ? numberToHex(nonce) : "0x",
      maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
      gas ? numberToHex(gas) : "0x",
      to3 ?? "0x",
      value10 ? numberToHex(value10) : "0x",
      data ?? "0x",
      serializedAccessList,
      serializedAuthorizationList,
      ...toYParitySignatureArray(transaction, signature)
    ])
  ]);
}
function serializeTransactionEIP4844(transaction, signature) {
  const { chainId, gas, nonce, to: to3, value: value10, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP4844(transaction);
  let blobVersionedHashes = transaction.blobVersionedHashes;
  let sidecars = transaction.sidecars;
  if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
    const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex(x));
    const kzg = transaction.kzg;
    const commitments2 = blobsToCommitments({
      blobs: blobs2,
      kzg
    });
    if (typeof blobVersionedHashes === "undefined")
      blobVersionedHashes = commitmentsToVersionedHashes({
        commitments: commitments2
      });
    if (typeof sidecars === "undefined") {
      const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });
      sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });
    }
  }
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    numberToHex(chainId),
    nonce ? numberToHex(nonce) : "0x",
    maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
    gas ? numberToHex(gas) : "0x",
    to3 ?? "0x",
    value10 ? numberToHex(value10) : "0x",
    data ?? "0x",
    serializedAccessList,
    maxFeePerBlobGas ? numberToHex(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...toYParitySignatureArray(transaction, signature)
  ];
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i = 0; i < sidecars.length; i++) {
      const { blob, commitment, proof } = sidecars[i];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concatHex([
    "0x03",
    sidecars ? (
      // If sidecars are enabled, envelope turns into a "wrapper":
      toRlp([serializedTransaction, blobs, commitments, proofs])
    ) : (
      // If sidecars are disabled, standard envelope is used:
      toRlp(serializedTransaction)
    )
  ]);
}
function serializeTransactionEIP1559(transaction, signature) {
  const { chainId, gas, nonce, to: to3, value: value10, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP1559(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    numberToHex(chainId),
    nonce ? numberToHex(nonce) : "0x",
    maxPriorityFeePerGas ? numberToHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? numberToHex(maxFeePerGas) : "0x",
    gas ? numberToHex(gas) : "0x",
    to3 ?? "0x",
    value10 ? numberToHex(value10) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x02",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP2930(transaction, signature) {
  const { chainId, gas, data, nonce, to: to3, value: value10, accessList, gasPrice } = transaction;
  assertTransactionEIP2930(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    numberToHex(chainId),
    nonce ? numberToHex(nonce) : "0x",
    gasPrice ? numberToHex(gasPrice) : "0x",
    gas ? numberToHex(gas) : "0x",
    to3 ?? "0x",
    value10 ? numberToHex(value10) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x01",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionLegacy(transaction, signature) {
  const { chainId = 0, gas, data, nonce, to: to3, value: value10, gasPrice } = transaction;
  assertTransactionLegacy(transaction);
  let serializedTransaction = [
    nonce ? numberToHex(nonce) : "0x",
    gasPrice ? numberToHex(gasPrice) : "0x",
    gas ? numberToHex(gas) : "0x",
    to3 ?? "0x",
    value10 ? numberToHex(value10) : "0x",
    data ?? "0x"
  ];
  if (signature) {
    const v = (() => {
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n;
        if (inferredChainId > 0)
          return signature.v;
        return 27n + (signature.v === 35n ? 0n : 1n);
      }
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      const v2 = 27n + (signature.v === 27n ? 0n : 1n);
      if (signature.v !== v2)
        throw new InvalidLegacyVError({ v: signature.v });
      return v2;
    })();
    const r = trim(signature.r);
    const s = trim(signature.s);
    serializedTransaction = [
      ...serializedTransaction,
      numberToHex(v),
      r === "0x00" ? "0x" : r,
      s === "0x00" ? "0x" : s
    ];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      numberToHex(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
  const signature = signature_ ?? transaction;
  const { v, yParity } = signature;
  if (typeof signature.r === "undefined")
    return [];
  if (typeof signature.s === "undefined")
    return [];
  if (typeof v === "undefined" && typeof yParity === "undefined")
    return [];
  const r = trim(signature.r);
  const s = trim(signature.s);
  const yParity_ = (() => {
    if (typeof yParity === "number")
      return yParity ? numberToHex(1) : "0x";
    if (v === 0n)
      return "0x";
    if (v === 1n)
      return numberToHex(1);
    return v === 27n ? "0x" : numberToHex(1);
  })();
  return [yParity_, r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
}

// node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js
function serializeAuthorizationList(authorizationList) {
  if (!authorizationList || authorizationList.length === 0)
    return [];
  const serializedAuthorizationList = [];
  for (const authorization of authorizationList) {
    const { chainId, nonce, ...signature } = authorization;
    const contractAddress = authorization.address;
    serializedAuthorizationList.push([
      chainId ? toHex(chainId) : "0x",
      contractAddress,
      nonce ? toHex(nonce) : "0x",
      ...toYParitySignatureArray({}, signature)
    ]);
  }
  return serializedAuthorizationList;
}

// node_modules/viem/_esm/utils/data/isBytes.js
function isBytes(value10) {
  if (!value10)
    return false;
  if (typeof value10 !== "object")
    return false;
  if (!("BYTES_PER_ELEMENT" in value10))
    return false;
  return value10.BYTES_PER_ELEMENT === 1 && value10.constructor.name === "Uint8Array";
}

// node_modules/viem/_esm/utils/address/getContractAddress.js
function getContractAddress(opts) {
  if (opts.opcode === "CREATE2")
    return getCreate2Address(opts);
  return getCreateAddress(opts);
}
function getCreateAddress(opts) {
  const from29 = toBytes(getAddress(opts.from));
  let nonce = toBytes(opts.nonce);
  if (nonce[0] === 0)
    nonce = new Uint8Array([]);
  return getAddress(`0x${keccak256(toRlp([from29, nonce], "bytes")).slice(26)}`);
}
function getCreate2Address(opts) {
  const from29 = toBytes(getAddress(opts.from));
  const salt = pad(isBytes(opts.salt) ? opts.salt : toBytes(opts.salt), {
    size: 32
  });
  const bytecodeHash = (() => {
    if ("bytecodeHash" in opts) {
      if (isBytes(opts.bytecodeHash))
        return opts.bytecodeHash;
      return toBytes(opts.bytecodeHash);
    }
    return keccak256(opts.bytecode, "bytes");
  })();
  return getAddress(slice(keccak256(concat([toBytes("0xff"), from29, salt, bytecodeHash])), 12));
}

// node_modules/@noble/hashes/esm/legacy.js
var SHA1_IV = Uint32Array.from([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]);
var SHA1_W = new Uint32Array(80);
var SHA1 = class extends HashMD {
  constructor() {
    super(64, 20, 8, false);
    this.A = SHA1_IV[0] | 0;
    this.B = SHA1_IV[1] | 0;
    this.C = SHA1_IV[2] | 0;
    this.D = SHA1_IV[3] | 0;
    this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A, B, C, D, E } = this;
    return [A, B, C, D, E];
  }
  set(A, B, C, D, E) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA1_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 80; i++)
      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
    let { A, B, C, D, E } = this;
    for (let i = 0; i < 80; i++) {
      let F, K2;
      if (i < 20) {
        F = Chi(B, C, D);
        K2 = 1518500249;
      } else if (i < 40) {
        F = B ^ C ^ D;
        K2 = 1859775393;
      } else if (i < 60) {
        F = Maj(B, C, D);
        K2 = 2400959708;
      } else {
        F = B ^ C ^ D;
        K2 = 3395469782;
      }
      const T = rotl(A, 5) + F + E + K2 + SHA1_W[i] | 0;
      E = D;
      D = C;
      C = rotl(B, 30);
      B = A;
      A = T;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    this.set(A, B, C, D, E);
  }
  roundClean() {
    clean(SHA1_W);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var sha12 = createHasher(() => new SHA1());
var p32 = Math.pow(2, 32);
var K = Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
var MD5_IV = SHA1_IV.slice(0, 4);
var MD5_W = new Uint32Array(16);
var MD5 = class extends HashMD {
  constructor() {
    super(64, 16, 8, true);
    this.A = MD5_IV[0] | 0;
    this.B = MD5_IV[1] | 0;
    this.C = MD5_IV[2] | 0;
    this.D = MD5_IV[3] | 0;
  }
  get() {
    const { A, B, C, D } = this;
    return [A, B, C, D];
  }
  set(A, B, C, D) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      MD5_W[i] = view.getUint32(offset, true);
    let { A, B, C, D } = this;
    for (let i = 0; i < 64; i++) {
      let F, g, s;
      if (i < 16) {
        F = Chi(B, C, D);
        g = i;
        s = [7, 12, 17, 22];
      } else if (i < 32) {
        F = Chi(D, B, C);
        g = (5 * i + 1) % 16;
        s = [5, 9, 14, 20];
      } else if (i < 48) {
        F = B ^ C ^ D;
        g = (3 * i + 5) % 16;
        s = [4, 11, 16, 23];
      } else {
        F = C ^ (B | ~D);
        g = 7 * i % 16;
        s = [6, 10, 15, 21];
      }
      F = F + A + K[i] + MD5_W[g];
      A = D;
      D = C;
      C = B;
      B = B + rotl(F, s[i % 4]);
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    this.set(A, B, C, D);
  }
  roundClean() {
    clean(MD5_W);
  }
  destroy() {
    this.set(0, 0, 0, 0);
    clean(this.buffer);
  }
};
var md52 = createHasher(() => new MD5());
var Rho160 = Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
var Pi160 = (() => Id160.map((i) => (9 * i + 5) % 16))();
var idxLR = (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i = 0; i < 4; i++)
    for (let j of res)
      j.push(j[i].map((k) => Rho160[k]));
  return res;
})();
var idxL = (() => idxLR[0])();
var idxR = (() => idxLR[1])();
var shifts160 = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => Uint8Array.from(i));
var shiftsL160 = idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
var shiftsR160 = idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
var Kl160 = Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group5, x, y, z) {
  if (group5 === 0)
    return x ^ y ^ z;
  if (group5 === 1)
    return x & y | ~x & z;
  if (group5 === 2)
    return (x | ~y) ^ z;
  if (group5 === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF_160[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group5 = 0; group5 < 5; group5++) {
      const rGroup = 4 - group5;
      const hbl = Kl160[group5], hbr = Kr160[group5];
      const rl = idxL[group5], rr = idxR[group5];
      const sl = shiftsL160[group5], sr = shiftsR160[group5];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + ripemd_f(group5, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = createHasher(() => new RIPEMD160());

// node_modules/@noble/hashes/esm/ripemd160.js
var ripemd1602 = ripemd160;

// node_modules/viem/_esm/constants/strings.js
var presignMessagePrefix = "Ethereum Signed Message:\n";

// node_modules/viem/_esm/utils/signature/toPrefixedMessage.js
function toPrefixedMessage(message_) {
  const message = (() => {
    if (typeof message_ === "string")
      return stringToHex(message_);
    if (typeof message_.raw === "string")
      return message_.raw;
    return bytesToHex(message_.raw);
  })();
  const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);
  return concat([prefix, message]);
}

// node_modules/viem/_esm/utils/signature/hashMessage.js
function hashMessage(message, to_) {
  return keccak256(toPrefixedMessage(message), to_);
}

// node_modules/viem/_esm/utils/signature/recoverMessageAddress.js
async function recoverMessageAddress({ message, signature }) {
  return recoverAddress({ hash: hashMessage(message), signature });
}

// node_modules/viem/_esm/utils/signature/verifyMessage.js
async function verifyMessage({ address, message, signature }) {
  return isAddressEqual(getAddress(address), await recoverMessageAddress({ message, signature }));
}

// node_modules/viem/_esm/constants/bytes.js
var erc6492MagicBytes = "0x6492649264926492649264926492649264926492649264926492649264926492";

// node_modules/viem/_esm/utils/signature/isErc6492Signature.js
function isErc6492Signature(signature) {
  return sliceHex(signature, -32) === erc6492MagicBytes;
}

// node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js
function serializeErc6492Signature(parameters) {
  const { address, data, signature, to: to3 = "hex" } = parameters;
  const signature_ = concatHex([
    encodeAbiParameters([{ type: "address" }, { type: "bytes" }, { type: "bytes" }], [address, data, signature]),
    erc6492MagicBytes
  ]);
  if (to3 === "hex")
    return signature_;
  return hexToBytes(signature_);
}

// node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey2 = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey2({ address, chainId });
      const promise4 = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise4;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey2({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey2({ address, chainId });
      let promise4 = promiseMap.get(key);
      if (!promise4) {
        promise4 = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise4);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise4;
    },
    reset({ address, chainId }) {
      const key = getKey2({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/viem/_esm/utils/formatters/proof.js
function formatStorageProof(storageProof) {
  return storageProof.map((proof) => ({
    ...proof,
    value: BigInt(proof.value)
  }));
}
function formatProof(proof) {
  return {
    ...proof,
    balance: proof.balance ? BigInt(proof.balance) : void 0,
    nonce: proof.nonce ? hexToNumber(proof.nonce) : void 0,
    storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0
  };
}

// node_modules/viem/_esm/actions/public/getProof.js
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
  const blockTag = blockTag_ ?? "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const proof = await client.request({
    method: "eth_getProof",
    params: [address, storageKeys, blockNumberHex || blockTag]
  });
  return formatProof(proof);
}

// node_modules/viem/_esm/actions/public/getStorageAt.js
async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const data = await client.request({
    method: "eth_getStorageAt",
    params: [address, slot, blockNumberHex || blockTag]
  });
  return data;
}

// node_modules/viem/_esm/actions/public/getTransaction.js
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash11, index: index3 }) {
  var _a106, _b32, _c7;
  const blockTag = blockTag_ || "latest";
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let transaction = null;
  if (hash11) {
    transaction = await client.request({
      method: "eth_getTransactionByHash",
      params: [hash11]
    }, { dedupe: true });
  } else if (blockHash) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, numberToHex(index3)]
    }, { dedupe: true });
  } else if (blockNumberHex || blockTag) {
    transaction = await client.request({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumberHex || blockTag, numberToHex(index3)]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!transaction)
    throw new TransactionNotFoundError({
      blockHash,
      blockNumber,
      blockTag,
      hash: hash11,
      index: index3
    });
  const format16 = ((_c7 = (_b32 = (_a106 = client.chain) == null ? void 0 : _a106.formatters) == null ? void 0 : _b32.transaction) == null ? void 0 : _c7.format) || formatTransaction;
  return format16(transaction);
}

// node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
async function getTransactionConfirmations(client, { hash: hash11, transactionReceipt }) {
  const [blockNumber, transaction] = await Promise.all([
    getAction(client, getBlockNumber, "getBlockNumber")({}),
    hash11 ? getAction(client, getTransaction, "getTransaction")({ hash: hash11 }) : void 0
  ]);
  const transactionBlockNumber = (transactionReceipt == null ? void 0 : transactionReceipt.blockNumber) || (transaction == null ? void 0 : transaction.blockNumber);
  if (!transactionBlockNumber)
    return 0n;
  return blockNumber - transactionBlockNumber + 1n;
}

// node_modules/viem/_esm/actions/public/getTransactionReceipt.js
async function getTransactionReceipt(client, { hash: hash11 }) {
  var _a106, _b32, _c7;
  const receipt = await client.request({
    method: "eth_getTransactionReceipt",
    params: [hash11]
  }, { dedupe: true });
  if (!receipt)
    throw new TransactionReceiptNotFoundError({ hash: hash11 });
  const format16 = ((_c7 = (_b32 = (_a106 = client.chain) == null ? void 0 : _a106.formatters) == null ? void 0 : _b32.transactionReceipt) == null ? void 0 : _c7.format) || formatTransactionReceipt;
  return format16(receipt);
}

// node_modules/viem/_esm/actions/public/multicall.js
async function multicall(client, parameters) {
  var _a106;
  const { account, allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
  const contracts = parameters.contracts;
  const batchSize = batchSize_ ?? (typeof ((_a106 = client.batch) == null ? void 0 : _a106.multicall) === "object" && client.batch.multicall.batchSize || 1024);
  let multicallAddress = multicallAddress_;
  if (!multicallAddress) {
    if (!client.chain)
      throw new Error("client chain not configured. multicallAddress is required.");
    multicallAddress = getChainContractAddress({
      blockNumber,
      chain: client.chain,
      contract: "multicall3"
    });
  }
  const chunkedCalls = [[]];
  let currentChunk = 0;
  let currentChunkSize = 0;
  for (let i = 0; i < contracts.length; i++) {
    const { abi: abi11, address, args: args2, functionName } = contracts[i];
    try {
      const callData = encodeFunctionData({ abi: abi11, args: args2, functionName });
      currentChunkSize += (callData.length - 2) / 2;
      if (
        // Check if batching is enabled.
        batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
        currentChunkSize > batchSize && // Check if the current chunk is not already empty.
        chunkedCalls[currentChunk].length > 0
      ) {
        currentChunk++;
        currentChunkSize = (callData.length - 2) / 2;
        chunkedCalls[currentChunk] = [];
      }
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData,
          target: address
        }
      ];
    } catch (err2) {
      const error4 = getContractError(err2, {
        abi: abi11,
        address,
        args: args2,
        docsPath: "/docs/contract/multicall",
        functionName,
        sender: account
      });
      if (!allowFailure)
        throw error4;
      chunkedCalls[currentChunk] = [
        ...chunkedCalls[currentChunk],
        {
          allowFailure: true,
          callData: "0x",
          target: address
        }
      ];
    }
  }
  const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, "readContract")({
    abi: multicall3Abi,
    account,
    address: multicallAddress,
    args: [calls],
    blockNumber,
    blockTag,
    functionName: "aggregate3",
    stateOverride
  })));
  const results = [];
  for (let i = 0; i < aggregate3Results.length; i++) {
    const result = aggregate3Results[i];
    if (result.status === "rejected") {
      if (!allowFailure)
        throw result.reason;
      for (let j = 0; j < chunkedCalls[i].length; j++) {
        results.push({
          status: "failure",
          error: result.reason,
          result: void 0
        });
      }
      continue;
    }
    const aggregate3Result = result.value;
    for (let j = 0; j < aggregate3Result.length; j++) {
      const { returnData, success } = aggregate3Result[j];
      const { callData } = chunkedCalls[i][j];
      const { abi: abi11, address, functionName, args: args2 } = contracts[results.length];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result2 = decodeFunctionResult({
          abi: abi11,
          args: args2,
          data: returnData,
          functionName
        });
        results.push(allowFailure ? { result: result2, status: "success" } : result2);
      } catch (err2) {
        const error4 = getContractError(err2, {
          abi: abi11,
          address,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error4;
        results.push({ error: error4, result: void 0, status: "failure" });
      }
    }
  }
  if (results.length !== contracts.length)
    throw new BaseError("multicall results mismatch");
  return results;
}

// node_modules/viem/_esm/actions/public/simulateBlocks.js
async function simulateBlocks(client, parameters) {
  const { blockNumber, blockTag = "latest", blocks, returnFullTransactions, traceTransfers, validation } = parameters;
  try {
    const blockStateCalls = [];
    for (const block2 of blocks) {
      const blockOverrides = block2.blockOverrides ? toRpc2(block2.blockOverrides) : void 0;
      const calls = block2.calls.map((call_) => {
        const call2 = call_;
        const account = call2.account ? parseAccount(call2.account) : void 0;
        const data = call2.abi ? encodeFunctionData(call2) : call2.data;
        const request2 = {
          ...call2,
          data: call2.dataSuffix ? concat([data || "0x", call2.dataSuffix]) : data,
          from: call2.from ?? (account == null ? void 0 : account.address)
        };
        assertRequest(request2);
        return formatTransactionRequest(request2);
      });
      const stateOverrides = block2.stateOverrides ? serializeStateOverride(block2.stateOverrides) : void 0;
      blockStateCalls.push({
        blockOverrides,
        calls,
        stateOverrides
      });
    }
    const blockNumberHex = typeof blockNumber === "bigint" ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const result = await client.request({
      method: "eth_simulateV1",
      params: [
        { blockStateCalls, returnFullTransactions, traceTransfers, validation },
        block
      ]
    });
    return result.map((block2, i) => ({
      ...formatBlock(block2),
      calls: block2.calls.map((call2, j) => {
        var _a106, _b32;
        const { abi: abi11, args: args2, functionName, to: to3 } = blocks[i].calls[j];
        const data = ((_a106 = call2.error) == null ? void 0 : _a106.data) ?? call2.returnData;
        const gasUsed = BigInt(call2.gasUsed);
        const logs = (_b32 = call2.logs) == null ? void 0 : _b32.map((log5) => formatLog(log5));
        const status3 = call2.status === "0x1" ? "success" : "failure";
        const result2 = abi11 && status3 === "success" && data !== "0x" ? decodeFunctionResult({
          abi: abi11,
          data,
          functionName
        }) : null;
        const error4 = (() => {
          var _a107;
          if (status3 === "success")
            return void 0;
          let error5 = void 0;
          if (((_a107 = call2.error) == null ? void 0 : _a107.data) === "0x")
            error5 = new AbiDecodingZeroDataError();
          else if (call2.error)
            error5 = new RawContractError(call2.error);
          if (!error5)
            return void 0;
          return getContractError(error5, {
            abi: abi11 ?? [],
            address: to3 ?? "0x",
            args: args2,
            functionName: functionName ?? "<unknown>"
          });
        })();
        return {
          data,
          gasUsed,
          logs,
          status: status3,
          ...status3 === "success" ? {
            result: result2
          } : {
            error: error4
          }
        };
      })
    }));
  } catch (e) {
    const cause3 = e;
    const error4 = getNodeError(cause3, {});
    if (error4 instanceof UnknownNodeError)
      throw cause3;
    throw error4;
  }
}

// node_modules/ox/_esm/core/AbiConstructor.js
var AbiConstructor_exports = {};
__export(AbiConstructor_exports, {
  decode: () => decode8,
  encode: () => encode9,
  format: () => format10,
  from: () => from7,
  fromAbi: () => fromAbi2
});

// node_modules/ox/_esm/core/AbiItem.js
var AbiItem_exports = {};
__export(AbiItem_exports, {
  AmbiguityError: () => AmbiguityError,
  InvalidSelectorSizeError: () => InvalidSelectorSizeError,
  NotFoundError: () => NotFoundError,
  format: () => format8,
  from: () => from5,
  fromAbi: () => fromAbi,
  getSelector: () => getSelector,
  getSignature: () => getSignature,
  getSignatureHash: () => getSignatureHash
});

// node_modules/ox/_esm/core/Hash.js
var Hash_exports2 = {};
__export(Hash_exports2, {
  keccak256: () => keccak2562,
  ripemd160: () => ripemd1604,
  sha256: () => sha2564,
  validate: () => validate10
});
function keccak2562(value10, options = {}) {
  const { as: as18 = typeof value10 === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value10));
  if (as18 === "Bytes")
    return bytes;
  return fromBytes(bytes);
}
function ripemd1604(value10, options = {}) {
  const { as: as18 = typeof value10 === "string" ? "Hex" : "Bytes" } = options;
  const bytes = ripemd1602(from(value10));
  if (as18 === "Bytes")
    return bytes;
  return fromBytes(bytes);
}
function sha2564(value10, options = {}) {
  const { as: as18 = typeof value10 === "string" ? "Hex" : "Bytes" } = options;
  const bytes = sha2562(from(value10));
  if (as18 === "Bytes")
    return bytes;
  return fromBytes(bytes);
}
function validate10(value10) {
  return validate2(value10) && size3(value10) === 32;
}

// node_modules/ox/_esm/core/Address.js
var Address_exports = {};
__export(Address_exports, {
  InvalidAddressError: () => InvalidAddressError2,
  InvalidChecksumError: () => InvalidChecksumError,
  InvalidInputError: () => InvalidInputError,
  assert: () => assert5,
  checksum: () => checksum2,
  from: () => from4,
  fromPublicKey: () => fromPublicKey,
  isEqual: () => isEqual3,
  validate: () => validate12
});

// node_modules/ox/_esm/core/Caches.js
var Caches_exports = {};
__export(Caches_exports, {
  checksum: () => checksum,
  clear: () => clear8
});

// node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size45) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size45;
  }
  get(key) {
    const value10 = super.get(key);
    if (super.has(key) && value10 !== void 0) {
      this.delete(key);
      super.set(key, value10);
    }
    return value10;
  }
  set(key, value10) {
    super.set(key, value10);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum = caches.checksum;
function clear8() {
  for (const cache of Object.values(caches))
    cache.clear();
}

// node_modules/ox/_esm/core/PublicKey.js
var PublicKey_exports = {};
__export(PublicKey_exports, {
  InvalidCompressedPrefixError: () => InvalidCompressedPrefixError,
  InvalidError: () => InvalidError,
  InvalidPrefixError: () => InvalidPrefixError,
  InvalidSerializedSizeError: () => InvalidSerializedSizeError,
  InvalidUncompressedPrefixError: () => InvalidUncompressedPrefixError,
  assert: () => assert4,
  compress: () => compress,
  from: () => from3,
  fromBytes: () => fromBytes4,
  fromHex: () => fromHex3,
  toBytes: () => toBytes5,
  toHex: () => toHex3,
  validate: () => validate11
});
function assert4(publicKey, options = {}) {
  const { compressed } = options;
  const { prefix, x, y } = publicKey;
  if (compressed === false || typeof x === "bigint" && typeof y === "bigint") {
    if (prefix !== 4)
      throw new InvalidPrefixError({
        prefix,
        cause: new InvalidUncompressedPrefixError()
      });
    return;
  }
  if (compressed === true || typeof x === "bigint" && typeof y === "undefined") {
    if (prefix !== 3 && prefix !== 2)
      throw new InvalidPrefixError({
        prefix,
        cause: new InvalidCompressedPrefixError()
      });
    return;
  }
  throw new InvalidError({ publicKey });
}
function compress(publicKey) {
  const { x, y } = publicKey;
  return {
    prefix: y % 2n === 0n ? 2 : 3,
    x
  };
}
function from3(value10) {
  const publicKey = (() => {
    if (validate2(value10))
      return fromHex3(value10);
    if (validate(value10))
      return fromBytes4(value10);
    const { prefix, x, y } = value10;
    if (typeof x === "bigint" && typeof y === "bigint")
      return { prefix: prefix ?? 4, x, y };
    return { prefix, x };
  })();
  assert4(publicKey);
  return publicKey;
}
function fromBytes4(publicKey) {
  return fromHex3(fromBytes(publicKey));
}
function fromHex3(publicKey) {
  if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68)
    throw new InvalidSerializedSizeError({ publicKey });
  if (publicKey.length === 130) {
    const x2 = BigInt(slice3(publicKey, 0, 32));
    const y = BigInt(slice3(publicKey, 32, 64));
    return {
      prefix: 4,
      x: x2,
      y
    };
  }
  if (publicKey.length === 132) {
    const prefix2 = Number(slice3(publicKey, 0, 1));
    const x2 = BigInt(slice3(publicKey, 1, 33));
    const y = BigInt(slice3(publicKey, 33, 65));
    return {
      prefix: prefix2,
      x: x2,
      y
    };
  }
  const prefix = Number(slice3(publicKey, 0, 1));
  const x = BigInt(slice3(publicKey, 1, 33));
  return {
    prefix,
    x
  };
}
function toBytes5(publicKey, options = {}) {
  return fromHex(toHex3(publicKey, options));
}
function toHex3(publicKey, options = {}) {
  assert4(publicKey);
  const { prefix, x, y } = publicKey;
  const { includePrefix = true } = options;
  const publicKey_ = concat3(
    includePrefix ? fromNumber2(prefix, { size: 1 }) : "0x",
    fromNumber2(x, { size: 32 }),
    // If the public key is not compressed, add the y coordinate.
    typeof y === "bigint" ? fromNumber2(y, { size: 32 }) : "0x"
  );
  return publicKey_;
}
function validate11(publicKey, options = {}) {
  try {
    assert4(publicKey, options);
    return true;
  } catch (error4) {
    return false;
  }
}
var InvalidError = class extends BaseError2 {
  constructor({ publicKey }) {
    super(`Value \`${stringify2(publicKey)}\` is not a valid public key.`, {
      metaMessages: [
        "Public key must contain:",
        "- an `x` and `prefix` value (compressed)",
        "- an `x`, `y`, and `prefix` value (uncompressed)"
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidError"
    });
  }
};
var InvalidPrefixError = class extends BaseError2 {
  constructor({ prefix, cause: cause3 }) {
    super(`Prefix "${prefix}" is invalid.`, {
      cause: cause3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidPrefixError"
    });
  }
};
var InvalidCompressedPrefixError = class extends BaseError2 {
  constructor() {
    super("Prefix must be 2 or 3 for compressed public keys.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidCompressedPrefixError"
    });
  }
};
var InvalidUncompressedPrefixError = class extends BaseError2 {
  constructor() {
    super("Prefix must be 4 for uncompressed public keys.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidUncompressedPrefixError"
    });
  }
};
var InvalidSerializedSizeError = class extends BaseError2 {
  constructor({ publicKey }) {
    super(`Value \`${publicKey}\` is an invalid public key size.`, {
      metaMessages: [
        "Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",
        `Received ${size3(from2(publicKey))} bytes.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidSerializedSizeError"
    });
  }
};

// node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert5(value10, options = {}) {
  const { strict: strict2 = true } = options;
  if (!addressRegex.test(value10))
    throw new InvalidAddressError2({
      address: value10,
      cause: new InvalidInputError()
    });
  if (strict2) {
    if (value10.toLowerCase() === value10)
      return;
    if (checksum2(value10) !== value10)
      throw new InvalidAddressError2({
        address: value10,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert5(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash11 = keccak2562(fromString(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash11[i >> 1] >> 4 >= 8 && characters[i]) {
      characters[i] = characters[i].toUpperCase();
    }
    if ((hash11[i >> 1] & 15) >= 8 && characters[i + 1]) {
      characters[i + 1] = characters[i + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
function from4(address, options = {}) {
  const { checksum: checksumVal = false } = options;
  assert5(address);
  if (checksumVal)
    return checksum2(address);
  return address;
}
function fromPublicKey(publicKey, options = {}) {
  const address = keccak2562(`0x${toHex3(publicKey).slice(4)}`).substring(26);
  return from4(`0x${address}`, options);
}
function isEqual3(addressA, addressB) {
  assert5(addressA, { strict: false });
  assert5(addressB, { strict: false });
  return addressA.toLowerCase() === addressB.toLowerCase();
}
function validate12(address, options = {}) {
  const { strict: strict2 = true } = options ?? {};
  try {
    assert5(address, { strict: strict2 });
    return true;
  } catch {
    return false;
  }
}
var InvalidAddressError2 = class extends BaseError2 {
  constructor({ address, cause: cause3 }) {
    super(`Address "${address}" is invalid.`, {
      cause: cause3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError2 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError2 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/ox/_esm/core/internal/abiItem.js
function normalizeSignature(signature) {
  let active2 = true;
  let current2 = "";
  let level = 0;
  let result = "";
  let valid = false;
  for (let i = 0; i < signature.length; i++) {
    const char2 = signature[i];
    if (["(", ")", ","].includes(char2))
      active2 = true;
    if (char2 === "(")
      level++;
    if (char2 === ")")
      level--;
    if (!active2)
      continue;
    if (level === 0) {
      if (char2 === " " && ["event", "function", "error", ""].includes(result))
        result = "";
      else {
        result += char2;
        if (char2 === ")") {
          valid = true;
          break;
        }
      }
      continue;
    }
    if (char2 === " ") {
      if (signature[i - 1] !== "," && current2 !== "," && current2 !== ",(") {
        current2 = "";
        active2 = false;
      }
      continue;
    }
    result += char2;
    current2 += char2;
  }
  if (!valid)
    throw new BaseError2("Unable to normalize signature.");
  return result;
}
function isArgOfType(arg, abiParameter) {
  const argType = typeof arg;
  const abiParameterType = abiParameter.type;
  switch (abiParameterType) {
    case "address":
      return validate12(arg, { strict: false });
    case "bool":
      return argType === "boolean";
    case "function":
      return argType === "string";
    case "string":
      return argType === "string";
    default: {
      if (abiParameterType === "tuple" && "components" in abiParameter)
        return Object.values(abiParameter.components).every((component, index3) => {
          return isArgOfType(Object.values(arg)[index3], component);
        });
      if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
        return argType === "number" || argType === "bigint";
      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
        return argType === "string" || arg instanceof Uint8Array;
      if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
        return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
          ...abiParameter,
          // Pop off `[]` or `[M]` from end of type
          type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
        }));
      }
      return false;
    }
  }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args2) {
  for (const parameterIndex in sourceParameters) {
    const sourceParameter = sourceParameters[parameterIndex];
    const targetParameter = targetParameters[parameterIndex];
    if (sourceParameter.type === "tuple" && targetParameter.type === "tuple" && "components" in sourceParameter && "components" in targetParameter)
      return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args2[parameterIndex]);
    const types3 = [sourceParameter.type, targetParameter.type];
    const ambiguous = (() => {
      if (types3.includes("address") && types3.includes("bytes20"))
        return true;
      if (types3.includes("address") && types3.includes("string"))
        return validate12(args2[parameterIndex], {
          strict: false
        });
      if (types3.includes("address") && types3.includes("bytes"))
        return validate12(args2[parameterIndex], {
          strict: false
        });
      return false;
    })();
    if (ambiguous)
      return types3;
  }
  return;
}

// node_modules/ox/_esm/core/AbiItem.js
function format8(abiItem) {
  return formatAbiItem(abiItem);
}
function from5(abiItem, options = {}) {
  const { prepare = true } = options;
  const item = (() => {
    if (Array.isArray(abiItem))
      return parseAbiItem(abiItem);
    if (typeof abiItem === "string")
      return parseAbiItem(abiItem);
    return abiItem;
  })();
  return {
    ...item,
    ...prepare ? { hash: getSignatureHash(item) } : {}
  };
}
function fromAbi(abi11, name, options) {
  const { args: args2 = [], prepare = true } = options ?? {};
  const isSelector = validate2(name, { strict: false });
  const abiItems = abi11.filter((abiItem2) => {
    if (isSelector) {
      if (abiItem2.type === "function" || abiItem2.type === "error")
        return getSelector(abiItem2) === slice3(name, 0, 4);
      if (abiItem2.type === "event")
        return getSignatureHash(abiItem2) === name;
      return false;
    }
    return "name" in abiItem2 && abiItem2.name === name;
  });
  if (abiItems.length === 0)
    throw new NotFoundError({ name });
  if (abiItems.length === 1)
    return {
      ...abiItems[0],
      ...prepare ? { hash: getSignatureHash(abiItems[0]) } : {}
    };
  let matchedAbiItem = void 0;
  for (const abiItem2 of abiItems) {
    if (!("inputs" in abiItem2))
      continue;
    if (!args2 || args2.length === 0) {
      if (!abiItem2.inputs || abiItem2.inputs.length === 0)
        return {
          ...abiItem2,
          ...prepare ? { hash: getSignatureHash(abiItem2) } : {}
        };
      continue;
    }
    if (!abiItem2.inputs)
      continue;
    if (abiItem2.inputs.length === 0)
      continue;
    if (abiItem2.inputs.length !== args2.length)
      continue;
    const matched = args2.every((arg, index3) => {
      const abiParameter = "inputs" in abiItem2 && abiItem2.inputs[index3];
      if (!abiParameter)
        return false;
      return isArgOfType(arg, abiParameter);
    });
    if (matched) {
      if (matchedAbiItem && "inputs" in matchedAbiItem && matchedAbiItem.inputs) {
        const ambiguousTypes = getAmbiguousTypes(abiItem2.inputs, matchedAbiItem.inputs, args2);
        if (ambiguousTypes)
          throw new AmbiguityError({
            abiItem: abiItem2,
            type: ambiguousTypes[0]
          }, {
            abiItem: matchedAbiItem,
            type: ambiguousTypes[1]
          });
      }
      matchedAbiItem = abiItem2;
    }
  }
  const abiItem = (() => {
    if (matchedAbiItem)
      return matchedAbiItem;
    const [abiItem2, ...overloads] = abiItems;
    return { ...abiItem2, overloads };
  })();
  if (!abiItem)
    throw new NotFoundError({ name });
  return {
    ...abiItem,
    ...prepare ? { hash: getSignatureHash(abiItem) } : {}
  };
}
function getSelector(abiItem) {
  return slice3(getSignatureHash(abiItem), 0, 4);
}
function getSignature(abiItem) {
  const signature = (() => {
    if (typeof abiItem === "string")
      return abiItem;
    return formatAbiItem(abiItem);
  })();
  return normalizeSignature(signature);
}
function getSignatureHash(abiItem) {
  if (typeof abiItem !== "string" && "hash" in abiItem && abiItem.hash)
    return abiItem.hash;
  return keccak2562(fromString2(getSignature(abiItem)));
}
var AmbiguityError = class extends BaseError2 {
  constructor(x, y) {
    super("Found ambiguous types in overloaded ABI Items.", {
      metaMessages: [
        // TODO: abitype to add support for signature-formatted ABI items.
        `\`${x.type}\` in \`${normalizeSignature(formatAbiItem(x.abiItem))}\`, and`,
        `\`${y.type}\` in \`${normalizeSignature(formatAbiItem(y.abiItem))}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.AmbiguityError"
    });
  }
};
var NotFoundError = class extends BaseError2 {
  constructor({ name, data, type: type8 = "item" }) {
    const selector = (() => {
      if (name)
        return ` with name "${name}"`;
      if (data)
        return ` with data "${data}"`;
      return "";
    })();
    super(`ABI ${type8}${selector} not found.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.NotFoundError"
    });
  }
};
var InvalidSelectorSizeError = class extends BaseError2 {
  constructor({ data }) {
    super(`Selector size is invalid. Expected 4 bytes. Received ${size3(data)} bytes ("${data}").`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiItem.InvalidSelectorSizeError"
    });
  }
};

// node_modules/ox/_esm/core/AbiParameters.js
var AbiParameters_exports = {};
__export(AbiParameters_exports, {
  ArrayLengthMismatchError: () => ArrayLengthMismatchError,
  BytesSizeMismatchError: () => BytesSizeMismatchError2,
  DataSizeTooSmallError: () => DataSizeTooSmallError,
  InvalidArrayError: () => InvalidArrayError,
  InvalidTypeError: () => InvalidTypeError,
  LengthMismatchError: () => LengthMismatchError,
  ZeroDataError: () => ZeroDataError,
  decode: () => decode7,
  encode: () => encode8,
  encodePacked: () => encodePacked2,
  format: () => format9,
  from: () => from6
});

// node_modules/ox/_esm/core/Solidity.js
var Solidity_exports = {};
__export(Solidity_exports, {
  arrayRegex: () => arrayRegex2,
  bytesRegex: () => bytesRegex2,
  integerRegex: () => integerRegex2,
  maxInt104: () => maxInt104,
  maxInt112: () => maxInt112,
  maxInt120: () => maxInt120,
  maxInt128: () => maxInt128,
  maxInt136: () => maxInt136,
  maxInt144: () => maxInt144,
  maxInt152: () => maxInt152,
  maxInt16: () => maxInt16,
  maxInt160: () => maxInt160,
  maxInt168: () => maxInt168,
  maxInt176: () => maxInt176,
  maxInt184: () => maxInt184,
  maxInt192: () => maxInt192,
  maxInt200: () => maxInt200,
  maxInt208: () => maxInt208,
  maxInt216: () => maxInt216,
  maxInt224: () => maxInt224,
  maxInt232: () => maxInt232,
  maxInt24: () => maxInt24,
  maxInt240: () => maxInt240,
  maxInt248: () => maxInt248,
  maxInt256: () => maxInt256,
  maxInt32: () => maxInt32,
  maxInt40: () => maxInt40,
  maxInt48: () => maxInt48,
  maxInt56: () => maxInt56,
  maxInt64: () => maxInt64,
  maxInt72: () => maxInt72,
  maxInt8: () => maxInt8,
  maxInt80: () => maxInt80,
  maxInt88: () => maxInt88,
  maxInt96: () => maxInt96,
  maxUint104: () => maxUint104,
  maxUint112: () => maxUint112,
  maxUint120: () => maxUint120,
  maxUint128: () => maxUint128,
  maxUint136: () => maxUint136,
  maxUint144: () => maxUint144,
  maxUint152: () => maxUint152,
  maxUint16: () => maxUint16,
  maxUint160: () => maxUint160,
  maxUint168: () => maxUint168,
  maxUint176: () => maxUint176,
  maxUint184: () => maxUint184,
  maxUint192: () => maxUint192,
  maxUint200: () => maxUint200,
  maxUint208: () => maxUint208,
  maxUint216: () => maxUint216,
  maxUint224: () => maxUint224,
  maxUint232: () => maxUint232,
  maxUint24: () => maxUint24,
  maxUint240: () => maxUint240,
  maxUint248: () => maxUint248,
  maxUint256: () => maxUint2562,
  maxUint32: () => maxUint32,
  maxUint40: () => maxUint40,
  maxUint48: () => maxUint48,
  maxUint56: () => maxUint56,
  maxUint64: () => maxUint64,
  maxUint72: () => maxUint72,
  maxUint8: () => maxUint8,
  maxUint80: () => maxUint80,
  maxUint88: () => maxUint88,
  maxUint96: () => maxUint96,
  minInt104: () => minInt104,
  minInt112: () => minInt112,
  minInt120: () => minInt120,
  minInt128: () => minInt128,
  minInt136: () => minInt136,
  minInt144: () => minInt144,
  minInt152: () => minInt152,
  minInt16: () => minInt16,
  minInt160: () => minInt160,
  minInt168: () => minInt168,
  minInt176: () => minInt176,
  minInt184: () => minInt184,
  minInt192: () => minInt192,
  minInt200: () => minInt200,
  minInt208: () => minInt208,
  minInt216: () => minInt216,
  minInt224: () => minInt224,
  minInt232: () => minInt232,
  minInt24: () => minInt24,
  minInt240: () => minInt240,
  minInt248: () => minInt248,
  minInt256: () => minInt256,
  minInt32: () => minInt32,
  minInt40: () => minInt40,
  minInt48: () => minInt48,
  minInt56: () => minInt56,
  minInt64: () => minInt64,
  minInt72: () => minInt72,
  minInt8: () => minInt8,
  minInt80: () => minInt80,
  minInt88: () => minInt88,
  minInt96: () => minInt96
});
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/ox/_esm/core/internal/abiParameters.js
function decodeParameter(cursor, param, options) {
  const { checksumAddress: checksumAddress2, staticPosition } = options;
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents) {
    const [length6, type8] = arrayComponents;
    return decodeArray(cursor, { ...param, type: type8 }, { checksumAddress: checksumAddress2, length: length6, staticPosition });
  }
  if (param.type === "tuple")
    return decodeTuple(cursor, param, {
      checksumAddress: checksumAddress2,
      staticPosition
    });
  if (param.type === "address")
    return decodeAddress(cursor, { checksum: checksumAddress2 });
  if (param.type === "bool")
    return decodeBool(cursor);
  if (param.type.startsWith("bytes"))
    return decodeBytes(cursor, param, { staticPosition });
  if (param.type.startsWith("uint") || param.type.startsWith("int"))
    return decodeNumber(cursor, param);
  if (param.type === "string")
    return decodeString(cursor, { staticPosition });
  throw new InvalidTypeError(param.type);
}
var sizeOfLength = 32;
var sizeOfOffset = 32;
function decodeAddress(cursor, options = {}) {
  const { checksum: checksum4 = false } = options;
  const value10 = cursor.readBytes(32);
  const wrap = (address) => checksum4 ? checksum2(address) : address;
  return [wrap(fromBytes(slice2(value10, -20))), 32];
}
function decodeArray(cursor, param, options) {
  const { checksumAddress: checksumAddress2, length: length6, staticPosition } = options;
  if (!length6) {
    const offset = toNumber(cursor.readBytes(sizeOfOffset));
    const start5 = staticPosition + offset;
    const startOfData = start5 + sizeOfLength;
    cursor.setPosition(start5);
    const length7 = toNumber(cursor.readBytes(sizeOfLength));
    const dynamicChild = hasDynamicChild(param);
    let consumed2 = 0;
    const value11 = [];
    for (let i = 0; i < length7; ++i) {
      cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));
      const [data, consumed_] = decodeParameter(cursor, param, {
        checksumAddress: checksumAddress2,
        staticPosition: startOfData
      });
      consumed2 += consumed_;
      value11.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value11, 32];
  }
  if (hasDynamicChild(param)) {
    const offset = toNumber(cursor.readBytes(sizeOfOffset));
    const start5 = staticPosition + offset;
    const value11 = [];
    for (let i = 0; i < length6; ++i) {
      cursor.setPosition(start5 + i * 32);
      const [data] = decodeParameter(cursor, param, {
        checksumAddress: checksumAddress2,
        staticPosition: start5
      });
      value11.push(data);
    }
    cursor.setPosition(staticPosition + 32);
    return [value11, 32];
  }
  let consumed = 0;
  const value10 = [];
  for (let i = 0; i < length6; ++i) {
    const [data, consumed_] = decodeParameter(cursor, param, {
      checksumAddress: checksumAddress2,
      staticPosition: staticPosition + consumed
    });
    consumed += consumed_;
    value10.push(data);
  }
  return [value10, consumed];
}
function decodeBool(cursor) {
  return [toBoolean(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
  const [_, size45] = param.type.split("bytes");
  if (!size45) {
    const offset = toNumber(cursor.readBytes(32));
    cursor.setPosition(staticPosition + offset);
    const length6 = toNumber(cursor.readBytes(32));
    if (length6 === 0) {
      cursor.setPosition(staticPosition + 32);
      return ["0x", 32];
    }
    const data = cursor.readBytes(length6);
    cursor.setPosition(staticPosition + 32);
    return [fromBytes(data), 32];
  }
  const value10 = fromBytes(cursor.readBytes(Number.parseInt(size45), 32));
  return [value10, 32];
}
function decodeNumber(cursor, param) {
  const signed2 = param.type.startsWith("int");
  const size45 = Number.parseInt(param.type.split("int")[1] || "256");
  const value10 = cursor.readBytes(32);
  return [
    size45 > 48 ? toBigInt(value10, { signed: signed2 }) : toNumber(value10, { signed: signed2 }),
    32
  ];
}
function decodeTuple(cursor, param, options) {
  const { checksumAddress: checksumAddress2, staticPosition } = options;
  const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
  const value10 = hasUnnamedChild ? [] : {};
  let consumed = 0;
  if (hasDynamicChild(param)) {
    const offset = toNumber(cursor.readBytes(sizeOfOffset));
    const start5 = staticPosition + offset;
    for (let i = 0; i < param.components.length; ++i) {
      const component = param.components[i];
      cursor.setPosition(start5 + consumed);
      const [data, consumed_] = decodeParameter(cursor, component, {
        checksumAddress: checksumAddress2,
        staticPosition: start5
      });
      consumed += consumed_;
      value10[hasUnnamedChild ? i : component == null ? void 0 : component.name] = data;
    }
    cursor.setPosition(staticPosition + 32);
    return [value10, 32];
  }
  for (let i = 0; i < param.components.length; ++i) {
    const component = param.components[i];
    const [data, consumed_] = decodeParameter(cursor, component, {
      checksumAddress: checksumAddress2,
      staticPosition
    });
    value10[hasUnnamedChild ? i : component == null ? void 0 : component.name] = data;
    consumed += consumed_;
  }
  return [value10, consumed];
}
function decodeString(cursor, { staticPosition }) {
  const offset = toNumber(cursor.readBytes(32));
  const start5 = staticPosition + offset;
  cursor.setPosition(start5);
  const length6 = toNumber(cursor.readBytes(32));
  if (length6 === 0) {
    cursor.setPosition(staticPosition + 32);
    return ["", 32];
  }
  const data = cursor.readBytes(length6, 32);
  const value10 = toString(trimLeft(data));
  cursor.setPosition(staticPosition + 32);
  return [value10, 32];
}
function prepareParameters({ checksumAddress: checksumAddress2, parameters, values: values15 }) {
  const preparedParameters = [];
  for (let i = 0; i < parameters.length; i++) {
    preparedParameters.push(prepareParameter({
      checksumAddress: checksumAddress2,
      parameter: parameters[i],
      value: values15[i]
    }));
  }
  return preparedParameters;
}
function prepareParameter({ checksumAddress: checksumAddress2 = false, parameter: parameter_, value: value10 }) {
  const parameter = parameter_;
  const arrayComponents = getArrayComponents(parameter.type);
  if (arrayComponents) {
    const [length6, type8] = arrayComponents;
    return encodeArray(value10, {
      checksumAddress: checksumAddress2,
      length: length6,
      parameter: {
        ...parameter,
        type: type8
      }
    });
  }
  if (parameter.type === "tuple") {
    return encodeTuple(value10, {
      checksumAddress: checksumAddress2,
      parameter
    });
  }
  if (parameter.type === "address") {
    return encodeAddress(value10, {
      checksum: checksumAddress2
    });
  }
  if (parameter.type === "bool") {
    return encodeBoolean(value10);
  }
  if (parameter.type.startsWith("uint") || parameter.type.startsWith("int")) {
    const signed2 = parameter.type.startsWith("int");
    const [, , size45 = "256"] = integerRegex2.exec(parameter.type) ?? [];
    return encodeNumber(value10, {
      signed: signed2,
      size: Number(size45)
    });
  }
  if (parameter.type.startsWith("bytes")) {
    return encodeBytes(value10, { type: parameter.type });
  }
  if (parameter.type === "string") {
    return encodeString(value10);
  }
  throw new InvalidTypeError(parameter.type);
}
function encode7(preparedParameters) {
  let staticSize = 0;
  for (let i = 0; i < preparedParameters.length; i++) {
    const { dynamic, encoded } = preparedParameters[i];
    if (dynamic)
      staticSize += 32;
    else
      staticSize += size3(encoded);
  }
  const staticParameters = [];
  const dynamicParameters = [];
  let dynamicSize = 0;
  for (let i = 0; i < preparedParameters.length; i++) {
    const { dynamic, encoded } = preparedParameters[i];
    if (dynamic) {
      staticParameters.push(fromNumber2(staticSize + dynamicSize, { size: 32 }));
      dynamicParameters.push(encoded);
      dynamicSize += size3(encoded);
    } else {
      staticParameters.push(encoded);
    }
  }
  return concat3(...staticParameters, ...dynamicParameters);
}
function encodeAddress(value10, options) {
  const { checksum: checksum4 = false } = options;
  assert5(value10, { strict: checksum4 });
  return {
    dynamic: false,
    encoded: padLeft2(value10.toLowerCase())
  };
}
function encodeArray(value10, options) {
  const { checksumAddress: checksumAddress2, length: length6, parameter } = options;
  const dynamic = length6 === null;
  if (!Array.isArray(value10))
    throw new InvalidArrayError(value10);
  if (!dynamic && value10.length !== length6)
    throw new ArrayLengthMismatchError({
      expectedLength: length6,
      givenLength: value10.length,
      type: `${parameter.type}[${length6}]`
    });
  let dynamicChild = false;
  const preparedParameters = [];
  for (let i = 0; i < value10.length; i++) {
    const preparedParam = prepareParameter({
      checksumAddress: checksumAddress2,
      parameter,
      value: value10[i]
    });
    if (preparedParam.dynamic)
      dynamicChild = true;
    preparedParameters.push(preparedParam);
  }
  if (dynamic || dynamicChild) {
    const data = encode7(preparedParameters);
    if (dynamic) {
      const length7 = fromNumber2(preparedParameters.length, { size: 32 });
      return {
        dynamic: true,
        encoded: preparedParameters.length > 0 ? concat3(length7, data) : length7
      };
    }
    if (dynamicChild)
      return { dynamic: true, encoded: data };
  }
  return {
    dynamic: false,
    encoded: concat3(...preparedParameters.map(({ encoded }) => encoded))
  };
}
function encodeBytes(value10, { type: type8 }) {
  const [, parametersize] = type8.split("bytes");
  const bytesSize = size3(value10);
  if (!parametersize) {
    let value_ = value10;
    if (bytesSize % 32 !== 0)
      value_ = padRight(value_, Math.ceil((value10.length - 2) / 2 / 32) * 32);
    return {
      dynamic: true,
      encoded: concat3(padLeft2(fromNumber2(bytesSize, { size: 32 })), value_)
    };
  }
  if (bytesSize !== Number.parseInt(parametersize))
    throw new BytesSizeMismatchError2({
      expectedSize: Number.parseInt(parametersize),
      value: value10
    });
  return { dynamic: false, encoded: padRight(value10) };
}
function encodeBoolean(value10) {
  if (typeof value10 !== "boolean")
    throw new BaseError2(`Invalid boolean value: "${value10}" (type: ${typeof value10}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: padLeft2(fromBoolean(value10)) };
}
function encodeNumber(value10, { signed: signed2, size: size45 }) {
  if (typeof size45 === "number") {
    const max14 = 2n ** (BigInt(size45) - (signed2 ? 1n : 0n)) - 1n;
    const min11 = signed2 ? -max14 - 1n : 0n;
    if (value10 > max14 || value10 < min11)
      throw new IntegerOutOfRangeError({
        max: max14.toString(),
        min: min11.toString(),
        signed: signed2,
        size: size45 / 8,
        value: value10.toString()
      });
  }
  return {
    dynamic: false,
    encoded: fromNumber2(value10, {
      size: 32,
      signed: signed2
    })
  };
}
function encodeString(value10) {
  const hexValue = fromString2(value10);
  const partsLength = Math.ceil(size3(hexValue) / 32);
  const parts2 = [];
  for (let i = 0; i < partsLength; i++) {
    parts2.push(padRight(slice3(hexValue, i * 32, (i + 1) * 32)));
  }
  return {
    dynamic: true,
    encoded: concat3(padRight(fromNumber2(size3(hexValue), { size: 32 })), ...parts2)
  };
}
function encodeTuple(value10, options) {
  const { checksumAddress: checksumAddress2, parameter } = options;
  let dynamic = false;
  const preparedParameters = [];
  for (let i = 0; i < parameter.components.length; i++) {
    const param_ = parameter.components[i];
    const index3 = Array.isArray(value10) ? i : param_.name;
    const preparedParam = prepareParameter({
      checksumAddress: checksumAddress2,
      parameter: param_,
      value: value10[index3]
    });
    preparedParameters.push(preparedParam);
    if (preparedParam.dynamic)
      dynamic = true;
  }
  return {
    dynamic,
    encoded: dynamic ? encode7(preparedParameters) : concat3(...preparedParameters.map(({ encoded }) => encoded))
  };
}
function getArrayComponents(type8) {
  const matches = type8.match(/^(.*)\[(\d+)?\]$/);
  return matches ? (
    // Return `null` if the array is dynamic.
    [matches[2] ? Number(matches[2]) : null, matches[1]]
  ) : void 0;
}
function hasDynamicChild(param) {
  var _a106;
  const { type: type8 } = param;
  if (type8 === "string")
    return true;
  if (type8 === "bytes")
    return true;
  if (type8.endsWith("[]"))
    return true;
  if (type8 === "tuple")
    return (_a106 = param.components) == null ? void 0 : _a106.some(hasDynamicChild);
  const arrayComponents = getArrayComponents(param.type);
  if (arrayComponents && hasDynamicChild({
    ...param,
    type: arrayComponents[1]
  }))
    return true;
  return false;
}

// node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length6, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length6 - 1);
    return this.bytes.subarray(position, position + length6);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value10) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value10;
    this.position++;
  },
  pushUint16(value10) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value10);
    this.position += 2;
  },
  pushUint24(value10) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value10 >> 8);
    this.dataView.setUint8(this.position + 2, value10 & ~4294967040);
    this.position += 3;
  },
  pushUint32(value10) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value10);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value10 = this.inspectByte();
    this.position++;
    return value10;
  },
  readBytes(length6, size45) {
    this.assertReadLimit();
    this._touch();
    const value10 = this.inspectBytes(length6);
    this.position += size45 ?? length6;
    return value10;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value10 = this.inspectUint8();
    this.position += 1;
    return value10;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value10 = this.inspectUint16();
    this.position += 2;
    return value10;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value10 = this.inspectUint24();
    this.position += 3;
    return value10;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value10 = this.inspectUint32();
    this.position += 4;
    return value10;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count9 = this.getReadCount();
    this.positionReadCount.set(this.position, count9 + 1);
    if (count9 > 0)
      this.recursiveReadCount++;
  }
};
function create(bytes, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = /* @__PURE__ */ new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
var NegativeOffsetError = class extends BaseError2 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError2 {
  constructor({ length: length6, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length6}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError2 {
  constructor({ count: count9, limit: limit2 }) {
    super(`Recursive read limit of \`${limit2}\` exceeded (recursive read count: \`${count9}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/ox/_esm/core/AbiParameters.js
function decode7(parameters, data, options = {}) {
  const { as: as18 = "Array", checksumAddress: checksumAddress2 = false } = options;
  const bytes = typeof data === "string" ? fromHex(data) : data;
  const cursor = create(bytes);
  if (size2(bytes) === 0 && parameters.length > 0)
    throw new ZeroDataError();
  if (size2(bytes) && size2(bytes) < 32)
    throw new DataSizeTooSmallError({
      data: typeof data === "string" ? data : fromBytes(data),
      parameters,
      size: size2(bytes)
    });
  let consumed = 0;
  const values15 = as18 === "Array" ? [] : {};
  for (let i = 0; i < parameters.length; ++i) {
    const param = parameters[i];
    cursor.setPosition(consumed);
    const [data2, consumed_] = decodeParameter(cursor, param, {
      checksumAddress: checksumAddress2,
      staticPosition: 0
    });
    consumed += consumed_;
    if (as18 === "Array")
      values15.push(data2);
    else
      values15[param.name ?? i] = data2;
  }
  return values15;
}
function encode8(parameters, values15, options) {
  const { checksumAddress: checksumAddress2 = false } = options ?? {};
  if (parameters.length !== values15.length)
    throw new LengthMismatchError({
      expectedLength: parameters.length,
      givenLength: values15.length
    });
  const preparedParameters = prepareParameters({
    checksumAddress: checksumAddress2,
    parameters,
    values: values15
  });
  const data = encode7(preparedParameters);
  if (data.length === 0)
    return "0x";
  return data;
}
function encodePacked2(types3, values15) {
  if (types3.length !== values15.length)
    throw new LengthMismatchError({
      expectedLength: types3.length,
      givenLength: values15.length
    });
  const data = [];
  for (let i = 0; i < types3.length; i++) {
    const type8 = types3[i];
    const value10 = values15[i];
    data.push(encodePacked2.encode(type8, value10));
  }
  return concat3(...data);
}
(function(encodePacked3) {
  function encode16(type8, value10, isArray2 = false) {
    if (type8 === "address") {
      const address = value10;
      assert5(address);
      return padLeft2(address.toLowerCase(), isArray2 ? 32 : 0);
    }
    if (type8 === "string")
      return fromString2(value10);
    if (type8 === "bytes")
      return value10;
    if (type8 === "bool")
      return padLeft2(fromBoolean(value10), isArray2 ? 32 : 1);
    const intMatch = type8.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits2 = "256"] = intMatch;
      const size45 = Number.parseInt(bits2) / 8;
      return fromNumber2(value10, {
        size: isArray2 ? 32 : size45,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type8.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size45] = bytesMatch;
      if (Number.parseInt(size45) !== (value10.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size45),
          value: value10
        });
      return padRight(value10, isArray2 ? 32 : 0);
    }
    const arrayMatch = type8.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value10)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i = 0; i < value10.length; i++) {
        data.push(encode16(childType, value10[i], true));
      }
      if (data.length === 0)
        return "0x";
      return concat3(...data);
    }
    throw new InvalidTypeError(type8);
  }
  encodePacked3.encode = encode16;
})(encodePacked2 || (encodePacked2 = {}));
function format9(parameters) {
  return formatAbiParameters(parameters);
}
function from6(parameters) {
  if (Array.isArray(parameters) && typeof parameters[0] === "string")
    return parseAbiParameters(parameters);
  if (typeof parameters === "string")
    return parseAbiParameters(parameters);
  return parameters;
}
var DataSizeTooSmallError = class extends BaseError2 {
  constructor({ data, parameters, size: size45 }) {
    super(`Data size of ${size45} bytes is too small for given parameters.`, {
      metaMessages: [
        `Params: (${formatAbiParameters(parameters)})`,
        `Data:   ${data} (${size45} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.DataSizeTooSmallError"
    });
  }
};
var ZeroDataError = class extends BaseError2 {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.');
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.ZeroDataError"
    });
  }
};
var ArrayLengthMismatchError = class extends BaseError2 {
  constructor({ expectedLength, givenLength, type: type8 }) {
    super(`Array length mismatch for type \`${type8}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.ArrayLengthMismatchError"
    });
  }
};
var BytesSizeMismatchError2 = class extends BaseError2 {
  constructor({ expectedSize, value: value10 }) {
    super(`Size of bytes "${value10}" (bytes${size3(value10)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidArrayError = class extends BaseError2 {
  constructor(value10) {
    super(`Value \`${value10}\` is not a valid array.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidArrayError"
    });
  }
};
var InvalidTypeError = class extends BaseError2 {
  constructor(type8) {
    super(`Type \`${type8}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/ox/_esm/core/AbiConstructor.js
function decode8(abiConstructor, options) {
  const { bytecode } = options;
  if (abiConstructor.inputs.length === 0)
    return void 0;
  const data = options.data.replace(bytecode, "0x");
  return decode7(abiConstructor.inputs, data);
}
function encode9(abiConstructor, options) {
  var _a106;
  const { bytecode, args: args2 } = options;
  return concat3(bytecode, ((_a106 = abiConstructor.inputs) == null ? void 0 : _a106.length) && (args2 == null ? void 0 : args2.length) ? encode8(abiConstructor.inputs, args2) : "0x");
}
function format10(abiConstructor) {
  return formatAbiItem(abiConstructor);
}
function from7(abiConstructor) {
  return from5(abiConstructor);
}
function fromAbi2(abi11) {
  const item = abi11.find((item2) => item2.type === "constructor");
  if (!item)
    throw new NotFoundError({ name: "constructor" });
  return item;
}

// node_modules/ox/_esm/core/AbiFunction.js
var AbiFunction_exports = {};
__export(AbiFunction_exports, {
  decodeData: () => decodeData2,
  decodeResult: () => decodeResult,
  encodeData: () => encodeData2,
  encodeResult: () => encodeResult,
  format: () => format11,
  from: () => from8,
  fromAbi: () => fromAbi3,
  getSelector: () => getSelector2
});
function decodeData2(abiFunction, data) {
  const { overloads } = abiFunction;
  if (size3(data) < 4)
    throw new InvalidSelectorSizeError({ data });
  if (abiFunction.inputs.length === 0)
    return void 0;
  const item = overloads ? fromAbi3([abiFunction, ...overloads], data) : abiFunction;
  if (size3(data) <= 4)
    return void 0;
  return decode7(item.inputs, slice3(data, 4));
}
function decodeResult(abiFunction, data, options = {}) {
  const values15 = decode7(abiFunction.outputs, data, options);
  if (values15 && Object.keys(values15).length === 0)
    return void 0;
  if (values15 && Object.keys(values15).length === 1) {
    if (Array.isArray(values15))
      return values15[0];
    return Object.values(values15)[0];
  }
  return values15;
}
function encodeData2(abiFunction, ...args2) {
  const { overloads } = abiFunction;
  const item = overloads ? fromAbi3([abiFunction, ...overloads], abiFunction.name, {
    args: args2[0]
  }) : abiFunction;
  const selector = getSelector2(item);
  const data = args2.length > 0 ? encode8(item.inputs, args2[0]) : void 0;
  return data ? concat3(selector, data) : selector;
}
function encodeResult(abiFunction, output, options = {}) {
  const { as: as18 = "Array" } = options;
  const values15 = (() => {
    if (abiFunction.outputs.length === 1)
      return [output];
    if (Array.isArray(output))
      return output;
    if (as18 === "Object")
      return Object.values(output);
    return [output];
  })();
  return encode8(abiFunction.outputs, values15);
}
function format11(abiFunction) {
  return formatAbiItem(abiFunction);
}
function from8(abiFunction, options = {}) {
  return from5(abiFunction, options);
}
function fromAbi3(abi11, name, options) {
  const item = fromAbi(abi11, name, options);
  if (item.type !== "function")
    throw new NotFoundError({ name, type: "function" });
  return item;
}
function getSelector2(abiItem) {
  return getSelector(abiItem);
}

// node_modules/viem/_esm/constants/address.js
var ethAddress = "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee";
var zeroAddress = "0x0000000000000000000000000000000000000000";

// node_modules/viem/_esm/actions/public/simulateCalls.js
var getBalanceCode = "0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033";
async function simulateCalls(client, parameters) {
  const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation } = parameters;
  const account = parameters.account ? parseAccount(parameters.account) : void 0;
  if (traceAssetChanges && !account)
    throw new BaseError("`account` is required when `traceAssetChanges` is true");
  const getBalanceData = account ? encode9(from7("constructor(bytes, bytes)"), {
    bytecode: deploylessCallViaBytecodeBytecode,
    args: [
      getBalanceCode,
      encodeData2(from8("function getBalance(address)"), [account.address])
    ]
  }) : void 0;
  const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async (call2) => {
    if (!call2.data && !call2.abi)
      return;
    const { accessList } = await createAccessList(client, {
      account: account.address,
      ...call2,
      data: call2.abi ? encodeFunctionData(call2) : call2.data
    });
    return accessList.map(({ address, storageKeys }) => storageKeys.length > 0 ? address : null);
  })).then((x) => x.flat().filter(Boolean)) : [];
  const blocks = await simulateBlocks(client, {
    blockNumber,
    blockTag,
    blocks: [
      ...traceAssetChanges ? [
        // ETH pre balances
        {
          calls: [{ data: getBalanceData }],
          stateOverrides
        },
        // Asset pre balances
        {
          calls: assetAddresses.map((address, i) => ({
            abi: [
              from8("function balanceOf(address) returns (uint256)")
            ],
            functionName: "balanceOf",
            args: [account.address],
            to: address,
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        }
      ] : [],
      {
        calls: [...calls, {}].map((call2) => ({
          ...call2,
          from: account == null ? void 0 : account.address
        })),
        stateOverrides
      },
      ...traceAssetChanges ? [
        // ETH post balances
        {
          calls: [{ data: getBalanceData }]
        },
        // Asset post balances
        {
          calls: assetAddresses.map((address, i) => ({
            abi: [
              from8("function balanceOf(address) returns (uint256)")
            ],
            functionName: "balanceOf",
            args: [account.address],
            to: address,
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        // Decimals
        {
          calls: assetAddresses.map((address, i) => ({
            to: address,
            abi: [
              from8("function decimals() returns (uint256)")
            ],
            functionName: "decimals",
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        // Token URI
        {
          calls: assetAddresses.map((address, i) => ({
            to: address,
            abi: [
              from8("function tokenURI(uint256) returns (string)")
            ],
            functionName: "tokenURI",
            args: [0n],
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        },
        // Symbols
        {
          calls: assetAddresses.map((address, i) => ({
            to: address,
            abi: [from8("function symbol() returns (string)")],
            functionName: "symbol",
            from: zeroAddress,
            nonce: i
          })),
          stateOverrides: [
            {
              address: zeroAddress,
              nonce: 0
            }
          ]
        }
      ] : []
    ],
    traceTransfers,
    validation
  });
  const block_results = traceAssetChanges ? blocks[2] : blocks[0];
  const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];
  const { calls: block_calls, ...block } = block_results;
  const results = block_calls.slice(0, -1) ?? [];
  const ethPre = (block_ethPre == null ? void 0 : block_ethPre.calls) ?? [];
  const assetsPre = (block_assetsPre == null ? void 0 : block_assetsPre.calls) ?? [];
  const balancesPre = [...ethPre, ...assetsPre].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
  const ethPost = (block_ethPost == null ? void 0 : block_ethPost.calls) ?? [];
  const assetsPost = (block_assetsPost == null ? void 0 : block_assetsPost.calls) ?? [];
  const balancesPost = [...ethPost, ...assetsPost].map((call2) => call2.status === "success" ? hexToBigInt(call2.data) : null);
  const decimals = ((block_decimals == null ? void 0 : block_decimals.calls) ?? []).map((x) => x.status === "success" ? x.result : null);
  const symbols = ((block_symbols == null ? void 0 : block_symbols.calls) ?? []).map((x) => x.status === "success" ? x.result : null);
  const tokenURI = ((block_tokenURI == null ? void 0 : block_tokenURI.calls) ?? []).map((x) => x.status === "success" ? x.result : null);
  const changes4 = [];
  for (const [i, balancePost] of balancesPost.entries()) {
    const balancePre = balancesPre[i];
    if (typeof balancePost !== "bigint")
      continue;
    if (typeof balancePre !== "bigint")
      continue;
    const decimals_ = decimals[i - 1];
    const symbol_ = symbols[i - 1];
    const tokenURI_ = tokenURI[i - 1];
    const token = (() => {
      if (i === 0)
        return {
          address: ethAddress,
          decimals: 18,
          symbol: "ETH"
        };
      return {
        address: assetAddresses[i - 1],
        decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : void 0,
        symbol: symbol_ ?? void 0
      };
    })();
    if (changes4.some((change) => change.token.address === token.address))
      continue;
    changes4.push({
      token,
      value: {
        pre: balancePre,
        post: balancePost,
        diff: balancePost - balancePre
      }
    });
  }
  return {
    assetChanges: changes4,
    block,
    results
  };
}

// node_modules/viem/_esm/utils/signature/serializeSignature.js
function serializeSignature({ r, s, to: to3 = "hex", v, yParity }) {
  const yParity_ = (() => {
    if (yParity === 0 || yParity === 1)
      return yParity;
    if (v && (v === 27n || v === 28n || v >= 35n))
      return v % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })();
  const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? "1b" : "1c"}`;
  if (to3 === "hex")
    return signature;
  return hexToBytes(signature);
}

// node_modules/viem/_esm/actions/public/verifyHash.js
async function verifyHash2(client, parameters) {
  var _a106, _b32, _c7;
  const { address, factory, factoryData, hash: hash11, signature, universalSignatureVerifierAddress = (_c7 = (_b32 = (_a106 = client.chain) == null ? void 0 : _a106.contracts) == null ? void 0 : _b32.universalSignatureVerifier) == null ? void 0 : _c7.address, ...rest } = parameters;
  const signatureHex = (() => {
    if (isHex(signature))
      return signature;
    if (typeof signature === "object" && "r" in signature && "s" in signature)
      return serializeSignature(signature);
    return bytesToHex(signature);
  })();
  const wrappedSignature = await (async () => {
    if (!factory && !factoryData)
      return signatureHex;
    if (isErc6492Signature(signatureHex))
      return signatureHex;
    return serializeErc6492Signature({
      address: factory,
      data: factoryData,
      signature: signatureHex
    });
  })();
  try {
    const args2 = universalSignatureVerifierAddress ? {
      to: universalSignatureVerifierAddress,
      data: encodeFunctionData({
        abi: universalSignatureValidatorAbi,
        functionName: "isValidSig",
        args: [address, hash11, wrappedSignature]
      }),
      ...rest
    } : {
      data: encodeDeployData({
        abi: universalSignatureValidatorAbi,
        args: [address, hash11, wrappedSignature],
        bytecode: universalSignatureValidatorByteCode
      }),
      ...rest
    };
    const { data } = await getAction(client, call, "call")(args2);
    return hexToBool(data ?? "0x0");
  } catch (error4) {
    try {
      const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash: hash11, signature }));
      if (verified)
        return true;
    } catch {
    }
    if (error4 instanceof CallExecutionError) {
      return false;
    }
    throw error4;
  }
}

// node_modules/viem/_esm/actions/public/verifyMessage.js
async function verifyMessage2(client, { address, message, factory, factoryData, signature, ...callRequest }) {
  const hash11 = hashMessage(message);
  return verifyHash2(client, {
    address,
    factory,
    factoryData,
    hash: hash11,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/actions/public/verifyTypedData.js
async function verifyTypedData2(client, parameters) {
  const { address, factory, factoryData, signature, message, primaryType, types: types3, domain: domain2, ...callRequest } = parameters;
  const hash11 = hashTypedData({ message, primaryType, types: types3, domain: domain2 });
  return verifyHash2(client, {
    address,
    factory,
    factoryData,
    hash: hash11,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/actions/public/watchBlockNumber.js
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError: onError6, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client.transport.type === "webSocket" || client.transport.type === "ipc")
      return false;
    if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
      return false;
    return true;
  })();
  let prevBlockNumber;
  const pollBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed,
      pollingInterval
    ]);
    return observe(observerId, { onBlockNumber, onError: onError6 }, (emit2) => poll13(async () => {
      var _a106;
      try {
        const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({ cacheTime: 0 });
        if (prevBlockNumber) {
          if (blockNumber === prevBlockNumber)
            return;
          if (blockNumber - prevBlockNumber > 1 && emitMissed) {
            for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
              emit2.onBlockNumber(i, prevBlockNumber);
              prevBlockNumber = i;
            }
          }
        }
        if (!prevBlockNumber || blockNumber > prevBlockNumber) {
          emit2.onBlockNumber(blockNumber, prevBlockNumber);
          prevBlockNumber = blockNumber;
        }
      } catch (err2) {
        (_a106 = emit2.onError) == null ? void 0 : _a106.call(emit2, err2);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlockNumber = () => {
    const observerId = stringify([
      "watchBlockNumber",
      client.uid,
      emitOnBegin,
      emitMissed
    ]);
    return observe(observerId, { onBlockNumber, onError: onError6 }, (emit2) => {
      let active2 = true;
      let unsubscribe = () => active2 = false;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["newHeads"],
            onData(data) {
              var _a106;
              if (!active2)
                return;
              const blockNumber = hexToBigInt((_a106 = data.result) == null ? void 0 : _a106.number);
              emit2.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error4) {
              var _a106;
              (_a106 = emit2.onError) == null ? void 0 : _a106.call(emit2, error4);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active2)
            unsubscribe();
        } catch (err2) {
          onError6 == null ? void 0 : onError6(err2);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

// node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
async function waitForTransactionReceipt(client, {
  confirmations = 1,
  hash: hash11,
  onReplaced,
  pollingInterval = client.pollingInterval,
  retryCount = 6,
  retryDelay = ({ count: count9 }) => ~~(1 << count9) * 200,
  // exponential backoff
  timeout: timeout6 = 18e4
}) {
  const observerId = stringify(["waitForTransactionReceipt", client.uid, hash11]);
  let transaction;
  let replacedTransaction;
  let receipt;
  let retrying = false;
  let _unobserve;
  let _unwatch;
  const { promise: promise4, resolve, reject: reject3 } = withResolvers();
  const timer4 = timeout6 ? setTimeout(() => {
    _unwatch();
    _unobserve();
    reject3(new WaitForTransactionReceiptTimeoutError({ hash: hash11 }));
  }, timeout6) : void 0;
  _unobserve = observe(observerId, { onReplaced, resolve, reject: reject3 }, (emit2) => {
    _unwatch = getAction(client, watchBlockNumber, "watchBlockNumber")({
      emitMissed: true,
      emitOnBegin: true,
      poll: true,
      pollingInterval,
      async onBlockNumber(blockNumber_) {
        const done17 = (fn2) => {
          clearTimeout(timer4);
          _unwatch();
          fn2();
          _unobserve();
        };
        let blockNumber = blockNumber_;
        if (retrying)
          return;
        try {
          if (receipt) {
            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
              return;
            done17(() => emit2.resolve(receipt));
            return;
          }
          if (!transaction) {
            retrying = true;
            await withRetry(async () => {
              transaction = await getAction(client, getTransaction, "getTransaction")({ hash: hash11 });
              if (transaction.blockNumber)
                blockNumber = transaction.blockNumber;
            }, {
              delay: retryDelay,
              retryCount
            });
            retrying = false;
          }
          receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({ hash: hash11 });
          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
            return;
          done17(() => emit2.resolve(receipt));
        } catch (err2) {
          if (err2 instanceof TransactionNotFoundError || err2 instanceof TransactionReceiptNotFoundError) {
            if (!transaction) {
              retrying = false;
              return;
            }
            try {
              replacedTransaction = transaction;
              retrying = true;
              const block = await withRetry(() => getAction(client, getBlock, "getBlock")({
                blockNumber,
                includeTransactions: true
              }), {
                delay: retryDelay,
                retryCount,
                shouldRetry: ({ error: error4 }) => error4 instanceof BlockNotFoundError
              });
              retrying = false;
              const replacementTransaction = block.transactions.find(({ from: from29, nonce }) => from29 === replacedTransaction.from && nonce === replacedTransaction.nonce);
              if (!replacementTransaction)
                return;
              receipt = await getAction(client, getTransactionReceipt, "getTransactionReceipt")({
                hash: replacementTransaction.hash
              });
              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                return;
              let reason = "replaced";
              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {
                reason = "repriced";
              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                reason = "cancelled";
              }
              done17(() => {
                var _a106;
                (_a106 = emit2.onReplaced) == null ? void 0 : _a106.call(emit2, {
                  reason,
                  replacedTransaction,
                  transaction: replacementTransaction,
                  transactionReceipt: receipt
                });
                emit2.resolve(receipt);
              });
            } catch (err_) {
              done17(() => emit2.reject(err_));
            }
          } else {
            done17(() => emit2.reject(err2));
          }
        }
      }
    });
  });
  return promise4;
}

// node_modules/viem/_esm/actions/public/watchBlocks.js
function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError: onError6, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (client.transport.type === "webSocket" || client.transport.type === "ipc")
      return false;
    if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
      return false;
    return true;
  })();
  const includeTransactions = includeTransactions_ ?? false;
  let prevBlock;
  const pollBlocks = () => {
    const observerId = stringify([
      "watchBlocks",
      client.uid,
      blockTag,
      emitMissed,
      emitOnBegin,
      includeTransactions,
      pollingInterval
    ]);
    return observe(observerId, { onBlock, onError: onError6 }, (emit2) => poll13(async () => {
      var _a106;
      try {
        const block = await getAction(client, getBlock, "getBlock")({
          blockTag,
          includeTransactions
        });
        if (block.number !== null && (prevBlock == null ? void 0 : prevBlock.number) != null) {
          if (block.number === prevBlock.number)
            return;
          if (block.number - prevBlock.number > 1 && emitMissed) {
            for (let i = (prevBlock == null ? void 0 : prevBlock.number) + 1n; i < block.number; i++) {
              const block2 = await getAction(client, getBlock, "getBlock")({
                blockNumber: i,
                includeTransactions
              });
              emit2.onBlock(block2, prevBlock);
              prevBlock = block2;
            }
          }
        }
        if (
          // If no previous block exists, emit.
          (prevBlock == null ? void 0 : prevBlock.number) == null || // If the block tag is "pending" with no block number, emit.
          blockTag === "pending" && (block == null ? void 0 : block.number) == null || // If the next block number is greater than the previous block number, emit.
          // We don't want to emit blocks in the past.
          block.number !== null && block.number > prevBlock.number
        ) {
          emit2.onBlock(block, prevBlock);
          prevBlock = block;
        }
      } catch (err2) {
        (_a106 = emit2.onError) == null ? void 0 : _a106.call(emit2, err2);
      }
    }, {
      emitOnBegin,
      interval: pollingInterval
    }));
  };
  const subscribeBlocks = () => {
    let active2 = true;
    let emitFetched = true;
    let unsubscribe = () => active2 = false;
    (async () => {
      try {
        if (emitOnBegin) {
          getAction(client, getBlock, "getBlock")({
            blockTag,
            includeTransactions
          }).then((block) => {
            if (!active2)
              return;
            if (!emitFetched)
              return;
            onBlock(block, void 0);
            emitFetched = false;
          }).catch(onError6);
        }
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["newHeads"],
          async onData(data) {
            var _a106;
            if (!active2)
              return;
            const block = await getAction(client, getBlock, "getBlock")({
              blockNumber: (_a106 = data.result) == null ? void 0 : _a106.number,
              includeTransactions
            }).catch(() => {
            });
            if (!active2)
              return;
            onBlock(block, prevBlock);
            emitFetched = false;
            prevBlock = block;
          },
          onError(error4) {
            onError6 == null ? void 0 : onError6(error4);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active2)
          unsubscribe();
      } catch (err2) {
        onError6 == null ? void 0 : onError6(err2);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollBlocks() : subscribeBlocks();
}

// node_modules/viem/_esm/actions/public/watchEvent.js
function watchEvent(client, { address, args: args2, batch = true, event, events, fromBlock, onError: onError6, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket" || client.transport.type === "ipc")
      return false;
    if (client.transport.type === "fallback" && (client.transport.transports[0].config.type === "webSocket" || client.transport.transports[0].config.type === "ipc"))
      return false;
    return true;
  })();
  const strict2 = strict_ ?? false;
  const pollEvent = () => {
    const observerId = stringify([
      "watchEvent",
      address,
      args2,
      batch,
      client.uid,
      event,
      pollingInterval,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError: onError6 }, (emit2) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter26;
      let initialized = false;
      const unwatch = poll13(async () => {
        var _a106;
        if (!initialized) {
          try {
            filter26 = await getAction(client, createEventFilter, "createEventFilter")({
              address,
              args: args2,
              event,
              events,
              strict: strict2,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter26) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter: filter26 });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getAction(client, getLogs, "getLogs")({
                address,
                args: args2,
                event,
                events,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit2.onLogs(logs);
          else
            for (const log5 of logs)
              emit2.onLogs([log5]);
        } catch (err2) {
          if (filter26 && err2 instanceof InvalidInputRpcError)
            initialized = false;
          (_a106 = emit2.onError) == null ? void 0 : _a106.call(emit2, err2);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter26)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter: filter26 });
        unwatch();
      };
    });
  };
  const subscribeEvent = () => {
    let active2 = true;
    let unsubscribe = () => active2 = false;
    (async () => {
      try {
        const transport = (() => {
          if (client.transport.type === "fallback") {
            const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket" || transport3.config.type === "ipc");
            if (!transport2)
              return client.transport;
            return transport2.value;
          }
          return client.transport;
        })();
        const events_ = events ?? (event ? [event] : void 0);
        let topics = [];
        if (events_) {
          const encoded = events_.flatMap((event2) => encodeEventTopics({
            abi: [event2],
            eventName: event2.name,
            args: args2
          }));
          topics = [encoded];
          if (event)
            topics = topics[0];
        }
        const { unsubscribe: unsubscribe_ } = await transport.subscribe({
          params: ["logs", { address, topics }],
          onData(data) {
            var _a106;
            if (!active2)
              return;
            const log5 = data.result;
            try {
              const { eventName, args: args3 } = decodeEventLog({
                abi: events_ ?? [],
                data: log5.data,
                topics: log5.topics,
                strict: strict2
              });
              const formatted = formatLog(log5, { args: args3, eventName });
              onLogs([formatted]);
            } catch (err2) {
              let eventName;
              let isUnnamed;
              if (err2 instanceof DecodeLogDataMismatch || err2 instanceof DecodeLogTopicsMismatch) {
                if (strict_)
                  return;
                eventName = err2.abiItem.name;
                isUnnamed = (_a106 = err2.abiItem.inputs) == null ? void 0 : _a106.some((x) => !("name" in x && x.name));
              }
              const formatted = formatLog(log5, {
                args: isUnnamed ? [] : {},
                eventName
              });
              onLogs([formatted]);
            }
          },
          onError(error4) {
            onError6 == null ? void 0 : onError6(error4);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active2)
          unsubscribe();
      } catch (err2) {
        onError6 == null ? void 0 : onError6(err2);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollEvent() : subscribeEvent();
}

// node_modules/viem/_esm/actions/public/watchPendingTransactions.js
function watchPendingTransactions(client, { batch = true, onError: onError6, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
  const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket" && client.transport.type !== "ipc";
  const pollPendingTransactions = () => {
    const observerId = stringify([
      "watchPendingTransactions",
      client.uid,
      batch,
      pollingInterval
    ]);
    return observe(observerId, { onTransactions, onError: onError6 }, (emit2) => {
      let filter26;
      const unwatch = poll13(async () => {
        var _a106;
        try {
          if (!filter26) {
            try {
              filter26 = await getAction(client, createPendingTransactionFilter, "createPendingTransactionFilter")({});
              return;
            } catch (err2) {
              unwatch();
              throw err2;
            }
          }
          const hashes = await getAction(client, getFilterChanges, "getFilterChanges")({ filter: filter26 });
          if (hashes.length === 0)
            return;
          if (batch)
            emit2.onTransactions(hashes);
          else
            for (const hash11 of hashes)
              emit2.onTransactions([hash11]);
        } catch (err2) {
          (_a106 = emit2.onError) == null ? void 0 : _a106.call(emit2, err2);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter26)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter: filter26 });
        unwatch();
      };
    });
  };
  const subscribePendingTransactions = () => {
    let active2 = true;
    let unsubscribe = () => active2 = false;
    (async () => {
      try {
        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
          params: ["newPendingTransactions"],
          onData(data) {
            if (!active2)
              return;
            const transaction = data.result;
            onTransactions([transaction]);
          },
          onError(error4) {
            onError6 == null ? void 0 : onError6(error4);
          }
        });
        unsubscribe = unsubscribe_;
        if (!active2)
          unsubscribe();
      } catch (err2) {
        onError6 == null ? void 0 : onError6(err2);
      }
    })();
    return () => unsubscribe();
  };
  return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

// node_modules/viem/_esm/utils/siwe/parseSiweMessage.js
function parseSiweMessage(message) {
  var _a106, _b32, _c7;
  const { scheme, statement, ...prefix } = ((_a106 = message.match(prefixRegex)) == null ? void 0 : _a106.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b32 = message.match(suffixRegex)) == null ? void 0 : _b32.groups) ?? {};
  const resources = (_c7 = message.split("Resources:")[1]) == null ? void 0 : _c7.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;

// node_modules/viem/_esm/utils/siwe/validateSiweMessage.js
function validateSiweMessage(parameters) {
  const { address, domain: domain2, message, nonce, scheme, time: time3 = /* @__PURE__ */ new Date() } = parameters;
  if (domain2 && message.domain !== domain2)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time3 >= message.expirationTime)
    return false;
  if (message.notBefore && time3 < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (!isAddress(message.address, { strict: false }))
      return false;
    if (address && !isAddressEqual(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}

// node_modules/viem/_esm/actions/siwe/verifySiweMessage.js
async function verifySiweMessage(client, parameters) {
  const { address, domain: domain2, message, nonce, scheme, signature, time: time3 = /* @__PURE__ */ new Date(), ...callRequest } = parameters;
  const parsed = parseSiweMessage(message);
  if (!parsed.address)
    return false;
  const isValid4 = validateSiweMessage({
    address,
    domain: domain2,
    message: parsed,
    nonce,
    scheme,
    time: time3
  });
  if (!isValid4)
    return false;
  const hash11 = hashMessage(message);
  return verifyHash2(client, {
    address: parsed.address,
    hash: hash11,
    signature,
    ...callRequest
  });
}

// node_modules/viem/_esm/clients/decorators/public.js
function publicActions(client) {
  return {
    call: (args2) => call(client, args2),
    createAccessList: (args2) => createAccessList(client, args2),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args2) => createContractEventFilter(client, args2),
    createEventFilter: (args2) => createEventFilter(client, args2),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args2) => estimateContractGas(client, args2),
    estimateGas: (args2) => estimateGas(client, args2),
    getBalance: (args2) => getBalance(client, args2),
    getBlobBaseFee: () => getBlobBaseFee(client),
    getBlock: (args2) => getBlock(client, args2),
    getBlockNumber: (args2) => getBlockNumber(client, args2),
    getBlockTransactionCount: (args2) => getBlockTransactionCount(client, args2),
    getBytecode: (args2) => getCode(client, args2),
    getChainId: () => getChainId(client),
    getCode: (args2) => getCode(client, args2),
    getContractEvents: (args2) => getContractEvents(client, args2),
    getEip712Domain: (args2) => getEip712Domain(client, args2),
    getEnsAddress: (args2) => getEnsAddress(client, args2),
    getEnsAvatar: (args2) => getEnsAvatar(client, args2),
    getEnsName: (args2) => getEnsName(client, args2),
    getEnsResolver: (args2) => getEnsResolver(client, args2),
    getEnsText: (args2) => getEnsText(client, args2),
    getFeeHistory: (args2) => getFeeHistory(client, args2),
    estimateFeesPerGas: (args2) => estimateFeesPerGas(client, args2),
    getFilterChanges: (args2) => getFilterChanges(client, args2),
    getFilterLogs: (args2) => getFilterLogs(client, args2),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args2) => getLogs(client, args2),
    getProof: (args2) => getProof(client, args2),
    estimateMaxPriorityFeePerGas: (args2) => estimateMaxPriorityFeePerGas(client, args2),
    getStorageAt: (args2) => getStorageAt(client, args2),
    getTransaction: (args2) => getTransaction(client, args2),
    getTransactionConfirmations: (args2) => getTransactionConfirmations(client, args2),
    getTransactionCount: (args2) => getTransactionCount(client, args2),
    getTransactionReceipt: (args2) => getTransactionReceipt(client, args2),
    multicall: (args2) => multicall(client, args2),
    prepareTransactionRequest: (args2) => prepareTransactionRequest(client, args2),
    readContract: (args2) => readContract(client, args2),
    sendRawTransaction: (args2) => sendRawTransaction(client, args2),
    simulate: (args2) => simulateBlocks(client, args2),
    simulateBlocks: (args2) => simulateBlocks(client, args2),
    simulateCalls: (args2) => simulateCalls(client, args2),
    simulateContract: (args2) => simulateContract(client, args2),
    verifyMessage: (args2) => verifyMessage2(client, args2),
    verifySiweMessage: (args2) => verifySiweMessage(client, args2),
    verifyTypedData: (args2) => verifyTypedData2(client, args2),
    uninstallFilter: (args2) => uninstallFilter(client, args2),
    waitForTransactionReceipt: (args2) => waitForTransactionReceipt(client, args2),
    watchBlocks: (args2) => watchBlocks(client, args2),
    watchBlockNumber: (args2) => watchBlockNumber(client, args2),
    watchContractEvent: (args2) => watchContractEvent(client, args2),
    watchEvent: (args2) => watchEvent(client, args2),
    watchPendingTransactions: (args2) => watchPendingTransactions(client, args2)
  };
}

// node_modules/viem/_esm/clients/createPublicClient.js
function createPublicClient(parameters) {
  const { key = "public", name = "Public Client" } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    type: "publicClient"
  });
  return client.extend(publicActions);
}

// node_modules/viem/_esm/actions/wallet/addChain.js
async function addChain(client, { chain: chain2 }) {
  const { id: id3, name, nativeCurrency, rpcUrls, blockExplorers } = chain2;
  await client.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: numberToHex(id3),
        chainName: name,
        nativeCurrency,
        rpcUrls: rpcUrls.default.http,
        blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url: url3 }) => url3) : void 0
      }
    ]
  }, { dedupe: true, retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/deployContract.js
function deployContract(walletClient, parameters) {
  const { abi: abi11, args: args2, bytecode, ...request2 } = parameters;
  const calldata = encodeDeployData({ abi: abi11, args: args2, bytecode });
  return sendTransaction(walletClient, {
    ...request2,
    ...request2.authorizationList ? { to: null } : {},
    data: calldata
  });
}

// node_modules/viem/_esm/actions/wallet/getAddresses.js
async function getAddresses(client) {
  var _a106;
  if (((_a106 = client.account) == null ? void 0 : _a106.type) === "local")
    return [client.account.address];
  const addresses = await client.request({ method: "eth_accounts" }, { dedupe: true });
  return addresses.map((address) => checksumAddress(address));
}

// node_modules/viem/_esm/actions/wallet/getCapabilities.js
async function getCapabilities(client, parameters = {}) {
  const { account = client.account, chainId } = parameters;
  const account_ = account ? parseAccount(account) : void 0;
  const params = chainId ? [account_ == null ? void 0 : account_.address, [numberToHex(chainId)]] : [account_ == null ? void 0 : account_.address];
  const capabilities_raw = await client.request({
    method: "wallet_getCapabilities",
    params
  });
  const capabilities = {};
  for (const [chainId2, capabilities_] of Object.entries(capabilities_raw)) {
    capabilities[Number(chainId2)] = {};
    for (let [key, value10] of Object.entries(capabilities_)) {
      if (key === "addSubAccount")
        key = "unstable_addSubAccount";
      capabilities[Number(chainId2)][key] = value10;
    }
  }
  return typeof chainId === "number" ? capabilities[chainId] : capabilities;
}

// node_modules/viem/_esm/actions/wallet/getPermissions.js
async function getPermissions(client) {
  const permissions = await client.request({ method: "wallet_getPermissions" }, { dedupe: true });
  return permissions;
}

// node_modules/viem/_esm/actions/wallet/prepareAuthorization.js
async function prepareAuthorization(client, parameters) {
  var _a106;
  const { account: account_ = client.account, chainId, nonce } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/eip7702/prepareAuthorization"
    });
  const account = parseAccount(account_);
  const executor = (() => {
    if (!parameters.executor)
      return void 0;
    if (parameters.executor === "self")
      return parameters.executor;
    return parseAccount(parameters.executor);
  })();
  const authorization = {
    address: parameters.contractAddress ?? parameters.address,
    chainId,
    nonce
  };
  if (typeof authorization.chainId === "undefined")
    authorization.chainId = ((_a106 = client.chain) == null ? void 0 : _a106.id) ?? await getAction(client, getChainId, "getChainId")({});
  if (typeof authorization.nonce === "undefined") {
    authorization.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
      address: account.address,
      blockTag: "pending"
    });
    if (executor === "self" || (executor == null ? void 0 : executor.address) && isAddressEqual(executor.address, account.address))
      authorization.nonce += 1;
  }
  return authorization;
}

// node_modules/viem/_esm/actions/wallet/requestAddresses.js
async function requestAddresses(client) {
  const addresses = await client.request({ method: "eth_requestAccounts" }, { dedupe: true, retryCount: 0 });
  return addresses.map((address) => getAddress(address));
}

// node_modules/viem/_esm/actions/wallet/requestPermissions.js
async function requestPermissions(client, permissions) {
  return client.request({
    method: "wallet_requestPermissions",
    params: [permissions]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/showCallsStatus.js
async function showCallsStatus(client, parameters) {
  const { id: id3 } = parameters;
  await client.request({
    method: "wallet_showCallsStatus",
    params: [id3]
  });
  return;
}

// node_modules/viem/_esm/actions/wallet/signAuthorization.js
async function signAuthorization(client, parameters) {
  const { account: account_ = client.account } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/eip7702/signAuthorization"
    });
  const account = parseAccount(account_);
  if (!account.signAuthorization)
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/eip7702/signAuthorization",
      metaMessages: [
        "The `signAuthorization` Action does not support JSON-RPC Accounts."
      ],
      type: account.type
    });
  const authorization = await prepareAuthorization(client, parameters);
  return account.signAuthorization(authorization);
}

// node_modules/viem/_esm/actions/wallet/signMessage.js
async function signMessage(client, { account: account_ = client.account, message }) {
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account = parseAccount(account_);
  if (account.signMessage)
    return account.signMessage({ message });
  const message_ = (() => {
    if (typeof message === "string")
      return stringToHex(message);
    if (message.raw instanceof Uint8Array)
      return toHex(message.raw);
    return message.raw;
  })();
  return client.request({
    method: "personal_sign",
    params: [message_, account.address]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/signTransaction.js
async function signTransaction(client, parameters) {
  var _a106, _b32, _c7, _d4;
  const { account: account_ = client.account, chain: chain2 = client.chain, ...transaction } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const account = parseAccount(account_);
  assertRequest({
    account,
    ...parameters
  });
  const chainId = await getAction(client, getChainId, "getChainId")({});
  if (chain2 !== null)
    assertCurrentChain({
      currentChainId: chainId,
      chain: chain2
    });
  const formatters = (chain2 == null ? void 0 : chain2.formatters) || ((_a106 = client.chain) == null ? void 0 : _a106.formatters);
  const format16 = ((_b32 = formatters == null ? void 0 : formatters.transactionRequest) == null ? void 0 : _b32.format) || formatTransactionRequest;
  if (account.signTransaction)
    return account.signTransaction({
      ...transaction,
      chainId
    }, { serializer: (_d4 = (_c7 = client.chain) == null ? void 0 : _c7.serializers) == null ? void 0 : _d4.transaction });
  return await client.request({
    method: "eth_signTransaction",
    params: [
      {
        ...format16(transaction),
        chainId: numberToHex(chainId),
        from: account.address
      }
    ]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/signTypedData.js
async function signTypedData(client, parameters) {
  const { account: account_ = client.account, domain: domain2, message, primaryType } = parameters;
  if (!account_)
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const account = parseAccount(account_);
  const types3 = {
    EIP712Domain: getTypesForEIP712Domain({ domain: domain2 }),
    ...parameters.types
  };
  validateTypedData({ domain: domain2, message, primaryType, types: types3 });
  if (account.signTypedData)
    return account.signTypedData({ domain: domain2, message, primaryType, types: types3 });
  const typedData = serializeTypedData({ domain: domain2, message, primaryType, types: types3 });
  return client.request({
    method: "eth_signTypedData_v4",
    params: [account.address, typedData]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/switchChain.js
async function switchChain(client, { id: id3 }) {
  await client.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: numberToHex(id3)
      }
    ]
  }, { retryCount: 0 });
}

// node_modules/viem/_esm/actions/wallet/watchAsset.js
async function watchAsset(client, params) {
  const added = await client.request({
    method: "wallet_watchAsset",
    params
  }, { retryCount: 0 });
  return added;
}

// node_modules/viem/_esm/clients/decorators/wallet.js
function walletActions(client) {
  return {
    addChain: (args2) => addChain(client, args2),
    deployContract: (args2) => deployContract(client, args2),
    getAddresses: () => getAddresses(client),
    getCallsStatus: (args2) => getCallsStatus(client, args2),
    getCapabilities: (args2) => getCapabilities(client, args2),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    prepareAuthorization: (args2) => prepareAuthorization(client, args2),
    prepareTransactionRequest: (args2) => prepareTransactionRequest(client, args2),
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (args2) => requestPermissions(client, args2),
    sendCalls: (args2) => sendCalls(client, args2),
    sendRawTransaction: (args2) => sendRawTransaction(client, args2),
    sendTransaction: (args2) => sendTransaction(client, args2),
    showCallsStatus: (args2) => showCallsStatus(client, args2),
    signAuthorization: (args2) => signAuthorization(client, args2),
    signMessage: (args2) => signMessage(client, args2),
    signTransaction: (args2) => signTransaction(client, args2),
    signTypedData: (args2) => signTypedData(client, args2),
    switchChain: (args2) => switchChain(client, args2),
    waitForCallsStatus: (args2) => waitForCallsStatus(client, args2),
    watchAsset: (args2) => watchAsset(client, args2),
    writeContract: (args2) => writeContract(client, args2)
  };
}

// node_modules/viem/_esm/clients/createWalletClient.js
function createWalletClient(parameters) {
  const { key = "wallet", name = "Wallet Client", transport } = parameters;
  const client = createClient({
    ...parameters,
    key,
    name,
    transport,
    type: "walletClient"
  });
  return client.extend(walletActions);
}

// node_modules/@graphprotocol/grc-20/dist/src/abis/space.js
var abi2 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "where",
        type: "address"
      },
      {
        internalType: "address",
        name: "who",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "permissionId",
        type: "bytes32"
      }
    ],
    name: "DaoUnauthorized",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "AdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "beacon",
        type: "address"
      }
    ],
    name: "BeaconUpgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "string",
        name: "contentUri",
        type: "string"
      }
    ],
    name: "EditsPublished",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "subspaceDao",
        type: "address"
      }
    ],
    name: "SubspaceAccepted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "subspaceDao",
        type: "address"
      }
    ],
    name: "SubspaceRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "predecessorSpace",
        type: "address"
      }
    ],
    name: "SuccessorSpaceCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "UPGRADE_PLUGIN_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_subspaceDao",
        type: "address"
      }
    ],
    name: "acceptSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "dao",
    outputs: [
      {
        internalType: "contract IDAO",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_dao",
        type: "address"
      },
      {
        internalType: "string",
        name: "_firstContentUri",
        type: "string"
      },
      {
        internalType: "address",
        name: "_predecessorSpace",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginType",
    outputs: [
      {
        internalType: "enum IPlugin.PluginType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_contentUri",
        type: "string"
      }
    ],
    name: "publishEdits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_subspaceDao",
        type: "address"
      }
    ],
    name: "removeSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      }
    ],
    name: "upgradeTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];

// node_modules/@graphprotocol/grc-20/dist/src/abis/main-voting.js
var abi3 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "AlreadyAMember",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "AlreadyAnEditor",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "AlreadyNotAMember",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "AlreadyNotAnEditor",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "where",
        type: "address"
      },
      {
        internalType: "address",
        name: "who",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "permissionId",
        type: "bytes32"
      }
    ],
    name: "DaoUnauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "limit",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "actual",
        type: "uint64"
      }
    ],
    name: "DateOutOfBounds",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint64",
        name: "limit",
        type: "uint64"
      },
      {
        internalType: "uint64",
        name: "actual",
        type: "uint64"
      }
    ],
    name: "DurationOutOfBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "EmptyContent",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "InvalidAddresslistUpdate",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "InvalidInterface",
    type: "error"
  },
  {
    inputs: [],
    name: "NoEditorsLeft",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "NotAMember",
    type: "error"
  },
  {
    inputs: [],
    name: "NotAnEditor",
    type: "error"
  },
  {
    inputs: [],
    name: "OnlyCreatorCanCancel",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "length",
        type: "uint256"
      }
    ],
    name: "OnlyOneEditorPerCall",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ProposalCreationForbidden",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecutionForbidden",
    type: "error"
  },
  {
    inputs: [],
    name: "ProposalIsNotOpen",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "limit",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "actual",
        type: "uint256"
      }
    ],
    name: "RatioOutOfBounds",
    type: "error"
  },
  {
    inputs: [],
    name: "Unauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "voteOption",
        type: "uint8"
      }
    ],
    name: "VoteCastForbidden",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "subspace",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "AcceptSubspaceProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "editor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "AddEditorProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "previousAdmin",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "newAdmin",
        type: "address"
      }
    ],
    name: "AdminChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "beacon",
        type: "address"
      }
    ],
    name: "BeaconUpgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address[]",
        name: "editors",
        type: "address[]"
      }
    ],
    name: "EditorsAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalCanceled",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        indexed: false,
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    name: "ProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecuted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "string",
        name: "contentUri",
        type: "string"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "PublishEditsProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "editor",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveEditorProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "member",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveMemberProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        indexed: true,
        internalType: "address",
        name: "subspace",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      }
    ],
    name: "RemoveSubspaceProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "implementation",
        type: "address"
      }
    ],
    name: "Upgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "voter",
        type: "address"
      },
      {
        indexed: false,
        internalType: "enum IMajorityVoting.VoteOption",
        name: "voteOption",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "votingPower",
        type: "uint256"
      }
    ],
    name: "VoteCast",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "enum MajorityVotingBase.VotingMode",
        name: "votingMode",
        type: "uint8"
      },
      {
        indexed: false,
        internalType: "uint32",
        name: "supportThreshold",
        type: "uint32"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "duration",
        type: "uint64"
      }
    ],
    name: "VotingSettingsUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "UPDATE_ADDRESSES_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPDATE_VOTING_SETTINGS_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "UPGRADE_PLUGIN_PERMISSION_ID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "addEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "addMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "addresslistLength",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "addresslistLengthAtBlock",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "canExecute",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_voter",
        type: "address"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      }
    ],
    name: "canVote",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "cancelProposal",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "_actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "_allowFailureMap",
        type: "uint256"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      },
      {
        internalType: "bool",
        name: "_tryEarlyExecution",
        type: "bool"
      }
    ],
    name: "createProposal",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "dao",
    outputs: [
      {
        internalType: "contract IDAO",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "duration",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "execute",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "getProposal",
    outputs: [
      {
        internalType: "bool",
        name: "open",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "executed",
        type: "bool"
      },
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "startDate",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "endDate",
            type: "uint64"
          },
          {
            internalType: "uint64",
            name: "snapshotBlock",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.ProposalParameters",
        name: "parameters",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "uint256",
            name: "abstain",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "yes",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "no",
            type: "uint256"
          }
        ],
        internalType: "struct MajorityVotingBase.Tally",
        name: "tally",
        type: "tuple"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "_voter",
        type: "address"
      }
    ],
    name: "getVoteOption",
    outputs: [
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "implementation",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_dao",
        type: "address"
      },
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "duration",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.VotingSettings",
        name: "_votingSettings",
        type: "tuple"
      },
      {
        internalType: "address[]",
        name: "_initialEditors",
        type: "address[]"
      },
      {
        internalType: "contract MemberAccessPlugin",
        name: "_memberAccessPlugin",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isEditor",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isListed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "isListedAtBlock",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isMinParticipationReached",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isSupportThresholdReached",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      }
    ],
    name: "isSupportThresholdReachedEarly",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpaceAsEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "memberAccessPlugin",
    outputs: [
      {
        internalType: "contract MemberAccessPlugin",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginType",
    outputs: [
      {
        internalType: "enum IPlugin.PluginType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeAcceptSubspace",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_proposedEditor",
        type: "address"
      }
    ],
    name: "proposeAddEditor",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_proposedMember",
        type: "address"
      }
    ],
    name: "proposeAddMember",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "string",
        name: "_editsContentUri",
        type: "string"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeEdits",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "proposeRemoveEditor",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "proposeRemoveMember",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadataContentUri",
        type: "bytes"
      },
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "proposeRemoveSubspace",
    outputs: [
      {
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "proxiableUUID",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "removeEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "removeMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "supportThreshold",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_blockNumber",
        type: "uint256"
      }
    ],
    name: "totalVotingPower",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "enum MajorityVotingBase.VotingMode",
            name: "votingMode",
            type: "uint8"
          },
          {
            internalType: "uint32",
            name: "supportThreshold",
            type: "uint32"
          },
          {
            internalType: "uint64",
            name: "duration",
            type: "uint64"
          }
        ],
        internalType: "struct MajorityVotingBase.VotingSettings",
        name: "_votingSettings",
        type: "tuple"
      }
    ],
    name: "updateVotingSettings",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      }
    ],
    name: "upgradeTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newImplementation",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "upgradeToAndCall",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_proposalId",
        type: "uint256"
      },
      {
        internalType: "enum IMajorityVoting.VoteOption",
        name: "_voteOption",
        type: "uint8"
      },
      {
        internalType: "bool",
        name: "_tryEarlyExecution",
        type: "bool"
      }
    ],
    name: "vote",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "votingMode",
    outputs: [
      {
        internalType: "enum MajorityVotingBase.VotingMode",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@graphprotocol/grc-20/dist/src/abis/personal-space-admin.js
var abi4 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "where",
        type: "address"
      },
      {
        internalType: "address",
        name: "who",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "permissionId",
        type: "bytes32"
      }
    ],
    name: "DaoUnauthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "caller",
        type: "address"
      }
    ],
    name: "NotAMember",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "editor",
        type: "address"
      }
    ],
    name: "EditorRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address[]",
        name: "editors",
        type: "address[]"
      }
    ],
    name: "EditorsAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberLeft",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "dao",
        type: "address"
      },
      {
        indexed: false,
        internalType: "address",
        name: "member",
        type: "address"
      }
    ],
    name: "MemberRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "startDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "uint64",
        name: "endDate",
        type: "uint64"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        indexed: false,
        internalType: "struct IDAO.Action[]",
        name: "actions",
        type: "tuple[]"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "allowFailureMap",
        type: "uint256"
      }
    ],
    name: "ProposalCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "proposalId",
        type: "uint256"
      }
    ],
    name: "ProposalExecuted",
    type: "event"
  },
  {
    inputs: [],
    name: "dao",
    outputs: [
      {
        internalType: "contract IDAO",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "_metadata",
        type: "bytes"
      },
      {
        components: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        internalType: "struct IDAO.Action[]",
        name: "_actions",
        type: "tuple[]"
      },
      {
        internalType: "uint256",
        name: "_allowFailureMap",
        type: "uint256"
      }
    ],
    name: "executeProposal",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_dao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_initialEditor",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isEditor",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_account",
        type: "address"
      }
    ],
    name: "isMember",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "leaveSpace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "pluginType",
    outputs: [
      {
        internalType: "enum IPlugin.PluginType",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "proposalCount",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitAcceptSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_contentUri",
        type: "string"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitEdits",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newEditor",
        type: "address"
      }
    ],
    name: "submitNewEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newMember",
        type: "address"
      }
    ],
    name: "submitNewMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_editor",
        type: "address"
      }
    ],
    name: "submitRemoveEditor",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_member",
        type: "address"
      }
    ],
    name: "submitRemoveMember",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract IDAO",
        name: "_subspaceDao",
        type: "address"
      },
      {
        internalType: "address",
        name: "_spacePlugin",
        type: "address"
      }
    ],
    name: "submitRemoveSubspace",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "_interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-process-geo-proposal-arguments.js
function getProcessGeoProposalArguments(spacePluginAddress, ipfsUri) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: spacePluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi: abi2,
          functionName: "publishEdits",
          args: [ipfsUri]
        })
      }
    ],
    BigInt(0),
    VoteOption.Yes,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-accept-subspace-arguments.js
function getAcceptSubspaceArguments({ spacePluginAddress, ipfsUri, subspaceToAccept }) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: spacePluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi: abi2,
          functionName: "acceptSubspace",
          args: [subspaceToAccept]
        })
      }
    ],
    BigInt(0),
    VoteOption.Yes,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-remove-subspace-arguments.js
function getRemoveSubspaceArguments({ spacePluginAddress, ipfsUri, subspaceToAccept }) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: spacePluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi: abi2,
          functionName: "removeSubspace",
          args: [subspaceToAccept]
        })
      }
    ],
    BigInt(0),
    VoteOption.Yes,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-accept-editor-arguments.js
function getAcceptEditorArguments({ votingPluginAddress, ipfsUri, editorAddress }) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: votingPluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi: abi3,
          functionName: "addEditor",
          args: [editorAddress]
        })
      }
    ],
    BigInt(0),
    VoteOption.None,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-remove-editor-arguments.js
function getRemoveEditorArguments({ votingPluginAddress, ipfsUri, editorAddress }) {
  return [
    stringToHex(ipfsUri),
    [
      {
        to: votingPluginAddress,
        value: BigInt(0),
        data: encodeFunctionData({
          abi: abi3,
          functionName: "removeMember",
          args: [editorAddress]
        })
      }
    ],
    BigInt(0),
    VoteOption.Yes,
    true
  ];
}

// node_modules/@graphprotocol/grc-20/dist/src/encodings/get-calldata-for-space-governance-type.js
function getCalldataForSpaceGovernanceType(args2) {
  switch (args2.type) {
    case "PUBLIC":
      return encodeFunctionData({
        functionName: "proposeEdits",
        abi: abi3,
        args: [stringToHex(args2.cid), args2.cid, args2.spacePluginAddress]
      });
    case "PERSONAL":
      return encodeFunctionData({
        functionName: "submitEdits",
        abi: abi4,
        args: [args2.cid, args2.spacePluginAddress]
      });
  }
}

// node_modules/@graphprotocol/grc-20/dist/src/core/account.js
var account_exports = {};
__export(account_exports, {
  make: () => make151
});

// node_modules/@graphprotocol/grc-20/dist/src/core/ids/system.js
var system_exports = {};
__export(system_exports, {
  ABOUT_PAGE: () => ABOUT_PAGE,
  ABOUT_PAGE_TEMPLATE: () => ABOUT_PAGE_TEMPLATE,
  ACADEMIC_FIELD_TEMPLATE: () => ACADEMIC_FIELD_TEMPLATE,
  ACADEMIC_FIELD_TYPE: () => ACADEMIC_FIELD_TYPE,
  ACCOUNTS_PROPERTY: () => ACCOUNTS_PROPERTY,
  ACCOUNT_TYPE: () => ACCOUNT_TYPE,
  ACTIVITIES_PAGE: () => ACTIVITIES_PAGE,
  ADDRESS_PROPERTY: () => ADDRESS_PROPERTY,
  ALL_OF_GEO_DATA_SOURCE: () => ALL_OF_GEO_DATA_SOURCE,
  BLOCKS: () => BLOCKS,
  BROADER_CLAIMS_PROPERTY: () => BROADER_CLAIMS_PROPERTY,
  BULLETED_LIST_VIEW: () => BULLETED_LIST_VIEW,
  CLAIMS_FROM_PROPERTY: () => CLAIMS_FROM_PROPERTY,
  COLLECTION_DATA_SOURCE: () => COLLECTION_DATA_SOURCE,
  COLLECTION_ITEM_RELATION_TYPE: () => COLLECTION_ITEM_RELATION_TYPE,
  COMPANY_TEMPLATE: () => COMPANY_TEMPLATE,
  COMPANY_TYPE: () => COMPANY_TYPE,
  COVER_PROPERTY: () => COVER_PROPERTY,
  CULTURE_PAGE: () => CULTURE_PAGE,
  CURRENCY_EUR_PROPERTY: () => CURRENCY_EUR_PROPERTY,
  CURRENCY_GBP_PROPERTY: () => CURRENCY_GBP_PROPERTY,
  CURRENCY_PROPERTY: () => CURRENCY_PROPERTY,
  CURRENCY_SIGN_PROPERTY: () => CURRENCY_SIGN_PROPERTY,
  CURRENCY_SYMBOL_PROPERTY: () => CURRENCY_SYMBOL_PROPERTY,
  CURRENCY_USD_PROPERTY: () => CURRENCY_USD_PROPERTY,
  DAO_TEMPLATE: () => DAO_TEMPLATE,
  DAO_TYPE: () => DAO_TYPE,
  DATA_BLOCK: () => DATA_BLOCK,
  DATA_SOURCE_PROPERTY: () => DATA_SOURCE_PROPERTY,
  DATA_SOURCE_TYPE_RELATION_TYPE: () => DATA_SOURCE_TYPE_RELATION_TYPE,
  DEFAULT_TYPE: () => DEFAULT_TYPE,
  DEFINITIONS_PROPERTY: () => DEFINITIONS_PROPERTY,
  DESCRIPTION_PROPERTY: () => DESCRIPTION_PROPERTY,
  EDUCATION_PAGE: () => EDUCATION_PAGE,
  EDUCATION_PAGE_TEMPLATE: () => EDUCATION_PAGE_TEMPLATE,
  EMAIL_PROPERTY: () => EMAIL_PROPERTY,
  ENTITY_FILTER: () => ENTITY_FILTER,
  ENTITY_ID_PROPERTY: () => ENTITY_ID_PROPERTY,
  EVENTS_PAGE: () => EVENTS_PAGE,
  FILTER: () => FILTER,
  FINANCES_PAGE: () => FINANCES_PAGE,
  FINANCE_OVERVIEW_TYPE: () => FINANCE_OVERVIEW_TYPE,
  FINANCE_SUMMMARY_TYPE: () => FINANCE_SUMMMARY_TYPE,
  FOREIGN_TYPES: () => FOREIGN_TYPES,
  GALLERY_VIEW: () => GALLERY_VIEW,
  GEO_LOCATION_PROPERTY: () => GEO_LOCATION_PROPERTY,
  GOALS_PROPERTY: () => GOALS_PROPERTY,
  GOAL_TYPE: () => GOAL_TYPE,
  GOVERNMENT_ORG_TYPE: () => GOVERNMENT_ORG_TYPE,
  GOVERNMENT_PAGE: () => GOVERNMENT_PAGE,
  IMAGE: () => IMAGE,
  IMAGE_BLOCK: () => IMAGE_BLOCK,
  IMAGE_FILE_TYPE_PROPERTY: () => IMAGE_FILE_TYPE_PROPERTY,
  IMAGE_HEIGHT_PROPERTY: () => IMAGE_HEIGHT_PROPERTY,
  IMAGE_TYPE: () => IMAGE_TYPE,
  IMAGE_URL_PROPERTY: () => IMAGE_URL_PROPERTY,
  IMAGE_WIDTH_PROPERTY: () => IMAGE_WIDTH_PROPERTY,
  INDUSTRY_TEMPLATE: () => INDUSTRY_TEMPLATE,
  INDUSTRY_TYPE: () => INDUSTRY_TYPE,
  INTEREST_TEMPLATE: () => INTEREST_TEMPLATE,
  INTEREST_TYPE: () => INTEREST_TYPE,
  JOBS_PAGE: () => JOBS_PAGE,
  LIST_VIEW: () => LIST_VIEW,
  MARKDOWN_CONTENT: () => MARKDOWN_CONTENT,
  MEMBERSHIP_CONTRACT_ADDRESS: () => MEMBERSHIP_CONTRACT_ADDRESS,
  MISSION_PROPERTY: () => MISSION_PROPERTY,
  NAME_PROPERTY: () => NAME_PROPERTY,
  NETWORK_PROPERTY: () => NETWORK_PROPERTY,
  NETWORK_TYPE: () => NETWORK_TYPE,
  NEWS_PAGE: () => NEWS_PAGE,
  NONPROFIT_CATEGORIES_PROPERTY: () => NONPROFIT_CATEGORIES_PROPERTY,
  NONPROFIT_TEMPLATE: () => NONPROFIT_TEMPLATE,
  NONPROFIT_TYPE: () => NONPROFIT_TYPE,
  ONTOLOGY_PAGE: () => ONTOLOGY_PAGE,
  ONTOLOGY_PAGE_TEMPLATE: () => ONTOLOGY_PAGE_TEMPLATE,
  PAGE_TYPE: () => PAGE_TYPE,
  PAGE_TYPE_PROPERTY: () => PAGE_TYPE_PROPERTY,
  PEOPLE_PAGE: () => PEOPLE_PAGE,
  PERSONAL_PAGE: () => PERSONAL_PAGE,
  PERSON_TEMPLATE: () => PERSON_TEMPLATE,
  PERSON_TYPE: () => PERSON_TYPE,
  PHONE_NUMBER_PROPERTY: () => PHONE_NUMBER_PROPERTY,
  PLACEHOLDER_IMAGE: () => PLACEHOLDER_IMAGE,
  PLACEHOLDER_TEXT: () => PLACEHOLDER_TEXT,
  PLACES_PAGE: () => PLACES_PAGE,
  POSTS_PAGE: () => POSTS_PAGE,
  POST_TYPE: () => POST_TYPE,
  PRODUCTS_PAGE: () => PRODUCTS_PAGE,
  PROFESSIONAL_PAGE: () => PROFESSIONAL_PAGE,
  PROJECTS_PAGE: () => PROJECTS_PAGE,
  PROJECT_TYPE: () => PROJECT_TYPE,
  PROPERTIES: () => PROPERTIES,
  PROPERTY: () => PROPERTY,
  PROTOCOL_TEMPLATE: () => PROTOCOL_TEMPLATE,
  PROTOCOL_TYPE: () => PROTOCOL_TYPE,
  QUERY_DATA_SOURCE: () => QUERY_DATA_SOURCE,
  QUOTES_PROPERTY: () => QUOTES_PROPERTY,
  REGION_PROPERTY: () => REGION_PROPERTY,
  REGION_TEMPLATE: () => REGION_TEMPLATE,
  REGION_TYPE: () => REGION_TYPE,
  RELATED_TOPICS_PROPERTY: () => RELATED_TOPICS_PROPERTY,
  RELATION: () => RELATION,
  RELATION_FROM_PROPERTY: () => RELATION_FROM_PROPERTY,
  RELATION_INDEX: () => RELATION_INDEX,
  RELATION_TO_PROPERTY: () => RELATION_TO_PROPERTY,
  RELATION_TYPE: () => RELATION_TYPE,
  RELATION_TYPE_PROPERTY: () => RELATION_TYPE_PROPERTY,
  RELATION_VALUE_RELATIONSHIP_TYPE: () => RELATION_VALUE_RELATIONSHIP_TYPE,
  RELEVANT_QUESTIONS_PROPERTY: () => RELEVANT_QUESTIONS_PROPERTY,
  ROLE_PROPERTY: () => ROLE_PROPERTY,
  ROOT_SPACE_ID: () => ROOT_SPACE_ID,
  ROOT_SPACE_TYPE: () => ROOT_SPACE_TYPE,
  SCHEMA_TYPE: () => SCHEMA_TYPE,
  SELECTOR_PROPERTY: () => SELECTOR_PROPERTY,
  SERVICES_PAGE: () => SERVICES_PAGE,
  SHOWN_COLUMNS: () => SHOWN_COLUMNS,
  SOURCE_SPACE_PROPERTY: () => SOURCE_SPACE_PROPERTY,
  SPACES_PAGE: () => SPACES_PAGE,
  SPACE_FILTER: () => SPACE_FILTER,
  SPACE_TYPE: () => SPACE_TYPE,
  SPEAKERS_PROPERTY: () => SPEAKERS_PROPERTY,
  STREET_ADDRESS_PROPERTY: () => STREET_ADDRESS_PROPERTY,
  SUBCLAIMS_PROPERTY: () => SUBCLAIMS_PROPERTY,
  TABLE_VIEW: () => TABLE_VIEW,
  TABS_PROPERTY: () => TABS_PROPERTY,
  TAB_TYPE: () => TAB_TYPE,
  TEAM_PAGE: () => TEAM_PAGE,
  TEMPLATE_PROPERTY: () => TEMPLATE_PROPERTY,
  TEXT_BLOCK: () => TEXT_BLOCK,
  TYPES_PROPERTY: () => TYPES_PROPERTY,
  URL: () => URL3,
  VALUES_PROPERTY: () => VALUES_PROPERTY,
  VERIFIED_SOURCE_PROPERTY: () => VERIFIED_SOURCE_PROPERTY,
  VIEW_PROPERTY: () => VIEW_PROPERTY,
  VIEW_TYPE: () => VIEW_TYPE,
  VISION_PROPERTY: () => VISION_PROPERTY
});
var ENTITY_ID_PROPERTY = Id("1a1fff33-5782-4c33-93c7-c3a5f3592b60");
var PROPERTY = Id("808a04ce-b21c-4d88-8ad1-2e240613e5ca");
var SCHEMA_TYPE = Id("e7d737c5-3676-4c60-9fa1-6aa64a8c90ad");
var PROPERTIES = Id("01412f83-8189-4ab1-8365-65c7fd358cc1");
var NAME_PROPERTY = Id("a126ca53-0c8e-48d5-b888-82c734c38935");
var DESCRIPTION_PROPERTY = Id("9b1f76ff-9711-404c-861e-59dc3fa7d037");
var COVER_PROPERTY = Id("34f53507-2e6b-42c5-a844-43981a77cfa2");
var TYPES_PROPERTY = Id("8f151ba4-de20-4e3c-9cb4-99ddf96f48f1");
var TABS_PROPERTY = Id("4d9cba1c-4766-4698-81cd-3273891a018b");
var BLOCKS = Id("beaba5cb-a677-41a8-b353-77030613fc70");
var URL3 = Id("283127c9-6142-4684-92ed-90b0ebc7f29a");
var IMAGE = Id("f3f790c4-c74e-4d23-a0a9-1e8ef84e30d9");
var RELATION = Id("4b6d9fc1-fbfe-474c-861c-83398e1b50d9");
var SPACE_TYPE = Id("362c1dbd-dc64-44bb-a3c4-652f38a642d7");
var RELATION_VALUE_RELATIONSHIP_TYPE = Id("9eea393f-17dd-4971-a62e-a603e8bfec20");
var IMAGE_TYPE = Id("ba4e4146-0010-499d-a0a3-caaa7f579d0e");
var IMAGE_FILE_TYPE_PROPERTY = Id("515f346f-e0fb-40c7-8ea9-5339787eecc1");
var IMAGE_HEIGHT_PROPERTY = Id("7f6ad043-3e21-4257-a6d4-8bdad36b1d84");
var IMAGE_URL_PROPERTY = Id("8a743832-c094-4a62-b665-0c3cc2f9c7bc");
var IMAGE_WIDTH_PROPERTY = Id("f7b33e08-b76d-4190-aada-cadaa9f561e1");
var DATA_BLOCK = Id("b8803a86-65de-412b-bb35-7e0c84adf473");
var DATA_SOURCE_PROPERTY = Id("8ac1c4bf-453b-44b7-9eda-5d1b527e5ea3");
var ALL_OF_GEO_DATA_SOURCE = Id("f9adb874-52b9-4982-8f55-aa40792751e3");
var COLLECTION_DATA_SOURCE = Id("1295037a-5d9c-4d09-b27c-5502654b9177");
var QUERY_DATA_SOURCE = Id("3b069b04-adbe-4728-917d-1283fd4ac27e");
var SELECTOR_PROPERTY = Id("38ad3edb-8eda-4330-941b-e9abd0dbc9e1");
var FILTER = Id("14a46854-bfd1-4b18-8215-2785c2dab9f3");
var SPACE_FILTER = Id("8f6df521-24fa-4576-887e-0442973e2f33");
var ENTITY_FILTER = Id("d6b8aa86-2c73-41ca-bddb-63aa0732174c");
var COLLECTION_ITEM_RELATION_TYPE = Id("a99f9ce1-2ffa-4dac-8c61-f6310d46064a");
var VIEW_PROPERTY = Id("1907fd1c-8111-4a3c-a378-b1f353425b65");
var VIEW_TYPE = Id("20a21dc2-7371-482f-a120-7b147f1dc319");
var TABLE_VIEW = Id("cba271ce-f7c1-4033-9047-614d174c69f1");
var LIST_VIEW = Id("7d497dba-09c2-49b8-968f-716bcf520473");
var BULLETED_LIST_VIEW = Id("0aaac6f7-c916-403e-af6d-2e086dc92ada");
var GALLERY_VIEW = Id("ccb70fc9-17f0-4a54-b86e-3b4d20cc7130");
var SHOWN_COLUMNS = Id("4221fb36-dcab-4c68-b150-701aaba6c8e0");
var DATA_SOURCE_TYPE_RELATION_TYPE = Id("1f69cc98-80d4-44ab-ad49-3df6a7b15ee4");
var IMAGE_BLOCK = Id("e3817941-7409-4df1-b519-1f3f1a0721e8");
var TEXT_BLOCK = Id("76474f2f-0089-4e77-a041-0b39fb17d0bf");
var MARKDOWN_CONTENT = Id("e3e363d1-dd29-4ccb-8e6f-f3b76d99bc33");
var RELATION_TYPE = Id("c167ef23-fb2a-4044-9ed9-45123ce7d2a9");
var RELATION_FROM_PROPERTY = Id("c43b537b-cff7-4271-8822-717fdf2c9c01");
var RELATION_TO_PROPERTY = Id("c1f4cb6f-ece4-4c3c-a447-ab005b756972");
var RELATION_TYPE_PROPERTY = Id("14611456-b466-4cab-920d-2245f59ce828");
var RELATION_INDEX = Id("ede47e69-30b0-4499-8ea4-aafbda449609");
var VERIFIED_SOURCE_PROPERTY = Id("265e869b-3a27-40bd-b652-a7a77b0df24f");
var SOURCE_SPACE_PROPERTY = Id("81891dec-cb6c-427e-aa1f-b917292ec2dc");
var ACADEMIC_FIELD_TYPE = Id("9959eb50-b029-4a15-8557-b39318cbb91b");
var COMPANY_TYPE = Id("e059a29e-6f6b-437b-bc15-c7983d078c0d");
var DAO_TYPE = Id("872cb6f6-926d-4bb3-9d63-ccede27232b8");
var GOVERNMENT_ORG_TYPE = Id("a87e0291-ec36-4572-8af2-1301b3099e97");
var INDUSTRY_TYPE = Id("fc512a40-8b55-44dc-85b8-5aae88b51fae");
var INTEREST_TYPE = Id("2c765cae-c1b6-4cc3-a65d-693d0a67eaeb");
var NONPROFIT_TYPE = Id("c7a192a3-3909-4572-a848-a56b64dc4636");
var POST_TYPE = Id("f3d44614-86b7-4d25-83d8-9709c9d84f65");
var PROJECT_TYPE = Id("484a18c5-030a-499c-b0f2-ef588ff16d50");
var PROTOCOL_TYPE = Id("c38c4198-10c2-4cf2-9dd5-8f194033fc31");
var REGION_TYPE = Id("c188844a-7224-42ab-b476-2991c9c913f1");
var ROOT_SPACE_TYPE = Id("06053fcf-6443-4dc6-80ca-8a3b173a6016");
var TEMPLATE_PROPERTY = Id("cf37cd59-840c-4dac-a22b-9d9dde536ea7");
var PAGE_TYPE = Id("480e3fc2-67f3-4993-85fb-acdf4ddeaa6b");
var PAGE_TYPE_PROPERTY = Id("62dfabe5-282d-44a7-ba93-f2e80d20743d");
var ACADEMIC_FIELD_TEMPLATE = Id("06beeb0f-418d-46ad-84c3-82d4b1e58a81");
var COMPANY_TEMPLATE = Id("bedb6493-dc5b-47b4-b1a5-c68bfbbb2b43");
var DAO_TEMPLATE = Id("7ee14d70-99f0-4d0a-b371-95f08b0295be");
var INDUSTRY_TEMPLATE = Id("d81abf98-18d9-4259-b968-e538c60c841b");
var INTEREST_TEMPLATE = Id("59fdefec-6815-4866-9065-6d0bc162f2ee");
var NONPROFIT_TEMPLATE = Id("838361ab-f358-4044-9f13-1586a3266a2b");
var PERSON_TEMPLATE = Id("6bc6a6b0-b9eb-441d-b898-14f7a726877c");
var PROTOCOL_TEMPLATE = Id("dd35d506-1787-402c-8e79-f696ab839135");
var REGION_TEMPLATE = Id("c50754d3-bcb4-4013-a403-83f1eb9a442e");
var ONTOLOGY_PAGE_TEMPLATE = Id("8f90bd6d-8147-4eb8-b67f-d34fa2af1397");
var EDUCATION_PAGE_TEMPLATE = Id("c4b7e33f-939a-4871-b9e2-2711b6d3f49f");
var ABOUT_PAGE_TEMPLATE = Id("31af0a8a-6bc1-4981-b2ac-c45f2ba4d27c");
var ABOUT_PAGE = Id("f93d044e-61f6-42a8-92eb-ef37a377a535");
var ACTIVITIES_PAGE = Id("080d3c03-a770-48f2-a306-5103214aaf45");
var CULTURE_PAGE = Id("01dbb38e-270b-4004-9615-fefb10d19f33");
var EDUCATION_PAGE = Id("bfdc5a8f-4f6a-4955-bfbd-7bea921d8a42");
var EVENTS_PAGE = Id("92e64c6e-36ad-453b-9533-9e4be1033cdf");
var FINANCES_PAGE = Id("c316cec6-ddaa-436c-9c52-43b4179db529");
var GOVERNMENT_PAGE = Id("50c29327-1dd2-425e-bd9c-c8257938c891");
var JOBS_PAGE = Id("b4ac6985-5e8e-46d8-8f73-3ed8a918d33a");
var NEWS_PAGE = Id("d172f6f6-93a8-4c28-9577-e9d43259863b");
var ONTOLOGY_PAGE = Id("6e7215ec-10ca-4904-8895-2d89070a9c69");
var PEOPLE_PAGE = Id("238bce0f-1420-4df7-85a3-088aded159fd");
var PERSONAL_PAGE = Id("02fc9e37-25a8-487e-b219-3df738004c62");
var PLACES_PAGE = Id("e4220e2f-6554-4321-9144-344c3be22c00");
var POSTS_PAGE = Id("69a88b15-9a8f-4d56-930e-d7fc84accb14");
var PRODUCTS_PAGE = Id("5f7474c7-115e-44e4-9608-af93edcaf491");
var PROFESSIONAL_PAGE = Id("c613778e-fc19-4342-aed5-43296a72880c");
var PROJECTS_PAGE = Id("1743389c-dafb-49a6-b667-9d8bc46f3f52");
var SERVICES_PAGE = Id("0c06c8a0-563e-420b-b8e5-3b9c911ffa37");
var SPACES_PAGE = Id("8afae81d-33b5-40f7-b89c-ea7d49b10f9f");
var TEAM_PAGE = Id("55147448-8894-4ff7-a163-2f96f7afa7df");
var FINANCE_OVERVIEW_TYPE = Id("2315fe0c-6a4d-4f99-bb19-b59c8e7c563a");
var FINANCE_SUMMMARY_TYPE = Id("40c3c7e1-e066-43df-8eea-9900514e96ed");
var ACCOUNT_TYPE = Id("cb69723f-7456-471a-a8ad-3e93ddc3edfe");
var ACCOUNTS_PROPERTY = Id("e4047a77-0043-4ed4-a410-72139bff7f7e");
var ADDRESS_PROPERTY = Id("85cebdf1-d84f-4afd-993b-35f182096b59");
var NETWORK_PROPERTY = Id("a945fa95-d15e-42bc-b70a-43d3933048dd");
var PERSON_TYPE = Id("7ed45f2b-c48b-419e-8e46-64d5ff680b0d");
var NETWORK_TYPE = Id("fca08431-1aa1-40f2-8a4d-0743c2a59df7");
var GEO_LOCATION_PROPERTY = Id("7cfc4990-e068-4b77-98aa-834137d02953");
var GOALS_PROPERTY = Id("eddd99d6-2033-4651-b046-2cecd1bd6ca5");
var GOAL_TYPE = Id("0fecaded-7c58-4a71-9a02-e1cb49800e27");
var MEMBERSHIP_CONTRACT_ADDRESS = Id("62f5aa2f-34ca-47c0-bcfc-a937396676dd");
var MISSION_PROPERTY = Id("e4ed96e6-92cf-42c4-967b-ab2cef56f889");
var PLACEHOLDER_IMAGE = Id("6c49012e-21fd-4b35-b976-60210ea0ae0f");
var PLACEHOLDER_TEXT = Id("503e9e78-8669-4243-9777-af8fb75cdc56");
var TAB_TYPE = Id("306a88ec-1960-4328-8cdb-77c23de2785a");
var ROLE_PROPERTY = Id("e4e366e9-d555-4b68-92bf-7358e824afd2");
var DEFAULT_TYPE = Id("36ea5723-0851-4012-945e-90d05f0e54e9");
var BROADER_CLAIMS_PROPERTY = Id("c682b9a5-82b3-4345-abc9-1c31cd09a253");
var CLAIMS_FROM_PROPERTY = Id("8ebf2fe7-270b-4a7e-806d-e481c8c058d0");
var DEFINITIONS_PROPERTY = Id("08abac45-2e19-4cb6-afaa-5e11a31eea99");
var EMAIL_PROPERTY = Id("0b63fdea-d04d-4985-8f18-f97995926e6e");
var FOREIGN_TYPES = Id("c2a3dd99-bd57-4593-a801-882e8280b94c");
var NONPROFIT_CATEGORIES_PROPERTY = Id("29094591-c312-43c4-9c4a-0c2eb5063e2c");
var PHONE_NUMBER_PROPERTY = Id("1840e2d2-487f-42a0-9265-f7e7a4752a75");
var QUOTES_PROPERTY = Id("f7286c68-3412-4673-bd58-c25450ab53f9");
var REGION_PROPERTY = Id("5b33846f-4742-49f9-86e5-7009978019a7");
var RELATED_TOPICS_PROPERTY = Id("cc42b16e-956e-4451-a304-5f27e1c3ed11");
var RELEVANT_QUESTIONS_PROPERTY = Id("b897ab9e-6409-473c-9071-0a34f3da537b");
var SPEAKERS_PROPERTY = Id("4725dae3-1163-4c87-8e87-dcf159e385a6");
var STREET_ADDRESS_PROPERTY = Id("3ed2eb81-20b1-488c-90f5-c84f58535083");
var SUBCLAIMS_PROPERTY = Id("09cf4adf-d8e8-4b2e-8cd1-48a3d9a24ac2");
var VALUES_PROPERTY = Id("15183b43-6f73-46b2-812d-edbe1de78343");
var VISION_PROPERTY = Id("4a306614-0c75-416c-a347-d36b3cc9c031");
var CURRENCY_PROPERTY = Id("9291e563-afbe-4709-8780-a52cbb0f4aa9");
var CURRENCY_SIGN_PROPERTY = Id("d9ada086-52e3-4b66-8893-0ccf2f9fd9ea");
var CURRENCY_SYMBOL_PROPERTY = Id("ace1e96c-9b83-47b4-bd33-1d302ec0a0f5");
var CURRENCY_USD_PROPERTY = Id("0d4d1b02-a9e8-4982-92c4-99b1d22cd430");
var CURRENCY_GBP_PROPERTY = Id("95593310-1e7c-43da-a02c-a6f4b630d48a");
var CURRENCY_EUR_PROPERTY = Id("6d5a3fed-379c-4889-b60e-d6265a482c93");
var ROOT_SPACE_ID = Id("08c4f093-7858-4b7c-9b94-b82e448abcff");

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-relation.js
var createRelation = ({ id: providedId, fromEntity, toEntity, position, toSpace, type: type8, entityId: providedEntityId, entityName, entityDescription, entityCover, entityValues, entityRelations, entityTypes }) => {
  if (providedId)
    assertValid(providedId, "`id` in `createRelation`");
  if (fromEntity)
    assertValid(fromEntity, "`fromEntity` in `createRelation`");
  if (toEntity)
    assertValid(toEntity, "`toEntity` in `createRelation`");
  if (toSpace)
    assertValid(toSpace, "`toSpace` in `createRelation`");
  if (type8)
    assertValid(type8, "`type` in `createRelation`");
  if (providedEntityId)
    assertValid(providedEntityId, "`entityId` in `createRelation`");
  if (entityCover)
    assertValid(entityCover, "`entityCover` in `createRelation`");
  for (const [key] of Object.entries(entityValues ?? {})) {
    assertValid(key, "`entityValues` in `createRelation`");
  }
  for (const [key] of Object.entries(entityRelations ?? {})) {
    assertValid(key, "`entityRelations` in `createRelation`");
  }
  for (const type9 of entityTypes ?? []) {
    assertValid(type9, "`entityTypes` in `createRelation`");
  }
  const id3 = providedId ?? generate();
  const entityId = providedEntityId ?? generate();
  const ops = [];
  ops.push({
    type: "CREATE_RELATION",
    relation: {
      id: Id(id3),
      entity: Id(entityId),
      fromEntity: Id(fromEntity),
      position,
      toEntity: Id(toEntity),
      toSpace: toSpace ? Id(toSpace) : void 0,
      type: Id(type8)
    }
  });
  if (entityName || entityDescription || entityCover || entityValues || entityRelations || entityTypes) {
    const { ops: entityOps } = createEntity({
      id: entityId,
      name: entityName,
      description: entityDescription,
      cover: entityCover,
      values: entityValues,
      relations: entityRelations,
      types: entityTypes
    });
    ops.push(...entityOps);
  }
  return { id: Id(id3), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-entity.js
var createEntity = ({ id: providedId, name, description, cover, values: values15, relations, types: types3 }) => {
  if (providedId)
    assertValid(providedId, "`id` in `createEntity`");
  if (cover)
    assertValid(cover, "`cover` in `createEntity`");
  for (const valueEntry of values15 ?? []) {
    assertValid(valueEntry.property, "`values` in `createEntity`");
    if (valueEntry.options) {
      const optionsParam = valueEntry.options;
      switch (optionsParam.type) {
        case "text":
          if (optionsParam.language) {
            assertValid(optionsParam.language, "`language` in `options` in `values` in `createEntity`");
          }
          break;
        case "number":
          if (optionsParam.unit) {
            assertValid(optionsParam.unit, "`unit` in `options` in `values` in `createEntity`");
          }
          break;
        default:
          throw new Error(`Invalid option type: ${optionsParam.type}`);
      }
    }
    for (const [key, relationEntry] of Object.entries(relations ?? {})) {
      assertValid(key, "`relations` in `createEntity`");
      if (Array.isArray(relationEntry)) {
        for (const relation of relationEntry) {
          assertValid(relation.toEntity, "`toEntity` in `relations` in `createEntity`");
          if (relation.toSpace)
            assertValid(relation.toSpace, "`toSpace` in `relations` in `createEntity`");
          if (relation.fromSpace)
            assertValid(relation.fromSpace, "`fromSpace` in `relations` in `createEntity`");
          if (relation.fromVersion)
            assertValid(relation.fromVersion, "`fromVersion` in `relations` in `createEntity`");
          if (relation.toVersion)
            assertValid(relation.toVersion, "`toVersion` in `relations` in `createEntity`");
          if (relation.entityId)
            assertValid(relation.entityId, "`entityId` in `relations` in `createEntity`");
          if (relation.entityCover)
            assertValid(relation.entityCover, "`entityCover` in `relations` in `createEntity`");
        }
      } else {
        assertValid(relationEntry.toEntity, "`toEntity` in `relations` in `createEntity`");
        if (relationEntry.toSpace)
          assertValid(relationEntry.toSpace, "`toSpace` in `relations` in `createEntity`");
        if (relationEntry.fromSpace)
          assertValid(relationEntry.fromSpace, "`fromSpace` in `relations` in `createEntity`");
        if (relationEntry.fromVersion)
          assertValid(relationEntry.fromVersion, "`fromVersion` in `relations` in `createEntity`");
        if (relationEntry.toVersion)
          assertValid(relationEntry.toVersion, "`toVersion` in `relations` in `createEntity`");
        if (relationEntry.entityId)
          assertValid(relationEntry.entityId, "`entityId` in `relations` in `createEntity`");
        if (relationEntry.entityCover)
          assertValid(relationEntry.entityCover, "`entityCover` in `relations` in `createEntity`");
      }
    }
  }
  for (const typeId of types3 ?? []) {
    assertValid(typeId, "`types` in `createEntity`");
  }
  const id3 = providedId ?? generate();
  let ops = [];
  const newValues = [];
  if (name) {
    newValues.push({
      property: NAME_PROPERTY,
      value: name
    });
  }
  if (description) {
    newValues.push({
      property: DESCRIPTION_PROPERTY,
      value: description
    });
  }
  for (const valueEntry of values15 ?? []) {
    let options = void 0;
    if (valueEntry.options) {
      const optionsParam = valueEntry.options;
      switch (optionsParam.type) {
        case "text":
          options = {
            text: {
              language: optionsParam.language
            }
          };
          break;
        case "number":
          options = {
            number: {
              unit: optionsParam.unit
            }
          };
          break;
      }
    }
    newValues.push({
      property: Id(valueEntry.property),
      value: valueEntry.value,
      options
    });
  }
  const op = {
    type: "UPDATE_ENTITY",
    entity: {
      id: Id(id3),
      values: newValues
    }
  };
  ops.push(op);
  if (cover) {
    ops.push({
      type: "CREATE_RELATION",
      relation: {
        id: generate(),
        entity: generate(),
        fromEntity: Id(id3),
        toEntity: Id(cover),
        type: COVER_PROPERTY
      }
    });
  }
  if (types3) {
    for (const typeId of types3) {
      ops.push({
        type: "CREATE_RELATION",
        relation: {
          id: generate(),
          entity: generate(),
          fromEntity: Id(id3),
          toEntity: Id(typeId),
          type: TYPES_PROPERTY
        }
      });
    }
  }
  for (const [typeId, value10] of Object.entries(relations ?? {})) {
    const relationsEntries = Array.isArray(value10) ? value10 : [value10];
    for (const relation of relationsEntries) {
      const relationId = relation.id ?? generate();
      const relationEntityId = relation.entityId ?? generate();
      const { ops: relationOps } = createRelation({
        id: relationId,
        fromEntity: id3,
        toEntity: relation.toEntity,
        type: Id(typeId),
        position: relation.position,
        toSpace: relation.toSpace,
        entityId: relationEntityId,
        entityName: relation.entityName,
        entityDescription: relation.entityDescription,
        entityCover: relation.entityCover,
        entityValues: relation.entityValues,
        entityRelations: relation.entityRelations,
        entityTypes: relation.entityTypes
      });
      ops = ops.concat(relationOps);
    }
  }
  return { id: Id(id3), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/core/get-checksum-address.js
function getChecksumAddress(address) {
  return getAddress(address);
}

// node_modules/@graphprotocol/grc-20/dist/src/core/ids/network.js
var network_exports = {};
__export(network_exports, {
  ETHEREUM: () => ETHEREUM,
  GEO: () => GEO,
  POLYGON: () => POLYGON
});
var POLYGON = Id("0370cdbd-57a9-46e9-a511-9c0c1ffc69d7");
var ETHEREUM = Id("90061c99-7659-42c3-b9d9-edbf6b834487");
var GEO = Id("943e38b9-e304-4300-866c-06af4e3c298a");

// node_modules/@graphprotocol/grc-20/dist/src/core/account.js
function make151(address) {
  const accountId = generate();
  const checkedAddress = getChecksumAddress(address);
  const ops = [];
  const { ops: entityOps } = createEntity({
    id: accountId,
    values: [
      {
        property: ADDRESS_PROPERTY,
        value: checkedAddress
      },
      {
        property: NAME_PROPERTY,
        value: checkedAddress
      }
    ]
  });
  ops.push(...entityOps);
  const { ops: accountOps } = createRelation({
    fromEntity: accountId,
    type: TYPES_PROPERTY,
    toEntity: ACCOUNT_TYPE
  });
  ops.push(...accountOps);
  const { ops: networkOps } = createRelation({
    fromEntity: accountId,
    type: NETWORK_PROPERTY,
    toEntity: ETHEREUM
  });
  ops.push(...networkOps);
  return {
    accountId,
    ops
  };
}

// node_modules/@graphprotocol/grc-20/dist/src/core/blocks/data.js
var data_exports2 = {};
__export(data_exports2, {
  make: () => make152
});

// node_modules/@graphprotocol/grc-20/dist/src/graph/update-entity.js
var updateEntity = ({ id: id3, name, description, cover, values: values15 }) => {
  assertValid(id3, "`id` in `updateEntity`");
  if (cover)
    assertValid(cover, "`cover` in `updateEntity`");
  for (const { property: property2, options } of values15 ?? []) {
    assertValid(property2, "`values` in `updateEntity`");
    if (options) {
      switch (options.type) {
        case "text":
          if (options.language) {
            assertValid(options.language, "`language` in `options` in `values` in `createEntity`");
          }
          break;
        case "number":
          if (options.unit) {
            assertValid(options.unit, "`unit` in `options` in `values` in `createEntity`");
          }
          break;
        default:
          throw new Error(`Invalid option type: ${options.type}`);
      }
    }
  }
  const ops = [];
  const newValues = [];
  if (name) {
    newValues.push({
      property: NAME_PROPERTY,
      value: name
    });
  }
  if (description) {
    newValues.push({
      property: DESCRIPTION_PROPERTY,
      value: description
    });
  }
  for (const valueEntry of values15 ?? []) {
    let options = void 0;
    if (valueEntry.options) {
      const optionsParam = valueEntry.options;
      switch (optionsParam.type) {
        case "text":
          options = {
            text: {
              language: optionsParam.language
            }
          };
          break;
        case "number":
          options = {
            number: {
              unit: optionsParam.unit
            }
          };
          break;
      }
    }
    newValues.push({
      property: Id(valueEntry.property),
      value: valueEntry.value,
      options
    });
  }
  const op = {
    type: "UPDATE_ENTITY",
    entity: {
      id: Id(id3),
      values: newValues
    }
  };
  ops.push(op);
  if (cover) {
    ops.push({
      type: "CREATE_RELATION",
      relation: {
        id: generate(),
        entity: generate(),
        fromEntity: Id(id3),
        toEntity: Id(cover),
        type: COVER_PROPERTY
      }
    });
  }
  return { id: Id(id3), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/core/ids/content.js
var content_exports = {};
__export(content_exports, {
  ARTICLE_TYPE: () => ARTICLE_TYPE,
  AUTHORS_PROPERTY: () => AUTHORS_PROPERTY,
  AVATAR_PROPERTY: () => AVATAR_PROPERTY,
  BROADER_GOALS_PROPERTY: () => BROADER_GOALS_PROPERTY,
  BROADER_PROJECTS_PROPERTY: () => BROADER_PROJECTS_PROPERTY,
  BROADER_TOPICS_PROPERTY: () => BROADER_TOPICS_PROPERTY,
  CITIES_PROPERTY: () => CITIES_PROPERTY,
  CITY_TYPE: () => CITY_TYPE,
  CLAIM_TYPE: () => CLAIM_TYPE,
  CONTINENTS_PROPERTY: () => CONTINENTS_PROPERTY,
  CONTINENT_TYPE: () => CONTINENT_TYPE,
  COUNTRIES_PROPERTY: () => COUNTRIES_PROPERTY,
  COUNTRY_TYPE: () => COUNTRY_TYPE,
  DISCLAIMER_PROPERTY: () => DISCLAIMER_PROPERTY,
  EVENT_DATE_PROPERTY: () => EVENT_DATE_PROPERTY,
  GOAL_TYPE: () => GOAL_TYPE2,
  HIGHLIGHTED_RELATED_ENTIRIES_PROPERTY: () => HIGHLIGHTED_RELATED_ENTIRIES_PROPERTY,
  JOB_TYPE: () => JOB_TYPE,
  LOCATION_PROPERTY: () => LOCATION_PROPERTY,
  NEWS_EVENT_TYPE: () => NEWS_EVENT_TYPE,
  NEWS_STORY_TYPE: () => NEWS_STORY_TYPE,
  OPPOSING_ARGUMENTS_PROPERTY: () => OPPOSING_ARGUMENTS_PROPERTY,
  OWNERS_PROPERTY: () => OWNERS_PROPERTY,
  PERSON_PROPERTY: () => PERSON_PROPERTY,
  POLICY_TYPE: () => POLICY_TYPE,
  PRINCIPLE_TYPE: () => PRINCIPLE_TYPE,
  PROJECT_PROPERTY: () => PROJECT_PROPERTY,
  PUBLISHER_PROPERTY: () => PUBLISHER_PROPERTY,
  PUBLISHER_TYPE: () => PUBLISHER_TYPE,
  PUBLISH_DATE_PROPERTY: () => PUBLISH_DATE_PROPERTY,
  QUOTES_THAT_SUPPORT_CLAIMS_PROPERTY: () => QUOTES_THAT_SUPPORT_CLAIMS_PROPERTY,
  QUOTE_TYPE: () => QUOTE_TYPE,
  REGION_TYPE: () => REGION_TYPE2,
  RELATED_ENTITIES_PROPERTY: () => RELATED_ENTITIES_PROPERTY,
  RELATED_PEOPLE_PROPERTY: () => RELATED_PEOPLE_PROPERTY,
  RELATED_PROJECTS_PROPERTY: () => RELATED_PROJECTS_PROPERTY,
  RELATED_SPACES_PROPERTY: () => RELATED_SPACES_PROPERTY,
  RELATED_TOPICS_PROPERTY: () => RELATED_TOPICS_PROPERTY2,
  ROLES_PROPERTY: () => ROLES_PROPERTY,
  SKILLS_PROPERTY: () => SKILLS_PROPERTY,
  SKILL_TYPE: () => SKILL_TYPE,
  SOURCES_PROPERTY: () => SOURCES_PROPERTY,
  SUBGOALS_PROPERTY: () => SUBGOALS_PROPERTY,
  SUBPROJECTS_PROPERTY: () => SUBPROJECTS_PROPERTY,
  SUBTOPICS_PROPERTY: () => SUBTOPICS_PROPERTY,
  SUPPORTING_ARGUMENTS_PROPERTY: () => SUPPORTING_ARGUMENTS_PROPERTY,
  TAG_TYPE: () => TAG_TYPE,
  TOPICS_PROPERTY: () => TOPICS_PROPERTY,
  TOPIC_TYPE: () => TOPIC_TYPE,
  VALUE_TYPE: () => VALUE_TYPE,
  WEBSITE_PROPERTY: () => WEBSITE_PROPERTY,
  WEB_ARCHIVE_URL_PROPERTY: () => WEB_ARCHIVE_URL_PROPERTY,
  WEB_URL_PROPERTY: () => WEB_URL_PROPERTY,
  X_PROPERTY: () => X_PROPERTY
});
var ARTICLE_TYPE = Id("a2a5ed0c-acef-46b1-835d-e457956ce915");
var CITY_TYPE = Id("01b05333-941a-4b00-bc78-fac5a15b467d");
var CLAIM_TYPE = Id("96f859ef-a1ca-4b22-9372-c86ad58b694b");
var CONTINENT_TYPE = Id("3317d044-a700-4a9d-bbaf-4c16ade42f76");
var COUNTRY_TYPE = Id("42a0a761-8c82-459f-ad08-34bfeb437cde");
var GOAL_TYPE2 = Id("1845ee99-80c6-48a3-abc3-809de1753c63");
var JOB_TYPE = Id("5ab7946f-82bc-4289-9d02-a5f13bd40935");
var NEWS_EVENT_TYPE = Id("bb9a85bd-6dc6-4efd-8232-e2782cb4b5f8");
var NEWS_STORY_TYPE = Id("e550fe51-7e90-4b2c-8fff-df13408f5634");
var POLICY_TYPE = Id("7f237bdd-d95f-4d3f-8686-f52a5dd29386");
var PUBLISHER_TYPE = Id("531ac4c5-e409-46ad-9dd3-abcd2db955a0");
var QUOTE_TYPE = Id("043a171c-6918-4dc3-a7db-b8471ca6fcc2");
var REGION_TYPE2 = Id("c188844a-7224-42ab-b476-2991c9c913f1");
var SKILL_TYPE = Id("9ca6ab1f-3a11-4e49-bbaf-72e0c9a985cf");
var TAG_TYPE = Id("e0fcc66c-9e86-43f4-8080-2469d8a1a93a");
var TOPIC_TYPE = Id("5ef5a586-0f27-4d8e-8f6c-59ae5b3e89e2");
var AVATAR_PROPERTY = Id("1155beff-fad5-49b7-a2e0-da4777b8792c");
var BROADER_GOALS_PROPERTY = Id("7072d8d0-3136-4993-9ae5-dacae05e25f9");
var SUBGOALS_PROPERTY = Id("ef0edbba-6987-4057-b616-836483df2344");
var DISCLAIMER_PROPERTY = Id("2877c1c3-d2ad-493f-abe7-6e1bb16e1c37");
var EVENT_DATE_PROPERTY = Id("52665f3e-fb7d-48d5-8b6b-abb21b0d36db");
var RELATED_PEOPLE_PROPERTY = Id("5df8e432-9cc5-4f03-8f85-4ac82e157ada");
var SKILLS_PROPERTY = Id("a38732e3-3a3d-47f9-a459-fb369c287709");
var ROLES_PROPERTY = Id("8fcfe5ef-3d91-47bd-8322-3830a998d26b");
var HIGHLIGHTED_RELATED_ENTIRIES_PROPERTY = Id("0a62474e-3a3f-4c86-b507-6ea582439dd1");
var PUBLISHER_PROPERTY = Id("9ec2b47e-4819-47c0-a99e-8ddb27a3ed8e");
var AUTHORS_PROPERTY = Id("91a9e2f6-e51a-48f7-9976-61de8561b690");
var WEB_ARCHIVE_URL_PROPERTY = Id("54aa3b25-c45d-4974-a937-6bb895aeaefe");
var PUBLISH_DATE_PROPERTY = Id("94e43fe8-faf2-4100-9eb8-87ab4f999723");
var OWNERS_PROPERTY = Id("c9ed4b4b-7294-4eda-9a03-a7975cd1651e");
var SOURCES_PROPERTY = Id("49c5d5e1-679a-4dbd-bfd3-3f618f227c94");
var QUOTES_THAT_SUPPORT_CLAIMS_PROPERTY = Id("f1576465-b8d1-479f-913c-9149fe0bd15e");
var OPPOSING_ARGUMENTS_PROPERTY = Id("4e6ec5d1-4292-498a-84e5-f607ca1a08ce");
var SUPPORTING_ARGUMENTS_PROPERTY = Id("1dc6a843-4588-4819-8e7a-6e672268f811");
var WEBSITE_PROPERTY = Id("eed38e74-e679-46bf-8a42-ea3e4f8fb5fb");
var BROADER_PROJECTS_PROPERTY = Id("28b3ee04-c2b9-46c3-bb9d-4c450e0f26fd");
var SUBPROJECTS_PROPERTY = Id("83240c7c-1a9b-4332-bbb5-67a76e02c003");
var TOPICS_PROPERTY = Id("458fbc07-0dbf-4c92-8f57-16f3fdde7c32");
var RELATED_ENTITIES_PROPERTY = Id("dfa6aebe-1ca9-4bf2-9fac-cc4cc7afb24c");
var X_PROPERTY = Id("0d625978-4b3c-4b57-a86f-de45c997c73c");
var CITIES_PROPERTY = Id("2282fece-7494-40d6-bcdc-aad2355c40fb");
var LOCATION_PROPERTY = Id("95d77002-1faf-4f7c-b7de-b21a7d48cda0");
var WEB_URL_PROPERTY = Id("412ff593-e915-4012-a43d-4c27ec5c68b6");
var SUBTOPICS_PROPERTY = Id("39e40cad-b23d-4f63-ab2f-aea1596436c7");
var RELATED_TOPICS_PROPERTY2 = Id("806d52bc-27e9-4c91-93c0-57978b093351");
var COUNTRIES_PROPERTY = Id("c4c88260-ea3a-4498-a2f9-be340a19758e");
var BROADER_TOPICS_PROPERTY = Id("b35bd6d3-9fb6-4f3a-8aea-f5a9b91b5ef6");
var RELATED_PROJECTS_PROPERTY = Id("6e3503fa-b974-460e-a3db-ab8af9a41427");
var CONTINENTS_PROPERTY = Id("1c5b7c0a-d187-425e-885c-2980d9db6b4b");
var PERSON_PROPERTY = Id("eb1141ae-ba35-43df-acdd-3329cccd8121");
var PROJECT_PROPERTY = Id("e3a96728-2b09-4af7-9af7-86ef1aa7837e");
var RELATED_SPACES_PROPERTY = Id("5b722cd3-61d6-494e-8887-1310566437ba");
var VALUE_TYPE = Id("fb1551b2-1816-46eb-8919-c73253c32022");
var PRINCIPLE_TYPE = Id("0f526048-26cf-40d6-8bab-967e5fb1a08a");

// node_modules/@graphprotocol/grc-20/dist/src/core/blocks/data.js
function getSourceTypeId(sourceType) {
  switch (sourceType) {
    case "COLLECTION":
      return system_exports.COLLECTION_DATA_SOURCE;
    case "GEO":
      return system_exports.ALL_OF_GEO_DATA_SOURCE;
    case "QUERY":
      return system_exports.QUERY_DATA_SOURCE;
  }
}
function make152({ fromId, sourceType, position, name }) {
  const newBlockId = generate();
  const ops = [];
  const { ops: dataBlockTypeOps } = createRelation({
    fromEntity: newBlockId,
    type: TYPES_PROPERTY,
    toEntity: DATA_BLOCK
  });
  ops.push(...dataBlockTypeOps);
  const { ops: dataBlockSourceTypeOps } = createRelation({
    fromEntity: newBlockId,
    type: DATA_SOURCE_TYPE_RELATION_TYPE,
    toEntity: getSourceTypeId(sourceType)
  });
  ops.push(...dataBlockSourceTypeOps);
  const { ops: dataBlockRelationOps } = createRelation({
    fromEntity: Id(fromId),
    type: BLOCKS,
    toEntity: Id(newBlockId),
    position
  });
  ops.push(...dataBlockRelationOps);
  if (name) {
    const { ops: nameOps } = updateEntity({
      id: newBlockId,
      values: [
        {
          property: NAME_PROPERTY,
          value: name
        }
      ]
    });
    ops.push(...nameOps);
  }
  return ops;
}

// node_modules/@graphprotocol/grc-20/dist/src/core/blocks/text.js
var text_exports = {};
__export(text_exports, {
  make: () => make153
});
function make153({ fromId, text, position }) {
  const newBlockId = generate();
  const ops = [];
  const { ops: textBlockTypeOps } = createRelation({
    fromEntity: newBlockId,
    type: TYPES_PROPERTY,
    toEntity: TEXT_BLOCK
  });
  ops.push(...textBlockTypeOps);
  const { ops: textBlockMarkdownTextOps } = updateEntity({
    id: newBlockId,
    values: [
      {
        property: MARKDOWN_CONTENT,
        value: text
      }
    ]
  });
  ops.push(...textBlockMarkdownTextOps);
  const { ops: textBlockRelationOps } = createRelation({
    fromEntity: Id(fromId),
    type: BLOCKS,
    toEntity: newBlockId,
    position
  });
  ops.push(...textBlockRelationOps);
  return ops;
}

// node_modules/@graphprotocol/grc-20/dist/src/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  getEditCalldata: () => getEditCalldata
});

// node_modules/@graphprotocol/grc-20/dist/src/graph/constants.js
var MAINNET_API_ORIGIN = "https://hypergraph-v2.up.railway.app";
var TESTNET_API_ORIGIN = "https://hypergraph-v2-testnet.up.railway.app";

// node_modules/@graphprotocol/grc-20/dist/src/encoding.js
var GetEditCalldataError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "_tag", "GetEditCalldataError");
  }
};
async function getEditCalldata(params) {
  const getCalldata = Micro_exports.gen(function* () {
    const result = yield* Micro_exports.tryPromise({
      try: () => fetch(`${params.network === "TESTNET" ? TESTNET_API_ORIGIN : MAINNET_API_ORIGIN}/space/${params.spaceId}/edit/calldata`, {
        method: "POST",
        body: JSON.stringify({ cid: params.cid })
      }),
      catch: (error4) => new GetEditCalldataError(`Could not get edit calldata from space ${params.spaceId}: ${error4}`)
    });
    const calldata = yield* Micro_exports.tryPromise({
      try: async () => {
        const { to: to3, data } = await result.json();
        return {
          to: to3,
          data
        };
      },
      catch: (error4) => new GetEditCalldataError(`Could not parse response from API when getting calldata for space ${params.spaceId}: ${error4}`)
    });
    return calldata;
  });
  return await Micro_exports.runPromise(getCalldata);
}

// node_modules/@graphprotocol/grc-20/dist/src/graph/index.js
var graph_exports = {};
__export(graph_exports, {
  createEntity: () => createEntity,
  createImage: () => createImage,
  createProperty: () => createProperty,
  createRelation: () => createRelation,
  createSpace: () => createSpace,
  createType: () => createType,
  deleteRelation: () => deleteRelation,
  serializeCheckbox: () => serializeCheckbox,
  serializeDate: () => serializeDate,
  serializeNumber: () => serializeNumber,
  serializePoint: () => serializePoint,
  unsetEntityValues: () => unsetEntityValues,
  unsetRelationFields: () => unsetRelationFields,
  updateEntity: () => updateEntity
});

// node_modules/@graphprotocol/grc-20/dist/src/ipfs.js
var ipfs_exports = {};
__export(ipfs_exports, {
  publishEdit: () => publishEdit,
  uploadCSV: () => uploadCSV,
  uploadImage: () => uploadImage
});

// node_modules/fflate/esm/browser.js
var ch2 = {};
var wk = function(c, id3, msg, transfer, cb) {
  var w = new Worker(ch2[id3] || (ch2[id3] = URL.createObjectURL(new Blob([
    c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
  ], { type: "text/javascript" }))));
  w.onmessage = function(e) {
    var d = e.data, ed = d.$e$;
    if (ed) {
      var err2 = new Error(ed[0]);
      err2["code"] = ed[1];
      err2.stack = ed[2];
      cb(err2, null);
    } else
      cb(null, d);
  };
  w.postMessage(msg, transfer);
  return w;
};
var u82 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u82([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u82([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u82([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start5) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start5 += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a105 = freb(fleb, 2);
var fl = _a105.b;
var revfl = _a105.r;
fl[28] = 258, revfl[258] = 28;
var _b31 = freb(fdeb, 0);
var fd = _b31.b;
var revfd = _b31.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
};
var flt = new u82(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u82(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flm = hMap(flt, 9, 0);
var flrm = hMap(flt, 9, 1);
var fdm = hMap(fdt, 5, 0);
var fdrm = hMap(fdt, 5, 1);
var max13 = function(a) {
  var m = a[0];
  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u82(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u82(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u82(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u82(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type8 = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type8) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type8 == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type8 == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u82(tl);
        var clt = new u82(19);
        for (var i = 0; i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max13(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0; i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max13(lt);
        dbt = max13(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add14 = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add14 = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end7 = bt + add14;
        if (bt < dt) {
          var shift2 = dl - dt, dend = Math.min(dt, end7);
          if (shift2 + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift2 + bt];
        }
        for (; bt < end7; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
  d[o + 2] |= v >> 16;
};
var hTree = function(d, mb) {
  var t = [];
  for (var i = 0; i < d.length; ++i) {
    if (d[i])
      t.push({ s: i, f: d[i] });
  }
  var s = t.length;
  var t2 = t.slice();
  if (!s)
    return { t: et, l: 0 };
  if (s == 1) {
    var v = new u82(t[0].s + 1);
    v[t[0].s] = 1;
    return { t: v, l: 1 };
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({ s: -1, f: 25001 });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
  t[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t2[0].s;
  for (var i = 1; i < s; ++i) {
    if (t2[i].s > maxSym)
      maxSym = t2[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i < s; ++i) {
      var i2_1 = t2[i].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i;
    }
    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u82(tr), l: mbt };
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i];
    }
  }
  return { c: cl.subarray(0, cli), n: s };
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i = 0; i < cl.length; ++i)
    l += cf[i] * cl[i];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    out[o + i + 4] = dat[i];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a106 = hTree(lf, 15), dlt = _a106.t, mlb = _a106.l;
  var _b32 = hTree(df, 15), ddt = _b32.t, mdb = _b32.l;
  var _c7 = lc(dlt), lclt = _c7.c, nlc = _c7.n;
  var _d4 = lc(ddt), lcdt = _d4.c, ndc = _d4.n;
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i)
    ++lcfreq[lclt[i] & 31];
  for (var i = 0; i < lcdt.length; ++i)
    ++lcfreq[lcdt[i] & 31];
  var _e2 = hTree(lcfreq, 7), lct = _e2.t, mlcb = _e2.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i = 0; i < nlcc; ++i)
      wbits(out, p + 3 * i, lct[clim[i]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    var sym = syms[i];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = new u82(0);
var dflt = function(dat, lvl, plvl, pre2, post, st) {
  var s = st.z || dat.length;
  var o = new u82(pre2 + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
  var w = o.subarray(pre2, o.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n = opt >> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head13 = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (; i + 2 < s; ++i) {
      var hv = hsh(i);
      var imod = i & 32767, pimod = head13[hv];
      prev[imod] = pimod;
      head13[hv] = imod;
      if (wi <= i) {
        var rem = s - i;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    for (i = Math.max(i, wi); i < s; ++i) {
      syms[li++] = dat[i];
      ++lf[dat[i]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head13, st.p = prev, st.i = i, st.w = wi;
    }
  } else {
    for (var i = st.w || 0; i < s + lst; i += 65535) {
      var e = i + 65535;
      if (e >= s) {
        w[pos / 8 | 0] = lst;
        e = s;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i, e));
    }
    st.i = s;
  }
  return slc(o, 0, pre2 + shft(pos) + post);
};
var crct = function() {
  var t = new Int32Array(256);
  for (var i = 0; i < 256; ++i) {
    var c = i, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t[i] = c;
  }
  return t;
}();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i = 0; i < d.length; ++i)
        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var adler = function() {
  var a = 1, b = 0;
  return {
    p: function(d) {
      var n = a, m = b;
      var l = d.length | 0;
      for (var i = 0; i != l; ) {
        var e = Math.min(i + 2655, l);
        for (; i < e; ++i)
          m += n += d[i];
        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }
      a = n, b = m;
    },
    d: function() {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | (a & 65280) << 8 | (b & 255) << 8 | b >> 8;
    }
  };
};
var dopt = function(dat, opt, pre2, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u82(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre2, post, st);
};
var mrg = function(a, b) {
  var o = {};
  for (var k in a)
    o[k] = a[k];
  for (var k in b)
    o[k] = b[k];
  return o;
};
var wcln = function(fn2, fnStr, td2) {
  var dt = fn2();
  var st = fn2.toString();
  var ks = st.slice(st.indexOf("[") + 1, st.lastIndexOf("]")).replace(/\s+/g, "").split(",");
  for (var i = 0; i < dt.length; ++i) {
    var v = dt[i], k = ks[i];
    if (typeof v == "function") {
      fnStr += ";" + k + "=";
      var st_1 = v.toString();
      if (v.prototype) {
        if (st_1.indexOf("[native code]") != -1) {
          var spInd = st_1.indexOf(" ", 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf("(", spInd));
        } else {
          fnStr += st_1;
          for (var t in v.prototype)
            fnStr += ";" + k + ".prototype." + t + "=" + v.prototype[t].toString();
        }
      } else
        fnStr += st_1;
    } else
      td2[k] = v;
  }
  return fnStr;
};
var ch = [];
var cbfs = function(v) {
  var tl = [];
  for (var k in v) {
    if (v[k].buffer) {
      tl.push((v[k] = new v[k].constructor(v[k])).buffer);
    }
  }
  return tl;
};
var wrkr = function(fns, init3, id3, cb) {
  if (!ch[id3]) {
    var fnStr = "", td_1 = {}, m = fns.length - 1;
    for (var i = 0; i < m; ++i)
      fnStr = wcln(fns[i], fnStr, td_1);
    ch[id3] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
  }
  var td2 = mrg({}, ch[id3].e);
  return wk(ch[id3].c + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + init3.toString() + "}", id3, td2, cbfs(td2), cb);
};
var bInflt = function() {
  return [u82, u16, i32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, ec, hMap, max13, bits, bits16, shft, slc, err, inflt, inflateSync, pbf, gopt];
};
var bDflt = function() {
  return [u82, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
};
var guze = function() {
  return [gzs, gzl];
};
var zule = function() {
  return [zls];
};
var pbf = function(msg) {
  return postMessage(msg, [msg.buffer]);
};
var gopt = function(o) {
  return o && {
    out: o.size && new u82(o.size),
    dictionary: o.dictionary
  };
};
var astrm = function(strm) {
  strm.ondata = function(dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };
  return function(ev) {
    if (ev.data.length) {
      strm.push(ev.data[0], ev.data[1]);
      postMessage([ev.data[0].length]);
    } else
      strm.flush();
  };
};
var astrmify = function(fns, strm, opts, init3, id3, flush, ext) {
  var t;
  var w = wrkr(fns, init3, id3, function(err2, dat) {
    if (err2)
      w.terminate(), strm.ondata.call(strm, err2);
    else if (!Array.isArray(dat))
      ext(dat);
    else if (dat.length == 1) {
      strm.queuedSize -= dat[0];
      if (strm.ondrain)
        strm.ondrain(dat[0]);
    } else {
      if (dat[1])
        w.terminate();
      strm.ondata.call(strm, err2, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);
  strm.queuedSize = 0;
  strm.push = function(d, f2) {
    if (!strm.ondata)
      err(5);
    if (t)
      strm.ondata(err(4, 0, 1), null, !!f2);
    strm.queuedSize += d.length;
    w.postMessage([d, t = f2], [d.buffer]);
  };
  strm.terminate = function() {
    w.terminate();
  };
  if (flush) {
    strm.flush = function() {
      w.postMessage([]);
    };
  }
};
var b2 = function(d, b) {
  return d[b] | d[b + 1] << 8;
};
var b4 = function(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};
var b8 = function(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
};
var wbytes = function(d, b, v) {
  for (; v; ++b)
    d[b] = v, v >>>= 8;
};
var gzh = function(c, o) {
  var fn2 = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
  if (o.mtime != 0)
    wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn2) {
    c[3] = 8;
    for (var i = 0; i <= fn2.length; ++i)
      c[i + 10] = fn2.charCodeAt(i);
  }
};
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var gzhl = function(o) {
  return 10 + (o.filename ? o.filename.length + 1 : 0);
};
var zlh = function(c, o) {
  var lv = o.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl2 << 6 | (o.dictionary && 32);
  c[1] |= 31 - (c[0] << 8 | c[1]) % 31;
  if (o.dictionary) {
    var h2 = adler();
    h2.p(o.dictionary);
    wbytes(c, 2, h2.d());
  }
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function StrmOpt(opts, cb) {
  if (typeof opts == "function")
    cb = opts, opts = {};
  this.ondata = cb;
  return opts;
}
var Deflate = function() {
  function Deflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
    this.s = { l: 0, i: 32768, w: 32768, z: 32768 };
    this.b = new u82(98304);
    if (this.o.dictionary) {
      var dict = this.o.dictionary.subarray(-32768);
      this.b.set(dict, 32768 - dict.length);
      this.s.i = 32768 - dict.length;
    }
  }
  Deflate2.prototype.p = function(c, f2) {
    this.ondata(dopt(c, this.o, 0, 0, this.s), f2);
  };
  Deflate2.prototype.push = function(chunk7, final) {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    var endLen = chunk7.length + this.s.z;
    if (endLen > this.b.length) {
      if (endLen > 2 * this.b.length - 32768) {
        var newBuf = new u82(endLen & -32768);
        newBuf.set(this.b.subarray(0, this.s.z));
        this.b = newBuf;
      }
      var split8 = this.b.length - this.s.z;
      this.b.set(chunk7.subarray(0, split8), this.s.z);
      this.s.z = this.b.length;
      this.p(this.b, false);
      this.b.set(this.b.subarray(-32768));
      this.b.set(chunk7.subarray(split8), 32768);
      this.s.z = chunk7.length - split8 + 32768;
      this.s.i = 32766, this.s.w = 32768;
    } else {
      this.b.set(chunk7, this.s.z);
      this.s.z += chunk7.length;
    }
    this.s.l = final & 1;
    if (this.s.z > this.s.w + 8191 || final) {
      this.p(this.b, final || false);
      this.s.w = this.s.i, this.s.i -= 2;
    }
  };
  Deflate2.prototype.flush = function() {
    if (!this.ondata)
      err(5);
    if (this.s.l)
      err(4);
    this.p(this.b, false);
    this.s.w = this.s.i, this.s.i -= 2;
  };
  return Deflate2;
}();
var AsyncDeflate = /* @__PURE__ */ function() {
  function AsyncDeflate2(opts, cb) {
    astrmify([
      bDflt,
      function() {
        return [astrm, Deflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6, 1);
  }
  return AsyncDeflate2;
}();
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var Inflate = function() {
  function Inflate2(opts, cb) {
    if (typeof opts == "function")
      cb = opts, opts = {};
    this.ondata = cb;
    var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);
    this.s = { i: 0, b: dict ? dict.length : 0 };
    this.o = new u82(32768);
    this.p = new u82(0);
    if (dict)
      this.o.set(dict);
  }
  Inflate2.prototype.e = function(c) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    if (!this.p.length)
      this.p = c;
    else if (c.length) {
      var n = new u82(this.p.length + c.length);
      n.set(this.p), n.set(c, this.p.length), this.p = n;
    }
  };
  Inflate2.prototype.c = function(final) {
    this.s.i = +(this.d = final || false);
    var bts = this.s.b;
    var dt = inflt(this.p, this.s, this.o);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  Inflate2.prototype.push = function(chunk7, final) {
    this.e(chunk7), this.c(final);
  };
  return Inflate2;
}();
var AsyncInflate = /* @__PURE__ */ function() {
  function AsyncInflate2(opts, cb) {
    astrmify([
      bInflt,
      function() {
        return [astrm, Inflate];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Inflate(ev.data);
      onmessage = astrm(strm);
    }, 7, 0);
  }
  return AsyncInflate2;
}();
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
var Gzip = function() {
  function Gzip2(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Gzip2.prototype.push = function(chunk7, final) {
    this.c.p(chunk7);
    this.l += chunk7.length;
    Deflate.prototype.push.call(this, chunk7, final);
  };
  Gzip2.prototype.p = function(c, f2) {
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f2 && 8, this.s);
    if (this.v)
      gzh(raw, this.o), this.v = 0;
    if (f2)
      wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f2);
  };
  Gzip2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Gzip2;
}();
function gzipSync(data, opts) {
  if (!opts)
    opts = {};
  var c = crc(), l = data.length;
  c.p(data);
  var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
  return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
var Gunzip = function() {
  function Gunzip2(opts, cb) {
    this.v = 1;
    this.r = 0;
    Inflate.call(this, opts, cb);
  }
  Gunzip2.prototype.push = function(chunk7, final) {
    Inflate.prototype.e.call(this, chunk7);
    this.r += chunk7.length;
    if (this.v) {
      var p = this.p.subarray(this.v - 1);
      var s = p.length > 3 ? gzs(p) : 4;
      if (s > p.length) {
        if (!final)
          return;
      } else if (this.v > 1 && this.onmember) {
        this.onmember(this.r - p.length);
      }
      this.p = p.subarray(s), this.v = 0;
    }
    Inflate.prototype.c.call(this, final);
    if (this.s.f && !this.s.l && !final) {
      this.v = shft(this.s.p) + 9;
      this.s = { i: 0 };
      this.o = new u82(0);
      this.push(new u82(0), final);
    }
  };
  return Gunzip2;
}();
var AsyncGunzip = /* @__PURE__ */ function() {
  function AsyncGunzip2(opts, cb) {
    var _this = this;
    astrmify([
      bInflt,
      guze,
      function() {
        return [astrm, Inflate, Gunzip];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Gunzip(ev.data);
      strm.onmember = function(offset) {
        return postMessage(offset);
      };
      onmessage = astrm(strm);
    }, 9, 0, function(offset) {
      return _this.onmember && _this.onmember(offset);
    });
  }
  return AsyncGunzip2;
}();
var Zlib = function() {
  function Zlib2(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  Zlib2.prototype.push = function(chunk7, final) {
    this.c.p(chunk7);
    Deflate.prototype.push.call(this, chunk7, final);
  };
  Zlib2.prototype.p = function(c, f2) {
    var raw = dopt(c, this.o, this.v && (this.o.dictionary ? 6 : 2), f2 && 4, this.s);
    if (this.v)
      zlh(raw, this.o), this.v = 0;
    if (f2)
      wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f2);
  };
  Zlib2.prototype.flush = function() {
    Deflate.prototype.flush.call(this);
  };
  return Zlib2;
}();
var Unzlib = function() {
  function Unzlib2(opts, cb) {
    Inflate.call(this, opts, cb);
    this.v = opts && opts.dictionary ? 2 : 1;
  }
  Unzlib2.prototype.push = function(chunk7, final) {
    Inflate.prototype.e.call(this, chunk7);
    if (this.v) {
      if (this.p.length < 6 && !final)
        return;
      this.p = this.p.subarray(zls(this.p, this.v - 1)), this.v = 0;
    }
    if (final) {
      if (this.p.length < 4)
        err(6, "invalid zlib data");
      this.p = this.p.subarray(0, -4);
    }
    Inflate.prototype.c.call(this, final);
  };
  return Unzlib2;
}();
var AsyncUnzlib = /* @__PURE__ */ function() {
  function AsyncUnzlib2(opts, cb) {
    astrmify([
      bInflt,
      zule,
      function() {
        return [astrm, Inflate, Unzlib];
      }
    ], this, StrmOpt.call(this, opts, cb), function(ev) {
      var strm = new Unzlib(ev.data);
      onmessage = astrm(strm);
    }, 11, 0);
  }
  return AsyncUnzlib2;
}();
var Decompress = function() {
  function Decompress2(opts, cb) {
    this.o = StrmOpt.call(this, opts, cb) || {};
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
  }
  Decompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(dat, final) {
      _this.ondata(dat, final);
    };
  };
  Decompress2.prototype.push = function(chunk7, final) {
    if (!this.ondata)
      err(5);
    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u82(this.p.length + chunk7.length);
        n.set(this.p), n.set(chunk7, this.p.length);
      } else
        this.p = chunk7;
      if (this.p.length > 2) {
        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(this.o) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(this.o) : new this.Z(this.o);
        this.i();
        this.s.push(this.p, final);
        this.p = null;
      }
    } else
      this.s.push(chunk7, final);
  };
  return Decompress2;
}();
var AsyncDecompress = function() {
  function AsyncDecompress2(opts, cb) {
    Decompress.call(this, opts, cb);
    this.queuedSize = 0;
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
  }
  AsyncDecompress2.prototype.i = function() {
    var _this = this;
    this.s.ondata = function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    };
    this.s.ondrain = function(size45) {
      _this.queuedSize -= size45;
      if (_this.ondrain)
        _this.ondrain(size45);
    };
  };
  AsyncDecompress2.prototype.push = function(chunk7, final) {
    this.queuedSize += chunk7.length;
    Decompress.prototype.push.call(this, chunk7, final);
  };
  return AsyncDecompress2;
}();
var te = typeof TextEncoder != "undefined" && new TextEncoder();
var td = typeof TextDecoder != "undefined" && new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
var dutf8 = function(d) {
  for (var r = "", i = 0; ; ) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length)
      return { s: r, r: slc(d, i - 1) };
    if (!eb)
      r += String.fromCharCode(c);
    else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1)
      r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
    else
      r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
var DecodeUTF8 = function() {
  function DecodeUTF82(cb) {
    this.ondata = cb;
    if (tds)
      this.t = new TextDecoder();
    else
      this.p = et;
  }
  DecodeUTF82.prototype.push = function(chunk7, final) {
    if (!this.ondata)
      err(5);
    final = !!final;
    if (this.t) {
      this.ondata(this.t.decode(chunk7, { stream: true }), final);
      if (final) {
        if (this.t.decode().length)
          err(8);
        this.t = null;
      }
      return;
    }
    if (!this.p)
      err(4);
    var dat = new u82(this.p.length + chunk7.length);
    dat.set(this.p);
    dat.set(chunk7, this.p.length);
    var _a106 = dutf8(dat), s = _a106.s, r = _a106.r;
    if (final) {
      if (r.length)
        err(8);
      this.p = null;
    } else
      this.p = r;
    this.ondata(s, final);
  };
  return DecodeUTF82;
}();
var EncodeUTF8 = function() {
  function EncodeUTF82(cb) {
    this.ondata = cb;
  }
  EncodeUTF82.prototype.push = function(chunk7, final) {
    if (!this.ondata)
      err(5);
    if (this.d)
      err(4);
    this.ondata(strToU8(chunk7), this.d = final || false);
  };
  return EncodeUTF82;
}();
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u82(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u82(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u82(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function strFromU8(dat, latin1) {
  if (latin1) {
    var r = "";
    for (var i = 0; i < dat.length; i += 16384)
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    return r;
  } else if (td) {
    return td.decode(dat);
  } else {
    var _a106 = dutf8(dat), s = _a106.s, r = _a106.r;
    if (r.length)
      err(8);
    return s;
  }
}
var dbf = function(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
};
var z64e = function(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
    ;
  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
};
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        err(9);
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b, f2, fn2, u, c, ce, co) {
  var fl2 = fn2.length, ex = f2.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null)
    d[b++] = 20, d[b++] = f2.os;
  d[b] = 20, b += 2;
  d[b++] = f2.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
  d[b++] = f2.compression & 255, d[b++] = f2.compression >> 8;
  var dt = new Date(f2.mtime == null ? Date.now() : f2.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    err(10);
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
  if (c != -1) {
    wbytes(d, b, f2.crc);
    wbytes(d, b + 4, c < 0 ? -c - 2 : c);
    wbytes(d, b + 8, f2.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f2.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }
  d.set(fn2, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col)
    d.set(co, b), b += col;
  return b;
};
var wzf = function(o, b, c, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
var ZipPassThrough = function() {
  function ZipPassThrough2(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  ZipPassThrough2.prototype.process = function(chunk7, final) {
    this.ondata(null, chunk7, final);
  };
  ZipPassThrough2.prototype.push = function(chunk7, final) {
    if (!this.ondata)
      err(5);
    this.c.p(chunk7);
    this.size += chunk7.length;
    if (final)
      this.crc = this.c.d();
    this.process(chunk7, final || false);
  };
  return ZipPassThrough2;
}();
var ZipDeflate = function() {
  function ZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function(dat, final) {
      _this.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }
  ZipDeflate2.prototype.process = function(chunk7, final) {
    try {
      this.d.push(chunk7, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  ZipDeflate2.prototype.push = function(chunk7, final) {
    ZipPassThrough.prototype.push.call(this, chunk7, final);
  };
  return ZipDeflate2;
}();
var AsyncZipDeflate = function() {
  function AsyncZipDeflate2(filename, opts) {
    var _this = this;
    if (!opts)
      opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function(err2, dat, final) {
      _this.ondata(err2, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }
  AsyncZipDeflate2.prototype.process = function(chunk7, final) {
    this.d.push(chunk7, final);
  };
  AsyncZipDeflate2.prototype.push = function(chunk7, final) {
    ZipPassThrough.prototype.push.call(this, chunk7, final);
  };
  return AsyncZipDeflate2;
}();
var Zip2 = function() {
  function Zip3(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  Zip3.prototype.add = function(file) {
    var _this = this;
    if (!this.ondata)
      err(5);
    if (this.d & 2)
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, false);
    else {
      var f2 = strToU8(file.filename), fl_1 = f2.length;
      var com = file.comment, o = com && strToU8(com);
      var u = fl_1 != file.filename.length || o && com.length != o.length;
      var hl_1 = fl_1 + exfl(file.extra) + 30;
      if (fl_1 > 65535)
        this.ondata(err(11, 0, 1), null, false);
      var header = new u82(hl_1);
      wzh(header, 0, file, f2, u, -1);
      var chks_1 = [header];
      var pAll_1 = function() {
        for (var _i = 0, chks_2 = chks_1; _i < chks_2.length; _i++) {
          var chk = chks_2[_i];
          _this.ondata(null, chk, false);
        }
        chks_1 = [];
      };
      var tr_1 = this.d;
      this.d = 0;
      var ind_1 = this.u.length;
      var uf_1 = mrg(file, {
        f: f2,
        u,
        o,
        t: function() {
          if (file.terminate)
            file.terminate();
        },
        r: function() {
          pAll_1();
          if (tr_1) {
            var nxt = _this.u[ind_1 + 1];
            if (nxt)
              nxt.r();
            else
              _this.d = 1;
          }
          tr_1 = 1;
        }
      });
      var cl_1 = 0;
      file.ondata = function(err2, dat, final) {
        if (err2) {
          _this.ondata(err2, dat, final);
          _this.terminate();
        } else {
          cl_1 += dat.length;
          chks_1.push(dat);
          if (final) {
            var dd = new u82(16);
            wbytes(dd, 0, 134695760);
            wbytes(dd, 4, file.crc);
            wbytes(dd, 8, cl_1);
            wbytes(dd, 12, file.size);
            chks_1.push(dd);
            uf_1.c = cl_1, uf_1.b = hl_1 + cl_1 + 16, uf_1.crc = file.crc, uf_1.size = file.size;
            if (tr_1)
              uf_1.r();
            tr_1 = 1;
          } else if (tr_1)
            pAll_1();
        }
      };
      this.u.push(uf_1);
    }
  };
  Zip3.prototype.end = function() {
    var _this = this;
    if (this.d & 2) {
      this.ondata(err(4 + (this.d & 1) * 8, 0, 1), null, true);
      return;
    }
    if (this.d)
      this.e();
    else
      this.u.push({
        r: function() {
          if (!(_this.d & 1))
            return;
          _this.u.splice(-1, 1);
          _this.e();
        },
        t: function() {
        }
      });
    this.d = 3;
  };
  Zip3.prototype.e = function() {
    var bt = 0, l = 0, tl = 0;
    for (var _i = 0, _a106 = this.u; _i < _a106.length; _i++) {
      var f2 = _a106[_i];
      tl += 46 + f2.f.length + exfl(f2.extra) + (f2.o ? f2.o.length : 0);
    }
    var out = new u82(tl + 22);
    for (var _b32 = 0, _c7 = this.u; _b32 < _c7.length; _b32++) {
      var f2 = _c7[_b32];
      wzh(out, bt, f2, f2.f, f2.u, -f2.c - 2, l, f2.o);
      bt += 46 + f2.f.length + exfl(f2.extra) + (f2.o ? f2.o.length : 0), l += f2.b;
    }
    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  Zip3.prototype.terminate = function() {
    for (var _i = 0, _a106 = this.u; _i < _a106.length; _i++) {
      var f2 = _a106[_i];
      f2.t();
    }
    this.d = 2;
  };
  return Zip3;
}();
var UnzipPassThrough = function() {
  function UnzipPassThrough2() {
  }
  UnzipPassThrough2.prototype.push = function(data, final) {
    this.ondata(null, data, final);
  };
  UnzipPassThrough2.compression = 0;
  return UnzipPassThrough2;
}();
var UnzipInflate = function() {
  function UnzipInflate2() {
    var _this = this;
    this.i = new Inflate(function(dat, final) {
      _this.ondata(null, dat, final);
    });
  }
  UnzipInflate2.prototype.push = function(data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  UnzipInflate2.compression = 8;
  return UnzipInflate2;
}();
var AsyncUnzipInflate = function() {
  function AsyncUnzipInflate2(_, sz) {
    var _this = this;
    if (sz < 32e4) {
      this.i = new Inflate(function(dat, final) {
        _this.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function(err2, dat, final) {
        _this.ondata(err2, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }
  AsyncUnzipInflate2.prototype.push = function(data, final) {
    if (this.i.terminate)
      data = slc(data, 0);
    this.i.push(data, final);
  };
  AsyncUnzipInflate2.compression = 8;
  return AsyncUnzipInflate2;
}();
var Unzip = function() {
  function Unzip2(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  Unzip2.prototype.push = function(chunk7, final) {
    var _this = this;
    if (!this.onfile)
      err(5);
    if (!this.p)
      err(4);
    if (this.c > 0) {
      var len = Math.min(this.c, chunk7.length);
      var toAdd = chunk7.subarray(0, len);
      this.c -= len;
      if (this.d)
        this.d.push(toAdd, !this.c);
      else
        this.k[0].push(toAdd);
      chunk7 = chunk7.subarray(len);
      if (chunk7.length)
        return this.push(chunk7, final);
    } else {
      var f2 = 0, i = 0, is4 = void 0, buf = void 0;
      if (!this.p.length)
        buf = chunk7;
      else if (!chunk7.length)
        buf = this.p;
      else {
        buf = new u82(this.p.length + chunk7.length);
        buf.set(this.p), buf.set(chunk7, this.p.length);
      }
      var l = buf.length, oc = this.c, add14 = oc && this.d;
      var _loop_2 = function() {
        var _a106;
        var sig = b4(buf, i);
        if (sig == 67324752) {
          f2 = 1, is4 = i;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);
          if (l > i + 30 + fnl + es) {
            var chks_3 = [];
            this_1.k.unshift(chks_3);
            f2 = 2;
            var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);
            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);
            if (sc_1 == 4294967295) {
              _a106 = dd ? [-2] : z64e(buf, i), sc_1 = _a106[0], su_1 = _a106[1];
            } else if (dd)
              sc_1 = -1;
            i += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function() {
                if (!file_1.ondata)
                  err(5);
                if (!sc_1)
                  file_1.ondata(null, et, true);
                else {
                  var ctr2 = _this.o[cmp_1];
                  if (!ctr2)
                    file_1.ondata(err(14, "unknown compression type " + cmp_1, 1), null, false);
                  d_1 = sc_1 < 0 ? new ctr2(fn_1) : new ctr2(fn_1, sc_1, su_1);
                  d_1.ondata = function(err2, dat3, final2) {
                    file_1.ondata(err2, dat3, final2);
                  };
                  for (var _i = 0, chks_4 = chks_3; _i < chks_4.length; _i++) {
                    var dat2 = chks_4[_i];
                    d_1.push(dat2, false);
                  }
                  if (_this.k[0] == chks_3 && _this.c)
                    _this.d = d_1;
                  else
                    d_1.push(et, true);
                }
              },
              terminate: function() {
                if (d_1 && d_1.terminate)
                  d_1.terminate();
              }
            };
            if (sc_1 >= 0)
              file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }
          return "break";
        } else if (oc) {
          if (sig == 134695760) {
            is4 = i += 12 + (oc == -2 && 8), f2 = 3, this_1.c = 0;
            return "break";
          } else if (sig == 33639248) {
            is4 = i -= 4, f2 = 3, this_1.c = 0;
            return "break";
          }
        }
      };
      var this_1 = this;
      for (; i < l - 4; ++i) {
        var state_1 = _loop_2();
        if (state_1 === "break")
          break;
      }
      this.p = et;
      if (oc < 0) {
        var dat = f2 ? buf.subarray(0, is4 - 12 - (oc == -2 && 8) - (b4(buf, is4 - 16) == 134695760 && 4)) : buf.subarray(0, i);
        if (add14)
          add14.push(dat, !!f2);
        else
          this.k[+(f2 == 2)].push(dat);
      }
      if (f2 & 2)
        return this.push(buf.subarray(i), final);
      this.p = buf.subarray(i);
    }
    if (final) {
      if (this.c)
        err(13);
      this.p = null;
    }
  };
  Unzip2.prototype.register = function(decoder4) {
    this.o[decoder4.compression] = decoder4;
  };
  return Unzip2;
}();

// node_modules/image-size/dist/index.mjs
var decoder2 = new TextDecoder();
var toUTF8String = (input, start5 = 0, end7 = input.length) => decoder2.decode(input.slice(start5, end7));
var toHexString = (input, start5 = 0, end7 = input.length) => input.slice(start5, end7).reduce((memo2, i) => memo2 + `0${i.toString(16)}`.slice(-2), "");
var getView = (input, offset) => new DataView(input.buffer, input.byteOffset + offset);
var readInt16LE = (input, offset = 0) => getView(input, offset).getInt16(0, true);
var readUInt16BE = (input, offset = 0) => getView(input, offset).getUint16(0, false);
var readUInt16LE = (input, offset = 0) => getView(input, offset).getUint16(0, true);
var readUInt24LE = (input, offset = 0) => {
  const view = getView(input, offset);
  return view.getUint16(0, true) + (view.getUint8(2) << 16);
};
var readInt32LE = (input, offset = 0) => getView(input, offset).getInt32(0, true);
var readUInt32BE = (input, offset = 0) => getView(input, offset).getUint32(0, false);
var readUInt32LE = (input, offset = 0) => getView(input, offset).getUint32(0, true);
var readUInt64 = (input, offset, isBigEndian) => getView(input, offset).getBigUint64(0, !isBigEndian);
var methods = {
  readUInt16BE,
  readUInt16LE,
  readUInt32BE,
  readUInt32LE
};
function readUInt(input, bits2, offset = 0, isBigEndian = false) {
  const endian = isBigEndian ? "BE" : "LE";
  const methodName = `readUInt${bits2}${endian}`;
  return methods[methodName](input, offset);
}
function readBox(input, offset) {
  if (input.length - offset < 4) return;
  const boxSize = readUInt32BE(input, offset);
  if (input.length - offset < boxSize) return;
  return {
    name: toUTF8String(input, 4 + offset, 8 + offset),
    offset,
    size: boxSize
  };
}
function findBox(input, boxName, currentOffset) {
  while (currentOffset < input.length) {
    const box = readBox(input, currentOffset);
    if (!box) break;
    if (box.name === boxName) return box;
    currentOffset += box.size > 0 ? box.size : 8;
  }
}
var BMP = {
  validate: (input) => toUTF8String(input, 0, 2) === "BM",
  calculate: (input) => ({
    height: Math.abs(readInt32LE(input, 22)),
    width: readUInt32LE(input, 18)
  })
};
var TYPE_ICON = 1;
var SIZE_HEADER = 2 + 2 + 2;
var SIZE_IMAGE_ENTRY = 1 + 1 + 1 + 1 + 2 + 2 + 4 + 4;
function getSizeFromOffset(input, offset) {
  const value10 = input[offset];
  return value10 === 0 ? 256 : value10;
}
function getImageSize(input, imageIndex) {
  const offset = SIZE_HEADER + imageIndex * SIZE_IMAGE_ENTRY;
  return {
    height: getSizeFromOffset(input, offset + 1),
    width: getSizeFromOffset(input, offset)
  };
}
var ICO = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_ICON;
  },
  calculate(input) {
    const nbImages = readUInt16LE(input, 4);
    const imageSize2 = getImageSize(input, 0);
    if (nbImages === 1) return imageSize2;
    const images = [];
    for (let imageIndex = 0; imageIndex < nbImages; imageIndex += 1) {
      images.push(getImageSize(input, imageIndex));
    }
    return {
      width: imageSize2.width,
      height: imageSize2.height,
      images
    };
  }
};
var TYPE_CURSOR = 2;
var CUR = {
  validate(input) {
    const reserved = readUInt16LE(input, 0);
    const imageCount = readUInt16LE(input, 4);
    if (reserved !== 0 || imageCount === 0) return false;
    const imageType = readUInt16LE(input, 2);
    return imageType === TYPE_CURSOR;
  },
  calculate: (input) => ICO.calculate(input)
};
var DDS = {
  validate: (input) => readUInt32LE(input, 0) === 542327876,
  calculate: (input) => ({
    height: readUInt32LE(input, 12),
    width: readUInt32LE(input, 16)
  })
};
var gifRegexp = /^GIF8[79]a/;
var GIF = {
  validate: (input) => gifRegexp.test(toUTF8String(input, 0, 6)),
  calculate: (input) => ({
    height: readUInt16LE(input, 8),
    width: readUInt16LE(input, 6)
  })
};
var brandMap = {
  avif: "avif",
  mif1: "heif",
  msf1: "heif",
  // heif-sequence
  heic: "heic",
  heix: "heic",
  hevc: "heic",
  // heic-sequence
  hevx: "heic"
  // heic-sequence
};
var HEIF = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "ftyp") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand2 = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand2 in brandMap;
  },
  calculate(input) {
    const metaBox = findBox(input, "meta", 0);
    const iprpBox = metaBox && findBox(input, "iprp", metaBox.offset + 12);
    const ipcoBox = iprpBox && findBox(input, "ipco", iprpBox.offset + 8);
    if (!ipcoBox) {
      throw new TypeError("Invalid HEIF, no ipco box found");
    }
    const type8 = toUTF8String(input, 8, 12);
    const images = [];
    let currentOffset = ipcoBox.offset + 8;
    while (currentOffset < ipcoBox.offset + ipcoBox.size) {
      const ispeBox = findBox(input, "ispe", currentOffset);
      if (!ispeBox) break;
      const rawWidth = readUInt32BE(input, ispeBox.offset + 12);
      const rawHeight = readUInt32BE(input, ispeBox.offset + 16);
      const clapBox = findBox(input, "clap", currentOffset);
      let width = rawWidth;
      let height = rawHeight;
      if (clapBox && clapBox.offset < ipcoBox.offset + ipcoBox.size) {
        const cropRight = readUInt32BE(input, clapBox.offset + 12);
        width = rawWidth - cropRight;
      }
      images.push({ height, width });
      currentOffset = ispeBox.offset + ispeBox.size;
    }
    if (images.length === 0) {
      throw new TypeError("Invalid HEIF, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      type: type8,
      ...images.length > 1 ? { images } : {}
    };
  }
};
var SIZE_HEADER2 = 4 + 4;
var FILE_LENGTH_OFFSET = 4;
var ENTRY_LENGTH_OFFSET = 4;
var ICON_TYPE_SIZE = {
  ICON: 32,
  "ICN#": 32,
  // m => 16 x 16
  "icm#": 16,
  icm4: 16,
  icm8: 16,
  // s => 16 x 16
  "ics#": 16,
  ics4: 16,
  ics8: 16,
  is32: 16,
  s8mk: 16,
  icp4: 16,
  // l => 32 x 32
  icl4: 32,
  icl8: 32,
  il32: 32,
  l8mk: 32,
  icp5: 32,
  ic11: 32,
  // h => 48 x 48
  ich4: 48,
  ich8: 48,
  ih32: 48,
  h8mk: 48,
  // . => 64 x 64
  icp6: 64,
  ic12: 32,
  // t => 128 x 128
  it32: 128,
  t8mk: 128,
  ic07: 128,
  // . => 256 x 256
  ic08: 256,
  ic13: 256,
  // . => 512 x 512
  ic09: 512,
  ic14: 512,
  // . => 1024 x 1024
  ic10: 1024
};
function readImageHeader(input, imageOffset) {
  const imageLengthOffset = imageOffset + ENTRY_LENGTH_OFFSET;
  return [
    toUTF8String(input, imageOffset, imageLengthOffset),
    readUInt32BE(input, imageLengthOffset)
  ];
}
function getImageSize2(type8) {
  const size45 = ICON_TYPE_SIZE[type8];
  return { width: size45, height: size45, type: type8 };
}
var ICNS = {
  validate: (input) => toUTF8String(input, 0, 4) === "icns",
  calculate(input) {
    const inputLength = input.length;
    const fileLength = readUInt32BE(input, FILE_LENGTH_OFFSET);
    let imageOffset = SIZE_HEADER2;
    const images = [];
    while (imageOffset < fileLength && imageOffset < inputLength) {
      const imageHeader = readImageHeader(input, imageOffset);
      const imageSize2 = getImageSize2(imageHeader[0]);
      images.push(imageSize2);
      imageOffset += imageHeader[1];
    }
    if (images.length === 0) {
      throw new TypeError("Invalid ICNS, no sizes found");
    }
    return {
      width: images[0].width,
      height: images[0].height,
      ...images.length > 1 ? { images } : {}
    };
  }
};
var J2C = {
  // TODO: this doesn't seem right. SIZ marker doesn't have to be right after the SOC
  validate: (input) => readUInt32BE(input, 0) === 4283432785,
  calculate: (input) => ({
    height: readUInt32BE(input, 12),
    width: readUInt32BE(input, 8)
  })
};
var JP2 = {
  validate(input) {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "jP  ") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand2 = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand2 === "jp2 ";
  },
  calculate(input) {
    const jp2hBox = findBox(input, "jp2h", 0);
    const ihdrBox = jp2hBox && findBox(input, "ihdr", jp2hBox.offset + 8);
    if (ihdrBox) {
      return {
        height: readUInt32BE(input, ihdrBox.offset + 8),
        width: readUInt32BE(input, ihdrBox.offset + 12)
      };
    }
    throw new TypeError("Unsupported JPEG 2000 format");
  }
};
var EXIF_MARKER = "45786966";
var APP1_DATA_SIZE_BYTES = 2;
var EXIF_HEADER_BYTES = 6;
var TIFF_BYTE_ALIGN_BYTES = 2;
var BIG_ENDIAN_BYTE_ALIGN = "4d4d";
var LITTLE_ENDIAN_BYTE_ALIGN = "4949";
var IDF_ENTRY_BYTES = 12;
var NUM_DIRECTORY_ENTRIES_BYTES = 2;
function isEXIF(input) {
  return toHexString(input, 2, 6) === EXIF_MARKER;
}
function extractSize(input, index3) {
  return {
    height: readUInt16BE(input, index3),
    width: readUInt16BE(input, index3 + 2)
  };
}
function extractOrientation(exifBlock, isBigEndian) {
  const idfOffset = 8;
  const offset = EXIF_HEADER_BYTES + idfOffset;
  const idfDirectoryEntries = readUInt(exifBlock, 16, offset, isBigEndian);
  for (let directoryEntryNumber = 0; directoryEntryNumber < idfDirectoryEntries; directoryEntryNumber++) {
    const start5 = offset + NUM_DIRECTORY_ENTRIES_BYTES + directoryEntryNumber * IDF_ENTRY_BYTES;
    const end7 = start5 + IDF_ENTRY_BYTES;
    if (start5 > exifBlock.length) {
      return;
    }
    const block = exifBlock.slice(start5, end7);
    const tagNumber = readUInt(block, 16, 0, isBigEndian);
    if (tagNumber === 274) {
      const dataFormat = readUInt(block, 16, 2, isBigEndian);
      if (dataFormat !== 3) {
        return;
      }
      const numberOfComponents = readUInt(block, 32, 4, isBigEndian);
      if (numberOfComponents !== 1) {
        return;
      }
      return readUInt(block, 16, 8, isBigEndian);
    }
  }
}
function validateExifBlock(input, index3) {
  const exifBlock = input.slice(APP1_DATA_SIZE_BYTES, index3);
  const byteAlign = toHexString(
    exifBlock,
    EXIF_HEADER_BYTES,
    EXIF_HEADER_BYTES + TIFF_BYTE_ALIGN_BYTES
  );
  const isBigEndian = byteAlign === BIG_ENDIAN_BYTE_ALIGN;
  const isLittleEndian = byteAlign === LITTLE_ENDIAN_BYTE_ALIGN;
  if (isBigEndian || isLittleEndian) {
    return extractOrientation(exifBlock, isBigEndian);
  }
}
function validateInput(input, index3) {
  if (index3 > input.length) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
}
var JPG = {
  validate: (input) => toHexString(input, 0, 2) === "ffd8",
  calculate(_input) {
    let input = _input.slice(4);
    let orientation;
    let next6;
    while (input.length) {
      const i = readUInt16BE(input, 0);
      validateInput(input, i);
      if (input[i] !== 255) {
        input = input.slice(1);
        continue;
      }
      if (isEXIF(input)) {
        orientation = validateExifBlock(input, i);
      }
      next6 = input[i + 1];
      if (next6 === 192 || next6 === 193 || next6 === 194) {
        const size45 = extractSize(input, i + 5);
        if (!orientation) {
          return size45;
        }
        return {
          height: size45.height,
          orientation,
          width: size45.width
        };
      }
      input = input.slice(i + 2);
    }
    throw new TypeError("Invalid JPG, no size found");
  }
};
var BitReader = class {
  constructor(input, endianness) {
    this.input = input;
    this.endianness = endianness;
    this.byteOffset = 2;
    this.bitOffset = 0;
  }
  /** Reads a specified number of bits, and move the offset */
  getBits(length6 = 1) {
    let result = 0;
    let bitsRead = 0;
    while (bitsRead < length6) {
      if (this.byteOffset >= this.input.length) {
        throw new Error("Reached end of input");
      }
      const currentByte = this.input[this.byteOffset];
      const bitsLeft = 8 - this.bitOffset;
      const bitsToRead = Math.min(length6 - bitsRead, bitsLeft);
      if (this.endianness === "little-endian") {
        const mask = (1 << bitsToRead) - 1;
        const bits2 = currentByte >> this.bitOffset & mask;
        result |= bits2 << bitsRead;
      } else {
        const mask = (1 << bitsToRead) - 1 << 8 - this.bitOffset - bitsToRead;
        const bits2 = (currentByte & mask) >> 8 - this.bitOffset - bitsToRead;
        result = result << bitsToRead | bits2;
      }
      bitsRead += bitsToRead;
      this.bitOffset += bitsToRead;
      if (this.bitOffset === 8) {
        this.byteOffset++;
        this.bitOffset = 0;
      }
    }
    return result;
  }
};
function calculateImageDimension(reader, isSmallImage) {
  if (isSmallImage) {
    return 8 * (1 + reader.getBits(5));
  }
  const sizeClass = reader.getBits(2);
  const extraBits = [9, 13, 18, 30][sizeClass];
  return 1 + reader.getBits(extraBits);
}
function calculateImageWidth(reader, isSmallImage, widthMode, height) {
  if (isSmallImage && widthMode === 0) {
    return 8 * (1 + reader.getBits(5));
  }
  if (widthMode === 0) {
    return calculateImageDimension(reader, false);
  }
  const aspectRatios = [1, 1.2, 4 / 3, 1.5, 16 / 9, 5 / 4, 2];
  return Math.floor(height * aspectRatios[widthMode - 1]);
}
var JXLStream = {
  validate: (input) => {
    return toHexString(input, 0, 2) === "ff0a";
  },
  calculate(input) {
    const reader = new BitReader(input, "little-endian");
    const isSmallImage = reader.getBits(1) === 1;
    const height = calculateImageDimension(reader, isSmallImage);
    const widthMode = reader.getBits(3);
    const width = calculateImageWidth(reader, isSmallImage, widthMode, height);
    return { width, height };
  }
};
function extractCodestream(input) {
  const jxlcBox = findBox(input, "jxlc", 0);
  if (jxlcBox) {
    return input.slice(jxlcBox.offset + 8, jxlcBox.offset + jxlcBox.size);
  }
  const partialStreams = extractPartialStreams(input);
  if (partialStreams.length > 0) {
    return concatenateCodestreams(partialStreams);
  }
  return void 0;
}
function extractPartialStreams(input) {
  const partialStreams = [];
  let offset = 0;
  while (offset < input.length) {
    const jxlpBox = findBox(input, "jxlp", offset);
    if (!jxlpBox) break;
    partialStreams.push(
      input.slice(jxlpBox.offset + 12, jxlpBox.offset + jxlpBox.size)
    );
    offset = jxlpBox.offset + jxlpBox.size;
  }
  return partialStreams;
}
function concatenateCodestreams(partialCodestreams) {
  const totalLength = partialCodestreams.reduce(
    (acc, curr) => acc + curr.length,
    0
  );
  const codestream = new Uint8Array(totalLength);
  let position = 0;
  for (const partial3 of partialCodestreams) {
    codestream.set(partial3, position);
    position += partial3.length;
  }
  return codestream;
}
var JXL = {
  validate: (input) => {
    const boxType = toUTF8String(input, 4, 8);
    if (boxType !== "JXL ") return false;
    const ftypBox = findBox(input, "ftyp", 0);
    if (!ftypBox) return false;
    const brand2 = toUTF8String(input, ftypBox.offset + 8, ftypBox.offset + 12);
    return brand2 === "jxl ";
  },
  calculate(input) {
    const codestream = extractCodestream(input);
    if (codestream) return JXLStream.calculate(codestream);
    throw new Error("No codestream found in JXL container");
  }
};
var KTX = {
  validate: (input) => {
    const signature = toUTF8String(input, 1, 7);
    return ["KTX 11", "KTX 20"].includes(signature);
  },
  calculate: (input) => {
    const type8 = input[5] === 49 ? "ktx" : "ktx2";
    const offset = type8 === "ktx" ? 36 : 20;
    return {
      height: readUInt32LE(input, offset + 4),
      width: readUInt32LE(input, offset),
      type: type8
    };
  }
};
var pngSignature = "PNG\r\n\n";
var pngImageHeaderChunkName = "IHDR";
var pngFriedChunkName = "CgBI";
var PNG = {
  validate(input) {
    if (pngSignature === toUTF8String(input, 1, 8)) {
      let chunkName = toUTF8String(input, 12, 16);
      if (chunkName === pngFriedChunkName) {
        chunkName = toUTF8String(input, 28, 32);
      }
      if (chunkName !== pngImageHeaderChunkName) {
        throw new TypeError("Invalid PNG");
      }
      return true;
    }
    return false;
  },
  calculate(input) {
    if (toUTF8String(input, 12, 16) === pngFriedChunkName) {
      return {
        height: readUInt32BE(input, 36),
        width: readUInt32BE(input, 32)
      };
    }
    return {
      height: readUInt32BE(input, 20),
      width: readUInt32BE(input, 16)
    };
  }
};
var PNMTypes = {
  P1: "pbm/ascii",
  P2: "pgm/ascii",
  P3: "ppm/ascii",
  P4: "pbm",
  P5: "pgm",
  P6: "ppm",
  P7: "pam",
  PF: "pfm"
};
var handlers = {
  default: (lines) => {
    let dimensions = [];
    while (lines.length > 0) {
      const line = lines.shift();
      if (line[0] === "#") {
        continue;
      }
      dimensions = line.split(" ");
      break;
    }
    if (dimensions.length === 2) {
      return {
        height: Number.parseInt(dimensions[1], 10),
        width: Number.parseInt(dimensions[0], 10)
      };
    }
    throw new TypeError("Invalid PNM");
  },
  pam: (lines) => {
    const size45 = {};
    while (lines.length > 0) {
      const line = lines.shift();
      if (line.length > 16 || line.charCodeAt(0) > 128) {
        continue;
      }
      const [key, value10] = line.split(" ");
      if (key && value10) {
        size45[key.toLowerCase()] = Number.parseInt(value10, 10);
      }
      if (size45.height && size45.width) {
        break;
      }
    }
    if (size45.height && size45.width) {
      return {
        height: size45.height,
        width: size45.width
      };
    }
    throw new TypeError("Invalid PAM");
  }
};
var PNM = {
  validate: (input) => toUTF8String(input, 0, 2) in PNMTypes,
  calculate(input) {
    const signature = toUTF8String(input, 0, 2);
    const type8 = PNMTypes[signature];
    const lines = toUTF8String(input, 3).split(/[\r\n]+/);
    const handler = handlers[type8] || handlers.default;
    return handler(lines);
  }
};
var PSD = {
  validate: (input) => toUTF8String(input, 0, 4) === "8BPS",
  calculate: (input) => ({
    height: readUInt32BE(input, 14),
    width: readUInt32BE(input, 18)
  })
};
var svgReg = /<svg\s([^>"']|"[^"]*"|'[^']*')*>/;
var extractorRegExps = {
  height: /\sheight=(['"])([^%]+?)\1/,
  root: svgReg,
  viewbox: /\sviewBox=(['"])(.+?)\1/i,
  width: /\swidth=(['"])([^%]+?)\1/
};
var INCH_CM = 2.54;
var units = {
  in: 96,
  cm: 96 / INCH_CM,
  em: 16,
  ex: 8,
  m: 96 / INCH_CM * 100,
  mm: 96 / INCH_CM / 10,
  pc: 96 / 72 / 12,
  pt: 96 / 72,
  px: 1
};
var unitsReg = new RegExp(
  `^([0-9.]+(?:e\\d+)?)(${Object.keys(units).join("|")})?$`
);
function parseLength(len) {
  const m = unitsReg.exec(len);
  if (!m) {
    return void 0;
  }
  return Math.round(Number(m[1]) * (units[m[2]] || 1));
}
function parseViewbox(viewbox) {
  const bounds = viewbox.split(" ");
  return {
    height: parseLength(bounds[3]),
    width: parseLength(bounds[2])
  };
}
function parseAttributes(root) {
  const width = root.match(extractorRegExps.width);
  const height = root.match(extractorRegExps.height);
  const viewbox = root.match(extractorRegExps.viewbox);
  return {
    height: height && parseLength(height[2]),
    viewbox: viewbox && parseViewbox(viewbox[2]),
    width: width && parseLength(width[2])
  };
}
function calculateByDimensions(attrs) {
  return {
    height: attrs.height,
    width: attrs.width
  };
}
function calculateByViewbox(attrs, viewbox) {
  const ratio = viewbox.width / viewbox.height;
  if (attrs.width) {
    return {
      height: Math.floor(attrs.width / ratio),
      width: attrs.width
    };
  }
  if (attrs.height) {
    return {
      height: attrs.height,
      width: Math.floor(attrs.height * ratio)
    };
  }
  return {
    height: viewbox.height,
    width: viewbox.width
  };
}
var SVG = {
  // Scan only the first kilo-byte to speed up the check on larger files
  validate: (input) => svgReg.test(toUTF8String(input, 0, 1e3)),
  calculate(input) {
    const root = toUTF8String(input).match(extractorRegExps.root);
    if (root) {
      const attrs = parseAttributes(root[0]);
      if (attrs.width && attrs.height) {
        return calculateByDimensions(attrs);
      }
      if (attrs.viewbox) {
        return calculateByViewbox(attrs, attrs.viewbox);
      }
    }
    throw new TypeError("Invalid SVG");
  }
};
var TGA = {
  validate(input) {
    return readUInt16LE(input, 0) === 0 && readUInt16LE(input, 4) === 0;
  },
  calculate(input) {
    return {
      height: readUInt16LE(input, 14),
      width: readUInt16LE(input, 12)
    };
  }
};
var CONSTANTS = {
  TAG: {
    WIDTH: 256,
    HEIGHT: 257,
    COMPRESSION: 259
  },
  TYPE: {
    SHORT: 3,
    LONG: 4,
    LONG8: 16
  },
  ENTRY_SIZE: {
    STANDARD: 12,
    BIG: 20
  },
  COUNT_SIZE: {
    STANDARD: 2,
    BIG: 8
  }
};
function readIFD(input, { isBigEndian, isBigTiff }) {
  const ifdOffset = isBigTiff ? Number(readUInt64(input, 8, isBigEndian)) : readUInt(input, 32, 4, isBigEndian);
  const entryCountSize = isBigTiff ? CONSTANTS.COUNT_SIZE.BIG : CONSTANTS.COUNT_SIZE.STANDARD;
  return input.slice(ifdOffset + entryCountSize);
}
function readTagValue(input, type8, offset, isBigEndian) {
  switch (type8) {
    case CONSTANTS.TYPE.SHORT:
      return readUInt(input, 16, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG:
      return readUInt(input, 32, offset, isBigEndian);
    case CONSTANTS.TYPE.LONG8: {
      const value10 = Number(readUInt64(input, offset, isBigEndian));
      if (value10 > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("Value too large");
      }
      return value10;
    }
    default:
      return 0;
  }
}
function nextTag(input, isBigTiff) {
  const entrySize = isBigTiff ? CONSTANTS.ENTRY_SIZE.BIG : CONSTANTS.ENTRY_SIZE.STANDARD;
  if (input.length > entrySize) {
    return input.slice(entrySize);
  }
}
function extractTags(input, { isBigEndian, isBigTiff }) {
  const tags3 = {};
  let temp = input;
  while (temp == null ? void 0 : temp.length) {
    const code = readUInt(temp, 16, 0, isBigEndian);
    const type8 = readUInt(temp, 16, 2, isBigEndian);
    const length6 = isBigTiff ? Number(readUInt64(temp, 4, isBigEndian)) : readUInt(temp, 32, 4, isBigEndian);
    if (code === 0) break;
    if (length6 === 1 && (type8 === CONSTANTS.TYPE.SHORT || type8 === CONSTANTS.TYPE.LONG || isBigTiff && type8 === CONSTANTS.TYPE.LONG8)) {
      const valueOffset = isBigTiff ? 12 : 8;
      tags3[code] = readTagValue(temp, type8, valueOffset, isBigEndian);
    }
    temp = nextTag(temp, isBigTiff);
  }
  return tags3;
}
function determineFormat(input) {
  const signature = toUTF8String(input, 0, 2);
  const version = readUInt(input, 16, 2, signature === "MM");
  return {
    isBigEndian: signature === "MM",
    isBigTiff: version === 43
  };
}
function validateBigTIFFHeader(input, isBigEndian) {
  const byteSize = readUInt(input, 16, 4, isBigEndian);
  const reserved = readUInt(input, 16, 6, isBigEndian);
  if (byteSize !== 8 || reserved !== 0) {
    throw new TypeError("Invalid BigTIFF header");
  }
}
var signatures = /* @__PURE__ */ new Set([
  "49492a00",
  // Little Endian
  "4d4d002a",
  // Big Endian
  "49492b00",
  // BigTIFF Little Endian
  "4d4d002b"
  // BigTIFF Big Endian
]);
var TIFF = {
  validate: (input) => {
    const signature = toHexString(input, 0, 4);
    return signatures.has(signature);
  },
  calculate(input) {
    const format16 = determineFormat(input);
    if (format16.isBigTiff) {
      validateBigTIFFHeader(input, format16.isBigEndian);
    }
    const ifdBuffer = readIFD(input, format16);
    const tags3 = extractTags(ifdBuffer, format16);
    const info3 = {
      height: tags3[CONSTANTS.TAG.HEIGHT],
      width: tags3[CONSTANTS.TAG.WIDTH],
      type: format16.isBigTiff ? "bigtiff" : "tiff"
    };
    if (tags3[CONSTANTS.TAG.COMPRESSION]) {
      info3.compression = tags3[CONSTANTS.TAG.COMPRESSION];
    }
    if (!info3.width || !info3.height) {
      throw new TypeError("Invalid Tiff. Missing tags");
    }
    return info3;
  }
};
function calculateExtended(input) {
  return {
    height: 1 + readUInt24LE(input, 7),
    width: 1 + readUInt24LE(input, 4)
  };
}
function calculateLossless(input) {
  return {
    height: 1 + ((input[4] & 15) << 10 | input[3] << 2 | (input[2] & 192) >> 6),
    width: 1 + ((input[2] & 63) << 8 | input[1])
  };
}
function calculateLossy(input) {
  return {
    height: readInt16LE(input, 8) & 16383,
    width: readInt16LE(input, 6) & 16383
  };
}
var WEBP = {
  validate(input) {
    const riffHeader = "RIFF" === toUTF8String(input, 0, 4);
    const webpHeader = "WEBP" === toUTF8String(input, 8, 12);
    const vp8Header = "VP8" === toUTF8String(input, 12, 15);
    return riffHeader && webpHeader && vp8Header;
  },
  calculate(_input) {
    const chunkHeader = toUTF8String(_input, 12, 16);
    const input = _input.slice(20, 30);
    if (chunkHeader === "VP8X") {
      const extendedHeader = input[0];
      const validStart = (extendedHeader & 192) === 0;
      const validEnd = (extendedHeader & 1) === 0;
      if (validStart && validEnd) {
        return calculateExtended(input);
      }
      throw new TypeError("Invalid WebP");
    }
    if (chunkHeader === "VP8 " && input[0] !== 47) {
      return calculateLossy(input);
    }
    const signature = toHexString(input, 3, 6);
    if (chunkHeader === "VP8L" && signature !== "9d012a") {
      return calculateLossless(input);
    }
    throw new TypeError("Invalid WebP");
  }
};
var typeHandlers = /* @__PURE__ */ new Map([
  ["bmp", BMP],
  ["cur", CUR],
  ["dds", DDS],
  ["gif", GIF],
  ["heif", HEIF],
  ["icns", ICNS],
  ["ico", ICO],
  ["j2c", J2C],
  ["jp2", JP2],
  ["jpg", JPG],
  ["jxl", JXL],
  ["jxl-stream", JXLStream],
  ["ktx", KTX],
  ["png", PNG],
  ["pnm", PNM],
  ["psd", PSD],
  ["svg", SVG],
  ["tga", TGA],
  ["tiff", TIFF],
  ["webp", WEBP]
]);
var types = Array.from(typeHandlers.keys());
var firstBytes = /* @__PURE__ */ new Map([
  [0, "heif"],
  [56, "psd"],
  [66, "bmp"],
  [68, "dds"],
  [71, "gif"],
  [73, "tiff"],
  [77, "tiff"],
  [82, "webp"],
  [105, "icns"],
  [137, "png"],
  [255, "jpg"]
]);
function detector(input) {
  const byte = input[0];
  const type8 = firstBytes.get(byte);
  if (type8 && typeHandlers.get(type8).validate(input)) {
    return type8;
  }
  return types.find((type22) => typeHandlers.get(type22).validate(input));
}
var globalOptions = {
  disabledTypes: []
};
function imageSize(input) {
  const type8 = detector(input);
  if (typeof type8 !== "undefined") {
    if (globalOptions.disabledTypes.indexOf(type8) > -1) {
      throw new TypeError(`disabled file type: ${type8}`);
    }
    const size45 = typeHandlers.get(type8).calculate(input);
    if (size45 !== void 0) {
      size45.type = size45.type ?? type8;
      if (size45.images && size45.images.length > 1) {
        const largestImage = size45.images.reduce((largest, current2) => {
          return current2.width * current2.height > largest.width * largest.height ? current2 : largest;
        }, size45.images[0]);
        size45.width = largestImage.width;
        size45.height = largestImage.height;
      }
      return size45;
    }
  }
  throw new TypeError(`unsupported file type: ${type8}`);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/assert.js
function assert6(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
var enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(enumObject) {
  const t = enumObject[enumTypeSymbol];
  assert6(t, "missing enum type on enum object");
  return t;
}
function setEnumType(enumObject, typeName, values15, opt) {
  enumObject[enumTypeSymbol] = makeEnumType(typeName, values15.map((v) => ({
    no: v.no,
    name: v.name,
    localName: enumObject[v.no]
  })), opt);
}
function makeEnumType(typeName, values15, _opt) {
  const names = /* @__PURE__ */ Object.create(null);
  const numbers = /* @__PURE__ */ Object.create(null);
  const normalValues = [];
  for (const value10 of values15) {
    const n = normalizeEnumValue(value10);
    normalValues.push(n);
    names[value10.name] = n;
    numbers[value10.no] = n;
  }
  return {
    typeName,
    values: normalValues,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(name) {
      return names[name];
    },
    findNumber(no) {
      return numbers[no];
    }
  };
}
function makeEnum(typeName, values15, opt) {
  const enumObject = {};
  for (const value10 of values15) {
    const n = normalizeEnumValue(value10);
    enumObject[n.localName] = n.no;
    enumObject[n.no] = n.localName;
  }
  setEnumType(enumObject, typeName, values15, opt);
  return enumObject;
}
function normalizeEnumValue(value10) {
  if ("localName" in value10) {
    return value10;
  }
  return Object.assign(Object.assign({}, value10), { localName: value10.name });
}

// node_modules/@bufbuild/protobuf/dist/esm/message.js
var Message = class {
  /**
   * Compare with a message of the same type.
   * Note that this function disregards extensions and unknown fields.
   */
  equals(other) {
    return this.getType().runtime.util.equals(this.getType(), this, other);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(bytes, options) {
    const type8 = this.getType(), format16 = type8.runtime.bin, opt = format16.makeReadOptions(options);
    format16.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
    return this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(jsonValue2, options) {
    const type8 = this.getType(), format16 = type8.runtime.json, opt = format16.makeReadOptions(options);
    format16.readMessage(type8, jsonValue2, opt, this);
    return this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(jsonString, options) {
    let json3;
    try {
      json3 = JSON.parse(jsonString);
    } catch (e) {
      throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
    }
    return this.fromJson(json3, options);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(options) {
    const type8 = this.getType(), bin = type8.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
    bin.writeMessage(this, writer, opt);
    return writer.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(options) {
    const type8 = this.getType(), json3 = type8.runtime.json, opt = json3.makeWriteOptions(options);
    return json3.writeMessage(this, opt);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(options) {
    var _a106;
    const value10 = this.toJson(options);
    return JSON.stringify(value10, null, (_a106 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a106 !== void 0 ? _a106 : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: true
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
function makeMessageType(runtime8, typeName, fields, opt) {
  var _a106;
  const localName2 = (_a106 = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a106 !== void 0 ? _a106 : typeName.substring(typeName.lastIndexOf(".") + 1);
  const type8 = {
    [localName2]: function(data) {
      runtime8.util.initFields(this);
      runtime8.util.initPartial(data, this);
    }
  }[localName2];
  Object.setPrototypeOf(type8.prototype, new Message());
  Object.assign(type8, {
    runtime: runtime8,
    typeName,
    fields: runtime8.util.newFieldList(fields),
    fromBinary(bytes, options) {
      return new type8().fromBinary(bytes, options);
    },
    fromJson(jsonValue2, options) {
      return new type8().fromJson(jsonValue2, options);
    },
    fromJsonString(jsonString, options) {
      return new type8().fromJsonString(jsonString, options);
    },
    equals(a, b) {
      return runtime8.util.equals(type8, a, b);
    }
  });
  return type8;
}

// node_modules/@bufbuild/protobuf/dist/esm/google/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift2 = 0; shift2 < 28; shift2 += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift2;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift2 = 3; shift2 <= 31; shift2 += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift2;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift2 = lo >>> i;
    const hasNext = !(shift2 >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift2 | 128 : shift2) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift2 = hi >>> i;
    const hasNext = !(shift2 >>> 7 == 0);
    const byte = (hasNext ? shift2 | 128 : shift2) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end7) {
    const digit1e6 = Number(dec.slice(begin, end7));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate7(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits2 = newBits(lo, hi);
  const negative2 = bits2.hi & 2147483648;
  if (negative2) {
    bits2 = negate7(bits2.lo, bits2.hi);
  }
  const result = uInt64ToString(bits2.lo, bits2.hi);
  return negative2 ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate7(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial3 = String(digit1e7);
  return "0000000".slice(partial3.length) + partial3;
};
function varint32write(value10, bytes) {
  if (value10 >= 0) {
    while (value10 > 127) {
      bytes.push(value10 & 127 | 128);
      value10 = value10 >>> 7;
    }
    bytes.push(value10);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value10 & 127 | 128);
      value10 = value10 >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value10) {
        const bi = typeof value10 == "bigint" ? value10 : BigInt(value10);
        if (bi > MAX || bi < MIN) {
          throw new Error(`int64 invalid: ${value10}`);
        }
        return bi;
      },
      uParse(value10) {
        const bi = typeof value10 == "bigint" ? value10 : BigInt(value10);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`uint64 invalid: ${value10}`);
        }
        return bi;
      },
      enc(value10) {
        dv.setBigInt64(0, this.parse(value10), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value10) {
        dv.setBigInt64(0, this.uParse(value10), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  const assertInt64String = (value10) => assert6(/^-?[0-9]+$/.test(value10), `int64 invalid: ${value10}`);
  const assertUInt64String = (value10) => assert6(/^[0-9]+$/.test(value10), `uint64 invalid: ${value10}`);
  return {
    zero: "0",
    supported: false,
    parse(value10) {
      if (typeof value10 != "string") {
        value10 = value10.toString();
      }
      assertInt64String(value10);
      return value10;
    },
    uParse(value10) {
      if (typeof value10 != "string") {
        value10 = value10.toString();
      }
      assertUInt64String(value10);
      return value10;
    },
    enc(value10) {
      if (typeof value10 != "string") {
        value10 = value10.toString();
      }
      assertInt64String(value10);
      return int64FromString(value10);
    },
    uEnc(value10) {
      if (typeof value10 != "string") {
        value10 = value10.toString();
      }
      assertUInt64String(value10);
      return int64FromString(value10);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
var protoInt64 = makeInt64Support();

// node_modules/@bufbuild/protobuf/dist/esm/scalar.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
})(LongType || (LongType = {}));

// node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
function scalarEquals(type8, a, b) {
  if (a === b) {
    return true;
  }
  if (type8 == ScalarType.BYTES) {
    if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  switch (type8) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return a == b;
  }
  return false;
}
function scalarZeroValue(type8, longType) {
  switch (type8) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return longType == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function isScalarZeroValue(type8, value10) {
  switch (type8) {
    case ScalarType.BOOL:
      return value10 === false;
    case ScalarType.STRING:
      return value10 === "";
    case ScalarType.BYTES:
      return value10 instanceof Uint8Array && !value10.byteLength;
    default:
      return value10 == 0;
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk7 = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk7.byteLength);
    return this.raw(chunk7);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type8) {
    return this.uint32((fieldNo << 3 | type8) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk7) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk7);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value10) {
    assertUInt32(value10);
    while (value10 > 127) {
      this.buf.push(value10 & 127 | 128);
      value10 = value10 >>> 7;
    }
    this.buf.push(value10);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value10) {
    assertInt32(value10);
    varint32write(value10, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value10) {
    this.buf.push(value10 ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value10) {
    this.uint32(value10.byteLength);
    return this.raw(value10);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value10) {
    let chunk7 = this.textEncoder.encode(value10);
    this.uint32(chunk7.byteLength);
    return this.raw(chunk7);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value10) {
    assertFloat32(value10);
    let chunk7 = new Uint8Array(4);
    new DataView(chunk7.buffer).setFloat32(0, value10, true);
    return this.raw(chunk7);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value10) {
    let chunk7 = new Uint8Array(8);
    new DataView(chunk7.buffer).setFloat64(0, value10, true);
    return this.raw(chunk7);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value10) {
    assertUInt32(value10);
    let chunk7 = new Uint8Array(4);
    new DataView(chunk7.buffer).setUint32(0, value10, true);
    return this.raw(chunk7);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value10) {
    assertInt32(value10);
    let chunk7 = new Uint8Array(4);
    new DataView(chunk7.buffer).setInt32(0, value10, true);
    return this.raw(chunk7);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value10) {
    assertInt32(value10);
    value10 = (value10 << 1 ^ value10 >> 31) >>> 0;
    varint32write(value10, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value10) {
    let chunk7 = new Uint8Array(8), view = new DataView(chunk7.buffer), tc = protoInt64.enc(value10);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk7);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value10) {
    let chunk7 = new Uint8Array(8), view = new DataView(chunk7.buffer), tc = protoInt64.uEnc(value10);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk7);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value10) {
    let tc = protoInt64.enc(value10);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value10) {
    let tc = protoInt64.enc(value10), sign10 = tc.hi >> 31, lo = tc.lo << 1 ^ sign10, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign10;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value10) {
    let tc = protoInt64.uEnc(value10);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag5 = this.uint32(), fieldNo = tag5 >>> 3, wireType = tag5 & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start5 = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      // eslint-disable-next-line
      // @ts-ignore TS7029: Fallthrough case in switch
      case WireType.Bit64:
        this.pos += 4;
      // eslint-disable-next-line
      // @ts-ignore TS7029: Fallthrough case in switch
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn2, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn2 !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn2);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start5, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt64.dec(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start5 = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start5, start5 + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/extensions.js
function makeExtension(runtime8, typeName, extendee, field) {
  let fi;
  return {
    typeName,
    extendee,
    get field() {
      if (!fi) {
        const i = typeof field == "function" ? field() : field;
        i.name = typeName.split(".").pop();
        i.jsonName = `[${typeName}]`;
        fi = runtime8.util.newFieldList([i]).list()[0];
      }
      return fi;
    },
    runtime: runtime8
  };
}
function createExtensionContainer(extension) {
  const localName2 = extension.field.localName;
  const container = /* @__PURE__ */ Object.create(null);
  container[localName2] = initExtensionField(extension);
  return [container, () => container[localName2]];
}
function initExtensionField(ext) {
  const field = ext.field;
  if (field.repeated) {
    return [];
  }
  if (field.default !== void 0) {
    return field.default;
  }
  switch (field.kind) {
    case "enum":
      return field.T.values[0].no;
    case "scalar":
      return scalarZeroValue(field.T, field.L);
    case "message":
      const T = field.T, value10 = new T();
      return T.fieldWrapper ? T.fieldWrapper.unwrapField(value10) : value10;
    case "map":
      throw "map fields are not allowed to be extensions";
  }
}
function filterUnknownFields(unknownFields, field) {
  if (!field.repeated && (field.kind == "enum" || field.kind == "scalar")) {
    for (let i = unknownFields.length - 1; i >= 0; --i) {
      if (unknownFields[i].no == field.no) {
        return [unknownFields[i]];
      }
    }
    return [];
  }
  return unknownFields.filter((uf) => uf.no === field.no);
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i = 0; i < encTable.length; i++)
  decTable[encTable[i].charCodeAt(0)] = i;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
var protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
    for (let i = 0; i < base64Str.length; i++) {
      b = decTable[base64Str.charCodeAt(i)];
      if (b === void 0) {
        switch (base64Str[i]) {
          // @ts-ignore TS7029: Fallthrough case in switch
          case "=":
            groupPos = 0;
          // reset state when padding found
          // @ts-ignore TS7029: Fallthrough case in switch
          case "\n":
          case "\r":
          case "	":
          case " ":
            continue;
          // skip white-space, and padding
          default:
            throw Error("invalid base64 string.");
        }
      }
      switch (groupPos) {
        case 0:
          p = b;
          groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p << 2 | (b & 48) >> 4;
          p = b;
          groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
          p = b;
          groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p & 3) << 6 | b;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error("invalid base64 string.");
    return bytes.subarray(0, bytePos);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(bytes) {
    let base643 = "", groupPos = 0, b, p = 0;
    for (let i = 0; i < bytes.length; i++) {
      b = bytes[i];
      switch (groupPos) {
        case 0:
          base643 += encTable[b >> 2];
          p = (b & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base643 += encTable[p | b >> 4];
          p = (b & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base643 += encTable[p | b >> 6];
          base643 += encTable[b & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base643 += encTable[p];
      base643 += "=";
      if (groupPos == 1)
        base643 += "=";
    }
    return base643;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/extension-accessor.js
function getExtension(message, extension, options) {
  assertExtendee(extension, message);
  const opt = extension.runtime.bin.makeReadOptions(options);
  const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);
  const [container, get48] = createExtensionContainer(extension);
  for (const uf of ufs) {
    extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);
  }
  return get48();
}
function setExtension(message, extension, value10, options) {
  assertExtendee(extension, message);
  const readOpt = extension.runtime.bin.makeReadOptions(options);
  const writeOpt = extension.runtime.bin.makeWriteOptions(options);
  if (hasExtension(message, extension)) {
    const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf) => uf.no != extension.field.no);
    message.getType().runtime.bin.discardUnknownFields(message);
    for (const uf of ufs) {
      message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);
    }
  }
  const writer = writeOpt.writerFactory();
  let f2 = extension.field;
  if (!f2.opt && !f2.repeated && (f2.kind == "enum" || f2.kind == "scalar")) {
    f2 = Object.assign(Object.assign({}, extension.field), { opt: true });
  }
  extension.runtime.bin.writeField(f2, value10, writer, writeOpt);
  const reader = readOpt.readerFactory(writer.finish());
  while (reader.pos < reader.len) {
    const [no, wireType] = reader.tag();
    const data = reader.skip(wireType, no);
    message.getType().runtime.bin.onUnknownField(message, no, wireType, data);
  }
}
function hasExtension(message, extension) {
  const messageType = message.getType();
  return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf) => uf.no == extension.field.no);
}
function assertExtendee(extension, message) {
  assert6(extension.extendee.typeName == message.getType().typeName, `extension ${extension.typeName} can only be applied to message ${extension.extendee.typeName}`);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/reflect.js
function isFieldSet(field, target) {
  const localName2 = field.localName;
  if (field.repeated) {
    return target[localName2].length > 0;
  }
  if (field.oneof) {
    return target[field.oneof.localName].case === localName2;
  }
  switch (field.kind) {
    case "enum":
    case "scalar":
      if (field.opt || field.req) {
        return target[localName2] !== void 0;
      }
      if (field.kind == "enum") {
        return target[localName2] !== field.T.values[0].no;
      }
      return !isScalarZeroValue(field.T, target[localName2]);
    case "message":
      return target[localName2] !== void 0;
    case "map":
      return Object.keys(target[localName2]).length > 0;
  }
}
function clearField(field, target) {
  const localName2 = field.localName;
  const implicitPresence = !field.opt && !field.req;
  if (field.repeated) {
    target[localName2] = [];
  } else if (field.oneof) {
    target[field.oneof.localName] = { case: void 0 };
  } else {
    switch (field.kind) {
      case "map":
        target[localName2] = {};
        break;
      case "enum":
        target[localName2] = implicitPresence ? field.T.values[0].no : void 0;
        break;
      case "scalar":
        target[localName2] = implicitPresence ? scalarZeroValue(field.T, field.L) : void 0;
        break;
      case "message":
        target[localName2] = void 0;
        break;
    }
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/is-message.js
function isMessage(arg, type8) {
  if (arg === null || typeof arg != "object") {
    return false;
  }
  if (!Object.getOwnPropertyNames(Message.prototype).every((m) => m in arg && typeof arg[m] == "function")) {
    return false;
  }
  const actualType = arg.getType();
  if (actualType === null || typeof actualType != "function" || !("typeName" in actualType) || typeof actualType.typeName != "string") {
    return false;
  }
  return type8 === void 0 ? true : actualType.typeName == type8.typeName;
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
function wrapField(type8, value10) {
  if (isMessage(value10) || !type8.fieldWrapper) {
    return value10;
  }
  return type8.fieldWrapper.wrapField(value10);
}
var wktWrapperToScalarType = {
  "google.protobuf.DoubleValue": ScalarType.DOUBLE,
  "google.protobuf.FloatValue": ScalarType.FLOAT,
  "google.protobuf.Int64Value": ScalarType.INT64,
  "google.protobuf.UInt64Value": ScalarType.UINT64,
  "google.protobuf.Int32Value": ScalarType.INT32,
  "google.protobuf.UInt32Value": ScalarType.UINT32,
  "google.protobuf.BoolValue": ScalarType.BOOL,
  "google.protobuf.StringValue": ScalarType.STRING,
  "google.protobuf.BytesValue": ScalarType.BYTES
};

// node_modules/@bufbuild/protobuf/dist/esm/private/json-format.js
var jsonReadDefaults = {
  ignoreUnknownFields: false
};
var jsonWriteDefaults = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
function makeReadOptions(options) {
  return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
}
function makeWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
}
var tokenNull = Symbol();
var tokenIgnoredUnknownEnum = Symbol();
function makeJsonFormat() {
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(type8, json3, options, message) {
      if (json3 == null || Array.isArray(json3) || typeof json3 != "object") {
        throw new Error(`cannot decode message ${type8.typeName} from JSON: ${debugJsonValue(json3)}`);
      }
      message = message !== null && message !== void 0 ? message : new type8();
      const oneofSeen = /* @__PURE__ */ new Map();
      const registry = options.typeRegistry;
      for (const [jsonKey, jsonValue2] of Object.entries(json3)) {
        const field = type8.fields.findJsonName(jsonKey);
        if (field) {
          if (field.oneof) {
            if (jsonValue2 === null && field.kind == "scalar") {
              continue;
            }
            const seen = oneofSeen.get(field.oneof);
            if (seen !== void 0) {
              throw new Error(`cannot decode message ${type8.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
            }
            oneofSeen.set(field.oneof, jsonKey);
          }
          readField(message, jsonValue2, field, options, type8);
        } else {
          let found = false;
          if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith("[") && jsonKey.endsWith("]")) {
            const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));
            if (ext && ext.extendee.typeName == type8.typeName) {
              found = true;
              const [container, get48] = createExtensionContainer(ext);
              readField(container, jsonValue2, ext.field, options, ext);
              setExtension(message, ext, get48(), options);
            }
          }
          if (!found && !options.ignoreUnknownFields) {
            throw new Error(`cannot decode message ${type8.typeName} from JSON: key "${jsonKey}" is unknown`);
          }
        }
      }
      return message;
    },
    writeMessage(message, options) {
      const type8 = message.getType();
      const json3 = {};
      let field;
      try {
        for (field of type8.fields.byNumber()) {
          if (!isFieldSet(field, message)) {
            if (field.req) {
              throw `required field not set`;
            }
            if (!options.emitDefaultValues) {
              continue;
            }
            if (!canEmitFieldDefaultValue(field)) {
              continue;
            }
          }
          const value10 = field.oneof ? message[field.oneof.localName].value : message[field.localName];
          const jsonValue2 = writeField(field, value10, options);
          if (jsonValue2 !== void 0) {
            json3[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
          }
        }
        const registry = options.typeRegistry;
        if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {
          for (const uf of type8.runtime.bin.listUnknownFields(message)) {
            const ext = registry.findExtensionFor(type8.typeName, uf.no);
            if (ext && hasExtension(message, ext)) {
              const value10 = getExtension(message, ext, options);
              const jsonValue2 = writeField(ext.field, value10, options);
              if (jsonValue2 !== void 0) {
                json3[ext.field.jsonName] = jsonValue2;
              }
            }
          }
        }
      } catch (e) {
        const m = field ? `cannot encode field ${type8.typeName}.${field.name} to JSON` : `cannot encode message ${type8.typeName} to JSON`;
        const r = e instanceof Error ? e.message : String(e);
        throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
      }
      return json3;
    },
    readScalar(type8, json3, longType) {
      return readScalar(type8, json3, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);
    },
    writeScalar(type8, value10, emitDefaultValues) {
      if (value10 === void 0) {
        return void 0;
      }
      if (emitDefaultValues || isScalarZeroValue(type8, value10)) {
        return writeScalar(type8, value10);
      }
      return void 0;
    },
    debug: debugJsonValue
  };
}
function debugJsonValue(json3) {
  if (json3 === null) {
    return "null";
  }
  switch (typeof json3) {
    case "object":
      return Array.isArray(json3) ? "array" : "object";
    case "string":
      return json3.length > 100 ? "string" : `"${json3.split('"').join('\\"')}"`;
    default:
      return String(json3);
  }
}
function readField(target, jsonValue2, field, options, parentType) {
  let localName2 = field.localName;
  if (field.repeated) {
    assert6(field.kind != "map");
    if (jsonValue2 === null) {
      return;
    }
    if (!Array.isArray(jsonValue2)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue2)}`);
    }
    const targetArray = target[localName2];
    for (const jsonItem of jsonValue2) {
      if (jsonItem === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`);
      }
      switch (field.kind) {
        case "message":
          targetArray.push(field.T.fromJson(jsonItem, options));
          break;
        case "enum":
          const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetArray.push(enumValue);
          }
          break;
        case "scalar":
          try {
            targetArray.push(readScalar(field.T, jsonItem, field.L, true));
          } catch (e) {
            let m = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonItem)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  } else if (field.kind == "map") {
    if (jsonValue2 === null) {
      return;
    }
    if (typeof jsonValue2 != "object" || Array.isArray(jsonValue2)) {
      throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue2)}`);
    }
    const targetMap = target[localName2];
    for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue2)) {
      if (jsonMapValue === null) {
        throw new Error(`cannot decode field ${parentType.typeName}.${field.name} from JSON: map value null`);
      }
      let key;
      try {
        key = readMapKey(field.K, jsonMapKey);
      } catch (e) {
        let m = `cannot decode map key for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue2)}`;
        if (e instanceof Error && e.message.length > 0) {
          m += `: ${e.message}`;
        }
        throw new Error(m);
      }
      switch (field.V.kind) {
        case "message":
          targetMap[key] = field.V.T.fromJson(jsonMapValue, options);
          break;
        case "enum":
          const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);
          if (enumValue !== tokenIgnoredUnknownEnum) {
            targetMap[key] = enumValue;
          }
          break;
        case "scalar":
          try {
            targetMap[key] = readScalar(field.V.T, jsonMapValue, LongType.BIGINT, true);
          } catch (e) {
            let m = `cannot decode map value for field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue2)}`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          break;
      }
    }
  } else {
    if (field.oneof) {
      target = target[field.oneof.localName] = { case: localName2 };
      localName2 = "value";
    }
    switch (field.kind) {
      case "message":
        const messageType = field.T;
        if (jsonValue2 === null && messageType.typeName != "google.protobuf.Value") {
          return;
        }
        let currentValue = target[localName2];
        if (isMessage(currentValue)) {
          currentValue.fromJson(jsonValue2, options);
        } else {
          target[localName2] = currentValue = messageType.fromJson(jsonValue2, options);
          if (messageType.fieldWrapper && !field.oneof) {
            target[localName2] = messageType.fieldWrapper.unwrapField(currentValue);
          }
        }
        break;
      case "enum":
        const enumValue = readEnum(field.T, jsonValue2, options.ignoreUnknownFields, false);
        switch (enumValue) {
          case tokenNull:
            clearField(field, target);
            break;
          case tokenIgnoredUnknownEnum:
            break;
          default:
            target[localName2] = enumValue;
            break;
        }
        break;
      case "scalar":
        try {
          const scalarValue = readScalar(field.T, jsonValue2, field.L, false);
          switch (scalarValue) {
            case tokenNull:
              clearField(field, target);
              break;
            default:
              target[localName2] = scalarValue;
              break;
          }
        } catch (e) {
          let m = `cannot decode field ${parentType.typeName}.${field.name} from JSON: ${debugJsonValue(jsonValue2)}`;
          if (e instanceof Error && e.message.length > 0) {
            m += `: ${e.message}`;
          }
          throw new Error(m);
        }
        break;
    }
  }
}
function readMapKey(type8, json3) {
  if (type8 === ScalarType.BOOL) {
    switch (json3) {
      case "true":
        json3 = true;
        break;
      case "false":
        json3 = false;
        break;
    }
  }
  return readScalar(type8, json3, LongType.BIGINT, true).toString();
}
function readScalar(type8, json3, longType, nullAsZeroValue) {
  if (json3 === null) {
    if (nullAsZeroValue) {
      return scalarZeroValue(type8, longType);
    }
    return tokenNull;
  }
  switch (type8) {
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (json3 === "NaN")
        return Number.NaN;
      if (json3 === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (json3 === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (json3 === "") {
        break;
      }
      if (typeof json3 == "string" && json3.trim().length !== json3.length) {
        break;
      }
      if (typeof json3 != "string" && typeof json3 != "number") {
        break;
      }
      const float2 = Number(json3);
      if (Number.isNaN(float2)) {
        break;
      }
      if (!Number.isFinite(float2)) {
        break;
      }
      if (type8 == ScalarType.FLOAT)
        assertFloat32(float2);
      return float2;
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      let int32;
      if (typeof json3 == "number")
        int32 = json3;
      else if (typeof json3 == "string" && json3.length > 0) {
        if (json3.trim().length === json3.length)
          int32 = Number(json3);
      }
      if (int32 === void 0)
        break;
      if (type8 == ScalarType.UINT32 || type8 == ScalarType.FIXED32)
        assertUInt32(int32);
      else
        assertInt32(int32);
      return int32;
    // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (typeof json3 != "number" && typeof json3 != "string")
        break;
      const long = protoInt64.parse(json3);
      return longType ? long.toString() : long;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (typeof json3 != "number" && typeof json3 != "string")
        break;
      const uLong = protoInt64.uParse(json3);
      return longType ? uLong.toString() : uLong;
    // bool:
    case ScalarType.BOOL:
      if (typeof json3 !== "boolean")
        break;
      return json3;
    // string:
    case ScalarType.STRING:
      if (typeof json3 !== "string") {
        break;
      }
      try {
        encodeURIComponent(json3);
      } catch (e) {
        throw new Error("invalid UTF8");
      }
      return json3;
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case ScalarType.BYTES:
      if (json3 === "")
        return new Uint8Array(0);
      if (typeof json3 !== "string")
        break;
      return protoBase64.dec(json3);
  }
  throw new Error();
}
function readEnum(type8, json3, ignoreUnknownFields, nullAsZeroValue) {
  if (json3 === null) {
    if (type8.typeName == "google.protobuf.NullValue") {
      return 0;
    }
    return nullAsZeroValue ? type8.values[0].no : tokenNull;
  }
  switch (typeof json3) {
    case "number":
      if (Number.isInteger(json3)) {
        return json3;
      }
      break;
    case "string":
      const value10 = type8.findName(json3);
      if (value10 !== void 0) {
        return value10.no;
      }
      if (ignoreUnknownFields) {
        return tokenIgnoredUnknownEnum;
      }
      break;
  }
  throw new Error(`cannot decode enum ${type8.typeName} from JSON: ${debugJsonValue(json3)}`);
}
function canEmitFieldDefaultValue(field) {
  if (field.repeated || field.kind == "map") {
    return true;
  }
  if (field.oneof) {
    return false;
  }
  if (field.kind == "message") {
    return false;
  }
  if (field.opt || field.req) {
    return false;
  }
  return true;
}
function writeField(field, value10, options) {
  if (field.kind == "map") {
    assert6(typeof value10 == "object" && value10 != null);
    const jsonObj = {};
    const entries6 = Object.entries(value10);
    switch (field.V.kind) {
      case "scalar":
        for (const [entryKey, entryValue] of entries6) {
          jsonObj[entryKey.toString()] = writeScalar(field.V.T, entryValue);
        }
        break;
      case "message":
        for (const [entryKey, entryValue] of entries6) {
          jsonObj[entryKey.toString()] = entryValue.toJson(options);
        }
        break;
      case "enum":
        const enumType = field.V.T;
        for (const [entryKey, entryValue] of entries6) {
          jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);
        }
        break;
    }
    return options.emitDefaultValues || entries6.length > 0 ? jsonObj : void 0;
  }
  if (field.repeated) {
    assert6(Array.isArray(value10));
    const jsonArr = [];
    switch (field.kind) {
      case "scalar":
        for (let i = 0; i < value10.length; i++) {
          jsonArr.push(writeScalar(field.T, value10[i]));
        }
        break;
      case "enum":
        for (let i = 0; i < value10.length; i++) {
          jsonArr.push(writeEnum(field.T, value10[i], options.enumAsInteger));
        }
        break;
      case "message":
        for (let i = 0; i < value10.length; i++) {
          jsonArr.push(value10[i].toJson(options));
        }
        break;
    }
    return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
  }
  switch (field.kind) {
    case "scalar":
      return writeScalar(field.T, value10);
    case "enum":
      return writeEnum(field.T, value10, options.enumAsInteger);
    case "message":
      return wrapField(field.T, value10).toJson(options);
  }
}
function writeEnum(type8, value10, enumAsInteger) {
  var _a106;
  assert6(typeof value10 == "number");
  if (type8.typeName == "google.protobuf.NullValue") {
    return null;
  }
  if (enumAsInteger) {
    return value10;
  }
  const val = type8.findNumber(value10);
  return (_a106 = val === null || val === void 0 ? void 0 : val.name) !== null && _a106 !== void 0 ? _a106 : value10;
}
function writeScalar(type8, value10) {
  switch (type8) {
    // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
    case ScalarType.INT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
      assert6(typeof value10 == "number");
      return value10;
    // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
    // Either numbers or strings are accepted. Exponent notation is also accepted.
    case ScalarType.FLOAT:
    // assertFloat32(value);
    case ScalarType.DOUBLE:
      assert6(typeof value10 == "number");
      if (Number.isNaN(value10))
        return "NaN";
      if (value10 === Number.POSITIVE_INFINITY)
        return "Infinity";
      if (value10 === Number.NEGATIVE_INFINITY)
        return "-Infinity";
      return value10;
    // string:
    case ScalarType.STRING:
      assert6(typeof value10 == "string");
      return value10;
    // bool:
    case ScalarType.BOOL:
      assert6(typeof value10 == "boolean");
      return value10;
    // JSON value will be a decimal string. Either numbers or strings are accepted.
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      assert6(typeof value10 == "bigint" || typeof value10 == "string" || typeof value10 == "number");
      return value10.toString();
    // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
    // Either standard or URL-safe base64 encoding with/without paddings are accepted.
    case ScalarType.BYTES:
      assert6(value10 instanceof Uint8Array);
      return protoBase64.enc(value10);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/private/binary-format.js
var unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
var readDefaults = {
  readUnknownFields: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
var writeDefaults = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions2(options) {
  return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function makeWriteOptions2(options) {
  return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
function makeBinaryFormat() {
  return {
    makeReadOptions: makeReadOptions2,
    makeWriteOptions: makeWriteOptions2,
    listUnknownFields(message) {
      var _a106;
      return (_a106 = message[unknownFieldsSymbol]) !== null && _a106 !== void 0 ? _a106 : [];
    },
    discardUnknownFields(message) {
      delete message[unknownFieldsSymbol];
    },
    writeUnknownFields(message, writer) {
      const m = message;
      const c = m[unknownFieldsSymbol];
      if (c) {
        for (const f2 of c) {
          writer.tag(f2.no, f2.wireType).raw(f2.data);
        }
      }
    },
    onUnknownField(message, no, wireType, data) {
      const m = message;
      if (!Array.isArray(m[unknownFieldsSymbol])) {
        m[unknownFieldsSymbol] = [];
      }
      m[unknownFieldsSymbol].push({ no, wireType, data });
    },
    readMessage(message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {
      const type8 = message.getType();
      const end7 = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;
      let fieldNo, wireType;
      while (reader.pos < end7) {
        [fieldNo, wireType] = reader.tag();
        if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {
          break;
        }
        const field = type8.fields.find(fieldNo);
        if (!field) {
          const data = reader.skip(wireType, fieldNo);
          if (options.readUnknownFields) {
            this.onUnknownField(message, fieldNo, wireType, data);
          }
          continue;
        }
        readField2(message, reader, field, wireType, options);
      }
      if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions
      (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {
        throw new Error(`invalid end group tag`);
      }
    },
    readField: readField2,
    writeMessage(message, writer, options) {
      const type8 = message.getType();
      for (const field of type8.fields.byNumber()) {
        if (!isFieldSet(field, message)) {
          if (field.req) {
            throw new Error(`cannot encode field ${type8.typeName}.${field.name} to binary: required field not set`);
          }
          continue;
        }
        const value10 = field.oneof ? message[field.oneof.localName].value : message[field.localName];
        writeField2(field, value10, writer, options);
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message, writer);
      }
      return writer;
    },
    writeField(field, value10, writer, options) {
      if (value10 === void 0) {
        return void 0;
      }
      writeField2(field, value10, writer, options);
    }
  };
}
function readField2(target, reader, field, wireType, options) {
  let { repeated: repeated4, localName: localName2 } = field;
  if (field.oneof) {
    target = target[field.oneof.localName];
    if (target.case != localName2) {
      delete target.value;
    }
    target.case = localName2;
    localName2 = "value";
  }
  switch (field.kind) {
    case "scalar":
    case "enum":
      const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      let read3 = readScalar2;
      if (field.kind == "scalar" && field.L > 0) {
        read3 = readScalarLTString;
      }
      if (repeated4) {
        let arr = target[localName2];
        const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;
        if (isPacked) {
          let e = reader.uint32() + reader.pos;
          while (reader.pos < e) {
            arr.push(read3(reader, scalarType));
          }
        } else {
          arr.push(read3(reader, scalarType));
        }
      } else {
        target[localName2] = read3(reader, scalarType);
      }
      break;
    case "message":
      const messageType = field.T;
      if (repeated4) {
        target[localName2].push(readMessageField(reader, new messageType(), options, field));
      } else {
        if (isMessage(target[localName2])) {
          readMessageField(reader, target[localName2], options, field);
        } else {
          target[localName2] = readMessageField(reader, new messageType(), options, field);
          if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
            target[localName2] = messageType.fieldWrapper.unwrapField(target[localName2]);
          }
        }
      }
      break;
    case "map":
      let [mapKey, mapVal] = readMapEntry(field, reader, options);
      target[localName2][mapKey] = mapVal;
      break;
  }
}
function readMessageField(reader, message, options, field) {
  const format16 = message.getType().runtime.bin;
  const delimited = field === null || field === void 0 ? void 0 : field.delimited;
  format16.readMessage(
    message,
    reader,
    delimited ? field.no : reader.uint32(),
    // eslint-disable-line @typescript-eslint/strict-boolean-expressions
    options,
    delimited
  );
  return message;
}
function readMapEntry(field, reader, options) {
  const length6 = reader.uint32(), end7 = reader.pos + length6;
  let key, val;
  while (reader.pos < end7) {
    const [fieldNo] = reader.tag();
    switch (fieldNo) {
      case 1:
        key = readScalar2(reader, field.K);
        break;
      case 2:
        switch (field.V.kind) {
          case "scalar":
            val = readScalar2(reader, field.V.T);
            break;
          case "enum":
            val = reader.int32();
            break;
          case "message":
            val = readMessageField(reader, new field.V.T(), options, void 0);
            break;
        }
        break;
    }
  }
  if (key === void 0) {
    key = scalarZeroValue(field.K, LongType.BIGINT);
  }
  if (typeof key != "string" && typeof key != "number") {
    key = key.toString();
  }
  if (val === void 0) {
    switch (field.V.kind) {
      case "scalar":
        val = scalarZeroValue(field.V.T, LongType.BIGINT);
        break;
      case "enum":
        val = field.V.T.values[0].no;
        break;
      case "message":
        val = new field.V.T();
        break;
    }
  }
  return [key, val];
}
function readScalarLTString(reader, type8) {
  const v = readScalar2(reader, type8);
  return typeof v == "bigint" ? v.toString() : v;
}
function readScalar2(reader, type8) {
  switch (type8) {
    case ScalarType.STRING:
      return reader.string();
    case ScalarType.BOOL:
      return reader.bool();
    case ScalarType.DOUBLE:
      return reader.double();
    case ScalarType.FLOAT:
      return reader.float();
    case ScalarType.INT32:
      return reader.int32();
    case ScalarType.INT64:
      return reader.int64();
    case ScalarType.UINT64:
      return reader.uint64();
    case ScalarType.FIXED64:
      return reader.fixed64();
    case ScalarType.BYTES:
      return reader.bytes();
    case ScalarType.FIXED32:
      return reader.fixed32();
    case ScalarType.SFIXED32:
      return reader.sfixed32();
    case ScalarType.SFIXED64:
      return reader.sfixed64();
    case ScalarType.SINT64:
      return reader.sint64();
    case ScalarType.UINT32:
      return reader.uint32();
    case ScalarType.SINT32:
      return reader.sint32();
  }
}
function writeField2(field, value10, writer, options) {
  assert6(value10 !== void 0);
  const repeated4 = field.repeated;
  switch (field.kind) {
    case "scalar":
    case "enum":
      let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
      if (repeated4) {
        assert6(Array.isArray(value10));
        if (field.packed) {
          writePacked(writer, scalarType, field.no, value10);
        } else {
          for (const item of value10) {
            writeScalar2(writer, scalarType, field.no, item);
          }
        }
      } else {
        writeScalar2(writer, scalarType, field.no, value10);
      }
      break;
    case "message":
      if (repeated4) {
        assert6(Array.isArray(value10));
        for (const item of value10) {
          writeMessageField(writer, options, field, item);
        }
      } else {
        writeMessageField(writer, options, field, value10);
      }
      break;
    case "map":
      assert6(typeof value10 == "object" && value10 != null);
      for (const [key, val] of Object.entries(value10)) {
        writeMapEntry(writer, options, field, key, val);
      }
      break;
  }
}
function writeMapEntry(writer, options, field, key, value10) {
  writer.tag(field.no, WireType.LengthDelimited);
  writer.fork();
  let keyValue = key;
  switch (field.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      keyValue = Number.parseInt(key);
      break;
    case ScalarType.BOOL:
      assert6(key == "true" || key == "false");
      keyValue = key == "true";
      break;
  }
  writeScalar2(writer, field.K, 1, keyValue);
  switch (field.V.kind) {
    case "scalar":
      writeScalar2(writer, field.V.T, 2, value10);
      break;
    case "enum":
      writeScalar2(writer, ScalarType.INT32, 2, value10);
      break;
    case "message":
      assert6(value10 !== void 0);
      writer.tag(2, WireType.LengthDelimited).bytes(value10.toBinary(options));
      break;
  }
  writer.join();
}
function writeMessageField(writer, options, field, value10) {
  const message = wrapField(field.T, value10);
  if (field.delimited)
    writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);
  else
    writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));
}
function writeScalar2(writer, type8, fieldNo, value10) {
  assert6(value10 !== void 0);
  let [wireType, method] = scalarTypeInfo(type8);
  writer.tag(fieldNo, wireType)[method](value10);
}
function writePacked(writer, type8, fieldNo, value10) {
  if (!value10.length) {
    return;
  }
  writer.tag(fieldNo, WireType.LengthDelimited).fork();
  let [, method] = scalarTypeInfo(type8);
  for (let i = 0; i < value10.length; i++) {
    writer[method](value10[i]);
  }
  writer.join();
}
function scalarTypeInfo(type8) {
  let wireType = WireType.Varint;
  switch (type8) {
    case ScalarType.BYTES:
    case ScalarType.STRING:
      wireType = WireType.LengthDelimited;
      break;
    case ScalarType.DOUBLE:
    case ScalarType.FIXED64:
    case ScalarType.SFIXED64:
      wireType = WireType.Bit64;
      break;
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.FLOAT:
      wireType = WireType.Bit32;
      break;
  }
  const method = ScalarType[type8].toLowerCase();
  return [wireType, method];
}

// node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(source, target) {
      if (source === void 0) {
        return;
      }
      const type8 = target.getType();
      for (const member of type8.fields.byMember()) {
        const localName2 = member.localName, t = target, s = source;
        if (s[localName2] == null) {
          continue;
        }
        switch (member.kind) {
          case "oneof":
            const sk = s[localName2].case;
            if (sk === void 0) {
              continue;
            }
            const sourceField = member.findField(sk);
            let val = s[localName2].value;
            if (sourceField && sourceField.kind == "message" && !isMessage(val, sourceField.T)) {
              val = new sourceField.T(val);
            } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
              val = toU8Arr(val);
            }
            t[localName2] = { case: sk, value: val };
            break;
          case "scalar":
          case "enum":
            let copy4 = s[localName2];
            if (member.T === ScalarType.BYTES) {
              copy4 = member.repeated ? copy4.map(toU8Arr) : toU8Arr(copy4);
            }
            t[localName2] = copy4;
            break;
          case "map":
            switch (member.V.kind) {
              case "scalar":
              case "enum":
                if (member.V.T === ScalarType.BYTES) {
                  for (const [k, v] of Object.entries(s[localName2])) {
                    t[localName2][k] = toU8Arr(v);
                  }
                } else {
                  Object.assign(t[localName2], s[localName2]);
                }
                break;
              case "message":
                const messageType = member.V.T;
                for (const k of Object.keys(s[localName2])) {
                  let val2 = s[localName2][k];
                  if (!messageType.fieldWrapper) {
                    val2 = new messageType(val2);
                  }
                  t[localName2][k] = val2;
                }
                break;
            }
            break;
          case "message":
            const mt = member.T;
            if (member.repeated) {
              t[localName2] = s[localName2].map((val2) => isMessage(val2, mt) ? val2 : new mt(val2));
            } else {
              const val2 = s[localName2];
              if (mt.fieldWrapper) {
                if (
                  // We can't use BytesValue.typeName as that will create a circular import
                  mt.typeName === "google.protobuf.BytesValue"
                ) {
                  t[localName2] = toU8Arr(val2);
                } else {
                  t[localName2] = val2;
                }
              } else {
                t[localName2] = isMessage(val2, mt) ? val2 : new mt(val2);
              }
            }
            break;
        }
      }
    },
    // TODO use isFieldSet() here to support future field presence
    equals(type8, a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      return type8.fields.byMember().every((m) => {
        const va = a[m.localName];
        const vb = b[m.localName];
        if (m.repeated) {
          if (va.length !== vb.length) {
            return false;
          }
          switch (m.kind) {
            case "message":
              return va.every((a2, i) => m.T.equals(a2, vb[i]));
            case "scalar":
              return va.every((a2, i) => scalarEquals(m.T, a2, vb[i]));
            case "enum":
              return va.every((a2, i) => scalarEquals(ScalarType.INT32, a2, vb[i]));
          }
          throw new Error(`repeated cannot contain ${m.kind}`);
        }
        switch (m.kind) {
          case "message":
            let a2 = va;
            let b3 = vb;
            if (m.T.fieldWrapper) {
              if (a2 !== void 0 && !isMessage(a2)) {
                a2 = m.T.fieldWrapper.wrapField(a2);
              }
              if (b3 !== void 0 && !isMessage(b3)) {
                b3 = m.T.fieldWrapper.wrapField(b3);
              }
            }
            return m.T.equals(a2, b3);
          case "enum":
            return scalarEquals(ScalarType.INT32, va, vb);
          case "scalar":
            return scalarEquals(m.T, va, vb);
          case "oneof":
            if (va.case !== vb.case) {
              return false;
            }
            const s = m.findField(va.case);
            if (s === void 0) {
              return true;
            }
            switch (s.kind) {
              case "message":
                return s.T.equals(va.value, vb.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, va.value, vb.value);
              case "scalar":
                return scalarEquals(s.T, va.value, vb.value);
            }
            throw new Error(`oneof cannot contain ${s.kind}`);
          case "map":
            const keys15 = Object.keys(va).concat(Object.keys(vb));
            switch (m.V.kind) {
              case "message":
                const messageType = m.V.T;
                return keys15.every((k) => messageType.equals(va[k], vb[k]));
              case "enum":
                return keys15.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
              case "scalar":
                const scalarType = m.V.T;
                return keys15.every((k) => scalarEquals(scalarType, va[k], vb[k]));
            }
            break;
        }
      });
    },
    // TODO use isFieldSet() here to support future field presence
    clone(message) {
      const type8 = message.getType(), target = new type8(), any3 = target;
      for (const member of type8.fields.byMember()) {
        const source = message[member.localName];
        let copy4;
        if (member.repeated) {
          copy4 = source.map(cloneSingularField);
        } else if (member.kind == "map") {
          copy4 = any3[member.localName];
          for (const [key, v] of Object.entries(source)) {
            copy4[key] = cloneSingularField(v);
          }
        } else if (member.kind == "oneof") {
          const f2 = member.findField(source.case);
          copy4 = f2 ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
        } else {
          copy4 = cloneSingularField(source);
        }
        any3[member.localName] = copy4;
      }
      for (const uf of type8.runtime.bin.listUnknownFields(message)) {
        type8.runtime.bin.onUnknownField(any3, uf.no, uf.wireType, uf.data);
      }
      return target;
    }
  };
}
function cloneSingularField(value10) {
  if (value10 === void 0) {
    return value10;
  }
  if (isMessage(value10)) {
    return value10.clone();
  }
  if (value10 instanceof Uint8Array) {
    const c = new Uint8Array(value10.byteLength);
    c.set(value10);
    return c;
  }
  return value10;
}
function toU8Arr(input) {
  return input instanceof Uint8Array ? input : new Uint8Array(input);
}

// node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
function makeProtoRuntime(syntax, newFieldList, initFields) {
  return {
    syntax,
    json: makeJsonFormat(),
    bin: makeBinaryFormat(),
    util: Object.assign(Object.assign({}, makeUtilCommon()), {
      newFieldList,
      initFields
    }),
    makeMessageType(typeName, fields, opt) {
      return makeMessageType(this, typeName, fields, opt);
    },
    makeEnum,
    makeEnumType,
    getEnumType,
    makeExtension(typeName, extendee, field) {
      return makeExtension(this, typeName, extendee, field);
    }
  };
}

// node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js
var InternalFieldList = class {
  constructor(fields, normalizer) {
    this._fields = fields;
    this._normalizer = normalizer;
  }
  findJsonName(jsonName) {
    if (!this.jsonNames) {
      const t = {};
      for (const f2 of this.list()) {
        t[f2.jsonName] = t[f2.name] = f2;
      }
      this.jsonNames = t;
    }
    return this.jsonNames[jsonName];
  }
  find(fieldNo) {
    if (!this.numbers) {
      const t = {};
      for (const f2 of this.list()) {
        t[f2.no] = f2;
      }
      this.numbers = t;
    }
    return this.numbers[fieldNo];
  }
  list() {
    if (!this.all) {
      this.all = this._normalizer(this._fields);
    }
    return this.all;
  }
  byNumber() {
    if (!this.numbersAsc) {
      this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
    }
    return this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const a = this.members;
      let o;
      for (const f2 of this.list()) {
        if (f2.oneof) {
          if (f2.oneof !== o) {
            o = f2.oneof;
            a.push(o);
          }
        } else {
          a.push(f2);
        }
      }
    }
    return this.members;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/names.js
function localFieldName(protoName, inOneof) {
  const name = protoCamelCase(protoName);
  if (inOneof) {
    return name;
  }
  return safeObjectProperty(safeMessageProperty(name));
}
function localOneofName(protoName) {
  return localFieldName(protoName, false);
}
var fieldJsonName = protoCamelCase;
function protoCamelCase(snakeCase4) {
  let capNext = false;
  const b = [];
  for (let i = 0; i < snakeCase4.length; i++) {
    let c = snakeCase4.charAt(i);
    switch (c) {
      case "_":
        capNext = true;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        b.push(c);
        capNext = false;
        break;
      default:
        if (capNext) {
          capNext = false;
          c = c.toUpperCase();
        }
        b.push(c);
        break;
    }
  }
  return b.join("");
}
var reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]);
var reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]);
var fallback2 = (name) => `${name}$`;
var safeMessageProperty = (name) => {
  if (reservedMessageProperties.has(name)) {
    return fallback2(name);
  }
  return name;
};
var safeObjectProperty = (name) => {
  if (reservedObjectProperties.has(name)) {
    return fallback2(name);
  }
  return name;
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field.js
var InternalOneofInfo = class {
  constructor(name) {
    this.kind = "oneof";
    this.repeated = false;
    this.packed = false;
    this.opt = false;
    this.req = false;
    this.default = void 0;
    this.fields = [];
    this.name = name;
    this.localName = localOneofName(name);
  }
  addField(field) {
    assert6(field.oneof === this, `field ${field.name} not one of ${this.name}`);
    this.fields.push(field);
  }
  findField(localName2) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < this.fields.length; i++) {
        this._lookup[this.fields[i].localName] = this.fields[i];
      }
    }
    return this._lookup[localName2];
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/private/field-normalize.js
function normalizeFieldInfos(fieldInfos, packedByDefault) {
  var _a106, _b32, _c7, _d4, _e2, _f2;
  const r = [];
  let o;
  for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
    const f2 = field;
    f2.localName = localFieldName(field.name, field.oneof !== void 0);
    f2.jsonName = (_a106 = field.jsonName) !== null && _a106 !== void 0 ? _a106 : fieldJsonName(field.name);
    f2.repeated = (_b32 = field.repeated) !== null && _b32 !== void 0 ? _b32 : false;
    if (field.kind == "scalar") {
      f2.L = (_c7 = field.L) !== null && _c7 !== void 0 ? _c7 : LongType.BIGINT;
    }
    f2.delimited = (_d4 = field.delimited) !== null && _d4 !== void 0 ? _d4 : false;
    f2.req = (_e2 = field.req) !== null && _e2 !== void 0 ? _e2 : false;
    f2.opt = (_f2 = field.opt) !== null && _f2 !== void 0 ? _f2 : false;
    if (field.packed === void 0) {
      if (packedByDefault) {
        f2.packed = field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
      } else {
        f2.packed = false;
      }
    }
    if (field.oneof !== void 0) {
      const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
      if (!o || o.name != ooname) {
        o = new InternalOneofInfo(ooname);
      }
      f2.oneof = o;
      o.addField(f2);
    }
    r.push(f2);
  }
  return r;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto3.js
var proto32 = makeProtoRuntime(
  "proto3",
  (fields) => {
    return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, true));
  },
  // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      if (member.opt) {
        continue;
      }
      const name = member.localName, t = target;
      if (member.repeated) {
        t[name] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name] = { case: void 0 };
          break;
        case "enum":
          t[name] = 0;
          break;
        case "map":
          t[name] = {};
          break;
        case "scalar":
          t[name] = scalarZeroValue(member.T, member.L);
          break;
        case "message":
          break;
      }
    }
  }
);

// node_modules/@bufbuild/protobuf/dist/esm/proto2.js
var proto22 = makeProtoRuntime(
  "proto2",
  (fields) => {
    return new InternalFieldList(fields, (source) => normalizeFieldInfos(source, false));
  },
  // TODO merge with proto3 and initExtensionField, also see initPartial, equals, clone
  (target) => {
    for (const member of target.getType().fields.byMember()) {
      const name = member.localName, t = target;
      if (member.repeated) {
        t[name] = [];
        continue;
      }
      switch (member.kind) {
        case "oneof":
          t[name] = { case: void 0 };
          break;
        case "map":
          t[name] = {};
          break;
        case "scalar":
        case "enum":
        case "message":
          break;
      }
    }
  }
);

// node_modules/@bufbuild/protobuf/dist/esm/proto-double.js
var protoDouble = {
  NaN: Number.NaN,
  POSITIVE_INFINITY: Number.POSITIVE_INFINITY,
  NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY
};

// node_modules/@bufbuild/protobuf/dist/esm/service-type.js
var MethodKind;
(function(MethodKind2) {
  MethodKind2[MethodKind2["Unary"] = 0] = "Unary";
  MethodKind2[MethodKind2["ServerStreaming"] = 1] = "ServerStreaming";
  MethodKind2[MethodKind2["ClientStreaming"] = 2] = "ClientStreaming";
  MethodKind2[MethodKind2["BiDiStreaming"] = 3] = "BiDiStreaming";
})(MethodKind || (MethodKind = {}));
var MethodIdempotency;
(function(MethodIdempotency2) {
  MethodIdempotency2[MethodIdempotency2["NoSideEffects"] = 1] = "NoSideEffects";
  MethodIdempotency2[MethodIdempotency2["Idempotent"] = 2] = "Idempotent";
})(MethodIdempotency || (MethodIdempotency = {}));

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/descriptor_pb.js
var Edition;
(function(Edition2) {
  Edition2[Edition2["EDITION_UNKNOWN"] = 0] = "EDITION_UNKNOWN";
  Edition2[Edition2["EDITION_LEGACY"] = 900] = "EDITION_LEGACY";
  Edition2[Edition2["EDITION_PROTO2"] = 998] = "EDITION_PROTO2";
  Edition2[Edition2["EDITION_PROTO3"] = 999] = "EDITION_PROTO3";
  Edition2[Edition2["EDITION_2023"] = 1e3] = "EDITION_2023";
  Edition2[Edition2["EDITION_2024"] = 1001] = "EDITION_2024";
  Edition2[Edition2["EDITION_1_TEST_ONLY"] = 1] = "EDITION_1_TEST_ONLY";
  Edition2[Edition2["EDITION_2_TEST_ONLY"] = 2] = "EDITION_2_TEST_ONLY";
  Edition2[Edition2["EDITION_99997_TEST_ONLY"] = 99997] = "EDITION_99997_TEST_ONLY";
  Edition2[Edition2["EDITION_99998_TEST_ONLY"] = 99998] = "EDITION_99998_TEST_ONLY";
  Edition2[Edition2["EDITION_99999_TEST_ONLY"] = 99999] = "EDITION_99999_TEST_ONLY";
  Edition2[Edition2["EDITION_MAX"] = 2147483647] = "EDITION_MAX";
})(Edition || (Edition = {}));
proto22.util.setEnumType(Edition, "google.protobuf.Edition", [
  { no: 0, name: "EDITION_UNKNOWN" },
  { no: 900, name: "EDITION_LEGACY" },
  { no: 998, name: "EDITION_PROTO2" },
  { no: 999, name: "EDITION_PROTO3" },
  { no: 1e3, name: "EDITION_2023" },
  { no: 1001, name: "EDITION_2024" },
  { no: 1, name: "EDITION_1_TEST_ONLY" },
  { no: 2, name: "EDITION_2_TEST_ONLY" },
  { no: 99997, name: "EDITION_99997_TEST_ONLY" },
  { no: 99998, name: "EDITION_99998_TEST_ONLY" },
  { no: 99999, name: "EDITION_99999_TEST_ONLY" },
  { no: 2147483647, name: "EDITION_MAX" }
]);
var FileDescriptorSet = class _FileDescriptorSet extends Message {
  constructor(data) {
    super();
    this.file = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileDescriptorSet().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FileDescriptorSet().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileDescriptorSet().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FileDescriptorSet, a, b);
  }
};
FileDescriptorSet.runtime = proto22;
FileDescriptorSet.typeName = "google.protobuf.FileDescriptorSet";
FileDescriptorSet.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "file", kind: "message", T: FileDescriptorProto, repeated: true }
]);
var FileDescriptorProto = class _FileDescriptorProto extends Message {
  constructor(data) {
    super();
    this.dependency = [];
    this.publicDependency = [];
    this.weakDependency = [];
    this.messageType = [];
    this.enumType = [];
    this.service = [];
    this.extension = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FileDescriptorProto().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FileDescriptorProto, a, b);
  }
};
FileDescriptorProto.runtime = proto22;
FileDescriptorProto.typeName = "google.protobuf.FileDescriptorProto";
FileDescriptorProto.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "package", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "dependency", kind: "scalar", T: 9, repeated: true },
  { no: 10, name: "public_dependency", kind: "scalar", T: 5, repeated: true },
  { no: 11, name: "weak_dependency", kind: "scalar", T: 5, repeated: true },
  { no: 4, name: "message_type", kind: "message", T: DescriptorProto, repeated: true },
  { no: 5, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
  { no: 6, name: "service", kind: "message", T: ServiceDescriptorProto, repeated: true },
  { no: 7, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 8, name: "options", kind: "message", T: FileOptions, opt: true },
  { no: 9, name: "source_code_info", kind: "message", T: SourceCodeInfo, opt: true },
  { no: 12, name: "syntax", kind: "scalar", T: 9, opt: true },
  { no: 14, name: "edition", kind: "enum", T: proto22.getEnumType(Edition), opt: true }
]);
var DescriptorProto = class _DescriptorProto extends Message {
  constructor(data) {
    super();
    this.field = [];
    this.extension = [];
    this.nestedType = [];
    this.enumType = [];
    this.extensionRange = [];
    this.oneofDecl = [];
    this.reservedRange = [];
    this.reservedName = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _DescriptorProto().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_DescriptorProto, a, b);
  }
};
DescriptorProto.runtime = proto22;
DescriptorProto.typeName = "google.protobuf.DescriptorProto";
DescriptorProto.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "field", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 6, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
  { no: 3, name: "nested_type", kind: "message", T: DescriptorProto, repeated: true },
  { no: 4, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
  { no: 5, name: "extension_range", kind: "message", T: DescriptorProto_ExtensionRange, repeated: true },
  { no: 8, name: "oneof_decl", kind: "message", T: OneofDescriptorProto, repeated: true },
  { no: 7, name: "options", kind: "message", T: MessageOptions, opt: true },
  { no: 9, name: "reserved_range", kind: "message", T: DescriptorProto_ReservedRange, repeated: true },
  { no: 10, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
]);
var DescriptorProto_ExtensionRange = class _DescriptorProto_ExtensionRange extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto_ExtensionRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _DescriptorProto_ExtensionRange().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto_ExtensionRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_DescriptorProto_ExtensionRange, a, b);
  }
};
DescriptorProto_ExtensionRange.runtime = proto22;
DescriptorProto_ExtensionRange.typeName = "google.protobuf.DescriptorProto.ExtensionRange";
DescriptorProto_ExtensionRange.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "options", kind: "message", T: ExtensionRangeOptions, opt: true }
]);
var DescriptorProto_ReservedRange = class _DescriptorProto_ReservedRange extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _DescriptorProto_ReservedRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _DescriptorProto_ReservedRange().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DescriptorProto_ReservedRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_DescriptorProto_ReservedRange, a, b);
  }
};
DescriptorProto_ReservedRange.runtime = proto22;
DescriptorProto_ReservedRange.typeName = "google.protobuf.DescriptorProto.ReservedRange";
DescriptorProto_ReservedRange.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
]);
var ExtensionRangeOptions = class _ExtensionRangeOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    this.declaration = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ExtensionRangeOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _ExtensionRangeOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ExtensionRangeOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_ExtensionRangeOptions, a, b);
  }
};
ExtensionRangeOptions.runtime = proto22;
ExtensionRangeOptions.typeName = "google.protobuf.ExtensionRangeOptions";
ExtensionRangeOptions.fields = proto22.util.newFieldList(() => [
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true },
  { no: 2, name: "declaration", kind: "message", T: ExtensionRangeOptions_Declaration, repeated: true },
  { no: 50, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 3, name: "verification", kind: "enum", T: proto22.getEnumType(ExtensionRangeOptions_VerificationState), opt: true, default: ExtensionRangeOptions_VerificationState.UNVERIFIED }
]);
var ExtensionRangeOptions_VerificationState;
(function(ExtensionRangeOptions_VerificationState2) {
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["DECLARATION"] = 0] = "DECLARATION";
  ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["UNVERIFIED"] = 1] = "UNVERIFIED";
})(ExtensionRangeOptions_VerificationState || (ExtensionRangeOptions_VerificationState = {}));
proto22.util.setEnumType(ExtensionRangeOptions_VerificationState, "google.protobuf.ExtensionRangeOptions.VerificationState", [
  { no: 0, name: "DECLARATION" },
  { no: 1, name: "UNVERIFIED" }
]);
var ExtensionRangeOptions_Declaration = class _ExtensionRangeOptions_Declaration extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ExtensionRangeOptions_Declaration().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _ExtensionRangeOptions_Declaration().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ExtensionRangeOptions_Declaration().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_ExtensionRangeOptions_Declaration, a, b);
  }
};
ExtensionRangeOptions_Declaration.runtime = proto22;
ExtensionRangeOptions_Declaration.typeName = "google.protobuf.ExtensionRangeOptions.Declaration";
ExtensionRangeOptions_Declaration.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "full_name", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "type", kind: "scalar", T: 9, opt: true },
  { no: 5, name: "reserved", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "repeated", kind: "scalar", T: 8, opt: true }
]);
var FieldDescriptorProto = class _FieldDescriptorProto extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FieldDescriptorProto().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FieldDescriptorProto, a, b);
  }
};
FieldDescriptorProto.runtime = proto22;
FieldDescriptorProto.typeName = "google.protobuf.FieldDescriptorProto";
FieldDescriptorProto.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "label", kind: "enum", T: proto22.getEnumType(FieldDescriptorProto_Label), opt: true },
  { no: 5, name: "type", kind: "enum", T: proto22.getEnumType(FieldDescriptorProto_Type), opt: true },
  { no: 6, name: "type_name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "extendee", kind: "scalar", T: 9, opt: true },
  { no: 7, name: "default_value", kind: "scalar", T: 9, opt: true },
  { no: 9, name: "oneof_index", kind: "scalar", T: 5, opt: true },
  { no: 10, name: "json_name", kind: "scalar", T: 9, opt: true },
  { no: 8, name: "options", kind: "message", T: FieldOptions, opt: true },
  { no: 17, name: "proto3_optional", kind: "scalar", T: 8, opt: true }
]);
var FieldDescriptorProto_Type;
(function(FieldDescriptorProto_Type2) {
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["DOUBLE"] = 1] = "DOUBLE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FLOAT"] = 2] = "FLOAT";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT64"] = 3] = "INT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT64"] = 4] = "UINT64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT32"] = 5] = "INT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED64"] = 6] = "FIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED32"] = 7] = "FIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BOOL"] = 8] = "BOOL";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["STRING"] = 9] = "STRING";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["GROUP"] = 10] = "GROUP";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["MESSAGE"] = 11] = "MESSAGE";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BYTES"] = 12] = "BYTES";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT32"] = 13] = "UINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["ENUM"] = 14] = "ENUM";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED32"] = 15] = "SFIXED32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED64"] = 16] = "SFIXED64";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT32"] = 17] = "SINT32";
  FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT64"] = 18] = "SINT64";
})(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));
proto22.util.setEnumType(FieldDescriptorProto_Type, "google.protobuf.FieldDescriptorProto.Type", [
  { no: 1, name: "TYPE_DOUBLE" },
  { no: 2, name: "TYPE_FLOAT" },
  { no: 3, name: "TYPE_INT64" },
  { no: 4, name: "TYPE_UINT64" },
  { no: 5, name: "TYPE_INT32" },
  { no: 6, name: "TYPE_FIXED64" },
  { no: 7, name: "TYPE_FIXED32" },
  { no: 8, name: "TYPE_BOOL" },
  { no: 9, name: "TYPE_STRING" },
  { no: 10, name: "TYPE_GROUP" },
  { no: 11, name: "TYPE_MESSAGE" },
  { no: 12, name: "TYPE_BYTES" },
  { no: 13, name: "TYPE_UINT32" },
  { no: 14, name: "TYPE_ENUM" },
  { no: 15, name: "TYPE_SFIXED32" },
  { no: 16, name: "TYPE_SFIXED64" },
  { no: 17, name: "TYPE_SINT32" },
  { no: 18, name: "TYPE_SINT64" }
]);
var FieldDescriptorProto_Label;
(function(FieldDescriptorProto_Label2) {
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["OPTIONAL"] = 1] = "OPTIONAL";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REPEATED"] = 3] = "REPEATED";
  FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REQUIRED"] = 2] = "REQUIRED";
})(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));
proto22.util.setEnumType(FieldDescriptorProto_Label, "google.protobuf.FieldDescriptorProto.Label", [
  { no: 1, name: "LABEL_OPTIONAL" },
  { no: 3, name: "LABEL_REPEATED" },
  { no: 2, name: "LABEL_REQUIRED" }
]);
var OneofDescriptorProto = class _OneofDescriptorProto extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _OneofDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _OneofDescriptorProto().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _OneofDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_OneofDescriptorProto, a, b);
  }
};
OneofDescriptorProto.runtime = proto22;
OneofDescriptorProto.typeName = "google.protobuf.OneofDescriptorProto";
OneofDescriptorProto.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "options", kind: "message", T: OneofOptions, opt: true }
]);
var EnumDescriptorProto = class _EnumDescriptorProto extends Message {
  constructor(data) {
    super();
    this.value = [];
    this.reservedRange = [];
    this.reservedName = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _EnumDescriptorProto().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_EnumDescriptorProto, a, b);
  }
};
EnumDescriptorProto.runtime = proto22;
EnumDescriptorProto.typeName = "google.protobuf.EnumDescriptorProto";
EnumDescriptorProto.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "value", kind: "message", T: EnumValueDescriptorProto, repeated: true },
  { no: 3, name: "options", kind: "message", T: EnumOptions, opt: true },
  { no: 4, name: "reserved_range", kind: "message", T: EnumDescriptorProto_EnumReservedRange, repeated: true },
  { no: 5, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
]);
var EnumDescriptorProto_EnumReservedRange = class _EnumDescriptorProto_EnumReservedRange extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumDescriptorProto_EnumReservedRange().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_EnumDescriptorProto_EnumReservedRange, a, b);
  }
};
EnumDescriptorProto_EnumReservedRange.runtime = proto22;
EnumDescriptorProto_EnumReservedRange.typeName = "google.protobuf.EnumDescriptorProto.EnumReservedRange";
EnumDescriptorProto_EnumReservedRange.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
]);
var EnumValueDescriptorProto = class _EnumValueDescriptorProto extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValueDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _EnumValueDescriptorProto().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValueDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_EnumValueDescriptorProto, a, b);
  }
};
EnumValueDescriptorProto.runtime = proto22;
EnumValueDescriptorProto.typeName = "google.protobuf.EnumValueDescriptorProto";
EnumValueDescriptorProto.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "number", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "options", kind: "message", T: EnumValueOptions, opt: true }
]);
var ServiceDescriptorProto = class _ServiceDescriptorProto extends Message {
  constructor(data) {
    super();
    this.method = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ServiceDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _ServiceDescriptorProto().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ServiceDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_ServiceDescriptorProto, a, b);
  }
};
ServiceDescriptorProto.runtime = proto22;
ServiceDescriptorProto.typeName = "google.protobuf.ServiceDescriptorProto";
ServiceDescriptorProto.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "method", kind: "message", T: MethodDescriptorProto, repeated: true },
  { no: 3, name: "options", kind: "message", T: ServiceOptions, opt: true }
]);
var MethodDescriptorProto = class _MethodDescriptorProto extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MethodDescriptorProto().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _MethodDescriptorProto().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MethodDescriptorProto().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_MethodDescriptorProto, a, b);
  }
};
MethodDescriptorProto.runtime = proto22;
MethodDescriptorProto.typeName = "google.protobuf.MethodDescriptorProto";
MethodDescriptorProto.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "input_type", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "output_type", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "options", kind: "message", T: MethodOptions, opt: true },
  { no: 5, name: "client_streaming", kind: "scalar", T: 8, opt: true, default: false },
  { no: 6, name: "server_streaming", kind: "scalar", T: 8, opt: true, default: false }
]);
var FileOptions = class _FileOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FileOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FileOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FileOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FileOptions, a, b);
  }
};
FileOptions.runtime = proto22;
FileOptions.typeName = "google.protobuf.FileOptions";
FileOptions.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "java_package", kind: "scalar", T: 9, opt: true },
  { no: 8, name: "java_outer_classname", kind: "scalar", T: 9, opt: true },
  { no: 10, name: "java_multiple_files", kind: "scalar", T: 8, opt: true, default: false },
  { no: 20, name: "java_generate_equals_and_hash", kind: "scalar", T: 8, opt: true },
  { no: 27, name: "java_string_check_utf8", kind: "scalar", T: 8, opt: true, default: false },
  { no: 9, name: "optimize_for", kind: "enum", T: proto22.getEnumType(FileOptions_OptimizeMode), opt: true, default: FileOptions_OptimizeMode.SPEED },
  { no: 11, name: "go_package", kind: "scalar", T: 9, opt: true },
  { no: 16, name: "cc_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 17, name: "java_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 18, name: "py_generic_services", kind: "scalar", T: 8, opt: true, default: false },
  { no: 23, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 31, name: "cc_enable_arenas", kind: "scalar", T: 8, opt: true, default: true },
  { no: 36, name: "objc_class_prefix", kind: "scalar", T: 9, opt: true },
  { no: 37, name: "csharp_namespace", kind: "scalar", T: 9, opt: true },
  { no: 39, name: "swift_prefix", kind: "scalar", T: 9, opt: true },
  { no: 40, name: "php_class_prefix", kind: "scalar", T: 9, opt: true },
  { no: 41, name: "php_namespace", kind: "scalar", T: 9, opt: true },
  { no: 44, name: "php_metadata_namespace", kind: "scalar", T: 9, opt: true },
  { no: 45, name: "ruby_package", kind: "scalar", T: 9, opt: true },
  { no: 50, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FileOptions_OptimizeMode;
(function(FileOptions_OptimizeMode2) {
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
  FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
})(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));
proto22.util.setEnumType(FileOptions_OptimizeMode, "google.protobuf.FileOptions.OptimizeMode", [
  { no: 1, name: "SPEED" },
  { no: 2, name: "CODE_SIZE" },
  { no: 3, name: "LITE_RUNTIME" }
]);
var MessageOptions = class _MessageOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MessageOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _MessageOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MessageOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_MessageOptions, a, b);
  }
};
MessageOptions.runtime = proto22;
MessageOptions.typeName = "google.protobuf.MessageOptions";
MessageOptions.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "message_set_wire_format", kind: "scalar", T: 8, opt: true, default: false },
  { no: 2, name: "no_standard_descriptor_accessor", kind: "scalar", T: 8, opt: true, default: false },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 7, name: "map_entry", kind: "scalar", T: 8, opt: true },
  { no: 11, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
  { no: 12, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FieldOptions = class _FieldOptions extends Message {
  constructor(data) {
    super();
    this.targets = [];
    this.editionDefaults = [];
    this.uninterpretedOption = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FieldOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FieldOptions, a, b);
  }
};
FieldOptions.runtime = proto22;
FieldOptions.typeName = "google.protobuf.FieldOptions";
FieldOptions.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "ctype", kind: "enum", T: proto22.getEnumType(FieldOptions_CType), opt: true, default: FieldOptions_CType.STRING },
  { no: 2, name: "packed", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "jstype", kind: "enum", T: proto22.getEnumType(FieldOptions_JSType), opt: true, default: FieldOptions_JSType.JS_NORMAL },
  { no: 5, name: "lazy", kind: "scalar", T: 8, opt: true, default: false },
  { no: 15, name: "unverified_lazy", kind: "scalar", T: 8, opt: true, default: false },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 10, name: "weak", kind: "scalar", T: 8, opt: true, default: false },
  { no: 16, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
  { no: 17, name: "retention", kind: "enum", T: proto22.getEnumType(FieldOptions_OptionRetention), opt: true },
  { no: 19, name: "targets", kind: "enum", T: proto22.getEnumType(FieldOptions_OptionTargetType), repeated: true },
  { no: 20, name: "edition_defaults", kind: "message", T: FieldOptions_EditionDefault, repeated: true },
  { no: 21, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 22, name: "feature_support", kind: "message", T: FieldOptions_FeatureSupport, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var FieldOptions_CType;
(function(FieldOptions_CType2) {
  FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
  FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
  FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
})(FieldOptions_CType || (FieldOptions_CType = {}));
proto22.util.setEnumType(FieldOptions_CType, "google.protobuf.FieldOptions.CType", [
  { no: 0, name: "STRING" },
  { no: 1, name: "CORD" },
  { no: 2, name: "STRING_PIECE" }
]);
var FieldOptions_JSType;
(function(FieldOptions_JSType2) {
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
  FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
})(FieldOptions_JSType || (FieldOptions_JSType = {}));
proto22.util.setEnumType(FieldOptions_JSType, "google.protobuf.FieldOptions.JSType", [
  { no: 0, name: "JS_NORMAL" },
  { no: 1, name: "JS_STRING" },
  { no: 2, name: "JS_NUMBER" }
]);
var FieldOptions_OptionRetention;
(function(FieldOptions_OptionRetention2) {
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
  FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
})(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));
proto22.util.setEnumType(FieldOptions_OptionRetention, "google.protobuf.FieldOptions.OptionRetention", [
  { no: 0, name: "RETENTION_UNKNOWN" },
  { no: 1, name: "RETENTION_RUNTIME" },
  { no: 2, name: "RETENTION_SOURCE" }
]);
var FieldOptions_OptionTargetType;
(function(FieldOptions_OptionTargetType2) {
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
  FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
})(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));
proto22.util.setEnumType(FieldOptions_OptionTargetType, "google.protobuf.FieldOptions.OptionTargetType", [
  { no: 0, name: "TARGET_TYPE_UNKNOWN" },
  { no: 1, name: "TARGET_TYPE_FILE" },
  { no: 2, name: "TARGET_TYPE_EXTENSION_RANGE" },
  { no: 3, name: "TARGET_TYPE_MESSAGE" },
  { no: 4, name: "TARGET_TYPE_FIELD" },
  { no: 5, name: "TARGET_TYPE_ONEOF" },
  { no: 6, name: "TARGET_TYPE_ENUM" },
  { no: 7, name: "TARGET_TYPE_ENUM_ENTRY" },
  { no: 8, name: "TARGET_TYPE_SERVICE" },
  { no: 9, name: "TARGET_TYPE_METHOD" }
]);
var FieldOptions_EditionDefault = class _FieldOptions_EditionDefault extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions_EditionDefault().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FieldOptions_EditionDefault().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions_EditionDefault().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FieldOptions_EditionDefault, a, b);
  }
};
FieldOptions_EditionDefault.runtime = proto22;
FieldOptions_EditionDefault.typeName = "google.protobuf.FieldOptions.EditionDefault";
FieldOptions_EditionDefault.fields = proto22.util.newFieldList(() => [
  { no: 3, name: "edition", kind: "enum", T: proto22.getEnumType(Edition), opt: true },
  { no: 2, name: "value", kind: "scalar", T: 9, opt: true }
]);
var FieldOptions_FeatureSupport = class _FieldOptions_FeatureSupport extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FieldOptions_FeatureSupport().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FieldOptions_FeatureSupport().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldOptions_FeatureSupport().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FieldOptions_FeatureSupport, a, b);
  }
};
FieldOptions_FeatureSupport.runtime = proto22;
FieldOptions_FeatureSupport.typeName = "google.protobuf.FieldOptions.FeatureSupport";
FieldOptions_FeatureSupport.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "edition_introduced", kind: "enum", T: proto22.getEnumType(Edition), opt: true },
  { no: 2, name: "edition_deprecated", kind: "enum", T: proto22.getEnumType(Edition), opt: true },
  { no: 3, name: "deprecation_warning", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "edition_removed", kind: "enum", T: proto22.getEnumType(Edition), opt: true }
]);
var OneofOptions = class _OneofOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _OneofOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _OneofOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _OneofOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_OneofOptions, a, b);
  }
};
OneofOptions.runtime = proto22;
OneofOptions.typeName = "google.protobuf.OneofOptions";
OneofOptions.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var EnumOptions = class _EnumOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _EnumOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_EnumOptions, a, b);
  }
};
EnumOptions.runtime = proto22;
EnumOptions.typeName = "google.protobuf.EnumOptions";
EnumOptions.fields = proto22.util.newFieldList(() => [
  { no: 2, name: "allow_alias", kind: "scalar", T: 8, opt: true },
  { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 6, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
  { no: 7, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var EnumValueOptions = class _EnumValueOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValueOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _EnumValueOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValueOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_EnumValueOptions, a, b);
  }
};
EnumValueOptions.runtime = proto22;
EnumValueOptions.typeName = "google.protobuf.EnumValueOptions";
EnumValueOptions.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 2, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 3, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
  { no: 4, name: "feature_support", kind: "message", T: FieldOptions_FeatureSupport, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var ServiceOptions = class _ServiceOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ServiceOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _ServiceOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ServiceOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_ServiceOptions, a, b);
  }
};
ServiceOptions.runtime = proto22;
ServiceOptions.typeName = "google.protobuf.ServiceOptions";
ServiceOptions.fields = proto22.util.newFieldList(() => [
  { no: 34, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var MethodOptions = class _MethodOptions extends Message {
  constructor(data) {
    super();
    this.uninterpretedOption = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _MethodOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _MethodOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _MethodOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_MethodOptions, a, b);
  }
};
MethodOptions.runtime = proto22;
MethodOptions.typeName = "google.protobuf.MethodOptions";
MethodOptions.fields = proto22.util.newFieldList(() => [
  { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
  { no: 34, name: "idempotency_level", kind: "enum", T: proto22.getEnumType(MethodOptions_IdempotencyLevel), opt: true, default: MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN },
  { no: 35, name: "features", kind: "message", T: FeatureSet, opt: true },
  { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
]);
var MethodOptions_IdempotencyLevel;
(function(MethodOptions_IdempotencyLevel2) {
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
  MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
})(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));
proto22.util.setEnumType(MethodOptions_IdempotencyLevel, "google.protobuf.MethodOptions.IdempotencyLevel", [
  { no: 0, name: "IDEMPOTENCY_UNKNOWN" },
  { no: 1, name: "NO_SIDE_EFFECTS" },
  { no: 2, name: "IDEMPOTENT" }
]);
var UninterpretedOption = class _UninterpretedOption extends Message {
  constructor(data) {
    super();
    this.name = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UninterpretedOption().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _UninterpretedOption().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UninterpretedOption().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_UninterpretedOption, a, b);
  }
};
UninterpretedOption.runtime = proto22;
UninterpretedOption.typeName = "google.protobuf.UninterpretedOption";
UninterpretedOption.fields = proto22.util.newFieldList(() => [
  { no: 2, name: "name", kind: "message", T: UninterpretedOption_NamePart, repeated: true },
  { no: 3, name: "identifier_value", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "positive_int_value", kind: "scalar", T: 4, opt: true },
  { no: 5, name: "negative_int_value", kind: "scalar", T: 3, opt: true },
  { no: 6, name: "double_value", kind: "scalar", T: 1, opt: true },
  { no: 7, name: "string_value", kind: "scalar", T: 12, opt: true },
  { no: 8, name: "aggregate_value", kind: "scalar", T: 9, opt: true }
]);
var UninterpretedOption_NamePart = class _UninterpretedOption_NamePart extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UninterpretedOption_NamePart().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _UninterpretedOption_NamePart().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UninterpretedOption_NamePart().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_UninterpretedOption_NamePart, a, b);
  }
};
UninterpretedOption_NamePart.runtime = proto22;
UninterpretedOption_NamePart.typeName = "google.protobuf.UninterpretedOption.NamePart";
UninterpretedOption_NamePart.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name_part", kind: "scalar", T: 9, req: true },
  { no: 2, name: "is_extension", kind: "scalar", T: 8, req: true }
]);
var FeatureSet = class _FeatureSet extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSet().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FeatureSet().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSet().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FeatureSet, a, b);
  }
};
FeatureSet.runtime = proto22;
FeatureSet.typeName = "google.protobuf.FeatureSet";
FeatureSet.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "field_presence", kind: "enum", T: proto22.getEnumType(FeatureSet_FieldPresence), opt: true },
  { no: 2, name: "enum_type", kind: "enum", T: proto22.getEnumType(FeatureSet_EnumType), opt: true },
  { no: 3, name: "repeated_field_encoding", kind: "enum", T: proto22.getEnumType(FeatureSet_RepeatedFieldEncoding), opt: true },
  { no: 4, name: "utf8_validation", kind: "enum", T: proto22.getEnumType(FeatureSet_Utf8Validation), opt: true },
  { no: 5, name: "message_encoding", kind: "enum", T: proto22.getEnumType(FeatureSet_MessageEncoding), opt: true },
  { no: 6, name: "json_format", kind: "enum", T: proto22.getEnumType(FeatureSet_JsonFormat), opt: true }
]);
var FeatureSet_FieldPresence;
(function(FeatureSet_FieldPresence2) {
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["FIELD_PRESENCE_UNKNOWN"] = 0] = "FIELD_PRESENCE_UNKNOWN";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["EXPLICIT"] = 1] = "EXPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["IMPLICIT"] = 2] = "IMPLICIT";
  FeatureSet_FieldPresence2[FeatureSet_FieldPresence2["LEGACY_REQUIRED"] = 3] = "LEGACY_REQUIRED";
})(FeatureSet_FieldPresence || (FeatureSet_FieldPresence = {}));
proto22.util.setEnumType(FeatureSet_FieldPresence, "google.protobuf.FeatureSet.FieldPresence", [
  { no: 0, name: "FIELD_PRESENCE_UNKNOWN" },
  { no: 1, name: "EXPLICIT" },
  { no: 2, name: "IMPLICIT" },
  { no: 3, name: "LEGACY_REQUIRED" }
]);
var FeatureSet_EnumType;
(function(FeatureSet_EnumType2) {
  FeatureSet_EnumType2[FeatureSet_EnumType2["ENUM_TYPE_UNKNOWN"] = 0] = "ENUM_TYPE_UNKNOWN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["OPEN"] = 1] = "OPEN";
  FeatureSet_EnumType2[FeatureSet_EnumType2["CLOSED"] = 2] = "CLOSED";
})(FeatureSet_EnumType || (FeatureSet_EnumType = {}));
proto22.util.setEnumType(FeatureSet_EnumType, "google.protobuf.FeatureSet.EnumType", [
  { no: 0, name: "ENUM_TYPE_UNKNOWN" },
  { no: 1, name: "OPEN" },
  { no: 2, name: "CLOSED" }
]);
var FeatureSet_RepeatedFieldEncoding;
(function(FeatureSet_RepeatedFieldEncoding2) {
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["REPEATED_FIELD_ENCODING_UNKNOWN"] = 0] = "REPEATED_FIELD_ENCODING_UNKNOWN";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["PACKED"] = 1] = "PACKED";
  FeatureSet_RepeatedFieldEncoding2[FeatureSet_RepeatedFieldEncoding2["EXPANDED"] = 2] = "EXPANDED";
})(FeatureSet_RepeatedFieldEncoding || (FeatureSet_RepeatedFieldEncoding = {}));
proto22.util.setEnumType(FeatureSet_RepeatedFieldEncoding, "google.protobuf.FeatureSet.RepeatedFieldEncoding", [
  { no: 0, name: "REPEATED_FIELD_ENCODING_UNKNOWN" },
  { no: 1, name: "PACKED" },
  { no: 2, name: "EXPANDED" }
]);
var FeatureSet_Utf8Validation;
(function(FeatureSet_Utf8Validation2) {
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["UTF8_VALIDATION_UNKNOWN"] = 0] = "UTF8_VALIDATION_UNKNOWN";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["VERIFY"] = 2] = "VERIFY";
  FeatureSet_Utf8Validation2[FeatureSet_Utf8Validation2["NONE"] = 3] = "NONE";
})(FeatureSet_Utf8Validation || (FeatureSet_Utf8Validation = {}));
proto22.util.setEnumType(FeatureSet_Utf8Validation, "google.protobuf.FeatureSet.Utf8Validation", [
  { no: 0, name: "UTF8_VALIDATION_UNKNOWN" },
  { no: 2, name: "VERIFY" },
  { no: 3, name: "NONE" }
]);
var FeatureSet_MessageEncoding;
(function(FeatureSet_MessageEncoding2) {
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["MESSAGE_ENCODING_UNKNOWN"] = 0] = "MESSAGE_ENCODING_UNKNOWN";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["LENGTH_PREFIXED"] = 1] = "LENGTH_PREFIXED";
  FeatureSet_MessageEncoding2[FeatureSet_MessageEncoding2["DELIMITED"] = 2] = "DELIMITED";
})(FeatureSet_MessageEncoding || (FeatureSet_MessageEncoding = {}));
proto22.util.setEnumType(FeatureSet_MessageEncoding, "google.protobuf.FeatureSet.MessageEncoding", [
  { no: 0, name: "MESSAGE_ENCODING_UNKNOWN" },
  { no: 1, name: "LENGTH_PREFIXED" },
  { no: 2, name: "DELIMITED" }
]);
var FeatureSet_JsonFormat;
(function(FeatureSet_JsonFormat2) {
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["JSON_FORMAT_UNKNOWN"] = 0] = "JSON_FORMAT_UNKNOWN";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["ALLOW"] = 1] = "ALLOW";
  FeatureSet_JsonFormat2[FeatureSet_JsonFormat2["LEGACY_BEST_EFFORT"] = 2] = "LEGACY_BEST_EFFORT";
})(FeatureSet_JsonFormat || (FeatureSet_JsonFormat = {}));
proto22.util.setEnumType(FeatureSet_JsonFormat, "google.protobuf.FeatureSet.JsonFormat", [
  { no: 0, name: "JSON_FORMAT_UNKNOWN" },
  { no: 1, name: "ALLOW" },
  { no: 2, name: "LEGACY_BEST_EFFORT" }
]);
var FeatureSetDefaults = class _FeatureSetDefaults extends Message {
  constructor(data) {
    super();
    this.defaults = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSetDefaults().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FeatureSetDefaults().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSetDefaults().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FeatureSetDefaults, a, b);
  }
};
FeatureSetDefaults.runtime = proto22;
FeatureSetDefaults.typeName = "google.protobuf.FeatureSetDefaults";
FeatureSetDefaults.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "defaults", kind: "message", T: FeatureSetDefaults_FeatureSetEditionDefault, repeated: true },
  { no: 4, name: "minimum_edition", kind: "enum", T: proto22.getEnumType(Edition), opt: true },
  { no: 5, name: "maximum_edition", kind: "enum", T: proto22.getEnumType(Edition), opt: true }
]);
var FeatureSetDefaults_FeatureSetEditionDefault = class _FeatureSetDefaults_FeatureSetEditionDefault extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FeatureSetDefaults_FeatureSetEditionDefault().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_FeatureSetDefaults_FeatureSetEditionDefault, a, b);
  }
};
FeatureSetDefaults_FeatureSetEditionDefault.runtime = proto22;
FeatureSetDefaults_FeatureSetEditionDefault.typeName = "google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault";
FeatureSetDefaults_FeatureSetEditionDefault.fields = proto22.util.newFieldList(() => [
  { no: 3, name: "edition", kind: "enum", T: proto22.getEnumType(Edition), opt: true },
  { no: 4, name: "overridable_features", kind: "message", T: FeatureSet, opt: true },
  { no: 5, name: "fixed_features", kind: "message", T: FeatureSet, opt: true }
]);
var SourceCodeInfo = class _SourceCodeInfo extends Message {
  constructor(data) {
    super();
    this.location = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceCodeInfo().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _SourceCodeInfo().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceCodeInfo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_SourceCodeInfo, a, b);
  }
};
SourceCodeInfo.runtime = proto22;
SourceCodeInfo.typeName = "google.protobuf.SourceCodeInfo";
SourceCodeInfo.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "location", kind: "message", T: SourceCodeInfo_Location, repeated: true }
]);
var SourceCodeInfo_Location = class _SourceCodeInfo_Location extends Message {
  constructor(data) {
    super();
    this.path = [];
    this.span = [];
    this.leadingDetachedComments = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceCodeInfo_Location().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _SourceCodeInfo_Location().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceCodeInfo_Location().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_SourceCodeInfo_Location, a, b);
  }
};
SourceCodeInfo_Location.runtime = proto22;
SourceCodeInfo_Location.typeName = "google.protobuf.SourceCodeInfo.Location";
SourceCodeInfo_Location.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 2, name: "span", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 3, name: "leading_comments", kind: "scalar", T: 9, opt: true },
  { no: 4, name: "trailing_comments", kind: "scalar", T: 9, opt: true },
  { no: 6, name: "leading_detached_comments", kind: "scalar", T: 9, repeated: true }
]);
var GeneratedCodeInfo = class _GeneratedCodeInfo extends Message {
  constructor(data) {
    super();
    this.annotation = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _GeneratedCodeInfo().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _GeneratedCodeInfo().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _GeneratedCodeInfo().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_GeneratedCodeInfo, a, b);
  }
};
GeneratedCodeInfo.runtime = proto22;
GeneratedCodeInfo.typeName = "google.protobuf.GeneratedCodeInfo";
GeneratedCodeInfo.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "annotation", kind: "message", T: GeneratedCodeInfo_Annotation, repeated: true }
]);
var GeneratedCodeInfo_Annotation = class _GeneratedCodeInfo_Annotation extends Message {
  constructor(data) {
    super();
    this.path = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _GeneratedCodeInfo_Annotation().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _GeneratedCodeInfo_Annotation().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _GeneratedCodeInfo_Annotation().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_GeneratedCodeInfo_Annotation, a, b);
  }
};
GeneratedCodeInfo_Annotation.runtime = proto22;
GeneratedCodeInfo_Annotation.typeName = "google.protobuf.GeneratedCodeInfo.Annotation";
GeneratedCodeInfo_Annotation.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
  { no: 2, name: "source_file", kind: "scalar", T: 9, opt: true },
  { no: 3, name: "begin", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "end", kind: "scalar", T: 5, opt: true },
  { no: 5, name: "semantic", kind: "enum", T: proto22.getEnumType(GeneratedCodeInfo_Annotation_Semantic), opt: true }
]);
var GeneratedCodeInfo_Annotation_Semantic;
(function(GeneratedCodeInfo_Annotation_Semantic2) {
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
  GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
})(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));
proto22.util.setEnumType(GeneratedCodeInfo_Annotation_Semantic, "google.protobuf.GeneratedCodeInfo.Annotation.Semantic", [
  { no: 0, name: "NONE" },
  { no: 1, name: "SET" },
  { no: 2, name: "ALIAS" }
]);

// node_modules/@bufbuild/protobuf/dist/esm/create-descriptor-set.js
var fieldTypeToScalarType = {
  [FieldDescriptorProto_Type.DOUBLE]: ScalarType.DOUBLE,
  [FieldDescriptorProto_Type.FLOAT]: ScalarType.FLOAT,
  [FieldDescriptorProto_Type.INT64]: ScalarType.INT64,
  [FieldDescriptorProto_Type.UINT64]: ScalarType.UINT64,
  [FieldDescriptorProto_Type.INT32]: ScalarType.INT32,
  [FieldDescriptorProto_Type.FIXED64]: ScalarType.FIXED64,
  [FieldDescriptorProto_Type.FIXED32]: ScalarType.FIXED32,
  [FieldDescriptorProto_Type.BOOL]: ScalarType.BOOL,
  [FieldDescriptorProto_Type.STRING]: ScalarType.STRING,
  [FieldDescriptorProto_Type.GROUP]: void 0,
  [FieldDescriptorProto_Type.MESSAGE]: void 0,
  [FieldDescriptorProto_Type.BYTES]: ScalarType.BYTES,
  [FieldDescriptorProto_Type.UINT32]: ScalarType.UINT32,
  [FieldDescriptorProto_Type.ENUM]: void 0,
  [FieldDescriptorProto_Type.SFIXED32]: ScalarType.SFIXED32,
  [FieldDescriptorProto_Type.SFIXED64]: ScalarType.SFIXED64,
  [FieldDescriptorProto_Type.SINT32]: ScalarType.SINT32,
  [FieldDescriptorProto_Type.SINT64]: ScalarType.SINT64
};
var FieldNumber;
(function(FieldNumber2) {
  FieldNumber2[FieldNumber2["FileDescriptorProto_Package"] = 2] = "FileDescriptorProto_Package";
  FieldNumber2[FieldNumber2["FileDescriptorProto_MessageType"] = 4] = "FileDescriptorProto_MessageType";
  FieldNumber2[FieldNumber2["FileDescriptorProto_EnumType"] = 5] = "FileDescriptorProto_EnumType";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Service"] = 6] = "FileDescriptorProto_Service";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Extension"] = 7] = "FileDescriptorProto_Extension";
  FieldNumber2[FieldNumber2["FileDescriptorProto_Syntax"] = 12] = "FileDescriptorProto_Syntax";
  FieldNumber2[FieldNumber2["DescriptorProto_Field"] = 2] = "DescriptorProto_Field";
  FieldNumber2[FieldNumber2["DescriptorProto_NestedType"] = 3] = "DescriptorProto_NestedType";
  FieldNumber2[FieldNumber2["DescriptorProto_EnumType"] = 4] = "DescriptorProto_EnumType";
  FieldNumber2[FieldNumber2["DescriptorProto_Extension"] = 6] = "DescriptorProto_Extension";
  FieldNumber2[FieldNumber2["DescriptorProto_OneofDecl"] = 8] = "DescriptorProto_OneofDecl";
  FieldNumber2[FieldNumber2["EnumDescriptorProto_Value"] = 2] = "EnumDescriptorProto_Value";
  FieldNumber2[FieldNumber2["ServiceDescriptorProto_Method"] = 2] = "ServiceDescriptorProto_Method";
})(FieldNumber || (FieldNumber = {}));

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/timestamp_pb.js
var Timestamp = class _Timestamp extends Message {
  constructor(data) {
    super();
    this.seconds = protoInt64.zero;
    this.nanos = 0;
    proto32.util.initPartial(data, this);
  }
  fromJson(json3, options) {
    if (typeof json3 !== "string") {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto32.json.debug(json3)}`);
    }
    const matches = json3.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!matches) {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
    }
    const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
    if (Number.isNaN(ms)) {
      throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
    }
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    this.seconds = protoInt64.parse(ms / 1e3);
    this.nanos = 0;
    if (matches[7]) {
      this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
    }
    return this;
  }
  toJson(options) {
    const ms = Number(this.seconds) * 1e3;
    if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
      throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
    }
    if (this.nanos < 0) {
      throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);
    }
    let z = "Z";
    if (this.nanos > 0) {
      const nanosStr = (this.nanos + 1e9).toString().substring(1);
      if (nanosStr.substring(3) === "000000") {
        z = "." + nanosStr.substring(0, 3) + "Z";
      } else if (nanosStr.substring(6) === "000") {
        z = "." + nanosStr.substring(0, 6) + "Z";
      } else {
        z = "." + nanosStr + "Z";
      }
    }
    return new Date(ms).toISOString().replace(".000Z", z);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return _Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(date5) {
    const ms = date5.getTime();
    return new _Timestamp({
      seconds: protoInt64.parse(Math.floor(ms / 1e3)),
      nanos: ms % 1e3 * 1e6
    });
  }
  static fromBinary(bytes, options) {
    return new _Timestamp().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Timestamp().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Timestamp().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Timestamp, a, b);
  }
};
Timestamp.runtime = proto32;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/duration_pb.js
var Duration2 = class _Duration extends Message {
  constructor(data) {
    super();
    this.seconds = protoInt64.zero;
    this.nanos = 0;
    proto32.util.initPartial(data, this);
  }
  fromJson(json3, options) {
    if (typeof json3 !== "string") {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto32.json.debug(json3)}`);
    }
    const match43 = json3.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
    if (match43 === null) {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto32.json.debug(json3)}`);
    }
    const longSeconds = Number(match43[1]);
    if (longSeconds > 315576e6 || longSeconds < -315576e6) {
      throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto32.json.debug(json3)}`);
    }
    this.seconds = protoInt64.parse(longSeconds);
    if (typeof match43[2] == "string") {
      const nanosStr = match43[2] + "0".repeat(9 - match43[2].length);
      this.nanos = parseInt(nanosStr);
      if (longSeconds < 0 || Object.is(longSeconds, -0)) {
        this.nanos = -this.nanos;
      }
    }
    return this;
  }
  toJson(options) {
    if (Number(this.seconds) > 315576e6 || Number(this.seconds) < -315576e6) {
      throw new Error(`cannot encode google.protobuf.Duration to JSON: value out of range`);
    }
    let text = this.seconds.toString();
    if (this.nanos !== 0) {
      let nanosStr = Math.abs(this.nanos).toString();
      nanosStr = "0".repeat(9 - nanosStr.length) + nanosStr;
      if (nanosStr.substring(3) === "000000") {
        nanosStr = nanosStr.substring(0, 3);
      } else if (nanosStr.substring(6) === "000") {
        nanosStr = nanosStr.substring(0, 6);
      }
      text += "." + nanosStr;
      if (this.nanos < 0 && Number(this.seconds) == 0) {
        text = "-" + text;
      }
    }
    return text + "s";
  }
  static fromBinary(bytes, options) {
    return new _Duration().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Duration().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Duration().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Duration, a, b);
  }
};
Duration2.runtime = proto32;
Duration2.typeName = "google.protobuf.Duration";
Duration2.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "seconds",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  },
  {
    no: 2,
    name: "nanos",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js
var Any2 = class _Any extends Message {
  constructor(data) {
    super();
    this.typeUrl = "";
    this.value = new Uint8Array(0);
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    var _a106;
    if (this.typeUrl === "") {
      return {};
    }
    const typeName = this.typeUrlToName(this.typeUrl);
    const messageType = (_a106 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a106 === void 0 ? void 0 : _a106.findMessage(typeName);
    if (!messageType) {
      throw new Error(`cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`);
    }
    const message = messageType.fromBinary(this.value);
    let json3 = message.toJson(options);
    if (typeName.startsWith("google.protobuf.") || (json3 === null || Array.isArray(json3) || typeof json3 !== "object")) {
      json3 = { value: json3 };
    }
    json3["@type"] = this.typeUrl;
    return json3;
  }
  fromJson(json3, options) {
    var _a106;
    if (json3 === null || Array.isArray(json3) || typeof json3 != "object") {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json3 === null ? "null" : Array.isArray(json3) ? "array" : typeof json3}`);
    }
    if (Object.keys(json3).length == 0) {
      return this;
    }
    const typeUrl = json3["@type"];
    if (typeof typeUrl != "string" || typeUrl == "") {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: "@type" is empty`);
    }
    const typeName = this.typeUrlToName(typeUrl), messageType = (_a106 = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a106 === void 0 ? void 0 : _a106.findMessage(typeName);
    if (!messageType) {
      throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);
    }
    let message;
    if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json3, "value")) {
      message = messageType.fromJson(json3["value"], options);
    } else {
      const copy4 = Object.assign({}, json3);
      delete copy4["@type"];
      message = messageType.fromJson(copy4, options);
    }
    this.packFrom(message);
    return this;
  }
  packFrom(message) {
    this.value = message.toBinary();
    this.typeUrl = this.typeNameToUrl(message.getType().typeName);
  }
  unpackTo(target) {
    if (!this.is(target.getType())) {
      return false;
    }
    target.fromBinary(this.value);
    return true;
  }
  unpack(registry) {
    if (this.typeUrl === "") {
      return void 0;
    }
    const messageType = registry.findMessage(this.typeUrlToName(this.typeUrl));
    if (!messageType) {
      return void 0;
    }
    return messageType.fromBinary(this.value);
  }
  is(type8) {
    if (this.typeUrl === "") {
      return false;
    }
    const name = this.typeUrlToName(this.typeUrl);
    let typeName = "";
    if (typeof type8 === "string") {
      typeName = type8;
    } else {
      typeName = type8.typeName;
    }
    return name === typeName;
  }
  typeNameToUrl(name) {
    return `type.googleapis.com/${name}`;
  }
  typeUrlToName(url3) {
    if (!url3.length) {
      throw new Error(`invalid type url: ${url3}`);
    }
    const slash = url3.lastIndexOf("/");
    const name = slash >= 0 ? url3.substring(slash + 1) : url3;
    if (!name.length) {
      throw new Error(`invalid type url: ${url3}`);
    }
    return name;
  }
  static pack(message) {
    const any3 = new _Any();
    any3.packFrom(message);
    return any3;
  }
  static fromBinary(bytes, options) {
    return new _Any().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Any().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Any().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Any, a, b);
  }
};
Any2.runtime = proto32;
Any2.typeName = "google.protobuf.Any";
Any2.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "value",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/empty_pb.js
var Empty = class _Empty extends Message {
  constructor(data) {
    super();
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Empty().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Empty().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Empty().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Empty, a, b);
  }
};
Empty.runtime = proto32;
Empty.typeName = "google.protobuf.Empty";
Empty.fields = proto32.util.newFieldList(() => []);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/field_mask_pb.js
var FieldMask = class _FieldMask extends Message {
  constructor(data) {
    super();
    this.paths = [];
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    function protoCamelCase2(snakeCase4) {
      let capNext = false;
      const b = [];
      for (let i = 0; i < snakeCase4.length; i++) {
        let c = snakeCase4.charAt(i);
        switch (c) {
          case "_":
            capNext = true;
            break;
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            b.push(c);
            capNext = false;
            break;
          default:
            if (capNext) {
              capNext = false;
              c = c.toUpperCase();
            }
            b.push(c);
            break;
        }
      }
      return b.join("");
    }
    return this.paths.map((p) => {
      if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {
        throw new Error('cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name "' + p + '" is irreversible');
      }
      return protoCamelCase2(p);
    }).join(",");
  }
  fromJson(json3, options) {
    if (typeof json3 !== "string") {
      throw new Error("cannot decode google.protobuf.FieldMask from JSON: " + proto32.json.debug(json3));
    }
    if (json3 === "") {
      return this;
    }
    function camelToSnake2(str) {
      if (str.includes("_")) {
        throw new Error("cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase");
      }
      const sc = str.replace(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
      return sc[0] === "_" ? sc.substring(1) : sc;
    }
    this.paths = json3.split(",").map(camelToSnake2);
    return this;
  }
  static fromBinary(bytes, options) {
    return new _FieldMask().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FieldMask().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FieldMask().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_FieldMask, a, b);
  }
};
FieldMask.runtime = proto32;
FieldMask.typeName = "google.protobuf.FieldMask";
FieldMask.fields = proto32.util.newFieldList(() => [
  { no: 1, name: "paths", kind: "scalar", T: 9, repeated: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/struct_pb.js
var NullValue;
(function(NullValue2) {
  NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
})(NullValue || (NullValue = {}));
proto32.util.setEnumType(NullValue, "google.protobuf.NullValue", [
  { no: 0, name: "NULL_VALUE" }
]);
var Struct2 = class _Struct extends Message {
  constructor(data) {
    super();
    this.fields = {};
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    const json3 = {};
    for (const [k, v] of Object.entries(this.fields)) {
      json3[k] = v.toJson(options);
    }
    return json3;
  }
  fromJson(json3, options) {
    if (typeof json3 != "object" || json3 == null || Array.isArray(json3)) {
      throw new Error("cannot decode google.protobuf.Struct from JSON " + proto32.json.debug(json3));
    }
    for (const [k, v] of Object.entries(json3)) {
      this.fields[k] = Value2.fromJson(v);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Struct().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Struct().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Struct().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Struct, a, b);
  }
};
Struct2.runtime = proto32;
Struct2.typeName = "google.protobuf.Struct";
Struct2.fields = proto32.util.newFieldList(() => [
  { no: 1, name: "fields", kind: "map", K: 9, V: { kind: "message", T: Value2 } }
]);
var Value2 = class _Value2 extends Message {
  constructor(data) {
    super();
    this.kind = { case: void 0 };
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    switch (this.kind.case) {
      case "nullValue":
        return null;
      case "numberValue":
        if (!Number.isFinite(this.kind.value)) {
          throw new Error("google.protobuf.Value cannot be NaN or Infinity");
        }
        return this.kind.value;
      case "boolValue":
        return this.kind.value;
      case "stringValue":
        return this.kind.value;
      case "structValue":
      case "listValue":
        return this.kind.value.toJson(Object.assign(Object.assign({}, options), { emitDefaultValues: true }));
    }
    throw new Error("google.protobuf.Value must have a value");
  }
  fromJson(json3, options) {
    switch (typeof json3) {
      case "number":
        this.kind = { case: "numberValue", value: json3 };
        break;
      case "string":
        this.kind = { case: "stringValue", value: json3 };
        break;
      case "boolean":
        this.kind = { case: "boolValue", value: json3 };
        break;
      case "object":
        if (json3 === null) {
          this.kind = { case: "nullValue", value: NullValue.NULL_VALUE };
        } else if (Array.isArray(json3)) {
          this.kind = { case: "listValue", value: ListValue.fromJson(json3) };
        } else {
          this.kind = { case: "structValue", value: Struct2.fromJson(json3) };
        }
        break;
      default:
        throw new Error("cannot decode google.protobuf.Value from JSON " + proto32.json.debug(json3));
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Value2().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Value2().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Value2().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Value2, a, b);
  }
};
Value2.runtime = proto32;
Value2.typeName = "google.protobuf.Value";
Value2.fields = proto32.util.newFieldList(() => [
  { no: 1, name: "null_value", kind: "enum", T: proto32.getEnumType(NullValue), oneof: "kind" },
  { no: 2, name: "number_value", kind: "scalar", T: 1, oneof: "kind" },
  { no: 3, name: "string_value", kind: "scalar", T: 9, oneof: "kind" },
  { no: 4, name: "bool_value", kind: "scalar", T: 8, oneof: "kind" },
  { no: 5, name: "struct_value", kind: "message", T: Struct2, oneof: "kind" },
  { no: 6, name: "list_value", kind: "message", T: ListValue, oneof: "kind" }
]);
var ListValue = class _ListValue extends Message {
  constructor(data) {
    super();
    this.values = [];
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return this.values.map((v) => v.toJson());
  }
  fromJson(json3, options) {
    if (!Array.isArray(json3)) {
      throw new Error("cannot decode google.protobuf.ListValue from JSON " + proto32.json.debug(json3));
    }
    for (let e of json3) {
      this.values.push(Value2.fromJson(e));
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _ListValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _ListValue().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ListValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_ListValue, a, b);
  }
};
ListValue.runtime = proto32;
ListValue.typeName = "google.protobuf.ListValue";
ListValue.fields = proto32.util.newFieldList(() => [
  { no: 1, name: "values", kind: "message", T: Value2, repeated: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/wrappers_pb.js
var DoubleValue = class _DoubleValue extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.DOUBLE, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.DOUBLE, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.DoubleValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _DoubleValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _DoubleValue().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _DoubleValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_DoubleValue, a, b);
  }
};
DoubleValue.runtime = proto32;
DoubleValue.typeName = "google.protobuf.DoubleValue";
DoubleValue.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 1
    /* ScalarType.DOUBLE */
  }
]);
DoubleValue.fieldWrapper = {
  wrapField(value10) {
    return new DoubleValue({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};
var FloatValue = class _FloatValue extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.FLOAT, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.FLOAT, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.FloatValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _FloatValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _FloatValue().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _FloatValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_FloatValue, a, b);
  }
};
FloatValue.runtime = proto32;
FloatValue.typeName = "google.protobuf.FloatValue";
FloatValue.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 2
    /* ScalarType.FLOAT */
  }
]);
FloatValue.fieldWrapper = {
  wrapField(value10) {
    return new FloatValue({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};
var Int64Value = class _Int64Value extends Message {
  constructor(data) {
    super();
    this.value = protoInt64.zero;
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.INT64, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.INT64, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.Int64Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Int64Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Int64Value().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Int64Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Int64Value, a, b);
  }
};
Int64Value.runtime = proto32;
Int64Value.typeName = "google.protobuf.Int64Value";
Int64Value.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 3
    /* ScalarType.INT64 */
  }
]);
Int64Value.fieldWrapper = {
  wrapField(value10) {
    return new Int64Value({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};
var UInt64Value = class _UInt64Value extends Message {
  constructor(data) {
    super();
    this.value = protoInt64.zero;
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.UINT64, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.UINT64, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.UInt64Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _UInt64Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _UInt64Value().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UInt64Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_UInt64Value, a, b);
  }
};
UInt64Value.runtime = proto32;
UInt64Value.typeName = "google.protobuf.UInt64Value";
UInt64Value.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 4
    /* ScalarType.UINT64 */
  }
]);
UInt64Value.fieldWrapper = {
  wrapField(value10) {
    return new UInt64Value({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};
var Int32Value = class _Int32Value extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.INT32, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.INT32, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.Int32Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _Int32Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Int32Value().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Int32Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Int32Value, a, b);
  }
};
Int32Value.runtime = proto32;
Int32Value.typeName = "google.protobuf.Int32Value";
Int32Value.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  }
]);
Int32Value.fieldWrapper = {
  wrapField(value10) {
    return new Int32Value({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};
var UInt32Value = class _UInt32Value extends Message {
  constructor(data) {
    super();
    this.value = 0;
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.UINT32, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.UINT32, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.UInt32Value from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _UInt32Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _UInt32Value().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UInt32Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_UInt32Value, a, b);
  }
};
UInt32Value.runtime = proto32;
UInt32Value.typeName = "google.protobuf.UInt32Value";
UInt32Value.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
]);
UInt32Value.fieldWrapper = {
  wrapField(value10) {
    return new UInt32Value({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};
var BoolValue = class _BoolValue extends Message {
  constructor(data) {
    super();
    this.value = false;
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.BOOL, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.BOOL, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.BoolValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _BoolValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _BoolValue().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _BoolValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_BoolValue, a, b);
  }
};
BoolValue.runtime = proto32;
BoolValue.typeName = "google.protobuf.BoolValue";
BoolValue.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  }
]);
BoolValue.fieldWrapper = {
  wrapField(value10) {
    return new BoolValue({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};
var StringValue = class _StringValue extends Message {
  constructor(data) {
    super();
    this.value = "";
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.STRING, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.STRING, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.StringValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _StringValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _StringValue().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _StringValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_StringValue, a, b);
  }
};
StringValue.runtime = proto32;
StringValue.typeName = "google.protobuf.StringValue";
StringValue.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
StringValue.fieldWrapper = {
  wrapField(value10) {
    return new StringValue({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};
var BytesValue = class _BytesValue extends Message {
  constructor(data) {
    super();
    this.value = new Uint8Array(0);
    proto32.util.initPartial(data, this);
  }
  toJson(options) {
    return proto32.json.writeScalar(ScalarType.BYTES, this.value, true);
  }
  fromJson(json3, options) {
    try {
      this.value = proto32.json.readScalar(ScalarType.BYTES, json3);
    } catch (e) {
      let m = `cannot decode message google.protobuf.BytesValue from JSON"`;
      if (e instanceof Error && e.message.length > 0) {
        m += `: ${e.message}`;
      }
      throw new Error(m);
    }
    return this;
  }
  static fromBinary(bytes, options) {
    return new _BytesValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _BytesValue().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _BytesValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_BytesValue, a, b);
  }
};
BytesValue.runtime = proto32;
BytesValue.typeName = "google.protobuf.BytesValue";
BytesValue.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "value",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]);
BytesValue.fieldWrapper = {
  wrapField(value10) {
    return new BytesValue({ value: value10 });
  },
  unwrapField(value10) {
    return value10.value;
  }
};

// node_modules/@bufbuild/protobuf/dist/esm/create-registry-from-desc.js
var wkEnums = [getEnumType(NullValue)];

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/compiler/plugin_pb.js
var Version = class _Version extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Version().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Version().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Version().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_Version, a, b);
  }
};
Version.runtime = proto22;
Version.typeName = "google.protobuf.compiler.Version";
Version.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "major", kind: "scalar", T: 5, opt: true },
  { no: 2, name: "minor", kind: "scalar", T: 5, opt: true },
  { no: 3, name: "patch", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "suffix", kind: "scalar", T: 9, opt: true }
]);
var CodeGeneratorRequest = class _CodeGeneratorRequest extends Message {
  constructor(data) {
    super();
    this.fileToGenerate = [];
    this.protoFile = [];
    this.sourceFileDescriptors = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorRequest().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _CodeGeneratorRequest().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorRequest().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_CodeGeneratorRequest, a, b);
  }
};
CodeGeneratorRequest.runtime = proto22;
CodeGeneratorRequest.typeName = "google.protobuf.compiler.CodeGeneratorRequest";
CodeGeneratorRequest.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "file_to_generate", kind: "scalar", T: 9, repeated: true },
  { no: 2, name: "parameter", kind: "scalar", T: 9, opt: true },
  { no: 15, name: "proto_file", kind: "message", T: FileDescriptorProto, repeated: true },
  { no: 17, name: "source_file_descriptors", kind: "message", T: FileDescriptorProto, repeated: true },
  { no: 3, name: "compiler_version", kind: "message", T: Version, opt: true }
]);
var CodeGeneratorResponse = class _CodeGeneratorResponse extends Message {
  constructor(data) {
    super();
    this.file = [];
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorResponse().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _CodeGeneratorResponse().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorResponse().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_CodeGeneratorResponse, a, b);
  }
};
CodeGeneratorResponse.runtime = proto22;
CodeGeneratorResponse.typeName = "google.protobuf.compiler.CodeGeneratorResponse";
CodeGeneratorResponse.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "error", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "supported_features", kind: "scalar", T: 4, opt: true },
  { no: 3, name: "minimum_edition", kind: "scalar", T: 5, opt: true },
  { no: 4, name: "maximum_edition", kind: "scalar", T: 5, opt: true },
  { no: 15, name: "file", kind: "message", T: CodeGeneratorResponse_File, repeated: true }
]);
var CodeGeneratorResponse_Feature;
(function(CodeGeneratorResponse_Feature2) {
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["NONE"] = 0] = "NONE";
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["PROTO3_OPTIONAL"] = 1] = "PROTO3_OPTIONAL";
  CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["SUPPORTS_EDITIONS"] = 2] = "SUPPORTS_EDITIONS";
})(CodeGeneratorResponse_Feature || (CodeGeneratorResponse_Feature = {}));
proto22.util.setEnumType(CodeGeneratorResponse_Feature, "google.protobuf.compiler.CodeGeneratorResponse.Feature", [
  { no: 0, name: "FEATURE_NONE" },
  { no: 1, name: "FEATURE_PROTO3_OPTIONAL" },
  { no: 2, name: "FEATURE_SUPPORTS_EDITIONS" }
]);
var CodeGeneratorResponse_File = class _CodeGeneratorResponse_File extends Message {
  constructor(data) {
    super();
    proto22.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _CodeGeneratorResponse_File().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _CodeGeneratorResponse_File().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _CodeGeneratorResponse_File().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto22.util.equals(_CodeGeneratorResponse_File, a, b);
  }
};
CodeGeneratorResponse_File.runtime = proto22;
CodeGeneratorResponse_File.typeName = "google.protobuf.compiler.CodeGeneratorResponse.File";
CodeGeneratorResponse_File.fields = proto22.util.newFieldList(() => [
  { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
  { no: 2, name: "insertion_point", kind: "scalar", T: 9, opt: true },
  { no: 15, name: "content", kind: "scalar", T: 9, opt: true },
  { no: 16, name: "generated_code_info", kind: "message", T: GeneratedCodeInfo, opt: true }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/source_context_pb.js
var SourceContext = class _SourceContext extends Message {
  constructor(data) {
    super();
    this.fileName = "";
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _SourceContext().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _SourceContext().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _SourceContext().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_SourceContext, a, b);
  }
};
SourceContext.runtime = proto32;
SourceContext.typeName = "google.protobuf.SourceContext";
SourceContext.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "file_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/type_pb.js
var Syntax;
(function(Syntax2) {
  Syntax2[Syntax2["PROTO2"] = 0] = "PROTO2";
  Syntax2[Syntax2["PROTO3"] = 1] = "PROTO3";
  Syntax2[Syntax2["EDITIONS"] = 2] = "EDITIONS";
})(Syntax || (Syntax = {}));
proto32.util.setEnumType(Syntax, "google.protobuf.Syntax", [
  { no: 0, name: "SYNTAX_PROTO2" },
  { no: 1, name: "SYNTAX_PROTO3" },
  { no: 2, name: "SYNTAX_EDITIONS" }
]);
var Type3 = class _Type extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.fields = [];
    this.oneofs = [];
    this.options = [];
    this.syntax = Syntax.PROTO2;
    this.edition = "";
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Type().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Type().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Type().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Type, a, b);
  }
};
Type3.runtime = proto32;
Type3.typeName = "google.protobuf.Type";
Type3.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "fields", kind: "message", T: Field2, repeated: true },
  { no: 3, name: "oneofs", kind: "scalar", T: 9, repeated: true },
  { no: 4, name: "options", kind: "message", T: Option2, repeated: true },
  { no: 5, name: "source_context", kind: "message", T: SourceContext },
  { no: 6, name: "syntax", kind: "enum", T: proto32.getEnumType(Syntax) },
  {
    no: 7,
    name: "edition",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var Field2 = class _Field extends Message {
  constructor(data) {
    super();
    this.kind = Field_Kind.TYPE_UNKNOWN;
    this.cardinality = Field_Cardinality.UNKNOWN;
    this.number = 0;
    this.name = "";
    this.typeUrl = "";
    this.oneofIndex = 0;
    this.packed = false;
    this.options = [];
    this.jsonName = "";
    this.defaultValue = "";
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Field().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Field().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Field().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Field, a, b);
  }
};
Field2.runtime = proto32;
Field2.typeName = "google.protobuf.Field";
Field2.fields = proto32.util.newFieldList(() => [
  { no: 1, name: "kind", kind: "enum", T: proto32.getEnumType(Field_Kind) },
  { no: 2, name: "cardinality", kind: "enum", T: proto32.getEnumType(Field_Cardinality) },
  {
    no: 3,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 4,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 6,
    name: "type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 7,
    name: "oneof_index",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  {
    no: 8,
    name: "packed",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 9, name: "options", kind: "message", T: Option2, repeated: true },
  {
    no: 10,
    name: "json_name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 11,
    name: "default_value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var Field_Kind;
(function(Field_Kind2) {
  Field_Kind2[Field_Kind2["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
  Field_Kind2[Field_Kind2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
  Field_Kind2[Field_Kind2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
  Field_Kind2[Field_Kind2["TYPE_INT64"] = 3] = "TYPE_INT64";
  Field_Kind2[Field_Kind2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
  Field_Kind2[Field_Kind2["TYPE_INT32"] = 5] = "TYPE_INT32";
  Field_Kind2[Field_Kind2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
  Field_Kind2[Field_Kind2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
  Field_Kind2[Field_Kind2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
  Field_Kind2[Field_Kind2["TYPE_STRING"] = 9] = "TYPE_STRING";
  Field_Kind2[Field_Kind2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
  Field_Kind2[Field_Kind2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
  Field_Kind2[Field_Kind2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
  Field_Kind2[Field_Kind2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
  Field_Kind2[Field_Kind2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
  Field_Kind2[Field_Kind2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
  Field_Kind2[Field_Kind2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
  Field_Kind2[Field_Kind2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
  Field_Kind2[Field_Kind2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
})(Field_Kind || (Field_Kind = {}));
proto32.util.setEnumType(Field_Kind, "google.protobuf.Field.Kind", [
  { no: 0, name: "TYPE_UNKNOWN" },
  { no: 1, name: "TYPE_DOUBLE" },
  { no: 2, name: "TYPE_FLOAT" },
  { no: 3, name: "TYPE_INT64" },
  { no: 4, name: "TYPE_UINT64" },
  { no: 5, name: "TYPE_INT32" },
  { no: 6, name: "TYPE_FIXED64" },
  { no: 7, name: "TYPE_FIXED32" },
  { no: 8, name: "TYPE_BOOL" },
  { no: 9, name: "TYPE_STRING" },
  { no: 10, name: "TYPE_GROUP" },
  { no: 11, name: "TYPE_MESSAGE" },
  { no: 12, name: "TYPE_BYTES" },
  { no: 13, name: "TYPE_UINT32" },
  { no: 14, name: "TYPE_ENUM" },
  { no: 15, name: "TYPE_SFIXED32" },
  { no: 16, name: "TYPE_SFIXED64" },
  { no: 17, name: "TYPE_SINT32" },
  { no: 18, name: "TYPE_SINT64" }
]);
var Field_Cardinality;
(function(Field_Cardinality2) {
  Field_Cardinality2[Field_Cardinality2["UNKNOWN"] = 0] = "UNKNOWN";
  Field_Cardinality2[Field_Cardinality2["OPTIONAL"] = 1] = "OPTIONAL";
  Field_Cardinality2[Field_Cardinality2["REQUIRED"] = 2] = "REQUIRED";
  Field_Cardinality2[Field_Cardinality2["REPEATED"] = 3] = "REPEATED";
})(Field_Cardinality || (Field_Cardinality = {}));
proto32.util.setEnumType(Field_Cardinality, "google.protobuf.Field.Cardinality", [
  { no: 0, name: "CARDINALITY_UNKNOWN" },
  { no: 1, name: "CARDINALITY_OPTIONAL" },
  { no: 2, name: "CARDINALITY_REQUIRED" },
  { no: 3, name: "CARDINALITY_REPEATED" }
]);
var Enum = class _Enum extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.enumvalue = [];
    this.options = [];
    this.syntax = Syntax.PROTO2;
    this.edition = "";
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Enum().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Enum().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Enum().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Enum, a, b);
  }
};
Enum.runtime = proto32;
Enum.typeName = "google.protobuf.Enum";
Enum.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "enumvalue", kind: "message", T: EnumValue, repeated: true },
  { no: 3, name: "options", kind: "message", T: Option2, repeated: true },
  { no: 4, name: "source_context", kind: "message", T: SourceContext },
  { no: 5, name: "syntax", kind: "enum", T: proto32.getEnumType(Syntax) },
  {
    no: 6,
    name: "edition",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);
var EnumValue = class _EnumValue extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.number = 0;
    this.options = [];
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _EnumValue().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _EnumValue().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _EnumValue().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_EnumValue, a, b);
  }
};
EnumValue.runtime = proto32;
EnumValue.typeName = "google.protobuf.EnumValue";
EnumValue.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "number",
    kind: "scalar",
    T: 5
    /* ScalarType.INT32 */
  },
  { no: 3, name: "options", kind: "message", T: Option2, repeated: true }
]);
var Option2 = class _Option extends Message {
  constructor(data) {
    super();
    this.name = "";
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Option().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Option().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Option().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Option, a, b);
  }
};
Option2.runtime = proto32;
Option2.typeName = "google.protobuf.Option";
Option2.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "value", kind: "message", T: Any2 }
]);

// node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/api_pb.js
var Api = class _Api extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.methods = [];
    this.options = [];
    this.version = "";
    this.mixins = [];
    this.syntax = Syntax.PROTO2;
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Api().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Api().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Api().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Api, a, b);
  }
};
Api.runtime = proto32;
Api.typeName = "google.protobuf.Api";
Api.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "methods", kind: "message", T: Method, repeated: true },
  { no: 3, name: "options", kind: "message", T: Option2, repeated: true },
  {
    no: 4,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 5, name: "source_context", kind: "message", T: SourceContext },
  { no: 6, name: "mixins", kind: "message", T: Mixin, repeated: true },
  { no: 7, name: "syntax", kind: "enum", T: proto32.getEnumType(Syntax) }
]);
var Method = class _Method extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.requestTypeUrl = "";
    this.requestStreaming = false;
    this.responseTypeUrl = "";
    this.responseStreaming = false;
    this.options = [];
    this.syntax = Syntax.PROTO2;
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Method().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Method().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Method().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Method, a, b);
  }
};
Method.runtime = proto32;
Method.typeName = "google.protobuf.Method";
Method.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "request_type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 3,
    name: "request_streaming",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  {
    no: 4,
    name: "response_type_url",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 5,
    name: "response_streaming",
    kind: "scalar",
    T: 8
    /* ScalarType.BOOL */
  },
  { no: 6, name: "options", kind: "message", T: Option2, repeated: true },
  { no: 7, name: "syntax", kind: "enum", T: proto32.getEnumType(Syntax) }
]);
var Mixin = class _Mixin extends Message {
  constructor(data) {
    super();
    this.name = "";
    this.root = "";
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Mixin().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Mixin().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Mixin().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Mixin, a, b);
  }
};
Mixin.runtime = proto32;
Mixin.typeName = "google.protobuf.Mixin";
Mixin.fields = proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 2,
    name: "root",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  }
]);

// node_modules/@graphprotocol/grc-20/dist/src/proto/gen/src/proto/ipfs_pb.js
var DataType;
(function(DataType2) {
  DataType2[DataType2["TEXT"] = 0] = "TEXT";
  DataType2[DataType2["NUMBER"] = 1] = "NUMBER";
  DataType2[DataType2["CHECKBOX"] = 2] = "CHECKBOX";
  DataType2[DataType2["TIME"] = 3] = "TIME";
  DataType2[DataType2["POINT"] = 4] = "POINT";
  DataType2[DataType2["RELATION"] = 5] = "RELATION";
})(DataType || (DataType = {}));
proto32.util.setEnumType(DataType, "grc20.DataType", [
  { no: 0, name: "TEXT" },
  { no: 1, name: "NUMBER" },
  { no: 2, name: "CHECKBOX" },
  { no: 3, name: "TIME" },
  { no: 4, name: "POINT" },
  { no: 5, name: "RELATION" }
]);
var _Edit = class _Edit extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: string name = 2;
     */
    __publicField(this, "name", "");
    /**
     * @generated from field: repeated grc20.Op ops = 3;
     */
    __publicField(this, "ops", []);
    /**
     * @generated from field: repeated bytes authors = 4;
     */
    __publicField(this, "authors", []);
    /**
     * @generated from field: optional bytes language = 5;
     */
    __publicField(this, "language");
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Edit().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Edit().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Edit().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Edit, a, b);
  }
};
__publicField(_Edit, "runtime", proto32);
__publicField(_Edit, "typeName", "grc20.Edit");
__publicField(_Edit, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "ops", kind: "message", T: Op, repeated: true },
  { no: 4, name: "authors", kind: "scalar", T: 12, repeated: true },
  { no: 5, name: "language", kind: "scalar", T: 12, opt: true }
]));
var Edit = _Edit;
var _ImportEdit = class _ImportEdit extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: string name = 2;
     */
    __publicField(this, "name", "");
    /**
     * @generated from field: repeated grc20.Op ops = 3;
     */
    __publicField(this, "ops", []);
    /**
     * @generated from field: repeated bytes authors = 4;
     */
    __publicField(this, "authors", []);
    /**
     * @generated from field: bytes created_by = 5;
     */
    __publicField(this, "createdBy", new Uint8Array(0));
    /**
     * @generated from field: string created_at = 6;
     */
    __publicField(this, "createdAt", "");
    /**
     * @generated from field: bytes block_hash = 7;
     */
    __publicField(this, "blockHash", new Uint8Array(0));
    /**
     * @generated from field: string block_number = 8;
     */
    __publicField(this, "blockNumber", "");
    /**
     * @generated from field: bytes transaction_hash = 9;
     */
    __publicField(this, "transactionHash", new Uint8Array(0));
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _ImportEdit().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _ImportEdit().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _ImportEdit().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_ImportEdit, a, b);
  }
};
__publicField(_ImportEdit, "runtime", proto32);
__publicField(_ImportEdit, "typeName", "grc20.ImportEdit");
__publicField(_ImportEdit, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "name",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "ops", kind: "message", T: Op, repeated: true },
  { no: 4, name: "authors", kind: "scalar", T: 12, repeated: true },
  {
    no: 5,
    name: "created_by",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 6,
    name: "created_at",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 7,
    name: "block_hash",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 8,
    name: "block_number",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  {
    no: 9,
    name: "transaction_hash",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  }
]));
var ImportEdit = _ImportEdit;
var _Import = class _Import extends Message {
  constructor(data) {
    super();
    /**
     * these strings are IPFS cids representing the import edit message
     *
     * @generated from field: repeated string edits = 1;
     */
    __publicField(this, "edits", []);
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Import().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Import().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Import().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Import, a, b);
  }
};
__publicField(_Import, "runtime", proto32);
__publicField(_Import, "typeName", "grc20.Import");
__publicField(_Import, "fields", proto32.util.newFieldList(() => [
  { no: 1, name: "edits", kind: "scalar", T: 9, repeated: true }
]));
var Import = _Import;
var _File = class _File extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: string version = 1;
     */
    __publicField(this, "version", "");
    /**
     * @generated from oneof grc20.File.payload
     */
    __publicField(this, "payload", { case: void 0 });
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _File().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _File().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _File().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_File, a, b);
  }
};
__publicField(_File, "runtime", proto32);
__publicField(_File, "typeName", "grc20.File");
__publicField(_File, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "version",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 2, name: "add_edit", kind: "message", T: Edit, oneof: "payload" },
  { no: 3, name: "import_space", kind: "message", T: Import, oneof: "payload" },
  { no: 4, name: "archive_space", kind: "scalar", T: 12, oneof: "payload" }
]));
var File = _File;
var _Op = class _Op extends Message {
  constructor(data) {
    super();
    /**
     * @generated from oneof grc20.Op.payload
     */
    __publicField(this, "payload", { case: void 0 });
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Op().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Op().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Op().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Op, a, b);
  }
};
__publicField(_Op, "runtime", proto32);
__publicField(_Op, "typeName", "grc20.Op");
__publicField(_Op, "fields", proto32.util.newFieldList(() => [
  { no: 1, name: "update_entity", kind: "message", T: Entity, oneof: "payload" },
  { no: 2, name: "create_relation", kind: "message", T: Relation, oneof: "payload" },
  { no: 3, name: "update_relation", kind: "message", T: RelationUpdate, oneof: "payload" },
  { no: 4, name: "delete_relation", kind: "scalar", T: 12, oneof: "payload" },
  { no: 5, name: "create_property", kind: "message", T: Property2, oneof: "payload" },
  { no: 6, name: "unset_entity_values", kind: "message", T: UnsetEntityValues, oneof: "payload" },
  { no: 7, name: "unset_relation_fields", kind: "message", T: UnsetRelationFields, oneof: "payload" }
]));
var Op = _Op;
var _Property = class _Property extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: grc20.DataType data_type = 2;
     */
    __publicField(this, "dataType", DataType.TEXT);
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Property().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Property().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Property().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Property, a, b);
  }
};
__publicField(_Property, "runtime", proto32);
__publicField(_Property, "typeName", "grc20.Property");
__publicField(_Property, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "data_type", kind: "enum", T: proto32.getEnumType(DataType) }
]));
var Property2 = _Property;
var _UnsetEntityValues = class _UnsetEntityValues extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: repeated bytes properties = 2;
     */
    __publicField(this, "properties", []);
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UnsetEntityValues().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _UnsetEntityValues().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UnsetEntityValues().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_UnsetEntityValues, a, b);
  }
};
__publicField(_UnsetEntityValues, "runtime", proto32);
__publicField(_UnsetEntityValues, "typeName", "grc20.UnsetEntityValues");
__publicField(_UnsetEntityValues, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "properties", kind: "scalar", T: 12, repeated: true }
]));
var UnsetEntityValues = _UnsetEntityValues;
var _Relation = class _Relation extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: bytes type = 2;
     */
    __publicField(this, "type", new Uint8Array(0));
    /**
     * @generated from field: bytes from_entity = 3;
     */
    __publicField(this, "fromEntity", new Uint8Array(0));
    /**
     * @generated from field: optional bytes from_space = 4;
     */
    __publicField(this, "fromSpace");
    /**
     * @generated from field: optional bytes from_version = 5;
     */
    __publicField(this, "fromVersion");
    /**
     * @generated from field: bytes to_entity = 6;
     */
    __publicField(this, "toEntity", new Uint8Array(0));
    /**
     * @generated from field: optional bytes to_space = 7;
     */
    __publicField(this, "toSpace");
    /**
     * @generated from field: optional bytes to_version = 8;
     */
    __publicField(this, "toVersion");
    /**
     * @generated from field: bytes entity = 9;
     */
    __publicField(this, "entity", new Uint8Array(0));
    /**
     * @generated from field: optional string position = 10;
     */
    __publicField(this, "position");
    /**
     * @generated from field: optional bool verified = 11;
     */
    __publicField(this, "verified");
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Relation().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Relation().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Relation().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Relation, a, b);
  }
};
__publicField(_Relation, "runtime", proto32);
__publicField(_Relation, "typeName", "grc20.Relation");
__publicField(_Relation, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "type",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 3,
    name: "from_entity",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 4, name: "from_space", kind: "scalar", T: 12, opt: true },
  { no: 5, name: "from_version", kind: "scalar", T: 12, opt: true },
  {
    no: 6,
    name: "to_entity",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 7, name: "to_space", kind: "scalar", T: 12, opt: true },
  { no: 8, name: "to_version", kind: "scalar", T: 12, opt: true },
  {
    no: 9,
    name: "entity",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 10, name: "position", kind: "scalar", T: 9, opt: true },
  { no: 11, name: "verified", kind: "scalar", T: 8, opt: true }
]));
var Relation = _Relation;
var _RelationUpdate = class _RelationUpdate extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: optional bytes from_space = 2;
     */
    __publicField(this, "fromSpace");
    /**
     * @generated from field: optional bytes from_version = 3;
     */
    __publicField(this, "fromVersion");
    /**
     * @generated from field: optional bytes to_space = 4;
     */
    __publicField(this, "toSpace");
    /**
     * @generated from field: optional bytes to_version = 5;
     */
    __publicField(this, "toVersion");
    /**
     * @generated from field: optional string position = 6;
     */
    __publicField(this, "position");
    /**
     * @generated from field: optional bool verified = 7;
     */
    __publicField(this, "verified");
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _RelationUpdate().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _RelationUpdate().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _RelationUpdate().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_RelationUpdate, a, b);
  }
};
__publicField(_RelationUpdate, "runtime", proto32);
__publicField(_RelationUpdate, "typeName", "grc20.RelationUpdate");
__publicField(_RelationUpdate, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "from_space", kind: "scalar", T: 12, opt: true },
  { no: 3, name: "from_version", kind: "scalar", T: 12, opt: true },
  { no: 4, name: "to_space", kind: "scalar", T: 12, opt: true },
  { no: 5, name: "to_version", kind: "scalar", T: 12, opt: true },
  { no: 6, name: "position", kind: "scalar", T: 9, opt: true },
  { no: 7, name: "verified", kind: "scalar", T: 8, opt: true }
]));
var RelationUpdate = _RelationUpdate;
var _UnsetRelationFields = class _UnsetRelationFields extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: optional bool from_space = 2;
     */
    __publicField(this, "fromSpace");
    /**
     * @generated from field: optional bool from_version = 3;
     */
    __publicField(this, "fromVersion");
    /**
     * @generated from field: optional bool to_space = 4;
     */
    __publicField(this, "toSpace");
    /**
     * @generated from field: optional bool to_version = 5;
     */
    __publicField(this, "toVersion");
    /**
     * @generated from field: optional bool position = 6;
     */
    __publicField(this, "position");
    /**
     * @generated from field: optional bool verified = 7;
     */
    __publicField(this, "verified");
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _UnsetRelationFields().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _UnsetRelationFields().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _UnsetRelationFields().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_UnsetRelationFields, a, b);
  }
};
__publicField(_UnsetRelationFields, "runtime", proto32);
__publicField(_UnsetRelationFields, "typeName", "grc20.UnsetRelationFields");
__publicField(_UnsetRelationFields, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "from_space", kind: "scalar", T: 8, opt: true },
  { no: 3, name: "from_version", kind: "scalar", T: 8, opt: true },
  { no: 4, name: "to_space", kind: "scalar", T: 8, opt: true },
  { no: 5, name: "to_version", kind: "scalar", T: 8, opt: true },
  { no: 6, name: "position", kind: "scalar", T: 8, opt: true },
  { no: 7, name: "verified", kind: "scalar", T: 8, opt: true }
]));
var UnsetRelationFields = _UnsetRelationFields;
var _Entity = class _Entity extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes id = 1;
     */
    __publicField(this, "id", new Uint8Array(0));
    /**
     * @generated from field: repeated grc20.Value values = 2;
     */
    __publicField(this, "values", []);
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Entity().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Entity().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Entity().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Entity, a, b);
  }
};
__publicField(_Entity, "runtime", proto32);
__publicField(_Entity, "typeName", "grc20.Entity");
__publicField(_Entity, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "id",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  { no: 2, name: "values", kind: "message", T: Value3, repeated: true }
]));
var Entity = _Entity;
var _Options = class _Options extends Message {
  constructor(data) {
    super();
    /**
     * @generated from oneof grc20.Options.value
     */
    __publicField(this, "value", { case: void 0 });
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Options().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Options().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Options().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Options, a, b);
  }
};
__publicField(_Options, "runtime", proto32);
__publicField(_Options, "typeName", "grc20.Options");
__publicField(_Options, "fields", proto32.util.newFieldList(() => [
  { no: 1, name: "text", kind: "message", T: TextOptions, oneof: "value" },
  { no: 2, name: "number", kind: "message", T: NumberOptions, oneof: "value" }
]));
var Options = _Options;
var _Value = class _Value extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: bytes property = 1;
     */
    __publicField(this, "property", new Uint8Array(0));
    /**
     * @generated from field: string value = 2;
     */
    __publicField(this, "value", "");
    /**
     * @generated from field: optional grc20.Options options = 3;
     */
    __publicField(this, "options");
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _Value().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _Value().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _Value().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_Value, a, b);
  }
};
__publicField(_Value, "runtime", proto32);
__publicField(_Value, "typeName", "grc20.Value");
__publicField(_Value, "fields", proto32.util.newFieldList(() => [
  {
    no: 1,
    name: "property",
    kind: "scalar",
    T: 12
    /* ScalarType.BYTES */
  },
  {
    no: 2,
    name: "value",
    kind: "scalar",
    T: 9
    /* ScalarType.STRING */
  },
  { no: 3, name: "options", kind: "message", T: Options, opt: true }
]));
var Value3 = _Value;
var _TextOptions = class _TextOptions extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: optional bytes language = 1;
     */
    __publicField(this, "language");
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _TextOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _TextOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _TextOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_TextOptions, a, b);
  }
};
__publicField(_TextOptions, "runtime", proto32);
__publicField(_TextOptions, "typeName", "grc20.TextOptions");
__publicField(_TextOptions, "fields", proto32.util.newFieldList(() => [
  { no: 1, name: "language", kind: "scalar", T: 12, opt: true }
]));
var TextOptions = _TextOptions;
var _NumberOptions = class _NumberOptions extends Message {
  constructor(data) {
    super();
    /**
     * @generated from field: optional bytes unit = 1;
     */
    __publicField(this, "unit");
    proto32.util.initPartial(data, this);
  }
  static fromBinary(bytes, options) {
    return new _NumberOptions().fromBinary(bytes, options);
  }
  static fromJson(jsonValue2, options) {
    return new _NumberOptions().fromJson(jsonValue2, options);
  }
  static fromJsonString(jsonString, options) {
    return new _NumberOptions().fromJsonString(jsonString, options);
  }
  static equals(a, b) {
    return proto32.util.equals(_NumberOptions, a, b);
  }
};
__publicField(_NumberOptions, "runtime", proto32);
__publicField(_NumberOptions, "typeName", "grc20.NumberOptions");
__publicField(_NumberOptions, "fields", proto32.util.newFieldList(() => [
  { no: 1, name: "unit", kind: "scalar", T: 12, opt: true }
]));
var NumberOptions = _NumberOptions;

// node_modules/@graphprotocol/grc-20/dist/src/proto/edit.js
var edit_exports = {};
__export(edit_exports, {
  encode: () => encode10
});
function hexToBytes3(hex2) {
  let hexString = hex2;
  if (hexString.startsWith("0x")) {
    hexString = hexString.slice(2);
  }
  if (hex2.length % 2 !== 0) {
    throw new Error("Invalid hex string: must have an even length");
  }
  const bytes = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < hex2.length; i += 2) {
    bytes[i / 2] = Number.parseInt(hex2.slice(i, i + 2), 16);
  }
  return bytes;
}
function encode10({ name, ops, author, language }) {
  return new Edit({
    id: toBytes4(generate()),
    name,
    ops: opsToBinary(ops),
    authors: [hexToBytes3(author)],
    language: language ? toBytes4(language) : void 0
  }).toBinary();
}
function convertRelationIdsToBase64(relation) {
  const result = {
    id: toBase64(relation.id),
    type: toBase64(relation.type),
    from_entity: toBase64(relation.fromEntity),
    to_entity: toBase64(relation.toEntity),
    entity: toBase64(relation.entity)
  };
  if (relation.fromSpace) {
    result.from_space = toBase64(relation.fromSpace);
  }
  if (relation.fromVersion) {
    result.from_version = toBase64(relation.fromVersion);
  }
  if (relation.toSpace) {
    result.to_space = toBase64(relation.toSpace);
  }
  if (relation.toVersion) {
    result.to_version = toBase64(relation.toVersion);
  }
  if (relation.position !== void 0) {
    result.position = relation.position;
  }
  if (relation.verified !== void 0) {
    result.verified = relation.verified;
  }
  return result;
}
function convertUnsetEntityValuesToBase64(unsetEntityValues2) {
  return {
    id: toBase64(unsetEntityValues2.id),
    properties: unsetEntityValues2.properties.map((propertyId) => toBase64(propertyId))
  };
}
function convertUpdateRelationToBase64(relation) {
  const result = {
    id: toBase64(relation.id)
  };
  if (relation.fromSpace) {
    result.from_space = toBase64(relation.fromSpace);
  }
  if (relation.fromVersion) {
    result.from_version = toBase64(relation.fromVersion);
  }
  if (relation.toSpace) {
    result.to_space = toBase64(relation.toSpace);
  }
  if (relation.toVersion) {
    result.to_version = toBase64(relation.toVersion);
  }
  if (relation.position !== void 0) {
    result.position = relation.position;
  }
  if (relation.verified !== void 0) {
    result.verified = relation.verified;
  }
  return result;
}
function convertUnsetRelationFieldsToBase64(unsetRelationFields2) {
  const result = {
    id: toBase64(unsetRelationFields2.id)
  };
  if (unsetRelationFields2.fromSpace !== void 0) {
    result.from_space = unsetRelationFields2.fromSpace;
  }
  if (unsetRelationFields2.fromVersion !== void 0) {
    result.from_version = unsetRelationFields2.fromVersion;
  }
  if (unsetRelationFields2.toSpace !== void 0) {
    result.to_space = unsetRelationFields2.toSpace;
  }
  if (unsetRelationFields2.toVersion !== void 0) {
    result.to_version = unsetRelationFields2.toVersion;
  }
  if (unsetRelationFields2.position !== void 0) {
    result.position = unsetRelationFields2.position;
  }
  if (unsetRelationFields2.verified !== void 0) {
    result.verified = unsetRelationFields2.verified;
  }
  return result;
}
function convertUpdateEntityToBase64(entity) {
  return {
    id: toBase64(entity.id).toString(),
    values: entity.values.map((value10) => {
      let options;
      if (value10.options) {
        if (value10.options.text) {
          options = {
            text: {
              ...value10.options.text.language ? {
                language: toBase64(Id(value10.options.text.language)).toString()
              } : null
            }
          };
        } else if (value10.options.number) {
          options = {
            number: {
              ...value10.options.number.unit ? { unit: toBase64(Id(value10.options.number.unit)).toString() } : {}
            }
          };
        }
      }
      const valueEntry = {
        property: toBase64(value10.property).toString(),
        value: value10.value
      };
      if (options) {
        valueEntry.options = options;
      }
      return valueEntry;
    })
  };
}
function convertPropertyToBase64(property2) {
  return {
    id: toBase64(property2.id).toString(),
    dataType: property2.dataType
  };
}
function opsToBinary(ops) {
  return ops.map((o) => {
    switch (o.type) {
      case "CREATE_RELATION":
        return new Op({
          payload: {
            case: "createRelation",
            value: Relation.fromJson(convertRelationIdsToBase64(o.relation))
          }
        });
      case "CREATE_PROPERTY":
        return new Op({
          payload: {
            case: "createProperty",
            value: Property2.fromJson(convertPropertyToBase64(o.property))
          }
        });
      case "DELETE_RELATION":
        return new Op({
          payload: {
            case: "deleteRelation",
            value: toBytes4(o.id)
          }
        });
      case "UPDATE_ENTITY":
        return new Op({
          payload: {
            case: "updateEntity",
            value: Entity.fromJson(convertUpdateEntityToBase64(o.entity))
          }
        });
      case "UNSET_ENTITY_VALUES":
        return new Op({
          payload: {
            case: "unsetEntityValues",
            value: UnsetEntityValues.fromJson(convertUnsetEntityValuesToBase64(o.unsetEntityValues))
          }
        });
      case "UPDATE_RELATION":
        return new Op({
          payload: {
            case: "updateRelation",
            value: RelationUpdate.fromJson(convertUpdateRelationToBase64(o.relation))
          }
        });
      case "UNSET_RELATION_FIELDS":
        return new Op({
          payload: {
            case: "unsetRelationFields",
            value: UnsetRelationFields.fromJson(convertUnsetRelationFieldsToBase64(o.unsetRelationFields))
          }
        });
    }
  });
}

// node_modules/@graphprotocol/grc-20/dist/src/ipfs.js
var IpfsUploadError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "_tag", "IpfsUploadError");
  }
};
async function publishEdit(args2) {
  const { name, ops, author, network = "MAINNET" } = args2;
  const edit = edit_exports.encode({ name, ops, author });
  const blob = new Blob([edit], { type: "application/octet-stream" });
  const formData = new FormData();
  formData.append("file", blob);
  const cid = await Micro_exports.runPromise(uploadBinary(formData, network));
  const result = Edit.fromBinary(edit);
  return { cid, editId: fromBytes2(result.id) };
}
async function uploadImage(params, network) {
  const formData = new FormData();
  let blob;
  if ("blob" in params) {
    blob = params.blob;
  } else {
    const response = await fetch(params.url);
    blob = await response.blob();
  }
  formData.append("file", blob);
  const buffer7 = Buffer.from(await blob.arrayBuffer());
  let dimensions;
  try {
    dimensions = imageSize(buffer7);
  } catch (error4) {
  }
  const cid = await Micro_exports.runPromise(uploadFile(formData, network));
  if (dimensions) {
    return {
      cid,
      dimensions: {
        width: dimensions.width,
        height: dimensions.height
      }
    };
  }
  return {
    cid
  };
}
async function uploadCSV(csvString, network) {
  const encoder3 = new TextEncoder();
  const csvStringBytes = encoder3.encode(csvString);
  const blob = await gzipSync(csvStringBytes);
  const formData = new FormData();
  formData.append("file", new Blob([blob], { type: "text/csv" }));
  return await Micro_exports.runPromise(uploadBinary(formData, network));
}
function uploadBinary(formData, network) {
  return Micro_exports.gen(function* () {
    const result = yield* Micro_exports.tryPromise({
      try: () => fetch(`${network === "TESTNET" ? TESTNET_API_ORIGIN : MAINNET_API_ORIGIN}/ipfs/upload-edit`, {
        method: "POST",
        body: formData
      }),
      catch: (error4) => new IpfsUploadError(`Could not upload data to IPFS: ${error4}`)
    });
    const maybeCid = yield* Micro_exports.tryPromise({
      try: async () => {
        const { cid } = await result.json();
        return cid;
      },
      catch: (error4) => new IpfsUploadError(`Could not parse response from IPFS: ${error4}`)
    });
    return maybeCid;
  });
}
function uploadFile(formData, network) {
  return Micro_exports.gen(function* () {
    const result = yield* Micro_exports.tryPromise({
      try: () => fetch(`${network === "TESTNET" ? TESTNET_API_ORIGIN : MAINNET_API_ORIGIN}/ipfs/upload-file`, {
        method: "POST",
        body: formData
      }),
      catch: (error4) => new IpfsUploadError(`Could not upload file to IPFS: ${error4}`)
    });
    const maybeCid = yield* Micro_exports.tryPromise({
      try: async () => {
        const { cid } = await result.json();
        return cid;
      },
      catch: (error4) => new IpfsUploadError(`Could not parse response from IPFS: ${error4}`)
    });
    return maybeCid;
  });
}

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-image.js
var createImage = async ({ name, description, id: providedId, ...params }) => {
  if (providedId)
    assertValid(providedId, "`id` in `createImage`");
  const id3 = providedId ?? generate();
  const { cid, dimensions } = await uploadImage(params);
  const values15 = [];
  values15.push({
    property: IMAGE_URL_PROPERTY,
    value: cid
  });
  if (dimensions == null ? void 0 : dimensions.height) {
    values15.push({
      property: IMAGE_HEIGHT_PROPERTY,
      value: dimensions.height.toString()
    });
  }
  if (dimensions == null ? void 0 : dimensions.width) {
    values15.push({
      property: IMAGE_WIDTH_PROPERTY,
      value: dimensions.width.toString()
    });
  }
  const { ops } = createEntity({
    id: id3,
    name,
    description,
    values: values15
  });
  ops.push({
    type: "CREATE_RELATION",
    relation: {
      id: generate(),
      entity: generate(),
      fromEntity: Id(id3),
      toEntity: IMAGE_TYPE,
      type: TYPES_PROPERTY
    }
  });
  return {
    id: Id(id3),
    ops
  };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-property.js
var createProperty = (params) => {
  const { id: id3, name, description, cover } = params;
  if (id3) {
    assertValid(id3, "`id` in `createProperty`");
  }
  if (cover)
    assertValid(cover, "`cover` in `createProperty`");
  if (params.dataType === "RELATION") {
    for (const propertyId of params.properties ?? []) {
      assertValid(propertyId, "`properties` in `createProperty`");
    }
    for (const relationValueTypeId of params.relationValueTypes ?? []) {
      assertValid(relationValueTypeId, "`relationValueTypes` in `createProperty`");
    }
  }
  const entityId = id3 ?? generate();
  const ops = [];
  ops.push({
    type: "CREATE_PROPERTY",
    property: {
      id: Id(entityId),
      dataType: params.dataType
    }
  });
  const { ops: entityOps } = createEntity({
    id: entityId,
    name,
    description,
    cover
  });
  ops.push(...entityOps);
  ops.push({
    type: "CREATE_RELATION",
    relation: {
      id: generate(),
      entity: generate(),
      fromEntity: Id(entityId),
      toEntity: PROPERTY,
      type: TYPES_PROPERTY
    }
  });
  if (params.dataType === "RELATION") {
    if (params.properties) {
      for (const propertyId of params.properties) {
        assertValid(propertyId);
        const { ops: relationOps } = createRelation({
          fromEntity: entityId,
          toEntity: propertyId,
          type: PROPERTY
        });
        ops.push(...relationOps);
      }
    }
    if (params.relationValueTypes) {
      for (const relationValueTypeId of params.relationValueTypes) {
        assertValid(relationValueTypeId);
        const { ops: relationOps } = createRelation({
          fromEntity: entityId,
          toEntity: relationValueTypeId,
          type: RELATION_VALUE_RELATIONSHIP_TYPE
        });
        ops.push(...relationOps);
      }
    }
  }
  return { id: Id(entityId), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-space.js
var createSpace = async (params) => {
  const apiHost = params.network === "TESTNET" ? TESTNET_API_ORIGIN : MAINNET_API_ORIGIN;
  console.log("apiHost", apiHost);
  const formData = new FormData();
  formData.append("name", params.name);
  formData.append("editorAddress", params.editorAddress);
  if (params.spaceEntityId) {
    formData.append("spaceEntityId", params.spaceEntityId);
  }
  if (params.ops) {
    formData.append("ops", JSON.stringify(params.ops));
  }
  const result = await fetch(`${apiHost}/deploy`, {
    method: "POST",
    body: JSON.stringify({
      spaceName: params.name,
      initialEditorAddress: params.editorAddress,
      ops: params.ops,
      spaceEntityId: params.spaceEntityId
    }),
    headers: {
      "Content-Type": "application/json"
    }
  });
  const jsonResult = await result.json();
  return { id: jsonResult.spaceId };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/create-type.js
var createType = ({ id: providedId, name, description, cover, properties }) => {
  if (providedId) {
    assertValid(providedId, "`id` in `createType`");
  }
  for (const propertyId of properties ?? []) {
    assertValid(propertyId, "`properties` in `createType`");
  }
  const id3 = providedId ?? generate();
  const { ops } = createEntity({
    id: id3,
    name,
    description,
    cover
  });
  assertValid(id3);
  ops.push({
    type: "CREATE_RELATION",
    relation: {
      id: generate(),
      entity: generate(),
      fromEntity: Id(id3),
      toEntity: SCHEMA_TYPE,
      type: TYPES_PROPERTY
    }
  });
  if (properties) {
    for (const propertyId of properties) {
      assertValid(propertyId, "`propertyId` in `createType`");
      ops.push({
        type: "CREATE_RELATION",
        relation: {
          id: generate(),
          entity: generate(),
          fromEntity: Id(id3),
          toEntity: Id(propertyId),
          type: PROPERTY
        }
      });
    }
  }
  return { id: Id(id3), ops };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/delete-relation.js
var deleteRelation = ({ id: id3 }) => {
  assertValid(id3, "`id` in `deleteRelation`");
  const op = {
    type: "DELETE_RELATION",
    id: Id(id3)
  };
  return { id: Id(id3), ops: [op] };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/serialize.js
var serializeNumber = (value10) => {
  return value10.toString();
};
var serializeCheckbox = (value10) => {
  return value10 ? "1" : "0";
};
var serializeDate = (value10) => {
  return value10.toISOString();
};
var serializePoint = (value10) => {
  return value10.join(",");
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/unset-entity-values.js
var unsetEntityValues = ({ id: id3, properties }) => {
  assertValid(id3, "`id` in `unsetEntityValues`");
  for (const propertyId of properties) {
    assertValid(propertyId, "`properties` in `unsetEntityValues`");
  }
  const op = {
    type: "UNSET_ENTITY_VALUES",
    unsetEntityValues: {
      id: Id(id3),
      properties: properties.map((propertyId) => Id(propertyId))
    }
  };
  return { id: Id(id3), ops: [op] };
};

// node_modules/@graphprotocol/grc-20/dist/src/graph/unset-relation-fields.js
var unsetRelationFields = ({ id: id3, fromVersion, toSpace, toVersion, position, verified }) => {
  assertValid(id3, "`id` in `unsetRelationFields`");
  const op = {
    type: "UNSET_RELATION_FIELDS",
    unsetRelationFields: {
      id: Id(id3),
      fromVersion,
      toSpace,
      toVersion,
      position,
      verified
    }
  };
  return { id: id3, ops: [op] };
};

// node_modules/@graphprotocol/grc-20/dist/src/core/position.js
var position_exports = {};
__export(position_exports, {
  compare: () => compare2,
  generate: () => generate2,
  generateBetween: () => generateBetween,
  sort: () => sort3
});

// node_modules/fractional-indexing-jittered/lib/index.js
function indexCharacterSet(options) {
  const dicts = createCharSetDicts(options.chars);
  const limits = integerLimits(
    dicts,
    options.firstPositive,
    options.mostPositive,
    options.mostNegative
  );
  const jitterRange = options.jitterRange ?? Math.floor(Math.pow(dicts.length, 3) / 5);
  const paddingRange = paddingDict(jitterRange, dicts.length);
  return {
    chars: options.chars,
    byChar: dicts.byChar,
    byCode: dicts.byCode,
    length: dicts.length,
    first: dicts.byCode[0],
    last: dicts.byCode[dicts.length - 1],
    firstPositive: limits.firstPositive,
    mostPositive: limits.mostPositive,
    firstNegative: limits.firstNegative,
    mostNegative: limits.mostNegative,
    jitterRange,
    paddingDict: paddingRange
  };
}
function createCharSetDicts(charSet) {
  const byCode = {};
  const byChar = {};
  const length6 = charSet.length;
  for (let i = 0; i < length6; i++) {
    const char2 = charSet[i];
    byCode[i] = char2;
    byChar[char2] = i;
  }
  return {
    byCode,
    byChar,
    length: length6
  };
}
function integerLimits(dicts, firstPositive, mostPositive, mostNegative) {
  const firstPositiveIndex = firstPositive ? dicts.byChar[firstPositive] : Math.ceil(dicts.length / 2);
  const mostPositiveIndex = mostPositive ? dicts.byChar[mostPositive] : dicts.length - 1;
  const mostNegativeIndex = mostNegative ? dicts.byChar[mostNegative] : 0;
  if (firstPositiveIndex === void 0 || mostPositiveIndex === void 0 || mostNegativeIndex === void 0) {
    throw new Error("invalid charSet");
  }
  if (mostPositiveIndex - firstPositiveIndex < 3) {
    throw new Error(
      "mostPositive must be at least 3 characters away from neutral"
    );
  }
  if (firstPositiveIndex - mostNegativeIndex < 3) {
    throw new Error(
      "mostNegative must be at least 3 characters away from neutral"
    );
  }
  return {
    firstPositive: dicts.byCode[firstPositiveIndex],
    mostPositive: dicts.byCode[mostPositiveIndex],
    firstNegative: dicts.byCode[firstPositiveIndex - 1],
    mostNegative: dicts.byCode[mostNegativeIndex]
  };
}
function paddingDict(jitterRange, charSetLength) {
  const paddingDict2 = {};
  let distance3 = 0;
  for (let i = 0; i < 100; i++) {
    paddingDict2[i] = Math.pow(charSetLength, i);
    if (paddingDict2[i] > jitterRange) {
      break;
    }
  }
  return paddingDict2;
}
var _base62CharSet = null;
function base62CharSet() {
  if (_base62CharSet)
    return _base62CharSet;
  return _base62CharSet = indexCharacterSet({
    // Base62 are all the alphanumeric characters, database and user friendly
    // For shorter strings and more room you could opt for more characters
    chars: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    // This gives us nice human readable keys to start with a0 a1 etc
    firstPositive: "a",
    mostPositive: "z",
    mostNegative: "A"
  });
}
function distanceBetween(a, b, charSet) {
  const indexA = charSet.byChar[a];
  const indexB = charSet.byChar[b];
  return Math.abs(indexA - indexB);
}
function integerLength(head13, charSet) {
  const firstChar = head13[0];
  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {
    throw new Error("invalid firstChar on key");
  }
  if (firstChar === charSet.mostPositive) {
    const firstLevel = distanceBetween(firstChar, charSet.firstPositive, charSet) + 1;
    return firstLevel + integerLengthFromSecondLevel(head13.slice(1), "positive", charSet);
  }
  if (firstChar === charSet.mostNegative) {
    const firstLevel = distanceBetween(firstChar, charSet.firstNegative, charSet) + 1;
    return firstLevel + integerLengthFromSecondLevel(head13.slice(1), "negative", charSet);
  }
  const isPositiveRange = firstChar >= charSet.firstPositive;
  if (isPositiveRange) {
    return distanceBetween(firstChar, charSet.firstPositive, charSet) + 2;
  } else {
    return distanceBetween(firstChar, charSet.firstNegative, charSet) + 2;
  }
}
function integerLengthFromSecondLevel(key, direction, charSet) {
  const firstChar = key[0];
  if (firstChar > charSet.mostPositive || firstChar < charSet.mostNegative) {
    throw new Error("invalid firstChar on key");
  }
  if (firstChar === charSet.mostPositive && direction === "positive") {
    const totalPositiveRoom = distanceBetween(firstChar, charSet.mostNegative, charSet) + 1;
    return totalPositiveRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);
  }
  if (firstChar === charSet.mostNegative && direction === "negative") {
    const totalNegativeRoom = distanceBetween(firstChar, charSet.mostPositive, charSet) + 1;
    return totalNegativeRoom + integerLengthFromSecondLevel(key.slice(1), direction, charSet);
  }
  if (direction === "positive") {
    return distanceBetween(firstChar, charSet.mostNegative, charSet) + 2;
  } else {
    return distanceBetween(firstChar, charSet.mostPositive, charSet) + 2;
  }
}
function makeSameLength(a, b, pad4, fillChar, forceLength) {
  const max14 = forceLength ?? Math.max(a.length, b.length);
  if (pad4 === "start") {
    return [a.padStart(max14, fillChar), b.padStart(max14, fillChar)];
  }
  return [a.padEnd(max14, fillChar), b.padEnd(max14, fillChar)];
}
function midPoint(lower, upper, charSet) {
  let [paddedLower, paddedUpper] = makeSameLength(
    lower,
    upper,
    "end",
    charSet.first
  );
  let distance3 = lexicalDistance(paddedLower, paddedUpper, charSet);
  if (distance3 === 1) {
    paddedLower = paddedLower.padEnd(paddedLower.length + 1, charSet.first);
    distance3 = charSet.length;
  }
  const mid = encodeToCharSet(Math.floor(distance3 / 2), charSet);
  return addCharSetKeys(paddedLower, mid, charSet);
}
function lexicalDistance(a, b, charSet) {
  const [lower, upper] = makeSameLength(a, b, "end", charSet.first).sort();
  const distance3 = subtractCharSetKeys(upper, lower, charSet);
  return decodeCharSetToNumber(distance3, charSet);
}
function addCharSetKeys(a, b, charSet) {
  const base = charSet.length;
  const [paddedA, paddedB] = makeSameLength(a, b, "start", charSet.first);
  const result = [];
  let carry = 0;
  for (let i = paddedA.length - 1; i >= 0; i--) {
    const digitA = charSet.byChar[paddedA[i]];
    const digitB = charSet.byChar[paddedB[i]];
    const sum7 = digitA + digitB + carry;
    carry = Math.floor(sum7 / base);
    const remainder3 = sum7 % base;
    result.unshift(charSet.byCode[remainder3]);
  }
  if (carry > 0) {
    result.unshift(charSet.byCode[carry]);
  }
  return result.join("");
}
function subtractCharSetKeys(a, b, charSet, stripLeadingZeros = true) {
  const base = charSet.length;
  const [paddedA, paddedB] = makeSameLength(a, b, "start", charSet.first);
  const result = [];
  let borrow = 0;
  for (let i = paddedA.length - 1; i >= 0; i--) {
    let digitA = charSet.byChar[paddedA[i]];
    const digitB = charSet.byChar[paddedB[i]] + borrow;
    if (digitA < digitB) {
      borrow = 1;
      digitA += base;
    } else {
      borrow = 0;
    }
    const difference9 = digitA - digitB;
    result.unshift(charSet.byCode[difference9]);
  }
  if (borrow > 0) {
    throw new Error(
      "Subtraction result is negative. Ensure a is greater than or equal to b."
    );
  }
  while (stripLeadingZeros && result.length > 1 && result[0] === charSet.first) {
    result.shift();
  }
  return result.join("");
}
function incrementKey(key, charSet) {
  return addCharSetKeys(key, charSet.byCode[1], charSet);
}
function decrementKey(key, charSet) {
  return subtractCharSetKeys(key, charSet.byCode[1], charSet, false);
}
function encodeToCharSet(int2, charSet) {
  if (int2 === 0) {
    return charSet.byCode[0];
  }
  let res = "";
  const max14 = charSet.length;
  while (int2 > 0) {
    res = charSet.byCode[int2 % max14] + res;
    int2 = Math.floor(int2 / max14);
  }
  return res;
}
function decodeCharSetToNumber(key, charSet) {
  let res = 0;
  const length6 = key.length;
  const max14 = charSet.length;
  for (let i = 0; i < length6; i++) {
    res += charSet.byChar[key[i]] * Math.pow(max14, length6 - i - 1);
  }
  return res;
}
function startKey(charSet) {
  return charSet.firstPositive + charSet.byCode[0];
}
function validInteger(integer4, charSet) {
  const length6 = integerLength(integer4, charSet);
  return length6 === integer4.length;
}
function validateOrderKey(orderKey, charSet) {
  getIntegerPart(orderKey, charSet);
}
function getIntegerPart(orderKey, charSet) {
  const head13 = integerHead(orderKey, charSet);
  const integerPartLength = integerLength(head13, charSet);
  if (integerPartLength > orderKey.length) {
    throw new Error("invalid order key length: " + orderKey);
  }
  return orderKey.slice(0, integerPartLength);
}
function validateInteger(integer4, charSet) {
  if (!validInteger(integer4, charSet)) {
    throw new Error("invalid integer length: " + integer4);
  }
}
function incrementInteger(integer4, charSet) {
  validateInteger(integer4, charSet);
  const [head13, digs] = splitInteger(integer4, charSet);
  const anyNonMaxedDigit = digs.split("").some((d) => d !== charSet.byCode[charSet.length - 1]);
  if (anyNonMaxedDigit) {
    const newDigits = incrementKey(digs, charSet);
    return head13 + newDigits;
  }
  const nextHead = incrementIntegerHead(head13, charSet);
  return startOnNewHead(nextHead, "lower", charSet);
}
function decrementInteger(integer4, charSet) {
  validateInteger(integer4, charSet);
  const [head13, digs] = splitInteger(integer4, charSet);
  const anyNonLimitDigit = digs.split("").some((d) => d !== charSet.byCode[0]);
  if (anyNonLimitDigit) {
    const newDigits = decrementKey(digs, charSet);
    return head13 + newDigits;
  }
  const nextHead = decrementIntegerHead(head13, charSet);
  return startOnNewHead(nextHead, "upper", charSet);
}
function integerHead(integer4, charSet) {
  let i = 0;
  if (integer4[0] === charSet.mostPositive) {
    while (integer4[i] === charSet.mostPositive) {
      i = i + 1;
    }
  }
  if (integer4[0] === charSet.mostNegative) {
    while (integer4[i] === charSet.mostNegative) {
      i = i + 1;
    }
  }
  return integer4.slice(0, i + 1);
}
function splitInteger(integer4, charSet) {
  const head13 = integerHead(integer4, charSet);
  const tail5 = integer4.slice(head13.length);
  return [head13, tail5];
}
function incrementIntegerHead(head13, charSet) {
  const inPositiveRange = head13 >= charSet.firstPositive;
  const nextHead = incrementKey(head13, charSet);
  const headIsLimitMax = head13[head13.length - 1] === charSet.mostPositive;
  const nextHeadIsLimitMax = nextHead[nextHead.length - 1] === charSet.mostPositive;
  if (inPositiveRange && nextHeadIsLimitMax) {
    return nextHead + charSet.mostNegative;
  }
  if (!inPositiveRange && headIsLimitMax) {
    return head13.slice(0, head13.length - 1);
  }
  return nextHead;
}
function decrementIntegerHead(head13, charSet) {
  const inPositiveRange = head13 >= charSet.firstPositive;
  const headIsLimitMin = head13[head13.length - 1] === charSet.mostNegative;
  if (inPositiveRange && headIsLimitMin) {
    const nextLevel = head13.slice(0, head13.length - 1);
    return decrementKey(nextLevel, charSet);
  }
  if (!inPositiveRange && headIsLimitMin) {
    return head13 + charSet.mostPositive;
  }
  return decrementKey(head13, charSet);
}
function startOnNewHead(head13, limit2, charSet) {
  const newLength = integerLength(head13, charSet);
  const fillChar = limit2 === "upper" ? charSet.byCode[charSet.length - 1] : charSet.byCode[0];
  return head13 + fillChar.repeat(newLength - head13.length);
}
function jitterString(orderKey, charSet) {
  const shift2 = encodeToCharSet(
    Math.floor(Math.random() * charSet.jitterRange),
    charSet
  );
  return addCharSetKeys(orderKey, shift2, charSet);
}
function padAndJitterString(orderKey, numberOfChars, charSet) {
  const paddedKey = orderKey.padEnd(
    orderKey.length + numberOfChars,
    charSet.first
  );
  return jitterString(paddedKey, charSet);
}
function paddingNeededForJitter(orderKey, b, charSet) {
  const integer4 = getIntegerPart(orderKey, charSet);
  const nextInteger = incrementInteger(integer4, charSet);
  let needed = 0;
  if (b !== null) {
    const distanceToB = lexicalDistance(orderKey, b, charSet);
    if (distanceToB < charSet.jitterRange + 1) {
      needed = Math.max(needed, paddingNeededForDistance(distanceToB, charSet));
    }
  }
  const distanceToNextInteger = lexicalDistance(orderKey, nextInteger, charSet);
  if (distanceToNextInteger < charSet.jitterRange + 1) {
    needed = Math.max(
      needed,
      paddingNeededForDistance(distanceToNextInteger, charSet)
    );
  }
  return needed;
}
function paddingNeededForDistance(distance3, charSet) {
  const gap = charSet.jitterRange - distance3;
  const firstBigger = Object.entries(charSet.paddingDict).find(
    ([_key, value10]) => {
      return value10 > gap;
    }
  );
  return firstBigger ? parseInt(firstBigger[0]) : 0;
}
function generateKeyBetween(lower, upper, charSet = base62CharSet()) {
  if (lower !== null) {
    validateOrderKey(lower, charSet);
  }
  if (upper !== null) {
    validateOrderKey(upper, charSet);
  }
  if (lower === null && upper === null) {
    return startKey(charSet);
  }
  if (lower === null) {
    const integer4 = getIntegerPart(upper, charSet);
    return decrementInteger(integer4, charSet);
  }
  if (upper === null) {
    const integer4 = getIntegerPart(lower, charSet);
    return incrementInteger(integer4, charSet);
  }
  if (lower >= upper) {
    throw new Error(lower + " >= " + upper);
  }
  return midPoint(lower, upper, charSet);
}
function generateJitteredKeyBetween(lower, upper, charSet = base62CharSet()) {
  const key = generateKeyBetween(lower, upper, charSet);
  const paddingNeeded = paddingNeededForJitter(key, upper, charSet);
  if (paddingNeeded) {
    return padAndJitterString(key, paddingNeeded, charSet);
  }
  return jitterString(key, charSet);
}

// node_modules/@graphprotocol/grc-20/dist/src/core/position.js
function generateBetween(first5, second) {
  return generateJitteredKeyBetween(first5, second);
}
function generate2() {
  return generateBetween(null, null);
}
function compare2(a, b) {
  if (a === null && b === null)
    return 0;
  if (a === null)
    return 1;
  if (b === null)
    return -1;
  return a.localeCompare(b);
}
function sort3(positions) {
  return positions.sort(compare2);
}

// node_modules/@graphprotocol/grc-20/dist/src/core/scheme.js
var scheme_exports = {};
__export(scheme_exports, {
  fromEntityId: () => fromEntityId,
  isValid: () => isValid3,
  toEntityId: () => toEntityId,
  toSpaceId: () => toSpaceId
});
var SPACE_SEARCH_PARAM = "s";
var SCHEME_PREFIX = "graph";
function fromEntityId(entityId, params = {}) {
  if (isValid3(entityId)) {
    throw new Error(`The passed in entityId should not start with ${SCHEME_PREFIX}://`);
  }
  let uri = `${SCHEME_PREFIX}://${entityId}`;
  if (params.spaceId) {
    uri = `${uri}?${SPACE_SEARCH_PARAM}=${params.spaceId}`;
  }
  return uri;
}
function isValid3(value10) {
  return value10.startsWith(`${SCHEME_PREFIX}://`);
}
function toEntityId(uri) {
  var _a106, _b32;
  const entity = (_b32 = (_a106 = uri.split(`${SCHEME_PREFIX}://`)) == null ? void 0 : _a106[1]) == null ? void 0 : _b32.split("?")[0];
  if (!entity) {
    throw new Error(`Could not parse entity id from provided URI: ${uri}`);
  }
  return entity;
}
function toSpaceId(uri) {
  const url3 = new URL(uri);
  const searchParams = url3.searchParams;
  if (!searchParams.has(SPACE_SEARCH_PARAM)) {
    return null;
  }
  return searchParams.get(SPACE_SEARCH_PARAM);
}

// node_modules/permissionless/_esm/utils/deepHexlify.js
function deepHexlify(obj) {
  if (typeof obj === "function") {
    return void 0;
  }
  if (obj == null || typeof obj === "string" || typeof obj === "boolean") {
    return obj;
  }
  if (typeof obj === "bigint") {
    return toHex(obj);
  }
  if (obj._isBigNumber != null || typeof obj !== "object") {
    return toHex(obj).replace(/^0x0/, "0x");
  }
  if (Array.isArray(obj)) {
    return obj.map((member) => deepHexlify(member));
  }
  return Object.keys(obj).reduce(
    // biome-ignore lint/suspicious/noExplicitAny: it's a recursive function, so it's hard to type
    (set26, key) => {
      set26[key] = deepHexlify(obj[key]);
      return set26;
    },
    {}
  );
}

// node_modules/permissionless/_esm/utils/isSmartAccountDeployed.js
var isSmartAccountDeployed = async (client, address) => {
  const contractCode = await getCode(client, {
    address
  });
  return Boolean(contractCode);
};

// node_modules/@scure/base/lib/esm/index.js
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf(isString3, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString3) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args2) {
  const id3 = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode16 = args2.map((x) => x.encode).reduceRight(wrap, id3);
  const decode11 = args2.map((x) => x.decode).reduce(wrap, id3);
  return { encode: encode16, decode: decode11 };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
function join8(separator = "") {
  astr("join", separator);
  return {
    encode: (from29) => {
      astrArr("join.decode", from29);
      return from29.join(separator);
    },
    decode: (to3) => {
      astr("join.decode", to3);
      return to3.split(separator);
    }
  };
}
function padding(bits2, chr = "=") {
  anumber2(bits2);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits2 % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end7 = input.length;
      if (end7 * bits2 % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end7 > 0 && input[end7 - 1] === chr; end7--) {
        const last8 = end7 - 1;
        const byte = last8 * bits2;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end7);
    }
  };
}
function normalize3(fn2) {
  afn(fn2);
  return { encode: (from29) => from29, decode: (to3) => fn2(to3) };
}
function convertRadix(data, from29, to3) {
  if (from29 < 2)
    throw new Error(`convertRadix: invalid from=${from29}, base cannot be less than 2`);
  if (to3 < 2)
    throw new Error(`convertRadix: invalid to=${to3}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber2(d);
    if (d < 0 || d >= from29)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done17 = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from29 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from29 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to3;
      carry = digitBase % to3;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to3 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done17)
        continue;
      else if (!rounded)
        pos = i;
      else
        done17 = false;
    }
    res.push(carry);
    if (done17)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd2 = (a, b) => b === 0 ? a : gcd2(b, a % b);
var radix2carry = (from29, to3) => from29 + (to3 - gcd2(from29, to3));
var powers = (() => {
  let res = [];
  for (let i = 0; i < 40; i++)
    res.push(2 ** i);
  return res;
})();
function convertRadix2(data, from29, to3, padding2) {
  aArr(data);
  if (from29 <= 0 || from29 > 32)
    throw new Error(`convertRadix2: wrong from=${from29}`);
  if (to3 <= 0 || to3 > 32)
    throw new Error(`convertRadix2: wrong to=${to3}`);
  if (radix2carry(from29, to3) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from29} to=${to3} carryBits=${radix2carry(from29, to3)}`);
  }
  let carry = 0;
  let pos = 0;
  const max14 = powers[from29];
  const mask = powers[to3] - 1;
  const res = [];
  for (const n of data) {
    anumber2(n);
    if (n >= max14)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from29}`);
    carry = carry << from29 | n;
    if (pos + from29 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from29}`);
    pos += from29;
    for (; pos >= to3; pos -= to3)
      res.push((carry >> pos - to3 & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to3 - pos & mask;
  if (!padding2 && pos >= from29)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber2(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits2, revPadding = false) {
  anumber2(bits2);
  if (bits2 <= 0 || bits2 > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits2) > 32 || radix2carry(bits2, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits2, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits2, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn2) {
  afn(fn2);
  return function(...args2) {
    try {
      return fn2.apply(null, args2);
    } catch (e) {
    }
  };
}
function checksum3(len, fn2) {
  anumber2(len);
  afn(fn2);
  return {
    encode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum7 = fn2(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum7, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn2(payload).slice(0, len);
      for (let i = 0; i < len; i++)
        if (newChecksum[i] !== oldChecksum[i])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var utils = {
  alphabet,
  chain,
  checksum: checksum3,
  convertRadix,
  convertRadix2,
  radix,
  radix2,
  join: join8,
  padding
};
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join8(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join8(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join8(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join8(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join8(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join8(""), normalize3((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s, isUrl) => {
  astr("base64", s);
  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
  const alphabet2 = isUrl ? "base64url" : "base64";
  if (s.length > 0 && !re.test(s))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(s, { alphabet: alphabet2, lastChunkHandling: "strict" });
};
var base642 = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64();
  },
  decode(s) {
    return decodeBase64Builtin(s, false);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join8(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join8(""));
var base64url = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64({ alphabet: "base64url" });
  },
  decode(s) {
    return decodeBase64Builtin(s, true);
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join8(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join8(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join8(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var createBase58check = (sha2565) => chain(checksum3(4, (data) => sha2565(sha2565(data))), base58);
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join8(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre2) {
  const b = pre2 >> 25;
  let chk = (pre2 & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode16(prefix, words, limit2 = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes2(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    const lowered = prefix.toLowerCase();
    const sum7 = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum7}`;
  }
  function decode11(str, limit2 = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit2 !== false && slen > limit2)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum7 = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum7))
      throw new Error(`Invalid checksum in ${str}: expected "${sum7}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode11);
  function decodeToBytes(str) {
    const { prefix, words } = decode11(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode16(prefix, toWords(bytes));
  }
  return {
    encode: encode16,
    decode: decode11,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes2(data);
    return data.toHex();
  },
  decode(s) {
    astr("hex", s);
    return Uint8Array.fromHex(s);
  }
};
var hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join8(""), normalize3((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/@scure/bip32/lib/esm/index.js
var Point = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha256);
function bytesToNumber2(bytes) {
  abytes(bytes);
  const h2 = bytes.length === 0 ? "0" : bytesToHex2(bytes);
  return BigInt("0x" + h2);
}
function numberToBytes2(num) {
  if (typeof num !== "bigint")
    throw new Error("bigint expected");
  return hexToBytes2(num.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha256(data));
var fromU32 = (data) => createView(data).getUint32(0, false);
var toU32 = (n) => {
  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
    throw new Error("invalid number, should be from 0 to 2**32-1, got " + n);
  }
  const buf = new Uint8Array(4);
  createView(buf).setUint32(0, n, false);
  return buf;
};
var HDKey = class _HDKey {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    abytes(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
    }
    const I = hmac(sha512, MASTER_SECRET, seed);
    return new _HDKey({
      versions,
      chainCode: I.slice(32),
      privateKey: I.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView(keyBuffer);
    const version = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new _HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new _HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json3) {
    return _HDKey.fromExtendedKey(json3.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode || null;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber2(opt.privateKey);
      this.privKeyBytes = numberToBytes2(this.privKey);
      this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path2) {
    if (!/^[mM]'?/.test(path2)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path2)) {
      return this;
    }
    const parts2 = path2.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c of parts2) {
      const m = /^(\d+)('?)$/.exec(c);
      const m1 = m && m[1];
      if (!m || m.length !== 3 || typeof m1 !== "string")
        throw new Error("invalid child index: " + c);
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index3) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index3);
    if (index3 >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes(this.pubKey, data);
    }
    const I = hmac(sha512, this.chainCode, data);
    const childTweak = bytesToNumber2(I.slice(0, 32));
    const chainCode = I.slice(32);
    if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index: index3
    };
    try {
      if (this.privateKey) {
        const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
        if (!secp256k1.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
        if (added.equals(Point.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new _HDKey(opt);
    } catch (err2) {
      return this.deriveChild(index3 + 1);
    }
  }
  sign(hash11) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    abytes(hash11, 32);
    return secp256k1.sign(hash11, this.privKey).toCompactRawBytes();
  }
  verify(hash11, signature) {
    abytes(hash11, 32);
    abytes(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k1.Signature.fromCompact(signature);
    } catch (error4) {
      return false;
    }
    return secp256k1.verify(sig, hash11, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    abytes(key, 33);
    return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// node_modules/@scure/bip39/esm/wordlists/czech.js
var wordlist = `abdikace
abeceda
adresa
agrese
akce
aktovka
alej
alkohol
amputace
ananas
andulka
anekdota
anketa
antika
anulovat
archa
arogance
asfalt
asistent
aspirace
astma
astronom
atlas
atletika
atol
autobus
azyl
babka
bachor
bacil
baculka
badatel
bageta
bagr
bahno
bakterie
balada
baletka
balkon
balonek
balvan
balza
bambus
bankomat
barbar
baret
barman
baroko
barva
baterka
batoh
bavlna
bazalka
bazilika
bazuka
bedna
beran
beseda
bestie
beton
bezinka
bezmoc
beztak
bicykl
bidlo
biftek
bikiny
bilance
biograf
biolog
bitva
bizon
blahobyt
blatouch
blecha
bledule
blesk
blikat
blizna
blokovat
bloudit
blud
bobek
bobr
bodlina
bodnout
bohatost
bojkot
bojovat
bokorys
bolest
borec
borovice
bota
boubel
bouchat
bouda
boule
bourat
boxer
bradavka
brambora
branka
bratr
brepta
briketa
brko
brloh
bronz
broskev
brunetka
brusinka
brzda
brzy
bublina
bubnovat
buchta
buditel
budka
budova
bufet
bujarost
bukvice
buldok
bulva
bunda
bunkr
burza
butik
buvol
buzola
bydlet
bylina
bytovka
bzukot
capart
carevna
cedr
cedule
cejch
cejn
cela
celer
celkem
celnice
cenina
cennost
cenovka
centrum
cenzor
cestopis
cetka
chalupa
chapadlo
charita
chata
chechtat
chemie
chichot
chirurg
chlad
chleba
chlubit
chmel
chmura
chobot
chochol
chodba
cholera
chomout
chopit
choroba
chov
chrapot
chrlit
chrt
chrup
chtivost
chudina
chutnat
chvat
chvilka
chvost
chyba
chystat
chytit
cibule
cigareta
cihelna
cihla
cinkot
cirkus
cisterna
citace
citrus
cizinec
cizost
clona
cokoliv
couvat
ctitel
ctnost
cudnost
cuketa
cukr
cupot
cvaknout
cval
cvik
cvrkot
cyklista
daleko
dareba
datel
datum
dcera
debata
dechovka
decibel
deficit
deflace
dekl
dekret
demokrat
deprese
derby
deska
detektiv
dikobraz
diktovat
dioda
diplom
disk
displej
divadlo
divoch
dlaha
dlouho
dluhopis
dnes
dobro
dobytek
docent
dochutit
dodnes
dohled
dohoda
dohra
dojem
dojnice
doklad
dokola
doktor
dokument
dolar
doleva
dolina
doma
dominant
domluvit
domov
donutit
dopad
dopis
doplnit
doposud
doprovod
dopustit
dorazit
dorost
dort
dosah
doslov
dostatek
dosud
dosyta
dotaz
dotek
dotknout
doufat
doutnat
dovozce
dozadu
doznat
dozorce
drahota
drak
dramatik
dravec
draze
drdol
drobnost
drogerie
drozd
drsnost
drtit
drzost
duben
duchovno
dudek
duha
duhovka
dusit
dusno
dutost
dvojice
dvorec
dynamit
ekolog
ekonomie
elektron
elipsa
email
emise
emoce
empatie
epizoda
epocha
epopej
epos
esej
esence
eskorta
eskymo
etiketa
euforie
evoluce
exekuce
exkurze
expedice
exploze
export
extrakt
facka
fajfka
fakulta
fanatik
fantazie
farmacie
favorit
fazole
federace
fejeton
fenka
fialka
figurant
filozof
filtr
finance
finta
fixace
fjord
flanel
flirt
flotila
fond
fosfor
fotbal
fotka
foton
frakce
freska
fronta
fukar
funkce
fyzika
galeje
garant
genetika
geolog
gilotina
glazura
glejt
golem
golfista
gotika
graf
gramofon
granule
grep
gril
grog
groteska
guma
hadice
hadr
hala
halenka
hanba
hanopis
harfa
harpuna
havran
hebkost
hejkal
hejno
hejtman
hektar
helma
hematom
herec
herna
heslo
hezky
historik
hladovka
hlasivky
hlava
hledat
hlen
hlodavec
hloh
hloupost
hltat
hlubina
hluchota
hmat
hmota
hmyz
hnis
hnojivo
hnout
hoblina
hoboj
hoch
hodiny
hodlat
hodnota
hodovat
hojnost
hokej
holinka
holka
holub
homole
honitba
honorace
horal
horda
horizont
horko
horlivec
hormon
hornina
horoskop
horstvo
hospoda
hostina
hotovost
houba
houf
houpat
houska
hovor
hradba
hranice
hravost
hrazda
hrbolek
hrdina
hrdlo
hrdost
hrnek
hrobka
hromada
hrot
hrouda
hrozen
hrstka
hrubost
hryzat
hubenost
hubnout
hudba
hukot
humr
husita
hustota
hvozd
hybnost
hydrant
hygiena
hymna
hysterik
idylka
ihned
ikona
iluze
imunita
infekce
inflace
inkaso
inovace
inspekce
internet
invalida
investor
inzerce
ironie
jablko
jachta
jahoda
jakmile
jakost
jalovec
jantar
jarmark
jaro
jasan
jasno
jatka
javor
jazyk
jedinec
jedle
jednatel
jehlan
jekot
jelen
jelito
jemnost
jenom
jepice
jeseter
jevit
jezdec
jezero
jinak
jindy
jinoch
jiskra
jistota
jitrnice
jizva
jmenovat
jogurt
jurta
kabaret
kabel
kabinet
kachna
kadet
kadidlo
kahan
kajak
kajuta
kakao
kaktus
kalamita
kalhoty
kalibr
kalnost
kamera
kamkoliv
kamna
kanibal
kanoe
kantor
kapalina
kapela
kapitola
kapka
kaple
kapota
kapr
kapusta
kapybara
karamel
karotka
karton
kasa
katalog
katedra
kauce
kauza
kavalec
kazajka
kazeta
kazivost
kdekoliv
kdesi
kedluben
kemp
keramika
kino
klacek
kladivo
klam
klapot
klasika
klaun
klec
klenba
klepat
klesnout
klid
klima
klisna
klobouk
klokan
klopa
kloub
klubovna
klusat
kluzkost
kmen
kmitat
kmotr
kniha
knot
koalice
koberec
kobka
kobliha
kobyla
kocour
kohout
kojenec
kokos
koktejl
kolaps
koleda
kolize
kolo
komando
kometa
komik
komnata
komora
kompas
komunita
konat
koncept
kondice
konec
konfese
kongres
konina
konkurs
kontakt
konzerva
kopanec
kopie
kopnout
koprovka
korbel
korektor
kormidlo
koroptev
korpus
koruna
koryto
korzet
kosatec
kostka
kotel
kotleta
kotoul
koukat
koupelna
kousek
kouzlo
kovboj
koza
kozoroh
krabice
krach
krajina
kralovat
krasopis
kravata
kredit
krejcar
kresba
kreveta
kriket
kritik
krize
krkavec
krmelec
krmivo
krocan
krok
kronika
kropit
kroupa
krovka
krtek
kruhadlo
krupice
krutost
krvinka
krychle
krypta
krystal
kryt
kudlanka
kufr
kujnost
kukla
kulajda
kulich
kulka
kulomet
kultura
kuna
kupodivu
kurt
kurzor
kutil
kvalita
kvasinka
kvestor
kynolog
kyselina
kytara
kytice
kytka
kytovec
kyvadlo
labrador
lachtan
ladnost
laik
lakomec
lamela
lampa
lanovka
lasice
laso
lastura
latinka
lavina
lebka
leckdy
leden
lednice
ledovka
ledvina
legenda
legie
legrace
lehce
lehkost
lehnout
lektvar
lenochod
lentilka
lepenka
lepidlo
letadlo
letec
letmo
letokruh
levhart
levitace
levobok
libra
lichotka
lidojed
lidskost
lihovina
lijavec
lilek
limetka
linie
linka
linoleum
listopad
litina
litovat
lobista
lodivod
logika
logoped
lokalita
loket
lomcovat
lopata
lopuch
lord
losos
lotr
loudal
louh
louka
louskat
lovec
lstivost
lucerna
lucifer
lump
lusk
lustrace
lvice
lyra
lyrika
lysina
madam
madlo
magistr
mahagon
majetek
majitel
majorita
makak
makovice
makrela
malba
malina
malovat
malvice
maminka
mandle
manko
marnost
masakr
maskot
masopust
matice
matrika
maturita
mazanec
mazivo
mazlit
mazurka
mdloba
mechanik
meditace
medovina
melasa
meloun
mentolka
metla
metoda
metr
mezera
migrace
mihnout
mihule
mikina
mikrofon
milenec
milimetr
milost
mimika
mincovna
minibar
minomet
minulost
miska
mistr
mixovat
mladost
mlha
mlhovina
mlok
mlsat
mluvit
mnich
mnohem
mobil
mocnost
modelka
modlitba
mohyla
mokro
molekula
momentka
monarcha
monokl
monstrum
montovat
monzun
mosaz
moskyt
most
motivace
motorka
motyka
moucha
moudrost
mozaika
mozek
mozol
mramor
mravenec
mrkev
mrtvola
mrzet
mrzutost
mstitel
mudrc
muflon
mulat
mumie
munice
muset
mutace
muzeum
muzikant
myslivec
mzda
nabourat
nachytat
nadace
nadbytek
nadhoz
nadobro
nadpis
nahlas
nahnat
nahodile
nahradit
naivita
najednou
najisto
najmout
naklonit
nakonec
nakrmit
nalevo
namazat
namluvit
nanometr
naoko
naopak
naostro
napadat
napevno
naplnit
napnout
naposled
naprosto
narodit
naruby
narychlo
nasadit
nasekat
naslepo
nastat
natolik
navenek
navrch
navzdory
nazvat
nebe
nechat
necky
nedaleko
nedbat
neduh
negace
nehet
nehoda
nejen
nejprve
neklid
nelibost
nemilost
nemoc
neochota
neonka
nepokoj
nerost
nerv
nesmysl
nesoulad
netvor
neuron
nevina
nezvykle
nicota
nijak
nikam
nikdy
nikl
nikterak
nitro
nocleh
nohavice
nominace
nora
norek
nositel
nosnost
nouze
noviny
novota
nozdra
nuda
nudle
nuget
nutit
nutnost
nutrie
nymfa
obal
obarvit
obava
obdiv
obec
obehnat
obejmout
obezita
obhajoba
obilnice
objasnit
objekt
obklopit
oblast
oblek
obliba
obloha
obluda
obnos
obohatit
obojek
obout
obrazec
obrna
obruba
obrys
obsah
obsluha
obstarat
obuv
obvaz
obvinit
obvod
obvykle
obyvatel
obzor
ocas
ocel
ocenit
ochladit
ochota
ochrana
ocitnout
odboj
odbyt
odchod
odcizit
odebrat
odeslat
odevzdat
odezva
odhadce
odhodit
odjet
odjinud
odkaz
odkoupit
odliv
odluka
odmlka
odolnost
odpad
odpis
odplout
odpor
odpustit
odpykat
odrazka
odsoudit
odstup
odsun
odtok
odtud
odvaha
odveta
odvolat
odvracet
odznak
ofina
ofsajd
ohlas
ohnisko
ohrada
ohrozit
ohryzek
okap
okenice
oklika
okno
okouzlit
okovy
okrasa
okres
okrsek
okruh
okupant
okurka
okusit
olejnina
olizovat
omak
omeleta
omezit
omladina
omlouvat
omluva
omyl
onehdy
opakovat
opasek
operace
opice
opilost
opisovat
opora
opozice
opravdu
oproti
orbital
orchestr
orgie
orlice
orloj
ortel
osada
oschnout
osika
osivo
oslava
oslepit
oslnit
oslovit
osnova
osoba
osolit
ospalec
osten
ostraha
ostuda
ostych
osvojit
oteplit
otisk
otop
otrhat
otrlost
otrok
otruby
otvor
ovanout
ovar
oves
ovlivnit
ovoce
oxid
ozdoba
pachatel
pacient
padouch
pahorek
pakt
palanda
palec
palivo
paluba
pamflet
pamlsek
panenka
panika
panna
panovat
panstvo
pantofle
paprika
parketa
parodie
parta
paruka
paryba
paseka
pasivita
pastelka
patent
patrona
pavouk
pazneht
pazourek
pecka
pedagog
pejsek
peklo
peloton
penalta
pendrek
penze
periskop
pero
pestrost
petarda
petice
petrolej
pevnina
pexeso
pianista
piha
pijavice
pikle
piknik
pilina
pilnost
pilulka
pinzeta
pipeta
pisatel
pistole
pitevna
pivnice
pivovar
placenta
plakat
plamen
planeta
plastika
platit
plavidlo
plaz
plech
plemeno
plenta
ples
pletivo
plevel
plivat
plnit
plno
plocha
plodina
plomba
plout
pluk
plyn
pobavit
pobyt
pochod
pocit
poctivec
podat
podcenit
podepsat
podhled
podivit
podklad
podmanit
podnik
podoba
podpora
podraz
podstata
podvod
podzim
poezie
pohanka
pohnutka
pohovor
pohroma
pohyb
pointa
pojistka
pojmout
pokazit
pokles
pokoj
pokrok
pokuta
pokyn
poledne
polibek
polknout
poloha
polynom
pomalu
pominout
pomlka
pomoc
pomsta
pomyslet
ponechat
ponorka
ponurost
popadat
popel
popisek
poplach
poprosit
popsat
popud
poradce
porce
porod
porucha
poryv
posadit
posed
posila
poskok
poslanec
posoudit
pospolu
postava
posudek
posyp
potah
potkan
potlesk
potomek
potrava
potupa
potvora
poukaz
pouto
pouzdro
povaha
povidla
povlak
povoz
povrch
povstat
povyk
povzdech
pozdrav
pozemek
poznatek
pozor
pozvat
pracovat
prahory
praktika
prales
praotec
praporek
prase
pravda
princip
prkno
probudit
procento
prodej
profese
prohra
projekt
prolomit
promile
pronikat
propad
prorok
prosba
proton
proutek
provaz
prskavka
prsten
prudkost
prut
prvek
prvohory
psanec
psovod
pstruh
ptactvo
puberta
puch
pudl
pukavec
puklina
pukrle
pult
pumpa
punc
pupen
pusa
pusinka
pustina
putovat
putyka
pyramida
pysk
pytel
racek
rachot
radiace
radnice
radon
raft
ragby
raketa
rakovina
rameno
rampouch
rande
rarach
rarita
rasovna
rastr
ratolest
razance
razidlo
reagovat
reakce
recept
redaktor
referent
reflex
rejnok
reklama
rekord
rekrut
rektor
reputace
revize
revma
revolver
rezerva
riskovat
riziko
robotika
rodokmen
rohovka
rokle
rokoko
romaneto
ropovod
ropucha
rorejs
rosol
rostlina
rotmistr
rotoped
rotunda
roubenka
roucho
roup
roura
rovina
rovnice
rozbor
rozchod
rozdat
rozeznat
rozhodce
rozinka
rozjezd
rozkaz
rozloha
rozmar
rozpad
rozruch
rozsah
roztok
rozum
rozvod
rubrika
ruchadlo
rukavice
rukopis
ryba
rybolov
rychlost
rydlo
rypadlo
rytina
ryzost
sadista
sahat
sako
samec
samizdat
samota
sanitka
sardinka
sasanka
satelit
sazba
sazenice
sbor
schovat
sebranka
secese
sedadlo
sediment
sedlo
sehnat
sejmout
sekera
sekta
sekunda
sekvoje
semeno
seno
servis
sesadit
seshora
seskok
seslat
sestra
sesuv
sesypat
setba
setina
setkat
setnout
setrvat
sever
seznam
shoda
shrnout
sifon
silnice
sirka
sirotek
sirup
situace
skafandr
skalisko
skanzen
skaut
skeptik
skica
skladba
sklenice
sklo
skluz
skoba
skokan
skoro
skripta
skrz
skupina
skvost
skvrna
slabika
sladidlo
slanina
slast
slavnost
sledovat
slepec
sleva
slezina
slib
slina
sliznice
slon
sloupek
slovo
sluch
sluha
slunce
slupka
slza
smaragd
smetana
smilstvo
smlouva
smog
smrad
smrk
smrtka
smutek
smysl
snad
snaha
snob
sobota
socha
sodovka
sokol
sopka
sotva
souboj
soucit
soudce
souhlas
soulad
soumrak
souprava
soused
soutok
souviset
spalovna
spasitel
spis
splav
spodek
spojenec
spolu
sponzor
spornost
spousta
sprcha
spustit
sranda
sraz
srdce
srna
srnec
srovnat
srpen
srst
srub
stanice
starosta
statika
stavba
stehno
stezka
stodola
stolek
stopa
storno
stoupat
strach
stres
strhnout
strom
struna
studna
stupnice
stvol
styk
subjekt
subtropy
suchar
sudost
sukno
sundat
sunout
surikata
surovina
svah
svalstvo
svetr
svatba
svazek
svisle
svitek
svoboda
svodidlo
svorka
svrab
sykavka
sykot
synek
synovec
sypat
sypkost
syrovost
sysel
sytost
tabletka
tabule
tahoun
tajemno
tajfun
tajga
tajit
tajnost
taktika
tamhle
tampon
tancovat
tanec
tanker
tapeta
tavenina
tazatel
technika
tehdy
tekutina
telefon
temnota
tendence
tenista
tenor
teplota
tepna
teprve
terapie
termoska
textil
ticho
tiskopis
titulek
tkadlec
tkanina
tlapka
tleskat
tlukot
tlupa
tmel
toaleta
topinka
topol
torzo
touha
toulec
tradice
traktor
tramp
trasa
traverza
trefit
trest
trezor
trhavina
trhlina
trochu
trojice
troska
trouba
trpce
trpitel
trpkost
trubec
truchlit
truhlice
trus
trvat
tudy
tuhnout
tuhost
tundra
turista
turnaj
tuzemsko
tvaroh
tvorba
tvrdost
tvrz
tygr
tykev
ubohost
uboze
ubrat
ubrousek
ubrus
ubytovna
ucho
uctivost
udivit
uhradit
ujednat
ujistit
ujmout
ukazatel
uklidnit
uklonit
ukotvit
ukrojit
ulice
ulita
ulovit
umyvadlo
unavit
uniforma
uniknout
upadnout
uplatnit
uplynout
upoutat
upravit
uran
urazit
usednout
usilovat
usmrtit
usnadnit
usnout
usoudit
ustlat
ustrnout
utahovat
utkat
utlumit
utonout
utopenec
utrousit
uvalit
uvolnit
uvozovka
uzdravit
uzel
uzenina
uzlina
uznat
vagon
valcha
valoun
vana
vandal
vanilka
varan
varhany
varovat
vcelku
vchod
vdova
vedro
vegetace
vejce
velbloud
veletrh
velitel
velmoc
velryba
venkov
veranda
verze
veselka
veskrze
vesnice
vespodu
vesta
veterina
veverka
vibrace
vichr
videohra
vidina
vidle
vila
vinice
viset
vitalita
vize
vizitka
vjezd
vklad
vkus
vlajka
vlak
vlasec
vlevo
vlhkost
vliv
vlnovka
vloupat
vnucovat
vnuk
voda
vodivost
vodoznak
vodstvo
vojensky
vojna
vojsko
volant
volba
volit
volno
voskovka
vozidlo
vozovna
vpravo
vrabec
vracet
vrah
vrata
vrba
vrcholek
vrhat
vrstva
vrtule
vsadit
vstoupit
vstup
vtip
vybavit
vybrat
vychovat
vydat
vydra
vyfotit
vyhledat
vyhnout
vyhodit
vyhradit
vyhubit
vyjasnit
vyjet
vyjmout
vyklopit
vykonat
vylekat
vymazat
vymezit
vymizet
vymyslet
vynechat
vynikat
vynutit
vypadat
vyplatit
vypravit
vypustit
vyrazit
vyrovnat
vyrvat
vyslovit
vysoko
vystavit
vysunout
vysypat
vytasit
vytesat
vytratit
vyvinout
vyvolat
vyvrhel
vyzdobit
vyznat
vzadu
vzbudit
vzchopit
vzdor
vzduch
vzdychat
vzestup
vzhledem
vzkaz
vzlykat
vznik
vzorek
vzpoura
vztah
vztek
xylofon
zabrat
zabydlet
zachovat
zadarmo
zadusit
zafoukat
zahltit
zahodit
zahrada
zahynout
zajatec
zajet
zajistit
zaklepat
zakoupit
zalepit
zamezit
zamotat
zamyslet
zanechat
zanikat
zaplatit
zapojit
zapsat
zarazit
zastavit
zasunout
zatajit
zatemnit
zatknout
zaujmout
zavalit
zavelet
zavinit
zavolat
zavrtat
zazvonit
zbavit
zbrusu
zbudovat
zbytek
zdaleka
zdarma
zdatnost
zdivo
zdobit
zdroj
zdvih
zdymadlo
zelenina
zeman
zemina
zeptat
zezadu
zezdola
zhatit
zhltnout
zhluboka
zhotovit
zhruba
zima
zimnice
zjemnit
zklamat
zkoumat
zkratka
zkumavka
zlato
zlehka
zloba
zlom
zlost
zlozvyk
zmapovat
zmar
zmatek
zmije
zmizet
zmocnit
zmodrat
zmrzlina
zmutovat
znak
znalost
znamenat
znovu
zobrazit
zotavit
zoubek
zoufale
zplodit
zpomalit
zprava
zprostit
zprudka
zprvu
zrada
zranit
zrcadlo
zrnitost
zrno
zrovna
zrychlit
zrzavost
zticha
ztratit
zubovina
zubr
zvednout
zvenku
zvesela
zvon
zvrat
zvukovod
zvyk`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/english.js
var wordlist2 = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/french.js
var wordlist3 = `abaisser
abandon
abdiquer
abeille
abolir
aborder
aboutir
aboyer
abrasif
abreuver
abriter
abroger
abrupt
absence
absolu
absurde
abusif
abyssal
academie
acajou
acarien
accabler
accepter
acclamer
accolade
accroche
accuser
acerbe
achat
acheter
aciduler
acier
acompte
acquerir
acronyme
acteur
actif
actuel
adepte
adequat
adhesif
adjectif
adjuger
admettre
admirer
adopter
adorer
adoucir
adresse
adroit
adulte
adverbe
aerer
aeronef
affaire
affecter
affiche
affreux
affubler
agacer
agencer
agile
agiter
agrafer
agreable
agrume
aider
aiguille
ailier
aimable
aisance
ajouter
ajuster
alarmer
alchimie
alerte
algebre
algue
aliener
aliment
alleger
alliage
allouer
allumer
alourdir
alpaga
altesse
alveole
amateur
ambigu
ambre
amenager
amertume
amidon
amiral
amorcer
amour
amovible
amphibie
ampleur
amusant
analyse
anaphore
anarchie
anatomie
ancien
aneantir
angle
angoisse
anguleux
animal
annexer
annonce
annuel
anodin
anomalie
anonyme
anormal
antenne
antidote
anxieux
apaiser
aperitif
aplanir
apologie
appareil
appeler
apporter
appuyer
aquarium
aqueduc
arbitre
arbuste
ardeur
ardoise
argent
arlequin
armature
armement
armoire
armure
arpenter
arracher
arriver
arroser
arsenic
arteriel
article
aspect
asphalte
aspirer
assaut
asservir
assiette
associer
assurer
asticot
astre
astuce
atelier
atome
atrium
atroce
attaque
attentif
attirer
attraper
aubaine
auberge
audace
audible
augurer
aurore
automne
autruche
avaler
avancer
avarice
avenir
averse
aveugle
aviateur
avide
avion
aviser
avoine
avouer
avril
axial
axiome
badge
bafouer
bagage
baguette
baignade
balancer
balcon
baleine
balisage
bambin
bancaire
bandage
banlieue
banniere
banquier
barbier
baril
baron
barque
barrage
bassin
bastion
bataille
bateau
batterie
baudrier
bavarder
belette
belier
belote
benefice
berceau
berger
berline
bermuda
besace
besogne
betail
beurre
biberon
bicycle
bidule
bijou
bilan
bilingue
billard
binaire
biologie
biopsie
biotype
biscuit
bison
bistouri
bitume
bizarre
blafard
blague
blanchir
blessant
blinder
blond
bloquer
blouson
bobard
bobine
boire
boiser
bolide
bonbon
bondir
bonheur
bonifier
bonus
bordure
borne
botte
boucle
boueux
bougie
boulon
bouquin
bourse
boussole
boutique
boxeur
branche
brasier
brave
brebis
breche
breuvage
bricoler
brigade
brillant
brioche
brique
brochure
broder
bronzer
brousse
broyeur
brume
brusque
brutal
bruyant
buffle
buisson
bulletin
bureau
burin
bustier
butiner
butoir
buvable
buvette
cabanon
cabine
cachette
cadeau
cadre
cafeine
caillou
caisson
calculer
calepin
calibre
calmer
calomnie
calvaire
camarade
camera
camion
campagne
canal
caneton
canon
cantine
canular
capable
caporal
caprice
capsule
capter
capuche
carabine
carbone
caresser
caribou
carnage
carotte
carreau
carton
cascade
casier
casque
cassure
causer
caution
cavalier
caverne
caviar
cedille
ceinture
celeste
cellule
cendrier
censurer
central
cercle
cerebral
cerise
cerner
cerveau
cesser
chagrin
chaise
chaleur
chambre
chance
chapitre
charbon
chasseur
chaton
chausson
chavirer
chemise
chenille
chequier
chercher
cheval
chien
chiffre
chignon
chimere
chiot
chlorure
chocolat
choisir
chose
chouette
chrome
chute
cigare
cigogne
cimenter
cinema
cintrer
circuler
cirer
cirque
citerne
citoyen
citron
civil
clairon
clameur
claquer
classe
clavier
client
cligner
climat
clivage
cloche
clonage
cloporte
cobalt
cobra
cocasse
cocotier
coder
codifier
coffre
cogner
cohesion
coiffer
coincer
colere
colibri
colline
colmater
colonel
combat
comedie
commande
compact
concert
conduire
confier
congeler
connoter
consonne
contact
convexe
copain
copie
corail
corbeau
cordage
corniche
corpus
correct
cortege
cosmique
costume
coton
coude
coupure
courage
couteau
couvrir
coyote
crabe
crainte
cravate
crayon
creature
crediter
cremeux
creuser
crevette
cribler
crier
cristal
critere
croire
croquer
crotale
crucial
cruel
crypter
cubique
cueillir
cuillere
cuisine
cuivre
culminer
cultiver
cumuler
cupide
curatif
curseur
cyanure
cycle
cylindre
cynique
daigner
damier
danger
danseur
dauphin
debattre
debiter
deborder
debrider
debutant
decaler
decembre
dechirer
decider
declarer
decorer
decrire
decupler
dedale
deductif
deesse
defensif
defiler
defrayer
degager
degivrer
deglutir
degrafer
dejeuner
delice
deloger
demander
demeurer
demolir
denicher
denouer
dentelle
denuder
depart
depenser
dephaser
deplacer
deposer
deranger
derober
desastre
descente
desert
designer
desobeir
dessiner
destrier
detacher
detester
detourer
detresse
devancer
devenir
deviner
devoir
diable
dialogue
diamant
dicter
differer
digerer
digital
digne
diluer
dimanche
diminuer
dioxyde
directif
diriger
discuter
disposer
dissiper
distance
divertir
diviser
docile
docteur
dogme
doigt
domaine
domicile
dompter
donateur
donjon
donner
dopamine
dortoir
dorure
dosage
doseur
dossier
dotation
douanier
double
douceur
douter
doyen
dragon
draper
dresser
dribbler
droiture
duperie
duplexe
durable
durcir
dynastie
eblouir
ecarter
echarpe
echelle
eclairer
eclipse
eclore
ecluse
ecole
economie
ecorce
ecouter
ecraser
ecremer
ecrivain
ecrou
ecume
ecureuil
edifier
eduquer
effacer
effectif
effigie
effort
effrayer
effusion
egaliser
egarer
ejecter
elaborer
elargir
electron
elegant
elephant
eleve
eligible
elitisme
eloge
elucider
eluder
emballer
embellir
embryon
emeraude
emission
emmener
emotion
emouvoir
empereur
employer
emporter
emprise
emulsion
encadrer
enchere
enclave
encoche
endiguer
endosser
endroit
enduire
energie
enfance
enfermer
enfouir
engager
engin
englober
enigme
enjamber
enjeu
enlever
ennemi
ennuyeux
enrichir
enrobage
enseigne
entasser
entendre
entier
entourer
entraver
enumerer
envahir
enviable
envoyer
enzyme
eolien
epaissir
epargne
epatant
epaule
epicerie
epidemie
epier
epilogue
epine
episode
epitaphe
epoque
epreuve
eprouver
epuisant
equerre
equipe
eriger
erosion
erreur
eruption
escalier
espadon
espece
espiegle
espoir
esprit
esquiver
essayer
essence
essieu
essorer
estime
estomac
estrade
etagere
etaler
etanche
etatique
eteindre
etendoir
eternel
ethanol
ethique
ethnie
etirer
etoffer
etoile
etonnant
etourdir
etrange
etroit
etude
euphorie
evaluer
evasion
eventail
evidence
eviter
evolutif
evoquer
exact
exagerer
exaucer
exceller
excitant
exclusif
excuse
executer
exemple
exercer
exhaler
exhorter
exigence
exiler
exister
exotique
expedier
explorer
exposer
exprimer
exquis
extensif
extraire
exulter
fable
fabuleux
facette
facile
facture
faiblir
falaise
fameux
famille
farceur
farfelu
farine
farouche
fasciner
fatal
fatigue
faucon
fautif
faveur
favori
febrile
feconder
federer
felin
femme
femur
fendoir
feodal
fermer
feroce
ferveur
festival
feuille
feutre
fevrier
fiasco
ficeler
fictif
fidele
figure
filature
filetage
filiere
filleul
filmer
filou
filtrer
financer
finir
fiole
firme
fissure
fixer
flairer
flamme
flasque
flatteur
fleau
fleche
fleur
flexion
flocon
flore
fluctuer
fluide
fluvial
folie
fonderie
fongible
fontaine
forcer
forgeron
formuler
fortune
fossile
foudre
fougere
fouiller
foulure
fourmi
fragile
fraise
franchir
frapper
frayeur
fregate
freiner
frelon
fremir
frenesie
frere
friable
friction
frisson
frivole
froid
fromage
frontal
frotter
fruit
fugitif
fuite
fureur
furieux
furtif
fusion
futur
gagner
galaxie
galerie
gambader
garantir
gardien
garnir
garrigue
gazelle
gazon
geant
gelatine
gelule
gendarme
general
genie
genou
gentil
geologie
geometre
geranium
germe
gestuel
geyser
gibier
gicler
girafe
givre
glace
glaive
glisser
globe
gloire
glorieux
golfeur
gomme
gonfler
gorge
gorille
goudron
gouffre
goulot
goupille
gourmand
goutte
graduel
graffiti
graine
grand
grappin
gratuit
gravir
grenat
griffure
griller
grimper
grogner
gronder
grotte
groupe
gruger
grutier
gruyere
guepard
guerrier
guide
guimauve
guitare
gustatif
gymnaste
gyrostat
habitude
hachoir
halte
hameau
hangar
hanneton
haricot
harmonie
harpon
hasard
helium
hematome
herbe
herisson
hermine
heron
hesiter
heureux
hiberner
hibou
hilarant
histoire
hiver
homard
hommage
homogene
honneur
honorer
honteux
horde
horizon
horloge
hormone
horrible
houleux
housse
hublot
huileux
humain
humble
humide
humour
hurler
hydromel
hygiene
hymne
hypnose
idylle
ignorer
iguane
illicite
illusion
image
imbiber
imiter
immense
immobile
immuable
impact
imperial
implorer
imposer
imprimer
imputer
incarner
incendie
incident
incliner
incolore
indexer
indice
inductif
inedit
ineptie
inexact
infini
infliger
informer
infusion
ingerer
inhaler
inhiber
injecter
injure
innocent
inoculer
inonder
inscrire
insecte
insigne
insolite
inspirer
instinct
insulter
intact
intense
intime
intrigue
intuitif
inutile
invasion
inventer
inviter
invoquer
ironique
irradier
irreel
irriter
isoler
ivoire
ivresse
jaguar
jaillir
jambe
janvier
jardin
jauger
jaune
javelot
jetable
jeton
jeudi
jeunesse
joindre
joncher
jongler
joueur
jouissif
journal
jovial
joyau
joyeux
jubiler
jugement
junior
jupon
juriste
justice
juteux
juvenile
kayak
kimono
kiosque
label
labial
labourer
lacerer
lactose
lagune
laine
laisser
laitier
lambeau
lamelle
lampe
lanceur
langage
lanterne
lapin
largeur
larme
laurier
lavabo
lavoir
lecture
legal
leger
legume
lessive
lettre
levier
lexique
lezard
liasse
liberer
libre
licence
licorne
liege
lievre
ligature
ligoter
ligue
limer
limite
limonade
limpide
lineaire
lingot
lionceau
liquide
lisiere
lister
lithium
litige
littoral
livreur
logique
lointain
loisir
lombric
loterie
louer
lourd
loutre
louve
loyal
lubie
lucide
lucratif
lueur
lugubre
luisant
lumiere
lunaire
lundi
luron
lutter
luxueux
machine
magasin
magenta
magique
maigre
maillon
maintien
mairie
maison
majorer
malaxer
malefice
malheur
malice
mallette
mammouth
mandater
maniable
manquant
manteau
manuel
marathon
marbre
marchand
mardi
maritime
marqueur
marron
marteler
mascotte
massif
materiel
matiere
matraque
maudire
maussade
mauve
maximal
mechant
meconnu
medaille
medecin
mediter
meduse
meilleur
melange
melodie
membre
memoire
menacer
mener
menhir
mensonge
mentor
mercredi
merite
merle
messager
mesure
metal
meteore
methode
metier
meuble
miauler
microbe
miette
mignon
migrer
milieu
million
mimique
mince
mineral
minimal
minorer
minute
miracle
miroiter
missile
mixte
mobile
moderne
moelleux
mondial
moniteur
monnaie
monotone
monstre
montagne
monument
moqueur
morceau
morsure
mortier
moteur
motif
mouche
moufle
moulin
mousson
mouton
mouvant
multiple
munition
muraille
murene
murmure
muscle
museum
musicien
mutation
muter
mutuel
myriade
myrtille
mystere
mythique
nageur
nappe
narquois
narrer
natation
nation
nature
naufrage
nautique
navire
nebuleux
nectar
nefaste
negation
negliger
negocier
neige
nerveux
nettoyer
neurone
neutron
neveu
niche
nickel
nitrate
niveau
noble
nocif
nocturne
noirceur
noisette
nomade
nombreux
nommer
normatif
notable
notifier
notoire
nourrir
nouveau
novateur
novembre
novice
nuage
nuancer
nuire
nuisible
numero
nuptial
nuque
nutritif
obeir
objectif
obliger
obscur
observer
obstacle
obtenir
obturer
occasion
occuper
ocean
octobre
octroyer
octupler
oculaire
odeur
odorant
offenser
officier
offrir
ogive
oiseau
oisillon
olfactif
olivier
ombrage
omettre
onctueux
onduler
onereux
onirique
opale
opaque
operer
opinion
opportun
opprimer
opter
optique
orageux
orange
orbite
ordonner
oreille
organe
orgueil
orifice
ornement
orque
ortie
osciller
osmose
ossature
otarie
ouragan
ourson
outil
outrager
ouvrage
ovation
oxyde
oxygene
ozone
paisible
palace
palmares
palourde
palper
panache
panda
pangolin
paniquer
panneau
panorama
pantalon
papaye
papier
papoter
papyrus
paradoxe
parcelle
paresse
parfumer
parler
parole
parrain
parsemer
partager
parure
parvenir
passion
pasteque
paternel
patience
patron
pavillon
pavoiser
payer
paysage
peigne
peintre
pelage
pelican
pelle
pelouse
peluche
pendule
penetrer
penible
pensif
penurie
pepite
peplum
perdrix
perforer
periode
permuter
perplexe
persil
perte
peser
petale
petit
petrir
peuple
pharaon
phobie
phoque
photon
phrase
physique
piano
pictural
piece
pierre
pieuvre
pilote
pinceau
pipette
piquer
pirogue
piscine
piston
pivoter
pixel
pizza
placard
plafond
plaisir
planer
plaque
plastron
plateau
pleurer
plexus
pliage
plomb
plonger
pluie
plumage
pochette
poesie
poete
pointe
poirier
poisson
poivre
polaire
policier
pollen
polygone
pommade
pompier
ponctuel
ponderer
poney
portique
position
posseder
posture
potager
poteau
potion
pouce
poulain
poumon
pourpre
poussin
pouvoir
prairie
pratique
precieux
predire
prefixe
prelude
prenom
presence
pretexte
prevoir
primitif
prince
prison
priver
probleme
proceder
prodige
profond
progres
proie
projeter
prologue
promener
propre
prospere
proteger
prouesse
proverbe
prudence
pruneau
psychose
public
puceron
puiser
pulpe
pulsar
punaise
punitif
pupitre
purifier
puzzle
pyramide
quasar
querelle
question
quietude
quitter
quotient
racine
raconter
radieux
ragondin
raideur
raisin
ralentir
rallonge
ramasser
rapide
rasage
ratisser
ravager
ravin
rayonner
reactif
reagir
realiser
reanimer
recevoir
reciter
reclamer
recolter
recruter
reculer
recycler
rediger
redouter
refaire
reflexe
reformer
refrain
refuge
regalien
region
reglage
regulier
reiterer
rejeter
rejouer
relatif
relever
relief
remarque
remede
remise
remonter
remplir
remuer
renard
renfort
renifler
renoncer
rentrer
renvoi
replier
reporter
reprise
reptile
requin
reserve
resineux
resoudre
respect
rester
resultat
retablir
retenir
reticule
retomber
retracer
reunion
reussir
revanche
revivre
revolte
revulsif
richesse
rideau
rieur
rigide
rigoler
rincer
riposter
risible
risque
rituel
rival
riviere
rocheux
romance
rompre
ronce
rondin
roseau
rosier
rotatif
rotor
rotule
rouge
rouille
rouleau
routine
royaume
ruban
rubis
ruche
ruelle
rugueux
ruiner
ruisseau
ruser
rustique
rythme
sabler
saboter
sabre
sacoche
safari
sagesse
saisir
salade
salive
salon
saluer
samedi
sanction
sanglier
sarcasme
sardine
saturer
saugrenu
saumon
sauter
sauvage
savant
savonner
scalpel
scandale
scelerat
scenario
sceptre
schema
science
scinder
score
scrutin
sculpter
seance
secable
secher
secouer
secreter
sedatif
seduire
seigneur
sejour
selectif
semaine
sembler
semence
seminal
senateur
sensible
sentence
separer
sequence
serein
sergent
serieux
serrure
serum
service
sesame
sevir
sevrage
sextuple
sideral
siecle
sieger
siffler
sigle
signal
silence
silicium
simple
sincere
sinistre
siphon
sirop
sismique
situer
skier
social
socle
sodium
soigneux
soldat
soleil
solitude
soluble
sombre
sommeil
somnoler
sonde
songeur
sonnette
sonore
sorcier
sortir
sosie
sottise
soucieux
soudure
souffle
soulever
soupape
source
soutirer
souvenir
spacieux
spatial
special
sphere
spiral
stable
station
sternum
stimulus
stipuler
strict
studieux
stupeur
styliste
sublime
substrat
subtil
subvenir
succes
sucre
suffixe
suggerer
suiveur
sulfate
superbe
supplier
surface
suricate
surmener
surprise
sursaut
survie
suspect
syllabe
symbole
symetrie
synapse
syntaxe
systeme
tabac
tablier
tactile
tailler
talent
talisman
talonner
tambour
tamiser
tangible
tapis
taquiner
tarder
tarif
tartine
tasse
tatami
tatouage
taupe
taureau
taxer
temoin
temporel
tenaille
tendre
teneur
tenir
tension
terminer
terne
terrible
tetine
texte
theme
theorie
therapie
thorax
tibia
tiede
timide
tirelire
tiroir
tissu
titane
titre
tituber
toboggan
tolerant
tomate
tonique
tonneau
toponyme
torche
tordre
tornade
torpille
torrent
torse
tortue
totem
toucher
tournage
tousser
toxine
traction
trafic
tragique
trahir
train
trancher
travail
trefle
tremper
tresor
treuil
triage
tribunal
tricoter
trilogie
triomphe
tripler
triturer
trivial
trombone
tronc
tropical
troupeau
tuile
tulipe
tumulte
tunnel
turbine
tuteur
tutoyer
tuyau
tympan
typhon
typique
tyran
ubuesque
ultime
ultrason
unanime
unifier
union
unique
unitaire
univers
uranium
urbain
urticant
usage
usine
usuel
usure
utile
utopie
vacarme
vaccin
vagabond
vague
vaillant
vaincre
vaisseau
valable
valise
vallon
valve
vampire
vanille
vapeur
varier
vaseux
vassal
vaste
vecteur
vedette
vegetal
vehicule
veinard
veloce
vendredi
venerer
venger
venimeux
ventouse
verdure
verin
vernir
verrou
verser
vertu
veston
veteran
vetuste
vexant
vexer
viaduc
viande
victoire
vidange
video
vignette
vigueur
vilain
village
vinaigre
violon
vipere
virement
virtuose
virus
visage
viseur
vision
visqueux
visuel
vital
vitesse
viticole
vitrine
vivace
vivipare
vocation
voguer
voile
voisin
voiture
volaille
volcan
voltiger
volume
vorace
vortex
voter
vouloir
voyage
voyelle
wagon
xenon
yacht
zebre
zenith
zeste
zoologie`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/italian.js
var wordlist4 = `abaco
abbaglio
abbinato
abete
abisso
abolire
abrasivo
abrogato
accadere
accenno
accusato
acetone
achille
acido
acqua
acre
acrilico
acrobata
acuto
adagio
addebito
addome
adeguato
aderire
adipe
adottare
adulare
affabile
affetto
affisso
affranto
aforisma
afoso
africano
agave
agente
agevole
aggancio
agire
agitare
agonismo
agricolo
agrumeto
aguzzo
alabarda
alato
albatro
alberato
albo
albume
alce
alcolico
alettone
alfa
algebra
aliante
alibi
alimento
allagato
allegro
allievo
allodola
allusivo
almeno
alogeno
alpaca
alpestre
altalena
alterno
alticcio
altrove
alunno
alveolo
alzare
amalgama
amanita
amarena
ambito
ambrato
ameba
america
ametista
amico
ammasso
ammenda
ammirare
ammonito
amore
ampio
ampliare
amuleto
anacardo
anagrafe
analista
anarchia
anatra
anca
ancella
ancora
andare
andrea
anello
angelo
angolare
angusto
anima
annegare
annidato
anno
annuncio
anonimo
anticipo
anzi
apatico
apertura
apode
apparire
appetito
appoggio
approdo
appunto
aprile
arabica
arachide
aragosta
araldica
arancio
aratura
arazzo
arbitro
archivio
ardito
arenile
argento
argine
arguto
aria
armonia
arnese
arredato
arringa
arrosto
arsenico
arso
artefice
arzillo
asciutto
ascolto
asepsi
asettico
asfalto
asino
asola
aspirato
aspro
assaggio
asse
assoluto
assurdo
asta
astenuto
astice
astratto
atavico
ateismo
atomico
atono
attesa
attivare
attorno
attrito
attuale
ausilio
austria
autista
autonomo
autunno
avanzato
avere
avvenire
avviso
avvolgere
azione
azoto
azzimo
azzurro
babele
baccano
bacino
baco
badessa
badilata
bagnato
baita
balcone
baldo
balena
ballata
balzano
bambino
bandire
baraonda
barbaro
barca
baritono
barlume
barocco
basilico
basso
batosta
battuto
baule
bava
bavosa
becco
beffa
belgio
belva
benda
benevole
benigno
benzina
bere
berlina
beta
bibita
bici
bidone
bifido
biga
bilancia
bimbo
binocolo
biologo
bipede
bipolare
birbante
birra
biscotto
bisesto
bisnonno
bisonte
bisturi
bizzarro
blando
blatta
bollito
bonifico
bordo
bosco
botanico
bottino
bozzolo
braccio
bradipo
brama
branca
bravura
bretella
brevetto
brezza
briglia
brillante
brindare
broccolo
brodo
bronzina
brullo
bruno
bubbone
buca
budino
buffone
buio
bulbo
buono
burlone
burrasca
bussola
busta
cadetto
caduco
calamaro
calcolo
calesse
calibro
calmo
caloria
cambusa
camerata
camicia
cammino
camola
campale
canapa
candela
cane
canino
canotto
cantina
capace
capello
capitolo
capogiro
cappero
capra
capsula
carapace
carcassa
cardo
carisma
carovana
carretto
cartolina
casaccio
cascata
caserma
caso
cassone
castello
casuale
catasta
catena
catrame
cauto
cavillo
cedibile
cedrata
cefalo
celebre
cellulare
cena
cenone
centesimo
ceramica
cercare
certo
cerume
cervello
cesoia
cespo
ceto
chela
chiaro
chicca
chiedere
chimera
china
chirurgo
chitarra
ciao
ciclismo
cifrare
cigno
cilindro
ciottolo
circa
cirrosi
citrico
cittadino
ciuffo
civetta
civile
classico
clinica
cloro
cocco
codardo
codice
coerente
cognome
collare
colmato
colore
colposo
coltivato
colza
coma
cometa
commando
comodo
computer
comune
conciso
condurre
conferma
congelare
coniuge
connesso
conoscere
consumo
continuo
convegno
coperto
copione
coppia
copricapo
corazza
cordata
coricato
cornice
corolla
corpo
corredo
corsia
cortese
cosmico
costante
cottura
covato
cratere
cravatta
creato
credere
cremoso
crescita
creta
criceto
crinale
crisi
critico
croce
cronaca
crostata
cruciale
crusca
cucire
cuculo
cugino
cullato
cupola
curatore
cursore
curvo
cuscino
custode
dado
daino
dalmata
damerino
daniela
dannoso
danzare
datato
davanti
davvero
debutto
decennio
deciso
declino
decollo
decreto
dedicato
definito
deforme
degno
delegare
delfino
delirio
delta
demenza
denotato
dentro
deposito
derapata
derivare
deroga
descritto
deserto
desiderio
desumere
detersivo
devoto
diametro
dicembre
diedro
difeso
diffuso
digerire
digitale
diluvio
dinamico
dinnanzi
dipinto
diploma
dipolo
diradare
dire
dirotto
dirupo
disagio
discreto
disfare
disgelo
disposto
distanza
disumano
dito
divano
divelto
dividere
divorato
doblone
docente
doganale
dogma
dolce
domato
domenica
dominare
dondolo
dono
dormire
dote
dottore
dovuto
dozzina
drago
druido
dubbio
dubitare
ducale
duna
duomo
duplice
duraturo
ebano
eccesso
ecco
eclissi
economia
edera
edicola
edile
editoria
educare
egemonia
egli
egoismo
egregio
elaborato
elargire
elegante
elencato
eletto
elevare
elfico
elica
elmo
elsa
eluso
emanato
emblema
emesso
emiro
emotivo
emozione
empirico
emulo
endemico
enduro
energia
enfasi
enoteca
entrare
enzima
epatite
epilogo
episodio
epocale
eppure
equatore
erario
erba
erboso
erede
eremita
erigere
ermetico
eroe
erosivo
errante
esagono
esame
esanime
esaudire
esca
esempio
esercito
esibito
esigente
esistere
esito
esofago
esortato
esoso
espanso
espresso
essenza
esso
esteso
estimare
estonia
estroso
esultare
etilico
etnico
etrusco
etto
euclideo
europa
evaso
evidenza
evitato
evoluto
evviva
fabbrica
faccenda
fachiro
falco
famiglia
fanale
fanfara
fango
fantasma
fare
farfalla
farinoso
farmaco
fascia
fastoso
fasullo
faticare
fato
favoloso
febbre
fecola
fede
fegato
felpa
feltro
femmina
fendere
fenomeno
fermento
ferro
fertile
fessura
festivo
fetta
feudo
fiaba
fiducia
fifa
figurato
filo
finanza
finestra
finire
fiore
fiscale
fisico
fiume
flacone
flamenco
flebo
flemma
florido
fluente
fluoro
fobico
focaccia
focoso
foderato
foglio
folata
folclore
folgore
fondente
fonetico
fonia
fontana
forbito
forchetta
foresta
formica
fornaio
foro
fortezza
forzare
fosfato
fosso
fracasso
frana
frassino
fratello
freccetta
frenata
fresco
frigo
frollino
fronde
frugale
frutta
fucilata
fucsia
fuggente
fulmine
fulvo
fumante
fumetto
fumoso
fune
funzione
fuoco
furbo
furgone
furore
fuso
futile
gabbiano
gaffe
galateo
gallina
galoppo
gambero
gamma
garanzia
garbo
garofano
garzone
gasdotto
gasolio
gastrico
gatto
gaudio
gazebo
gazzella
geco
gelatina
gelso
gemello
gemmato
gene
genitore
gennaio
genotipo
gergo
ghepardo
ghiaccio
ghisa
giallo
gilda
ginepro
giocare
gioiello
giorno
giove
girato
girone
gittata
giudizio
giurato
giusto
globulo
glutine
gnomo
gobba
golf
gomito
gommone
gonfio
gonna
governo
gracile
grado
grafico
grammo
grande
grattare
gravoso
grazia
greca
gregge
grifone
grigio
grinza
grotta
gruppo
guadagno
guaio
guanto
guardare
gufo
guidare
ibernato
icona
identico
idillio
idolo
idra
idrico
idrogeno
igiene
ignaro
ignorato
ilare
illeso
illogico
illudere
imballo
imbevuto
imbocco
imbuto
immane
immerso
immolato
impacco
impeto
impiego
importo
impronta
inalare
inarcare
inattivo
incanto
incendio
inchino
incisivo
incluso
incontro
incrocio
incubo
indagine
india
indole
inedito
infatti
infilare
inflitto
ingaggio
ingegno
inglese
ingordo
ingrosso
innesco
inodore
inoltrare
inondato
insano
insetto
insieme
insonnia
insulina
intasato
intero
intonaco
intuito
inumidire
invalido
invece
invito
iperbole
ipnotico
ipotesi
ippica
iride
irlanda
ironico
irrigato
irrorare
isolato
isotopo
isterico
istituto
istrice
italia
iterare
labbro
labirinto
lacca
lacerato
lacrima
lacuna
laddove
lago
lampo
lancetta
lanterna
lardoso
larga
laringe
lastra
latenza
latino
lattuga
lavagna
lavoro
legale
leggero
lembo
lentezza
lenza
leone
lepre
lesivo
lessato
lesto
letterale
leva
levigato
libero
lido
lievito
lilla
limatura
limitare
limpido
lineare
lingua
liquido
lira
lirica
lisca
lite
litigio
livrea
locanda
lode
logica
lombare
londra
longevo
loquace
lorenzo
loto
lotteria
luce
lucidato
lumaca
luminoso
lungo
lupo
luppolo
lusinga
lusso
lutto
macabro
macchina
macero
macinato
madama
magico
maglia
magnete
magro
maiolica
malafede
malgrado
malinteso
malsano
malto
malumore
mana
mancia
mandorla
mangiare
manifesto
mannaro
manovra
mansarda
mantide
manubrio
mappa
maratona
marcire
maretta
marmo
marsupio
maschera
massaia
mastino
materasso
matricola
mattone
maturo
mazurca
meandro
meccanico
mecenate
medesimo
meditare
mega
melassa
melis
melodia
meninge
meno
mensola
mercurio
merenda
merlo
meschino
mese
messere
mestolo
metallo
metodo
mettere
miagolare
mica
micelio
michele
microbo
midollo
miele
migliore
milano
milite
mimosa
minerale
mini
minore
mirino
mirtillo
miscela
missiva
misto
misurare
mitezza
mitigare
mitra
mittente
mnemonico
modello
modifica
modulo
mogano
mogio
mole
molosso
monastero
monco
mondina
monetario
monile
monotono
monsone
montato
monviso
mora
mordere
morsicato
mostro
motivato
motosega
motto
movenza
movimento
mozzo
mucca
mucosa
muffa
mughetto
mugnaio
mulatto
mulinello
multiplo
mummia
munto
muovere
murale
musa
muscolo
musica
mutevole
muto
nababbo
nafta
nanometro
narciso
narice
narrato
nascere
nastrare
naturale
nautica
naviglio
nebulosa
necrosi
negativo
negozio
nemmeno
neofita
neretto
nervo
nessuno
nettuno
neutrale
neve
nevrotico
nicchia
ninfa
nitido
nobile
nocivo
nodo
nome
nomina
nordico
normale
norvegese
nostrano
notare
notizia
notturno
novella
nucleo
nulla
numero
nuovo
nutrire
nuvola
nuziale
oasi
obbedire
obbligo
obelisco
oblio
obolo
obsoleto
occasione
occhio
occidente
occorrere
occultare
ocra
oculato
odierno
odorare
offerta
offrire
offuscato
oggetto
oggi
ognuno
olandese
olfatto
oliato
oliva
ologramma
oltre
omaggio
ombelico
ombra
omega
omissione
ondoso
onere
onice
onnivoro
onorevole
onta
operato
opinione
opposto
oracolo
orafo
ordine
orecchino
orefice
orfano
organico
origine
orizzonte
orma
ormeggio
ornativo
orologio
orrendo
orribile
ortensia
ortica
orzata
orzo
osare
oscurare
osmosi
ospedale
ospite
ossa
ossidare
ostacolo
oste
otite
otre
ottagono
ottimo
ottobre
ovale
ovest
ovino
oviparo
ovocito
ovunque
ovviare
ozio
pacchetto
pace
pacifico
padella
padrone
paese
paga
pagina
palazzina
palesare
pallido
palo
palude
pandoro
pannello
paolo
paonazzo
paprica
parabola
parcella
parere
pargolo
pari
parlato
parola
partire
parvenza
parziale
passivo
pasticca
patacca
patologia
pattume
pavone
peccato
pedalare
pedonale
peggio
peloso
penare
pendice
penisola
pennuto
penombra
pensare
pentola
pepe
pepita
perbene
percorso
perdonato
perforare
pergamena
periodo
permesso
perno
perplesso
persuaso
pertugio
pervaso
pesatore
pesista
peso
pestifero
petalo
pettine
petulante
pezzo
piacere
pianta
piattino
piccino
picozza
piega
pietra
piffero
pigiama
pigolio
pigro
pila
pilifero
pillola
pilota
pimpante
pineta
pinna
pinolo
pioggia
piombo
piramide
piretico
pirite
pirolisi
pitone
pizzico
placebo
planare
plasma
platano
plenario
pochezza
poderoso
podismo
poesia
poggiare
polenta
poligono
pollice
polmonite
polpetta
polso
poltrona
polvere
pomice
pomodoro
ponte
popoloso
porfido
poroso
porpora
porre
portata
posa
positivo
possesso
postulato
potassio
potere
pranzo
prassi
pratica
precluso
predica
prefisso
pregiato
prelievo
premere
prenotare
preparato
presenza
pretesto
prevalso
prima
principe
privato
problema
procura
produrre
profumo
progetto
prolunga
promessa
pronome
proposta
proroga
proteso
prova
prudente
prugna
prurito
psiche
pubblico
pudica
pugilato
pugno
pulce
pulito
pulsante
puntare
pupazzo
pupilla
puro
quadro
qualcosa
quasi
querela
quota
raccolto
raddoppio
radicale
radunato
raffica
ragazzo
ragione
ragno
ramarro
ramingo
ramo
randagio
rantolare
rapato
rapina
rappreso
rasatura
raschiato
rasente
rassegna
rastrello
rata
ravveduto
reale
recepire
recinto
recluta
recondito
recupero
reddito
redimere
regalato
registro
regola
regresso
relazione
remare
remoto
renna
replica
reprimere
reputare
resa
residente
responso
restauro
rete
retina
retorica
rettifica
revocato
riassunto
ribadire
ribelle
ribrezzo
ricarica
ricco
ricevere
riciclato
ricordo
ricreduto
ridicolo
ridurre
rifasare
riflesso
riforma
rifugio
rigare
rigettato
righello
rilassato
rilevato
rimanere
rimbalzo
rimedio
rimorchio
rinascita
rincaro
rinforzo
rinnovo
rinomato
rinsavito
rintocco
rinuncia
rinvenire
riparato
ripetuto
ripieno
riportare
ripresa
ripulire
risata
rischio
riserva
risibile
riso
rispetto
ristoro
risultato
risvolto
ritardo
ritegno
ritmico
ritrovo
riunione
riva
riverso
rivincita
rivolto
rizoma
roba
robotico
robusto
roccia
roco
rodaggio
rodere
roditore
rogito
rollio
romantico
rompere
ronzio
rosolare
rospo
rotante
rotondo
rotula
rovescio
rubizzo
rubrica
ruga
rullino
rumine
rumoroso
ruolo
rupe
russare
rustico
sabato
sabbiare
sabotato
sagoma
salasso
saldatura
salgemma
salivare
salmone
salone
saltare
saluto
salvo
sapere
sapido
saporito
saraceno
sarcasmo
sarto
sassoso
satellite
satira
satollo
saturno
savana
savio
saziato
sbadiglio
sbalzo
sbancato
sbarra
sbattere
sbavare
sbendare
sbirciare
sbloccato
sbocciato
sbrinare
sbruffone
sbuffare
scabroso
scadenza
scala
scambiare
scandalo
scapola
scarso
scatenare
scavato
scelto
scenico
scettro
scheda
schiena
sciarpa
scienza
scindere
scippo
sciroppo
scivolo
sclerare
scodella
scolpito
scomparto
sconforto
scoprire
scorta
scossone
scozzese
scriba
scrollare
scrutinio
scuderia
scultore
scuola
scuro
scusare
sdebitare
sdoganare
seccatura
secondo
sedano
seggiola
segnalato
segregato
seguito
selciato
selettivo
sella
selvaggio
semaforo
sembrare
seme
seminato
sempre
senso
sentire
sepolto
sequenza
serata
serbato
sereno
serio
serpente
serraglio
servire
sestina
setola
settimana
sfacelo
sfaldare
sfamato
sfarzoso
sfaticato
sfera
sfida
sfilato
sfinge
sfocato
sfoderare
sfogo
sfoltire
sforzato
sfratto
sfruttato
sfuggito
sfumare
sfuso
sgabello
sgarbato
sgonfiare
sgorbio
sgrassato
sguardo
sibilo
siccome
sierra
sigla
signore
silenzio
sillaba
simbolo
simpatico
simulato
sinfonia
singolo
sinistro
sino
sintesi
sinusoide
sipario
sisma
sistole
situato
slitta
slogatura
sloveno
smarrito
smemorato
smentito
smeraldo
smilzo
smontare
smottato
smussato
snellire
snervato
snodo
sobbalzo
sobrio
soccorso
sociale
sodale
soffitto
sogno
soldato
solenne
solido
sollazzo
solo
solubile
solvente
somatico
somma
sonda
sonetto
sonnifero
sopire
soppeso
sopra
sorgere
sorpasso
sorriso
sorso
sorteggio
sorvolato
sospiro
sosta
sottile
spada
spalla
spargere
spatola
spavento
spazzola
specie
spedire
spegnere
spelatura
speranza
spessore
spettrale
spezzato
spia
spigoloso
spillato
spinoso
spirale
splendido
sportivo
sposo
spranga
sprecare
spronato
spruzzo
spuntino
squillo
sradicare
srotolato
stabile
stacco
staffa
stagnare
stampato
stantio
starnuto
stasera
statuto
stelo
steppa
sterzo
stiletto
stima
stirpe
stivale
stizzoso
stonato
storico
strappo
stregato
stridulo
strozzare
strutto
stuccare
stufo
stupendo
subentro
succoso
sudore
suggerito
sugo
sultano
suonare
superbo
supporto
surgelato
surrogato
sussurro
sutura
svagare
svedese
sveglio
svelare
svenuto
svezia
sviluppo
svista
svizzera
svolta
svuotare
tabacco
tabulato
tacciare
taciturno
tale
talismano
tampone
tannino
tara
tardivo
targato
tariffa
tarpare
tartaruga
tasto
tattico
taverna
tavolata
tazza
teca
tecnico
telefono
temerario
tempo
temuto
tendone
tenero
tensione
tentacolo
teorema
terme
terrazzo
terzetto
tesi
tesserato
testato
tetro
tettoia
tifare
tigella
timbro
tinto
tipico
tipografo
tiraggio
tiro
titanio
titolo
titubante
tizio
tizzone
toccare
tollerare
tolto
tombola
tomo
tonfo
tonsilla
topazio
topologia
toppa
torba
tornare
torrone
tortora
toscano
tossire
tostatura
totano
trabocco
trachea
trafila
tragedia
tralcio
tramonto
transito
trapano
trarre
trasloco
trattato
trave
treccia
tremolio
trespolo
tributo
tricheco
trifoglio
trillo
trincea
trio
tristezza
triturato
trivella
tromba
trono
troppo
trottola
trovare
truccato
tubatura
tuffato
tulipano
tumulto
tunisia
turbare
turchino
tuta
tutela
ubicato
uccello
uccisore
udire
uditivo
uffa
ufficio
uguale
ulisse
ultimato
umano
umile
umorismo
uncinetto
ungere
ungherese
unicorno
unificato
unisono
unitario
unte
uovo
upupa
uragano
urgenza
urlo
usanza
usato
uscito
usignolo
usuraio
utensile
utilizzo
utopia
vacante
vaccinato
vagabondo
vagliato
valanga
valgo
valico
valletta
valoroso
valutare
valvola
vampata
vangare
vanitoso
vano
vantaggio
vanvera
vapore
varano
varcato
variante
vasca
vedetta
vedova
veduto
vegetale
veicolo
velcro
velina
velluto
veloce
venato
vendemmia
vento
verace
verbale
vergogna
verifica
vero
verruca
verticale
vescica
vessillo
vestale
veterano
vetrina
vetusto
viandante
vibrante
vicenda
vichingo
vicinanza
vidimare
vigilia
vigneto
vigore
vile
villano
vimini
vincitore
viola
vipera
virgola
virologo
virulento
viscoso
visione
vispo
vissuto
visura
vita
vitello
vittima
vivanda
vivido
viziare
voce
voga
volatile
volere
volpe
voragine
vulcano
zampogna
zanna
zappato
zattera
zavorra
zefiro
zelante
zelo
zenzero
zerbino
zibetto
zinco
zircone
zitto
zolla
zotico
zucchero
zufolo
zulu
zuppa`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/japanese.js
var wordlist5 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/korean.js
var wordlist6 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/portuguese.js
var wordlist7 = `abacate
abaixo
abalar
abater
abduzir
abelha
aberto
abismo
abotoar
abranger
abreviar
abrigar
abrupto
absinto
absoluto
absurdo
abutre
acabado
acalmar
acampar
acanhar
acaso
aceitar
acelerar
acenar
acervo
acessar
acetona
achatar
acidez
acima
acionado
acirrar
aclamar
aclive
acolhida
acomodar
acoplar
acordar
acumular
acusador
adaptar
adega
adentro
adepto
adequar
aderente
adesivo
adeus
adiante
aditivo
adjetivo
adjunto
admirar
adorar
adquirir
adubo
adverso
advogado
aeronave
afastar
aferir
afetivo
afinador
afivelar
aflito
afluente
afrontar
agachar
agarrar
agasalho
agenciar
agilizar
agiota
agitado
agora
agradar
agreste
agrupar
aguardar
agulha
ajoelhar
ajudar
ajustar
alameda
alarme
alastrar
alavanca
albergue
albino
alcatra
aldeia
alecrim
alegria
alertar
alface
alfinete
algum
alheio
aliar
alicate
alienar
alinhar
aliviar
almofada
alocar
alpiste
alterar
altitude
alucinar
alugar
aluno
alusivo
alvo
amaciar
amador
amarelo
amassar
ambas
ambiente
ameixa
amenizar
amido
amistoso
amizade
amolador
amontoar
amoroso
amostra
amparar
ampliar
ampola
anagrama
analisar
anarquia
anatomia
andaime
anel
anexo
angular
animar
anjo
anomalia
anotado
ansioso
anterior
anuidade
anunciar
anzol
apagador
apalpar
apanhado
apego
apelido
apertada
apesar
apetite
apito
aplauso
aplicada
apoio
apontar
aposta
aprendiz
aprovar
aquecer
arame
aranha
arara
arcada
ardente
areia
arejar
arenito
aresta
argiloso
argola
arma
arquivo
arraial
arrebate
arriscar
arroba
arrumar
arsenal
arterial
artigo
arvoredo
asfaltar
asilado
aspirar
assador
assinar
assoalho
assunto
astral
atacado
atadura
atalho
atarefar
atear
atender
aterro
ateu
atingir
atirador
ativo
atoleiro
atracar
atrevido
atriz
atual
atum
auditor
aumentar
aura
aurora
autismo
autoria
autuar
avaliar
avante
avaria
avental
avesso
aviador
avisar
avulso
axila
azarar
azedo
azeite
azulejo
babar
babosa
bacalhau
bacharel
bacia
bagagem
baiano
bailar
baioneta
bairro
baixista
bajular
baleia
baliza
balsa
banal
bandeira
banho
banir
banquete
barato
barbado
baronesa
barraca
barulho
baseado
bastante
batata
batedor
batida
batom
batucar
baunilha
beber
beijo
beirada
beisebol
beldade
beleza
belga
beliscar
bendito
bengala
benzer
berimbau
berlinda
berro
besouro
bexiga
bezerro
bico
bicudo
bienal
bifocal
bifurcar
bigorna
bilhete
bimestre
bimotor
biologia
biombo
biosfera
bipolar
birrento
biscoito
bisneto
bispo
bissexto
bitola
bizarro
blindado
bloco
bloquear
boato
bobagem
bocado
bocejo
bochecha
boicotar
bolada
boletim
bolha
bolo
bombeiro
bonde
boneco
bonita
borbulha
borda
boreal
borracha
bovino
boxeador
branco
brasa
braveza
breu
briga
brilho
brincar
broa
brochura
bronzear
broto
bruxo
bucha
budismo
bufar
bule
buraco
busca
busto
buzina
cabana
cabelo
cabide
cabo
cabrito
cacau
cacetada
cachorro
cacique
cadastro
cadeado
cafezal
caiaque
caipira
caixote
cajado
caju
calafrio
calcular
caldeira
calibrar
calmante
calota
camada
cambista
camisa
camomila
campanha
camuflar
canavial
cancelar
caneta
canguru
canhoto
canivete
canoa
cansado
cantar
canudo
capacho
capela
capinar
capotar
capricho
captador
capuz
caracol
carbono
cardeal
careca
carimbar
carneiro
carpete
carreira
cartaz
carvalho
casaco
casca
casebre
castelo
casulo
catarata
cativar
caule
causador
cautelar
cavalo
caverna
cebola
cedilha
cegonha
celebrar
celular
cenoura
censo
centeio
cercar
cerrado
certeiro
cerveja
cetim
cevada
chacota
chaleira
chamado
chapada
charme
chatice
chave
chefe
chegada
cheiro
cheque
chicote
chifre
chinelo
chocalho
chover
chumbo
chutar
chuva
cicatriz
ciclone
cidade
cidreira
ciente
cigana
cimento
cinto
cinza
ciranda
circuito
cirurgia
citar
clareza
clero
clicar
clone
clube
coado
coagir
cobaia
cobertor
cobrar
cocada
coelho
coentro
coeso
cogumelo
coibir
coifa
coiote
colar
coleira
colher
colidir
colmeia
colono
coluna
comando
combinar
comentar
comitiva
comover
complexo
comum
concha
condor
conectar
confuso
congelar
conhecer
conjugar
consumir
contrato
convite
cooperar
copeiro
copiador
copo
coquetel
coragem
cordial
corneta
coronha
corporal
correio
cortejo
coruja
corvo
cosseno
costela
cotonete
couro
couve
covil
cozinha
cratera
cravo
creche
credor
creme
crer
crespo
criada
criminal
crioulo
crise
criticar
crosta
crua
cruzeiro
cubano
cueca
cuidado
cujo
culatra
culminar
culpar
cultura
cumprir
cunhado
cupido
curativo
curral
cursar
curto
cuspir
custear
cutelo
damasco
datar
debater
debitar
deboche
debulhar
decalque
decimal
declive
decote
decretar
dedal
dedicado
deduzir
defesa
defumar
degelo
degrau
degustar
deitado
deixar
delator
delegado
delinear
delonga
demanda
demitir
demolido
dentista
depenado
depilar
depois
depressa
depurar
deriva
derramar
desafio
desbotar
descanso
desenho
desfiado
desgaste
desigual
deslize
desmamar
desova
despesa
destaque
desviar
detalhar
detentor
detonar
detrito
deusa
dever
devido
devotado
dezena
diagrama
dialeto
didata
difuso
digitar
dilatado
diluente
diminuir
dinastia
dinheiro
diocese
direto
discreta
disfarce
disparo
disquete
dissipar
distante
ditador
diurno
diverso
divisor
divulgar
dizer
dobrador
dolorido
domador
dominado
donativo
donzela
dormente
dorsal
dosagem
dourado
doutor
drenagem
drible
drogaria
duelar
duende
dueto
duplo
duquesa
durante
duvidoso
eclodir
ecoar
ecologia
edificar
edital
educado
efeito
efetivar
ejetar
elaborar
eleger
eleitor
elenco
elevador
eliminar
elogiar
embargo
embolado
embrulho
embutido
emenda
emergir
emissor
empatia
empenho
empinado
empolgar
emprego
empurrar
emulador
encaixe
encenado
enchente
encontro
endeusar
endossar
enfaixar
enfeite
enfim
engajado
engenho
englobar
engomado
engraxar
enguia
enjoar
enlatar
enquanto
enraizar
enrolado
enrugar
ensaio
enseada
ensino
ensopado
entanto
enteado
entidade
entortar
entrada
entulho
envergar
enviado
envolver
enxame
enxerto
enxofre
enxuto
epiderme
equipar
ereto
erguido
errata
erva
ervilha
esbanjar
esbelto
escama
escola
escrita
escuta
esfinge
esfolar
esfregar
esfumado
esgrima
esmalte
espanto
espelho
espiga
esponja
espreita
espumar
esquerda
estaca
esteira
esticar
estofado
estrela
estudo
esvaziar
etanol
etiqueta
euforia
europeu
evacuar
evaporar
evasivo
eventual
evidente
evoluir
exagero
exalar
examinar
exato
exausto
excesso
excitar
exclamar
executar
exemplo
exibir
exigente
exonerar
expandir
expelir
expirar
explanar
exposto
expresso
expulsar
externo
extinto
extrato
fabricar
fabuloso
faceta
facial
fada
fadiga
faixa
falar
falta
familiar
fandango
fanfarra
fantoche
fardado
farelo
farinha
farofa
farpa
fartura
fatia
fator
favorita
faxina
fazenda
fechado
feijoada
feirante
felino
feminino
fenda
feno
fera
feriado
ferrugem
ferver
festejar
fetal
feudal
fiapo
fibrose
ficar
ficheiro
figurado
fileira
filho
filme
filtrar
firmeza
fisgada
fissura
fita
fivela
fixador
fixo
flacidez
flamingo
flanela
flechada
flora
flutuar
fluxo
focal
focinho
fofocar
fogo
foguete
foice
folgado
folheto
forjar
formiga
forno
forte
fosco
fossa
fragata
fralda
frango
frasco
fraterno
freira
frente
fretar
frieza
friso
fritura
fronha
frustrar
fruteira
fugir
fulano
fuligem
fundar
fungo
funil
furador
furioso
futebol
gabarito
gabinete
gado
gaiato
gaiola
gaivota
galega
galho
galinha
galocha
ganhar
garagem
garfo
gargalo
garimpo
garoupa
garrafa
gasoduto
gasto
gata
gatilho
gaveta
gazela
gelado
geleia
gelo
gemada
gemer
gemido
generoso
gengiva
genial
genoma
genro
geologia
gerador
germinar
gesso
gestor
ginasta
gincana
gingado
girafa
girino
glacial
glicose
global
glorioso
goela
goiaba
golfe
golpear
gordura
gorjeta
gorro
gostoso
goteira
governar
gracejo
gradual
grafite
gralha
grampo
granada
gratuito
graveto
graxa
grego
grelhar
greve
grilo
grisalho
gritaria
grosso
grotesco
grudado
grunhido
gruta
guache
guarani
guaxinim
guerrear
guiar
guincho
guisado
gula
guloso
guru
habitar
harmonia
haste
haver
hectare
herdar
heresia
hesitar
hiato
hibernar
hidratar
hiena
hino
hipismo
hipnose
hipoteca
hoje
holofote
homem
honesto
honrado
hormonal
hospedar
humorado
iate
ideia
idoso
ignorado
igreja
iguana
ileso
ilha
iludido
iluminar
ilustrar
imagem
imediato
imenso
imersivo
iminente
imitador
imortal
impacto
impedir
implante
impor
imprensa
impune
imunizar
inalador
inapto
inativo
incenso
inchar
incidir
incluir
incolor
indeciso
indireto
indutor
ineficaz
inerente
infantil
infestar
infinito
inflamar
informal
infrator
ingerir
inibido
inicial
inimigo
injetar
inocente
inodoro
inovador
inox
inquieto
inscrito
inseto
insistir
inspetor
instalar
insulto
intacto
integral
intimar
intocado
intriga
invasor
inverno
invicto
invocar
iogurte
iraniano
ironizar
irreal
irritado
isca
isento
isolado
isqueiro
italiano
janeiro
jangada
janta
jararaca
jardim
jarro
jasmim
jato
javali
jazida
jejum
joaninha
joelhada
jogador
joia
jornal
jorrar
jovem
juba
judeu
judoca
juiz
julgador
julho
jurado
jurista
juro
justa
labareda
laboral
lacre
lactante
ladrilho
lagarta
lagoa
laje
lamber
lamentar
laminar
lampejo
lanche
lapidar
lapso
laranja
lareira
largura
lasanha
lastro
lateral
latido
lavanda
lavoura
lavrador
laxante
lazer
lealdade
lebre
legado
legendar
legista
leigo
leiloar
leitura
lembrete
leme
lenhador
lentilha
leoa
lesma
leste
letivo
letreiro
levar
leveza
levitar
liberal
libido
liderar
ligar
ligeiro
limitar
limoeiro
limpador
linda
linear
linhagem
liquidez
listagem
lisura
litoral
livro
lixa
lixeira
locador
locutor
lojista
lombo
lona
longe
lontra
lorde
lotado
loteria
loucura
lousa
louvar
luar
lucidez
lucro
luneta
lustre
lutador
luva
macaco
macete
machado
macio
madeira
madrinha
magnata
magreza
maior
mais
malandro
malha
malote
maluco
mamilo
mamoeiro
mamute
manada
mancha
mandato
manequim
manhoso
manivela
manobrar
mansa
manter
manusear
mapeado
maquinar
marcador
maresia
marfim
margem
marinho
marmita
maroto
marquise
marreco
martelo
marujo
mascote
masmorra
massagem
mastigar
matagal
materno
matinal
matutar
maxilar
medalha
medida
medusa
megafone
meiga
melancia
melhor
membro
memorial
menino
menos
mensagem
mental
merecer
mergulho
mesada
mesclar
mesmo
mesquita
mestre
metade
meteoro
metragem
mexer
mexicano
micro
migalha
migrar
milagre
milenar
milhar
mimado
minerar
minhoca
ministro
minoria
miolo
mirante
mirtilo
misturar
mocidade
moderno
modular
moeda
moer
moinho
moita
moldura
moleza
molho
molinete
molusco
montanha
moqueca
morango
morcego
mordomo
morena
mosaico
mosquete
mostarda
motel
motim
moto
motriz
muda
muito
mulata
mulher
multar
mundial
munido
muralha
murcho
muscular
museu
musical
nacional
nadador
naja
namoro
narina
narrado
nascer
nativa
natureza
navalha
navegar
navio
neblina
nebuloso
negativa
negociar
negrito
nervoso
neta
neural
nevasca
nevoeiro
ninar
ninho
nitidez
nivelar
nobreza
noite
noiva
nomear
nominal
nordeste
nortear
notar
noticiar
noturno
novelo
novilho
novo
nublado
nudez
numeral
nupcial
nutrir
nuvem
obcecado
obedecer
objetivo
obrigado
obscuro
obstetra
obter
obturar
ocidente
ocioso
ocorrer
oculista
ocupado
ofegante
ofensiva
oferenda
oficina
ofuscado
ogiva
olaria
oleoso
olhar
oliveira
ombro
omelete
omisso
omitir
ondulado
oneroso
ontem
opcional
operador
oponente
oportuno
oposto
orar
orbitar
ordem
ordinal
orfanato
orgasmo
orgulho
oriental
origem
oriundo
orla
ortodoxo
orvalho
oscilar
ossada
osso
ostentar
otimismo
ousadia
outono
outubro
ouvido
ovelha
ovular
oxidar
oxigenar
pacato
paciente
pacote
pactuar
padaria
padrinho
pagar
pagode
painel
pairar
paisagem
palavra
palestra
palheta
palito
palmada
palpitar
pancada
panela
panfleto
panqueca
pantanal
papagaio
papelada
papiro
parafina
parcial
pardal
parede
partida
pasmo
passado
pastel
patamar
patente
patinar
patrono
paulada
pausar
peculiar
pedalar
pedestre
pediatra
pedra
pegada
peitoral
peixe
pele
pelicano
penca
pendurar
peneira
penhasco
pensador
pente
perceber
perfeito
pergunta
perito
permitir
perna
perplexo
persiana
pertence
peruca
pescado
pesquisa
pessoa
petiscar
piada
picado
piedade
pigmento
pilastra
pilhado
pilotar
pimenta
pincel
pinguim
pinha
pinote
pintar
pioneiro
pipoca
piquete
piranha
pires
pirueta
piscar
pistola
pitanga
pivete
planta
plaqueta
platina
plebeu
plumagem
pluvial
pneu
poda
poeira
poetisa
polegada
policiar
poluente
polvilho
pomar
pomba
ponderar
pontaria
populoso
porta
possuir
postal
pote
poupar
pouso
povoar
praia
prancha
prato
praxe
prece
predador
prefeito
premiar
prensar
preparar
presilha
pretexto
prevenir
prezar
primata
princesa
prisma
privado
processo
produto
profeta
proibido
projeto
prometer
propagar
prosa
protetor
provador
publicar
pudim
pular
pulmonar
pulseira
punhal
punir
pupilo
pureza
puxador
quadra
quantia
quarto
quase
quebrar
queda
queijo
quente
querido
quimono
quina
quiosque
rabanada
rabisco
rachar
racionar
radial
raiar
rainha
raio
raiva
rajada
ralado
ramal
ranger
ranhura
rapadura
rapel
rapidez
raposa
raquete
raridade
rasante
rascunho
rasgar
raspador
rasteira
rasurar
ratazana
ratoeira
realeza
reanimar
reaver
rebaixar
rebelde
rebolar
recado
recente
recheio
recibo
recordar
recrutar
recuar
rede
redimir
redonda
reduzida
reenvio
refinar
refletir
refogar
refresco
refugiar
regalia
regime
regra
reinado
reitor
rejeitar
relativo
remador
remendo
remorso
renovado
reparo
repelir
repleto
repolho
represa
repudiar
requerer
resenha
resfriar
resgatar
residir
resolver
respeito
ressaca
restante
resumir
retalho
reter
retirar
retomada
retratar
revelar
revisor
revolta
riacho
rica
rigidez
rigoroso
rimar
ringue
risada
risco
risonho
robalo
rochedo
rodada
rodeio
rodovia
roedor
roleta
romano
roncar
rosado
roseira
rosto
rota
roteiro
rotina
rotular
rouco
roupa
roxo
rubro
rugido
rugoso
ruivo
rumo
rupestre
russo
sabor
saciar
sacola
sacudir
sadio
safira
saga
sagrada
saibro
salada
saleiro
salgado
saliva
salpicar
salsicha
saltar
salvador
sambar
samurai
sanar
sanfona
sangue
sanidade
sapato
sarda
sargento
sarjeta
saturar
saudade
saxofone
sazonal
secar
secular
seda
sedento
sediado
sedoso
sedutor
segmento
segredo
segundo
seiva
seleto
selvagem
semanal
semente
senador
senhor
sensual
sentado
separado
sereia
seringa
serra
servo
setembro
setor
sigilo
silhueta
silicone
simetria
simpatia
simular
sinal
sincero
singular
sinopse
sintonia
sirene
siri
situado
soberano
sobra
socorro
sogro
soja
solda
soletrar
solteiro
sombrio
sonata
sondar
sonegar
sonhador
sono
soprano
soquete
sorrir
sorteio
sossego
sotaque
soterrar
sovado
sozinho
suavizar
subida
submerso
subsolo
subtrair
sucata
sucesso
suco
sudeste
sufixo
sugador
sugerir
sujeito
sulfato
sumir
suor
superior
suplicar
suposto
suprimir
surdina
surfista
surpresa
surreal
surtir
suspiro
sustento
tabela
tablete
tabuada
tacho
tagarela
talher
talo
talvez
tamanho
tamborim
tampa
tangente
tanto
tapar
tapioca
tardio
tarefa
tarja
tarraxa
tatuagem
taurino
taxativo
taxista
teatral
tecer
tecido
teclado
tedioso
teia
teimar
telefone
telhado
tempero
tenente
tensor
tentar
termal
terno
terreno
tese
tesoura
testado
teto
textura
texugo
tiara
tigela
tijolo
timbrar
timidez
tingido
tinteiro
tiragem
titular
toalha
tocha
tolerar
tolice
tomada
tomilho
tonel
tontura
topete
tora
torcido
torneio
torque
torrada
torto
tostar
touca
toupeira
toxina
trabalho
tracejar
tradutor
trafegar
trajeto
trama
trancar
trapo
traseiro
tratador
travar
treino
tremer
trepidar
trevo
triagem
tribo
triciclo
tridente
trilogia
trindade
triplo
triturar
triunfal
trocar
trombeta
trova
trunfo
truque
tubular
tucano
tudo
tulipa
tupi
turbo
turma
turquesa
tutelar
tutorial
uivar
umbigo
unha
unidade
uniforme
urologia
urso
urtiga
urubu
usado
usina
usufruir
vacina
vadiar
vagaroso
vaidoso
vala
valente
validade
valores
vantagem
vaqueiro
varanda
vareta
varrer
vascular
vasilha
vassoura
vazar
vazio
veado
vedar
vegetar
veicular
veleiro
velhice
veludo
vencedor
vendaval
venerar
ventre
verbal
verdade
vereador
vergonha
vermelho
verniz
versar
vertente
vespa
vestido
vetorial
viaduto
viagem
viajar
viatura
vibrador
videira
vidraria
viela
viga
vigente
vigiar
vigorar
vilarejo
vinco
vinheta
vinil
violeta
virada
virtude
visitar
visto
vitral
viveiro
vizinho
voador
voar
vogal
volante
voleibol
voltagem
volumoso
vontade
vulto
vuvuzela
xadrez
xarope
xeque
xeretar
xerife
xingar
zangado
zarpar
zebu
zelador
zombar
zoologia
zumbido`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/simplified-chinese.js
var wordlist8 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/spanish.js
var wordlist9 = `abaco
abdomen
abeja
abierto
abogado
abono
aborto
abrazo
abrir
abuelo
abuso
acabar
academia
acceso
accion
aceite
acelga
acento
aceptar
acido
aclarar
acne
acoger
acoso
activo
acto
actriz
actuar
acudir
acuerdo
acusar
adicto
admitir
adoptar
adorno
aduana
adulto
aereo
afectar
aficion
afinar
afirmar
agil
agitar
agonia
agosto
agotar
agregar
agrio
agua
agudo
aguila
aguja
ahogo
ahorro
aire
aislar
ajedrez
ajeno
ajuste
alacran
alambre
alarma
alba
album
alcalde
aldea
alegre
alejar
alerta
aleta
alfiler
alga
algodon
aliado
aliento
alivio
alma
almeja
almibar
altar
alteza
altivo
alto
altura
alumno
alzar
amable
amante
amapola
amargo
amasar
ambar
ambito
ameno
amigo
amistad
amor
amparo
amplio
ancho
anciano
ancla
andar
anden
anemia
angulo
anillo
animo
anis
anotar
antena
antiguo
antojo
anual
anular
anuncio
anadir
anejo
ano
apagar
aparato
apetito
apio
aplicar
apodo
aporte
apoyo
aprender
aprobar
apuesta
apuro
arado
arana
arar
arbitro
arbol
arbusto
archivo
arco
arder
ardilla
arduo
area
arido
aries
armonia
arnes
aroma
arpa
arpon
arreglo
arroz
arruga
arte
artista
asa
asado
asalto
ascenso
asegurar
aseo
asesor
asiento
asilo
asistir
asno
asombro
aspero
astilla
astro
astuto
asumir
asunto
atajo
ataque
atar
atento
ateo
atico
atleta
atomo
atraer
atroz
atun
audaz
audio
auge
aula
aumento
ausente
autor
aval
avance
avaro
ave
avellana
avena
avestruz
avion
aviso
ayer
ayuda
ayuno
azafran
azar
azote
azucar
azufre
azul
baba
babor
bache
bahia
baile
bajar
balanza
balcon
balde
bambu
banco
banda
bano
barba
barco
barniz
barro
bascula
baston
basura
batalla
bateria
batir
batuta
baul
bazar
bebe
bebida
bello
besar
beso
bestia
bicho
bien
bingo
blanco
bloque
blusa
boa
bobina
bobo
boca
bocina
boda
bodega
boina
bola
bolero
bolsa
bomba
bondad
bonito
bono
bonsai
borde
borrar
bosque
bote
botin
boveda
bozal
bravo
brazo
brecha
breve
brillo
brinco
brisa
broca
broma
bronce
brote
bruja
brusco
bruto
buceo
bucle
bueno
buey
bufanda
bufon
buho
buitre
bulto
burbuja
burla
burro
buscar
butaca
buzon
caballo
cabeza
cabina
cabra
cacao
cadaver
cadena
caer
cafe
caida
caiman
caja
cajon
cal
calamar
calcio
caldo
calidad
calle
calma
calor
calvo
cama
cambio
camello
camino
campo
cancer
candil
canela
canguro
canica
canto
cana
canon
caoba
caos
capaz
capitan
capote
captar
capucha
cara
carbon
carcel
careta
carga
carino
carne
carpeta
carro
carta
casa
casco
casero
caspa
castor
catorce
catre
caudal
causa
cazo
cebolla
ceder
cedro
celda
celebre
celoso
celula
cemento
ceniza
centro
cerca
cerdo
cereza
cero
cerrar
certeza
cesped
cetro
chacal
chaleco
champu
chancla
chapa
charla
chico
chiste
chivo
choque
choza
chuleta
chupar
ciclon
ciego
cielo
cien
cierto
cifra
cigarro
cima
cinco
cine
cinta
cipres
circo
ciruela
cisne
cita
ciudad
clamor
clan
claro
clase
clave
cliente
clima
clinica
cobre
coccion
cochino
cocina
coco
codigo
codo
cofre
coger
cohete
cojin
cojo
cola
colcha
colegio
colgar
colina
collar
colmo
columna
combate
comer
comida
comodo
compra
conde
conejo
conga
conocer
consejo
contar
copa
copia
corazon
corbata
corcho
cordon
corona
correr
coser
cosmos
costa
craneo
crater
crear
crecer
creido
crema
cria
crimen
cripta
crisis
cromo
cronica
croqueta
crudo
cruz
cuadro
cuarto
cuatro
cubo
cubrir
cuchara
cuello
cuento
cuerda
cuesta
cueva
cuidar
culebra
culpa
culto
cumbre
cumplir
cuna
cuneta
cuota
cupon
cupula
curar
curioso
curso
curva
cutis
dama
danza
dar
dardo
datil
deber
debil
decada
decir
dedo
defensa
definir
dejar
delfin
delgado
delito
demora
denso
dental
deporte
derecho
derrota
desayuno
deseo
desfile
desnudo
destino
desvio
detalle
detener
deuda
dia
diablo
diadema
diamante
diana
diario
dibujo
dictar
diente
dieta
diez
dificil
digno
dilema
diluir
dinero
directo
dirigir
disco
diseno
disfraz
diva
divino
doble
doce
dolor
domingo
don
donar
dorado
dormir
dorso
dos
dosis
dragon
droga
ducha
duda
duelo
dueno
dulce
duo
duque
durar
dureza
duro
ebano
ebrio
echar
eco
ecuador
edad
edicion
edificio
editor
educar
efecto
eficaz
eje
ejemplo
elefante
elegir
elemento
elevar
elipse
elite
elixir
elogio
eludir
embudo
emitir
emocion
empate
empeno
empleo
empresa
enano
encargo
enchufe
encia
enemigo
enero
enfado
enfermo
engano
enigma
enlace
enorme
enredo
ensayo
ensenar
entero
entrar
envase
envio
epoca
equipo
erizo
escala
escena
escolar
escribir
escudo
esencia
esfera
esfuerzo
espada
espejo
espia
esposa
espuma
esqui
estar
este
estilo
estufa
etapa
eterno
etica
etnia
evadir
evaluar
evento
evitar
exacto
examen
exceso
excusa
exento
exigir
exilio
existir
exito
experto
explicar
exponer
extremo
fabrica
fabula
fachada
facil
factor
faena
faja
falda
fallo
falso
faltar
fama
familia
famoso
faraon
farmacia
farol
farsa
fase
fatiga
fauna
favor
fax
febrero
fecha
feliz
feo
feria
feroz
fertil
fervor
festin
fiable
fianza
fiar
fibra
ficcion
ficha
fideo
fiebre
fiel
fiera
fiesta
figura
fijar
fijo
fila
filete
filial
filtro
fin
finca
fingir
finito
firma
flaco
flauta
flecha
flor
flota
fluir
flujo
fluor
fobia
foca
fogata
fogon
folio
folleto
fondo
forma
forro
fortuna
forzar
fosa
foto
fracaso
fragil
franja
frase
fraude
freir
freno
fresa
frio
frito
fruta
fuego
fuente
fuerza
fuga
fumar
funcion
funda
furgon
furia
fusil
futbol
futuro
gacela
gafas
gaita
gajo
gala
galeria
gallo
gamba
ganar
gancho
ganga
ganso
garaje
garza
gasolina
gastar
gato
gavilan
gemelo
gemir
gen
genero
genio
gente
geranio
gerente
germen
gesto
gigante
gimnasio
girar
giro
glaciar
globo
gloria
gol
golfo
goloso
golpe
goma
gordo
gorila
gorra
gota
goteo
gozar
grada
grafico
grano
grasa
gratis
grave
grieta
grillo
gripe
gris
grito
grosor
grua
grueso
grumo
grupo
guante
guapo
guardia
guerra
guia
guino
guion
guiso
guitarra
gusano
gustar
haber
habil
hablar
hacer
hacha
hada
hallar
hamaca
harina
haz
hazana
hebilla
hebra
hecho
helado
helio
hembra
herir
hermano
heroe
hervir
hielo
hierro
higado
higiene
hijo
himno
historia
hocico
hogar
hoguera
hoja
hombre
hongo
honor
honra
hora
hormiga
horno
hostil
hoyo
hueco
huelga
huerta
hueso
huevo
huida
huir
humano
humedo
humilde
humo
hundir
huracan
hurto
icono
ideal
idioma
idolo
iglesia
iglu
igual
ilegal
ilusion
imagen
iman
imitar
impar
imperio
imponer
impulso
incapaz
indice
inerte
infiel
informe
ingenio
inicio
inmenso
inmune
innato
insecto
instante
interes
intimo
intuir
inutil
invierno
ira
iris
ironia
isla
islote
jabali
jabon
jamon
jarabe
jardin
jarra
jaula
jazmin
jefe
jeringa
jinete
jornada
joroba
joven
joya
juerga
jueves
juez
jugador
jugo
juguete
juicio
junco
jungla
junio
juntar
jupiter
jurar
justo
juvenil
juzgar
kilo
koala
labio
lacio
lacra
lado
ladron
lagarto
lagrima
laguna
laico
lamer
lamina
lampara
lana
lancha
langosta
lanza
lapiz
largo
larva
lastima
lata
latex
latir
laurel
lavar
lazo
leal
leccion
leche
lector
leer
legion
legumbre
lejano
lengua
lento
lena
leon
leopardo
lesion
letal
letra
leve
leyenda
libertad
libro
licor
lider
lidiar
lienzo
liga
ligero
lima
limite
limon
limpio
lince
lindo
linea
lingote
lino
linterna
liquido
liso
lista
litera
litio
litro
llaga
llama
llanto
llave
llegar
llenar
llevar
llorar
llover
lluvia
lobo
locion
loco
locura
logica
logro
lombriz
lomo
lonja
lote
lucha
lucir
lugar
lujo
luna
lunes
lupa
lustro
luto
luz
maceta
macho
madera
madre
maduro
maestro
mafia
magia
mago
maiz
maldad
maleta
malla
malo
mama
mambo
mamut
manco
mando
manejar
manga
maniqui
manjar
mano
manso
manta
manana
mapa
maquina
mar
marco
marea
marfil
margen
marido
marmol
marron
martes
marzo
masa
mascara
masivo
matar
materia
matiz
matriz
maximo
mayor
mazorca
mecha
medalla
medio
medula
mejilla
mejor
melena
melon
memoria
menor
mensaje
mente
menu
mercado
merengue
merito
mes
meson
meta
meter
metodo
metro
mezcla
miedo
miel
miembro
miga
mil
milagro
militar
millon
mimo
mina
minero
minimo
minuto
miope
mirar
misa
miseria
misil
mismo
mitad
mito
mochila
mocion
moda
modelo
moho
mojar
molde
moler
molino
momento
momia
monarca
moneda
monja
monto
mono
morada
morder
moreno
morir
morro
morsa
mortal
mosca
mostrar
motivo
mover
movil
mozo
mucho
mudar
mueble
muela
muerte
muestra
mugre
mujer
mula
muleta
multa
mundo
muneca
mural
muro
musculo
museo
musgo
musica
muslo
nacar
nacion
nadar
naipe
naranja
nariz
narrar
nasal
natal
nativo
natural
nausea
naval
nave
navidad
necio
nectar
negar
negocio
negro
neon
nervio
neto
neutro
nevar
nevera
nicho
nido
niebla
nieto
ninez
nino
nitido
nivel
nobleza
noche
nomina
noria
norma
norte
nota
noticia
novato
novela
novio
nube
nuca
nucleo
nudillo
nudo
nuera
nueve
nuez
nulo
numero
nutria
oasis
obeso
obispo
objeto
obra
obrero
observar
obtener
obvio
oca
ocaso
oceano
ochenta
ocho
ocio
ocre
octavo
octubre
oculto
ocupar
ocurrir
odiar
odio
odisea
oeste
ofensa
oferta
oficio
ofrecer
ogro
oido
oir
ojo
ola
oleada
olfato
olivo
olla
olmo
olor
olvido
ombligo
onda
onza
opaco
opcion
opera
opinar
oponer
optar
optica
opuesto
oracion
orador
oral
orbita
orca
orden
oreja
organo
orgia
orgullo
oriente
origen
orilla
oro
orquesta
oruga
osadia
oscuro
osezno
oso
ostra
otono
otro
oveja
ovulo
oxido
oxigeno
oyente
ozono
pacto
padre
paella
pagina
pago
pais
pajaro
palabra
palco
paleta
palido
palma
paloma
palpar
pan
panal
panico
pantera
panuelo
papa
papel
papilla
paquete
parar
parcela
pared
parir
paro
parpado
parque
parrafo
parte
pasar
paseo
pasion
paso
pasta
pata
patio
patria
pausa
pauta
pavo
payaso
peaton
pecado
pecera
pecho
pedal
pedir
pegar
peine
pelar
peldano
pelea
peligro
pellejo
pelo
peluca
pena
pensar
penon
peon
peor
pepino
pequeno
pera
percha
perder
pereza
perfil
perico
perla
permiso
perro
persona
pesa
pesca
pesimo
pestana
petalo
petroleo
pez
pezuna
picar
pichon
pie
piedra
pierna
pieza
pijama
pilar
piloto
pimienta
pino
pintor
pinza
pina
piojo
pipa
pirata
pisar
piscina
piso
pista
piton
pizca
placa
plan
plata
playa
plaza
pleito
pleno
plomo
pluma
plural
pobre
poco
poder
podio
poema
poesia
poeta
polen
policia
pollo
polvo
pomada
pomelo
pomo
pompa
poner
porcion
portal
posada
poseer
posible
poste
potencia
potro
pozo
prado
precoz
pregunta
premio
prensa
preso
previo
primo
principe
prision
privar
proa
probar
proceso
producto
proeza
profesor
programa
prole
promesa
pronto
propio
proximo
prueba
publico
puchero
pudor
pueblo
puerta
puesto
pulga
pulir
pulmon
pulpo
pulso
puma
punto
punal
puno
pupa
pupila
pure
quedar
queja
quemar
querer
queso
quieto
quimica
quince
quitar
rabano
rabia
rabo
racion
radical
raiz
rama
rampa
rancho
rango
rapaz
rapido
rapto
rasgo
raspa
rato
rayo
raza
razon
reaccion
realidad
rebano
rebote
recaer
receta
rechazo
recoger
recreo
recto
recurso
red
redondo
reducir
reflejo
reforma
refran
refugio
regalo
regir
regla
regreso
rehen
reino
reir
reja
relato
relevo
relieve
relleno
reloj
remar
remedio
remo
rencor
rendir
renta
reparto
repetir
reposo
reptil
res
rescate
resina
respeto
resto
resumen
retiro
retorno
retrato
reunir
reves
revista
rey
rezar
rico
riego
rienda
riesgo
rifa
rigido
rigor
rincon
rinon
rio
riqueza
risa
ritmo
rito
rizo
roble
roce
rociar
rodar
rodeo
rodilla
roer
rojizo
rojo
romero
romper
ron
ronco
ronda
ropa
ropero
rosa
rosca
rostro
rotar
rubi
rubor
rudo
rueda
rugir
ruido
ruina
ruleta
rulo
rumbo
rumor
ruptura
ruta
rutina
sabado
saber
sabio
sable
sacar
sagaz
sagrado
sala
saldo
salero
salir
salmon
salon
salsa
salto
salud
salvar
samba
sancion
sandia
sanear
sangre
sanidad
sano
santo
sapo
saque
sardina
sarten
sastre
satan
sauna
saxofon
seccion
seco
secreto
secta
sed
seguir
seis
sello
selva
semana
semilla
senda
sensor
senal
senor
separar
sepia
sequia
ser
serie
sermon
servir
sesenta
sesion
seta
setenta
severo
sexo
sexto
sidra
siesta
siete
siglo
signo
silaba
silbar
silencio
silla
simbolo
simio
sirena
sistema
sitio
situar
sobre
socio
sodio
sol
solapa
soldado
soledad
solido
soltar
solucion
sombra
sondeo
sonido
sonoro
sonrisa
sopa
soplar
soporte
sordo
sorpresa
sorteo
sosten
sotano
suave
subir
suceso
sudor
suegra
suelo
sueno
suerte
sufrir
sujeto
sultan
sumar
superar
suplir
suponer
supremo
sur
surco
sureno
surgir
susto
sutil
tabaco
tabique
tabla
tabu
taco
tacto
tajo
talar
talco
talento
talla
talon
tamano
tambor
tango
tanque
tapa
tapete
tapia
tapon
taquilla
tarde
tarea
tarifa
tarjeta
tarot
tarro
tarta
tatuaje
tauro
taza
tazon
teatro
techo
tecla
tecnica
tejado
tejer
tejido
tela
telefono
tema
temor
templo
tenaz
tender
tener
tenis
tenso
teoria
terapia
terco
termino
ternura
terror
tesis
tesoro
testigo
tetera
texto
tez
tibio
tiburon
tiempo
tienda
tierra
tieso
tigre
tijera
tilde
timbre
timido
timo
tinta
tio
tipico
tipo
tira
tiron
titan
titere
titulo
tiza
toalla
tobillo
tocar
tocino
todo
toga
toldo
tomar
tono
tonto
topar
tope
toque
torax
torero
tormenta
torneo
toro
torpedo
torre
torso
tortuga
tos
tosco
toser
toxico
trabajo
tractor
traer
trafico
trago
traje
tramo
trance
trato
trauma
trazar
trebol
tregua
treinta
tren
trepar
tres
tribu
trigo
tripa
triste
triunfo
trofeo
trompa
tronco
tropa
trote
trozo
truco
trueno
trufa
tuberia
tubo
tuerto
tumba
tumor
tunel
tunica
turbina
turismo
turno
tutor
ubicar
ulcera
umbral
unidad
unir
universo
uno
untar
una
urbano
urbe
urgente
urna
usar
usuario
util
utopia
uva
vaca
vacio
vacuna
vagar
vago
vaina
vajilla
vale
valido
valle
valor
valvula
vampiro
vara
variar
varon
vaso
vecino
vector
vehiculo
veinte
vejez
vela
velero
veloz
vena
vencer
venda
veneno
vengar
venir
venta
venus
ver
verano
verbo
verde
vereda
verja
verso
verter
via
viaje
vibrar
vicio
victima
vida
video
vidrio
viejo
viernes
vigor
vil
villa
vinagre
vino
vinedo
violin
viral
virgo
virtud
visor
vispera
vista
vitamina
viudo
vivaz
vivero
vivir
vivo
volcan
volumen
volver
voraz
votar
voto
voz
vuelo
vulgar
yacer
yate
yegua
yema
yerno
yeso
yodo
yoga
yogur
zafiro
zanja
zapato
zarza
zona
zorro
zumo
zurdo`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/traditional-chinese.js
var wordlist10 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash11, _password, _salt, _opts) {
  ahash(hash11);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber(c);
  anumber(dkLen);
  anumber(asyncTick);
  if (c < 1)
    throw new Error("iterations (c) should be >= 1");
  const password = kdfInputToBytes(_password);
  const salt = kdfInputToBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash11, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u);
  return DK;
}
function pbkdf2(hash11, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash11, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
async function pbkdf2Async(hash11, password, salt, opts) {
  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash11, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    await asyncLoop(c - 1, asyncTick, () => {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    });
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/@scure/bip39/esm/index.js
var isJapanese = (wordlist11) => wordlist11[0] === "";
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize4(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
function aentropy(ent) {
  abytes(ent, 16, 20, 24, 28, 32);
}
function generateMnemonic(wordlist11, strength = 128) {
  anumber(strength);
  if (strength % 32 !== 0 || strength > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic(randomBytes(strength / 8), wordlist11);
}
var calcChecksum = (entropy) => {
  const bitsLeft = 8 - entropy.length / 4;
  return new Uint8Array([sha256(entropy)[0] >> bitsLeft << bitsLeft]);
};
function getCoder(wordlist11) {
  if (!Array.isArray(wordlist11) || wordlist11.length !== 2048 || typeof wordlist11[0] !== "string")
    throw new Error("Wordlist: expected array of 2048 strings");
  wordlist11.forEach((i) => {
    if (typeof i !== "string")
      throw new Error("wordlist: non-string element: " + i);
  });
  return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist11));
}
function mnemonicToEntropy(mnemonic, wordlist11) {
  const { words } = normalize4(mnemonic);
  const entropy = getCoder(wordlist11).decode(words);
  aentropy(entropy);
  return entropy;
}
function entropyToMnemonic(entropy, wordlist11) {
  aentropy(entropy);
  const words = getCoder(wordlist11).encode(entropy);
  return words.join(isJapanese(wordlist11) ? "" : " ");
}
function validateMnemonic(mnemonic, wordlist11) {
  try {
    mnemonicToEntropy(mnemonic, wordlist11);
  } catch (e) {
    return false;
  }
  return true;
}
var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize4(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}

// node_modules/viem/_esm/accounts/generatePrivateKey.js
function generatePrivateKey() {
  return toHex(secp256k1.utils.randomPrivateKey());
}

// node_modules/viem/_esm/accounts/toAccount.js
function toAccount(source) {
  if (typeof source === "string") {
    if (!isAddress(source, { strict: false }))
      throw new InvalidAddressError({ address: source });
    return {
      address: source,
      type: "json-rpc"
    };
  }
  if (!isAddress(source.address, { strict: false }))
    throw new InvalidAddressError({ address: source.address });
  return {
    address: source.address,
    nonceManager: source.nonceManager,
    sign: source.sign,
    signAuthorization: source.signAuthorization,
    signMessage: source.signMessage,
    signTransaction: source.signTransaction,
    signTypedData: source.signTypedData,
    source: "custom",
    type: "local"
  };
}

// node_modules/viem/_esm/accounts/utils/sign.js
var extraEntropy = false;
async function sign4({ hash: hash11, privateKey, to: to3 = "object" }) {
  const { r, s, recovery } = secp256k1.sign(hash11.slice(2), privateKey.slice(2), { lowS: true, extraEntropy });
  const signature = {
    r: numberToHex(r, { size: 32 }),
    s: numberToHex(s, { size: 32 }),
    v: recovery ? 28n : 27n,
    yParity: recovery
  };
  return (() => {
    if (to3 === "bytes" || to3 === "hex")
      return serializeSignature({ ...signature, to: to3 });
    return signature;
  })();
}

// node_modules/viem/_esm/accounts/utils/signAuthorization.js
async function signAuthorization2(parameters) {
  const { chainId, nonce, privateKey, to: to3 = "object" } = parameters;
  const address = parameters.contractAddress ?? parameters.address;
  const signature = await sign4({
    hash: hashAuthorization({ address, chainId, nonce }),
    privateKey,
    to: to3
  });
  if (to3 === "object")
    return {
      address,
      chainId,
      nonce,
      ...signature
    };
  return signature;
}

// node_modules/viem/_esm/accounts/utils/signMessage.js
async function signMessage2({ message, privateKey }) {
  return await sign4({ hash: hashMessage(message), privateKey, to: "hex" });
}

// node_modules/viem/_esm/accounts/utils/signTransaction.js
async function signTransaction2(parameters) {
  const { privateKey, transaction, serializer = serializeTransaction } = parameters;
  const signableTransaction = (() => {
    if (transaction.type === "eip4844")
      return {
        ...transaction,
        sidecars: false
      };
    return transaction;
  })();
  const signature = await sign4({
    hash: keccak256(serializer(signableTransaction)),
    privateKey
  });
  return serializer(transaction, signature);
}

// node_modules/viem/_esm/accounts/utils/signTypedData.js
async function signTypedData2(parameters) {
  const { privateKey, ...typedData } = parameters;
  return await sign4({
    hash: hashTypedData(typedData),
    privateKey,
    to: "hex"
  });
}

// node_modules/viem/_esm/accounts/privateKeyToAccount.js
function privateKeyToAccount(privateKey, options = {}) {
  const { nonceManager: nonceManager2 } = options;
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress(publicKey);
  const account = toAccount({
    address,
    nonceManager: nonceManager2,
    async sign({ hash: hash11 }) {
      return sign4({ hash: hash11, privateKey, to: "hex" });
    },
    async signAuthorization(authorization) {
      return signAuthorization2({ ...authorization, privateKey });
    },
    async signMessage({ message }) {
      return signMessage2({ message, privateKey });
    },
    async signTransaction(transaction, { serializer } = {}) {
      return signTransaction2({ privateKey, transaction, serializer });
    },
    async signTypedData(typedData) {
      return signTypedData2({ ...typedData, privateKey });
    }
  });
  return {
    ...account,
    publicKey,
    source: "privateKey"
  };
}

// node_modules/permissionless/_esm/utils/toOwner.js
async function toOwner({ owner, address }) {
  if ("type" in owner && owner.type === "local") {
    return owner;
  }
  let walletClient = void 0;
  if ("request" in owner) {
    if (!address) {
      try {
        ;
        [address] = await owner.request({
          method: "eth_requestAccounts"
        });
      } catch {
        ;
        [address] = await owner.request({
          method: "eth_accounts"
        });
      }
    }
    if (!address) {
      throw new Error("address is required");
    }
    walletClient = createWalletClient({
      account: address,
      transport: custom3(owner)
    });
  }
  if (!walletClient) {
    walletClient = owner;
  }
  return toAccount({
    address: walletClient.account.address,
    async signMessage({ message }) {
      return walletClient.signMessage({ message });
    },
    async signTypedData(typedData) {
      return getAction(walletClient, signTypedData, "signTypedData")(typedData);
    },
    async signTransaction(_) {
      throw new Error("Smart account signer doesn't need to sign transactions");
    }
  });
}

// node_modules/permissionless/_esm/errors/index.js
var AccountNotFoundError2 = class extends BaseError {
  constructor({ docsPath: docsPath3 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join("\n"), {
      docsPath: docsPath3,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
};

// node_modules/permissionless/_esm/actions/erc7579/supportsModule.js
function parseModuleTypeId(type8) {
  switch (type8) {
    case "validator":
      return BigInt(1);
    case "executor":
      return BigInt(2);
    case "fallback":
      return BigInt(3);
    case "hook":
      return BigInt(4);
    default:
      throw new Error("Invalid module type");
  }
}
async function supportsModule(client, args2) {
  const { account: account_ = client.account } = args2;
  if (!account_) {
    throw new AccountNotFoundError2({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const account = parseAccount(account_);
  const publicClient = account.client;
  const abi11 = [
    {
      name: "supportsModule",
      type: "function",
      stateMutability: "view",
      inputs: [
        {
          type: "uint256",
          name: "moduleTypeId"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    }
  ];
  try {
    return await getAction(publicClient, readContract, "readContract")({
      abi: abi11,
      functionName: "supportsModule",
      args: [parseModuleTypeId(args2.type)],
      address: account.address
    });
  } catch (error4) {
    if (error4 instanceof ContractFunctionExecutionError) {
      const { factory, factoryData } = await account.getFactoryArgs();
      const result = await getAction(publicClient, call, "call")({
        factory,
        factoryData,
        to: account.address,
        data: encodeFunctionData({
          abi: abi11,
          functionName: "supportsModule",
          args: [parseModuleTypeId(args2.type)]
        })
      });
      if (!result || !result.data) {
        throw new Error("accountId result is empty");
      }
      return decodeFunctionResult({
        abi: abi11,
        functionName: "supportsModule",
        data: result.data
      });
    }
    throw error4;
  }
}

// node_modules/permissionless/_esm/utils/encodeInstallModule.js
function encodeInstallModule(parameters) {
  const account = parameters.account;
  if (!account) {
    throw new AccountNotFoundError2({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const modules = Array.isArray(parameters.modules) ? parameters.modules : [parameters.modules];
  return modules.map(({ type: type8, address, context: context15, initData }) => ({
    to: account.address,
    value: BigInt(0),
    data: encodeFunctionData({
      abi: [
        {
          type: "function",
          name: "installModule",
          inputs: [
            {
              name: "moduleType",
              type: "uint256",
              internalType: "uint256"
            },
            {
              name: "module",
              type: "address",
              internalType: "address"
            },
            {
              name: "initData",
              type: "bytes",
              internalType: "bytes"
            }
          ],
          outputs: [],
          stateMutability: "nonpayable"
        }
      ],
      functionName: "installModule",
      args: [
        parseModuleTypeId(type8),
        getAddress(address),
        context15 ?? initData
      ]
    })
  }));
}

// node_modules/permissionless/_esm/actions/erc7579/supportsExecutionMode.js
function parseCallType(callType) {
  switch (callType) {
    case "call":
      return "0x00";
    case "batchcall":
      return "0x01";
    case "delegatecall":
      return "0xff";
  }
}
function encodeExecutionMode({ type: type8, revertOnError, selector, context: context15 }) {
  return encodePacked(["bytes1", "bytes1", "bytes4", "bytes4", "bytes22"], [
    toHex(toBytes(parseCallType(type8), { size: 1 })),
    toHex(toBytes(revertOnError ? "0x01" : "0x00", { size: 1 })),
    toHex(toBytes("0x0", { size: 4 })),
    toHex(toBytes(selector ?? "0x", { size: 4 })),
    toHex(toBytes(context15 ?? "0x", { size: 22 }))
  ]);
}
async function supportsExecutionMode(client, args2) {
  const { account: account_ = client.account, type: type8, revertOnError, selector, context: context15 } = args2;
  if (!account_) {
    throw new AccountNotFoundError2({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  }
  const account = parseAccount(account_);
  const publicClient = account.client;
  const encodedMode = encodeExecutionMode({
    type: type8,
    revertOnError,
    selector,
    context: context15
  });
  const abi11 = [
    {
      name: "supportsExecutionMode",
      type: "function",
      stateMutability: "view",
      inputs: [
        {
          type: "bytes32",
          name: "encodedMode"
        }
      ],
      outputs: [
        {
          type: "bool"
        }
      ]
    }
  ];
  try {
    return await getAction(publicClient, readContract, "readContract")({
      abi: abi11,
      functionName: "supportsExecutionMode",
      args: [encodedMode],
      address: account.address
    });
  } catch (error4) {
    if (error4 instanceof ContractFunctionExecutionError) {
      const { factory, factoryData } = await account.getFactoryArgs();
      const result = await getAction(publicClient, call, "call")({
        factory,
        factoryData,
        to: account.address,
        data: encodeFunctionData({
          abi: abi11,
          functionName: "supportsExecutionMode",
          args: [encodedMode]
        })
      });
      if (!result || !result.data) {
        throw new Error("accountId result is empty");
      }
      return decodeFunctionResult({
        abi: abi11,
        functionName: "supportsExecutionMode",
        data: result.data
      });
    }
    throw error4;
  }
}

// node_modules/permissionless/_esm/utils/encode7579Calls.js
function encode7579Calls({ mode, callData }) {
  if (callData.length > 1 && (mode == null ? void 0 : mode.type) !== "batchcall") {
    throw new Error(`mode ${JSON.stringify(mode)} does not supported for batchcall calldata`);
  }
  const executeAbi = [
    {
      type: "function",
      name: "execute",
      inputs: [
        {
          name: "execMode",
          type: "bytes32",
          internalType: "ExecMode"
        },
        {
          name: "executionCalldata",
          type: "bytes",
          internalType: "bytes"
        }
      ],
      outputs: [],
      stateMutability: "payable"
    }
  ];
  if (callData.length > 1) {
    return encodeFunctionData({
      abi: executeAbi,
      functionName: "execute",
      args: [
        encodeExecutionMode(mode),
        encodeAbiParameters([
          {
            name: "executionBatch",
            type: "tuple[]",
            components: [
              {
                name: "target",
                type: "address"
              },
              {
                name: "value",
                type: "uint256"
              },
              {
                name: "callData",
                type: "bytes"
              }
            ]
          }
        ], [
          callData.map((arg) => {
            return {
              target: arg.to,
              value: arg.value ?? 0n,
              callData: arg.data ?? "0x"
            };
          })
        ])
      ]
    });
  }
  const call2 = callData.length === 0 ? void 0 : callData[0];
  if (!call2) {
    throw new Error("No calls to encode");
  }
  return encodeFunctionData({
    abi: executeAbi,
    functionName: "execute",
    args: [
      encodeExecutionMode(mode),
      concatHex([
        call2.to,
        toHex(call2.value ?? 0n, { size: 32 }),
        call2.data ?? "0x"
      ])
    ]
  });
}

// node_modules/permissionless/_esm/utils/decode7579Calls.js
function decode7579Calls(callData) {
  const executeAbi = [
    {
      type: "function",
      name: "execute",
      inputs: [
        {
          name: "execMode",
          type: "bytes32",
          internalType: "ExecMode"
        },
        {
          name: "executionCalldata",
          type: "bytes",
          internalType: "bytes"
        }
      ],
      outputs: [],
      stateMutability: "payable"
    }
  ];
  const decoded = decodeFunctionData({
    abi: executeAbi,
    data: callData
  });
  const mode = decoded.args[0];
  const executionCalldata = decoded.args[1];
  const callType = slice(mode, 0, 1);
  const revertOnError = slice(mode, 1, 2);
  const selector = slice(mode, 3, 7);
  const context15 = slice(mode, 7);
  let type8;
  switch (BigInt(callType)) {
    case BigInt(0):
      type8 = "call";
      break;
    case BigInt(1):
      type8 = "batchcall";
      break;
    case BigInt(255):
      type8 = "delegatecall";
      break;
    default:
      throw new Error("Invalid call type");
  }
  const decodedMode = {
    type: type8,
    revertOnError: BigInt(revertOnError) === BigInt(1),
    selector,
    context: context15
  };
  if (decodedMode.type === "batchcall") {
    const [calls] = decodeAbiParameters([
      {
        name: "executionBatch",
        type: "tuple[]",
        components: [
          {
            name: "target",
            type: "address"
          },
          {
            name: "value",
            type: "uint256"
          },
          {
            name: "callData",
            type: "bytes"
          }
        ]
      }
    ], executionCalldata);
    return {
      mode: decodedMode,
      callData: calls.map((call2) => ({
        to: call2.target,
        value: call2.value,
        data: call2.callData
      }))
    };
  }
  const to3 = getAddress(slice(executionCalldata, 0, 20));
  const value10 = BigInt(slice(executionCalldata, 20, 52));
  const data = size(executionCalldata) > 52 ? slice(executionCalldata, 52) : "0x";
  return {
    mode: decodedMode,
    callData: [
      {
        to: to3,
        value: value10,
        data
      }
    ]
  };
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var WebAuthnP256_exports = {};
__export(WebAuthnP256_exports, {
  CredentialCreationFailedError: () => CredentialCreationFailedError,
  CredentialRequestFailedError: () => CredentialRequestFailedError,
  createChallenge: () => createChallenge,
  createCredential: () => createCredential,
  getAuthenticatorData: () => getAuthenticatorData,
  getClientDataJSON: () => getClientDataJSON,
  getCredentialCreationOptions: () => getCredentialCreationOptions,
  getCredentialRequestOptions: () => getCredentialRequestOptions,
  getSignPayload: () => getSignPayload,
  sign: () => sign6,
  verify: () => verify2
});

// node_modules/ox/_esm/core/Base64.js
var Base64_exports = {};
__export(Base64_exports, {
  fromBytes: () => fromBytes5,
  fromHex: () => fromHex4,
  fromString: () => fromString7,
  toBytes: () => toBytes6,
  toHex: () => toHex4,
  toString: () => toString4
});
var encoder2 = new TextEncoder();
var decoder3 = new TextDecoder();
var integerToCharacter = Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a, i) => [i, a.charCodeAt(0)]));
var characterToInteger = {
  ...Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a, i) => [a.charCodeAt(0), i])),
  ["=".charCodeAt(0)]: 0,
  ["-".charCodeAt(0)]: 62,
  ["_".charCodeAt(0)]: 63
};
function fromBytes5(value10, options = {}) {
  const { pad: pad4 = true, url: url3 = false } = options;
  const encoded = new Uint8Array(Math.ceil(value10.length / 3) * 4);
  for (let i = 0, j = 0; j < value10.length; i += 4, j += 3) {
    const y = (value10[j] << 16) + (value10[j + 1] << 8) + (value10[j + 2] | 0);
    encoded[i] = integerToCharacter[y >> 18];
    encoded[i + 1] = integerToCharacter[y >> 12 & 63];
    encoded[i + 2] = integerToCharacter[y >> 6 & 63];
    encoded[i + 3] = integerToCharacter[y & 63];
  }
  const k = value10.length % 3;
  const end7 = Math.floor(value10.length / 3) * 4 + (k && k + 1);
  let base643 = decoder3.decode(new Uint8Array(encoded.buffer, 0, end7));
  if (pad4 && k === 1)
    base643 += "==";
  if (pad4 && k === 2)
    base643 += "=";
  if (url3)
    base643 = base643.replaceAll("+", "-").replaceAll("/", "_");
  return base643;
}
function fromHex4(value10, options = {}) {
  return fromBytes5(fromHex(value10), options);
}
function fromString7(value10, options = {}) {
  return fromBytes5(fromString(value10), options);
}
function toBytes6(value10) {
  const base643 = value10.replace(/=+$/, "");
  const size45 = base643.length;
  const decoded = new Uint8Array(size45 + 3);
  encoder2.encodeInto(base643 + "===", decoded);
  for (let i = 0, j = 0; i < base643.length; i += 4, j += 3) {
    const x = (characterToInteger[decoded[i]] << 18) + (characterToInteger[decoded[i + 1]] << 12) + (characterToInteger[decoded[i + 2]] << 6) + characterToInteger[decoded[i + 3]];
    decoded[j] = x >> 16;
    decoded[j + 1] = x >> 8 & 255;
    decoded[j + 2] = x & 255;
  }
  const decodedSize = (size45 >> 2) * 3 + (size45 % 4 && size45 % 4 - 1);
  return new Uint8Array(decoded.buffer, 0, decodedSize);
}
function toHex4(value10) {
  return fromBytes(toBytes6(value10));
}
function toString4(value10) {
  return toString(toBytes6(value10));
}

// node_modules/ox/_esm/core/P256.js
var P256_exports = {};
__export(P256_exports, {
  getPublicKey: () => getPublicKey,
  noble: () => noble,
  randomPrivateKey: () => randomPrivateKey,
  recoverPublicKey: () => recoverPublicKey2,
  sign: () => sign5,
  verify: () => verify
});

// node_modules/@noble/curves/esm/nist.js
var p256_CURVE = {
  p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  h: BigInt(1),
  a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),
  b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")
};
var p384_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),
  n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),
  h: BigInt(1),
  a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),
  b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),
  Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),
  Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")
};
var p521_CURVE = {
  p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
  n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),
  h: BigInt(1),
  a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),
  b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),
  Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),
  Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")
};
var Fp256 = Field(p256_CURVE.p);
var Fp384 = Field(p384_CURVE.p);
var Fp521 = Field(p521_CURVE.p);
function createSWU(field, opts) {
  const map49 = mapToCurveSimpleSWU(field, opts);
  return (scalars) => map49(scalars[0]);
}
var p256 = createCurve({ ...p256_CURVE, Fp: Fp256, lowS: false }, sha256);
var p256_hasher = (() => {
  return createHasher2(p256.Point, createSWU(Fp256, {
    A: p256_CURVE.a,
    B: p256_CURVE.b,
    Z: Fp256.create(BigInt("-10"))
  }), {
    DST: "P256_XMD:SHA-256_SSWU_RO_",
    encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
    p: p256_CURVE.p,
    m: 1,
    k: 128,
    expand: "xmd",
    hash: sha256
  });
})();
var p384 = createCurve({ ...p384_CURVE, Fp: Fp384, lowS: false }, sha384);
var p384_hasher = (() => {
  return createHasher2(p384.Point, createSWU(Fp384, {
    A: p384_CURVE.a,
    B: p384_CURVE.b,
    Z: Fp384.create(BigInt("-12"))
  }), {
    DST: "P384_XMD:SHA-384_SSWU_RO_",
    encodeDST: "P384_XMD:SHA-384_SSWU_NU_",
    p: p384_CURVE.p,
    m: 1,
    k: 192,
    expand: "xmd",
    hash: sha384
  });
})();
var p521 = createCurve({ ...p521_CURVE, Fp: Fp521, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, sha512);
var p521_hasher = (() => {
  return createHasher2(p521.Point, createSWU(Fp521, {
    A: p521_CURVE.a,
    B: p521_CURVE.b,
    Z: Fp521.create(BigInt("-4"))
  }), {
    DST: "P521_XMD:SHA-512_SSWU_RO_",
    encodeDST: "P521_XMD:SHA-512_SSWU_NU_",
    p: p521_CURVE.p,
    m: 1,
    k: 256,
    expand: "xmd",
    hash: sha512
  });
})();

// node_modules/@noble/curves/esm/p256.js
var p2562 = p256;
var secp256r1 = p256;
var hashToCurve = (() => p256_hasher.hashToCurve)();
var encodeToCurve = (() => p256_hasher.encodeToCurve)();

// node_modules/ox/_esm/core/internal/entropy.js
var extraEntropy2 = false;

// node_modules/ox/_esm/core/P256.js
var noble = secp256r1;
function getPublicKey(options) {
  const { privateKey } = options;
  const point = secp256r1.ProjectivePoint.fromPrivateKey(typeof privateKey === "string" ? privateKey.slice(2) : fromBytes(privateKey).slice(2));
  return from3(point);
}
function randomPrivateKey(options = {}) {
  const { as: as18 = "Hex" } = options;
  const bytes = secp256r1.utils.randomPrivateKey();
  if (as18 === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function recoverPublicKey2(options) {
  const { payload, signature } = options;
  const { r, s, yParity } = signature;
  const signature_ = new secp256r1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);
  const payload_ = payload instanceof Uint8Array ? fromBytes(payload) : payload;
  const point = signature_.recoverPublicKey(payload_.substring(2));
  return from3(point);
}
function sign5(options) {
  const { extraEntropy: extraEntropy3 = extraEntropy2, hash: hash11, payload, privateKey } = options;
  const { r, s, recovery } = secp256r1.sign(payload instanceof Uint8Array ? payload : fromHex(payload), privateKey instanceof Uint8Array ? privateKey : fromHex(privateKey), {
    extraEntropy: typeof extraEntropy3 === "boolean" ? extraEntropy3 : from2(extraEntropy3).slice(2),
    lowS: true,
    ...hash11 ? { prehash: true } : {}
  });
  return {
    r,
    s,
    yParity: recovery
  };
}
function verify(options) {
  const { hash: hash11, payload, publicKey, signature } = options;
  return secp256r1.verify(signature, payload instanceof Uint8Array ? payload : fromHex(payload), toHex3(publicKey).substring(2), ...hash11 ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/internal/webauthn.js
function parseAsn1Signature(bytes) {
  const r_start = bytes[4] === 0 ? 5 : 4;
  const r_end = r_start + 32;
  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;
  const r = BigInt(fromBytes(bytes.slice(r_start, r_end)));
  const s = BigInt(fromBytes(bytes.slice(s_start)));
  return {
    r,
    s: s > p2562.CURVE.n / 2n ? p2562.CURVE.n - s : s
  };
}
async function parseCredentialPublicKey(response) {
  try {
    const publicKeyBuffer = response.getPublicKey();
    if (!publicKeyBuffer)
      throw new CredentialCreationFailedError();
    const publicKeyBytes = new Uint8Array(publicKeyBuffer);
    const cryptoKey = await crypto.subtle.importKey("spki", new Uint8Array(publicKeyBytes), {
      name: "ECDSA",
      namedCurve: "P-256",
      hash: "SHA-256"
    }, true, ["verify"]);
    const publicKey = new Uint8Array(await crypto.subtle.exportKey("raw", cryptoKey));
    return from3(publicKey);
  } catch (error4) {
    if (error4.message !== "Permission denied to access object")
      throw error4;
    const data = new Uint8Array(response.attestationObject);
    const coordinateLength = 32;
    const cborPrefix = 88;
    const findStart = (key) => {
      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);
      for (let i = 0; i < data.length - coordinate.length; i++)
        if (coordinate.every((byte, j) => data[i + j] === byte))
          return i + coordinate.length;
      throw new CredentialCreationFailedError();
    };
    const xStart = findStart(33);
    const yStart = findStart(34);
    return from3(new Uint8Array([
      4,
      ...data.slice(xStart, xStart + coordinateLength),
      ...data.slice(yStart, yStart + coordinateLength)
    ]));
  }
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var createChallenge = Uint8Array.from([
  105,
  171,
  180,
  181,
  160,
  222,
  75,
  198,
  42,
  42,
  32,
  31,
  141,
  37,
  186,
  233
]);
async function createCredential(options) {
  const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options;
  const creationOptions = getCredentialCreationOptions(rest);
  try {
    const credential = await createFn(creationOptions);
    if (!credential)
      throw new CredentialCreationFailedError();
    const response = credential.response;
    const publicKey = await parseCredentialPublicKey(response);
    return {
      id: credential.id,
      publicKey,
      raw: credential
    };
  } catch (error4) {
    throw new CredentialCreationFailedError({
      cause: error4
    });
  }
}
function getAuthenticatorData(options = {}) {
  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options;
  const rpIdHash = sha2564(fromString2(rpId));
  const flag_bytes = fromNumber2(flag, { size: 1 });
  const signCount_bytes = fromNumber2(signCount, { size: 4 });
  return concat3(rpIdHash, flag_bytes, signCount_bytes);
}
function getClientDataJSON(options) {
  const { challenge, crossOrigin = false, extraClientData, origin = window.location.origin } = options;
  return JSON.stringify({
    type: "webauthn.get",
    challenge: fromHex4(challenge, { url: true, pad: false }),
    origin,
    crossOrigin,
    ...extraClientData
  });
}
function getCredentialCreationOptions(options) {
  const { attestation = "none", authenticatorSelection = {
    residentKey: "preferred",
    requireResidentKey: false,
    userVerification: "required"
  }, challenge = createChallenge, excludeCredentialIds, name: name_, rp = {
    id: window.location.hostname,
    name: window.document.title
  }, user, extensions } = options;
  const name = (user == null ? void 0 : user.name) ?? name_;
  return {
    publicKey: {
      attestation,
      authenticatorSelection,
      challenge,
      ...excludeCredentialIds ? {
        excludeCredentials: excludeCredentialIds == null ? void 0 : excludeCredentialIds.map((id3) => ({
          id: toBytes6(id3),
          type: "public-key"
        }))
      } : {},
      pubKeyCredParams: [
        {
          type: "public-key",
          alg: -7
          // p256
        }
      ],
      rp,
      user: {
        id: (user == null ? void 0 : user.id) ?? keccak2562(fromString(name), { as: "Bytes" }),
        name,
        displayName: (user == null ? void 0 : user.displayName) ?? name
      },
      extensions
    }
  };
}
function getCredentialRequestOptions(options) {
  const { credentialId, challenge, rpId = window.location.hostname, userVerification = "required" } = options;
  return {
    publicKey: {
      ...credentialId ? {
        allowCredentials: Array.isArray(credentialId) ? credentialId.map((id3) => ({
          id: toBytes6(id3),
          type: "public-key"
        })) : [
          {
            id: toBytes6(credentialId),
            type: "public-key"
          }
        ]
      } : {},
      challenge: fromHex(challenge),
      rpId,
      userVerification
    }
  };
}
function getSignPayload(options) {
  const { challenge, crossOrigin, extraClientData, flag, origin, rpId, signCount, userVerification = "required" } = options;
  const authenticatorData = getAuthenticatorData({
    flag,
    rpId,
    signCount
  });
  const clientDataJSON = getClientDataJSON({
    challenge,
    crossOrigin,
    extraClientData,
    origin
  });
  const clientDataJSONHash = sha2564(fromString2(clientDataJSON));
  const challengeIndex = clientDataJSON.indexOf('"challenge"');
  const typeIndex = clientDataJSON.indexOf('"type"');
  const metadata = {
    authenticatorData,
    clientDataJSON,
    challengeIndex,
    typeIndex,
    userVerificationRequired: userVerification === "required"
  };
  const payload = concat3(authenticatorData, clientDataJSONHash);
  return { metadata, payload };
}
async function sign6(options) {
  const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options;
  const requestOptions = getCredentialRequestOptions(rest);
  try {
    const credential = await getFn(requestOptions);
    if (!credential)
      throw new CredentialRequestFailedError();
    const response = credential.response;
    const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));
    const challengeIndex = clientDataJSON.indexOf('"challenge"');
    const typeIndex = clientDataJSON.indexOf('"type"');
    const signature = parseAsn1Signature(new Uint8Array(response.signature));
    return {
      metadata: {
        authenticatorData: fromBytes(new Uint8Array(response.authenticatorData)),
        clientDataJSON,
        challengeIndex,
        typeIndex,
        userVerificationRequired: requestOptions.publicKey.userVerification === "required"
      },
      signature,
      raw: credential
    };
  } catch (error4) {
    throw new CredentialRequestFailedError({
      cause: error4
    });
  }
}
function verify2(options) {
  const { challenge, hash: hash11 = true, metadata, publicKey, signature } = options;
  const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired } = metadata;
  const authenticatorDataBytes = fromHex(authenticatorData);
  if (authenticatorDataBytes.length < 37)
    return false;
  const flag = authenticatorDataBytes[32];
  if ((flag & 1) !== 1)
    return false;
  if (userVerificationRequired && (flag & 4) !== 4)
    return false;
  if ((flag & 8) !== 8 && (flag & 16) === 16)
    return false;
  const type8 = '"type":"webauthn.get"';
  if (type8 !== clientDataJSON.slice(Number(typeIndex), type8.length + 1))
    return false;
  const match43 = clientDataJSON.slice(Number(challengeIndex)).match(/^"challenge":"(.*?)"/);
  if (!match43)
    return false;
  const [_, challenge_extracted] = match43;
  if (fromBytes(toBytes6(challenge_extracted)) !== challenge)
    return false;
  const clientDataJSONHash = sha2564(fromString(clientDataJSON), {
    as: "Bytes"
  });
  const payload = concat2(authenticatorDataBytes, clientDataJSONHash);
  return verify({
    hash: hash11,
    payload,
    publicKey,
    signature
  });
}
var CredentialCreationFailedError = class extends BaseError2 {
  constructor({ cause: cause3 } = {}) {
    super("Failed to create credential.", {
      cause: cause3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialCreationFailedError"
    });
  }
};
var CredentialRequestFailedError = class extends BaseError2 {
  constructor({ cause: cause3 } = {}) {
    super("Failed to request credential.", {
      cause: cause3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialRequestFailedError"
    });
  }
};

// node_modules/ox/_esm/core/Signature.js
var Signature_exports = {};
__export(Signature_exports, {
  InvalidRError: () => InvalidRError,
  InvalidSError: () => InvalidSError,
  InvalidSerializedSizeError: () => InvalidSerializedSizeError2,
  InvalidVError: () => InvalidVError,
  InvalidYParityError: () => InvalidYParityError,
  MissingPropertiesError: () => MissingPropertiesError,
  assert: () => assert7,
  extract: () => extract2,
  from: () => from9,
  fromBytes: () => fromBytes6,
  fromDerBytes: () => fromDerBytes,
  fromDerHex: () => fromDerHex,
  fromHex: () => fromHex5,
  fromLegacy: () => fromLegacy,
  fromRpc: () => fromRpc2,
  fromTuple: () => fromTuple,
  toBytes: () => toBytes7,
  toDerBytes: () => toDerBytes,
  toDerHex: () => toDerHex,
  toHex: () => toHex5,
  toLegacy: () => toLegacy,
  toRpc: () => toRpc3,
  toTuple: () => toTuple,
  vToYParity: () => vToYParity,
  validate: () => validate13,
  yParityToV: () => yParityToV
});
function assert7(signature, options = {}) {
  const { recovered } = options;
  if (typeof signature.r === "undefined")
    throw new MissingPropertiesError({ signature });
  if (typeof signature.s === "undefined")
    throw new MissingPropertiesError({ signature });
  if (recovered && typeof signature.yParity === "undefined")
    throw new MissingPropertiesError({ signature });
  if (signature.r < 0n || signature.r > maxUint2562)
    throw new InvalidRError({ value: signature.r });
  if (signature.s < 0n || signature.s > maxUint2562)
    throw new InvalidSError({ value: signature.s });
  if (typeof signature.yParity === "number" && signature.yParity !== 0 && signature.yParity !== 1)
    throw new InvalidYParityError({ value: signature.yParity });
}
function fromBytes6(signature) {
  return fromHex5(fromBytes(signature));
}
function fromHex5(signature) {
  if (signature.length !== 130 && signature.length !== 132)
    throw new InvalidSerializedSizeError2({ signature });
  const r = BigInt(slice3(signature, 0, 32));
  const s = BigInt(slice3(signature, 32, 64));
  const yParity = (() => {
    const yParity2 = Number(`0x${signature.slice(130)}`);
    if (Number.isNaN(yParity2))
      return void 0;
    try {
      return vToYParity(yParity2);
    } catch {
      throw new InvalidYParityError({ value: yParity2 });
    }
  })();
  if (typeof yParity === "undefined")
    return {
      r,
      s
    };
  return {
    r,
    s,
    yParity
  };
}
function extract2(value10) {
  if (typeof value10.r === "undefined")
    return void 0;
  if (typeof value10.s === "undefined")
    return void 0;
  return from9(value10);
}
function from9(signature) {
  const signature_ = (() => {
    if (typeof signature === "string")
      return fromHex5(signature);
    if (signature instanceof Uint8Array)
      return fromBytes6(signature);
    if (typeof signature.r === "string")
      return fromRpc2(signature);
    if (signature.v)
      return fromLegacy(signature);
    return {
      r: signature.r,
      s: signature.s,
      ...typeof signature.yParity !== "undefined" ? { yParity: signature.yParity } : {}
    };
  })();
  assert7(signature_);
  return signature_;
}
function fromDerBytes(signature) {
  return fromDerHex(fromBytes(signature));
}
function fromDerHex(signature) {
  const { r, s } = secp256k1.Signature.fromDER(from2(signature).slice(2));
  return { r, s };
}
function fromLegacy(signature) {
  return {
    r: signature.r,
    s: signature.s,
    yParity: vToYParity(signature.v)
  };
}
function fromRpc2(signature) {
  const yParity = (() => {
    const v = signature.v ? Number(signature.v) : void 0;
    let yParity2 = signature.yParity ? Number(signature.yParity) : void 0;
    if (typeof v === "number" && typeof yParity2 !== "number")
      yParity2 = vToYParity(v);
    if (typeof yParity2 !== "number")
      throw new InvalidYParityError({ value: signature.yParity });
    return yParity2;
  })();
  return {
    r: BigInt(signature.r),
    s: BigInt(signature.s),
    yParity
  };
}
function fromTuple(tuple7) {
  const [yParity, r, s] = tuple7;
  return from9({
    r: r === "0x" ? 0n : BigInt(r),
    s: s === "0x" ? 0n : BigInt(s),
    yParity: yParity === "0x" ? 0 : Number(yParity)
  });
}
function toBytes7(signature) {
  return fromHex(toHex5(signature));
}
function toHex5(signature) {
  assert7(signature);
  const r = signature.r;
  const s = signature.s;
  const signature_ = concat3(
    fromNumber2(r, { size: 32 }),
    fromNumber2(s, { size: 32 }),
    // If the signature is recovered, add the recovery byte to the signature.
    typeof signature.yParity === "number" ? fromNumber2(yParityToV(signature.yParity), { size: 1 }) : "0x"
  );
  return signature_;
}
function toDerBytes(signature) {
  const sig = new secp256k1.Signature(signature.r, signature.s);
  return sig.toDERRawBytes();
}
function toDerHex(signature) {
  const sig = new secp256k1.Signature(signature.r, signature.s);
  return `0x${sig.toDERHex()}`;
}
function toLegacy(signature) {
  return {
    r: signature.r,
    s: signature.s,
    v: yParityToV(signature.yParity)
  };
}
function toRpc3(signature) {
  const { r, s, yParity } = signature;
  return {
    r: fromNumber2(r, { size: 32 }),
    s: fromNumber2(s, { size: 32 }),
    yParity: yParity === 0 ? "0x0" : "0x1"
  };
}
function toTuple(signature) {
  const { r, s, yParity } = signature;
  return [
    yParity ? "0x01" : "0x",
    r === 0n ? "0x" : trimLeft2(fromNumber2(r)),
    s === 0n ? "0x" : trimLeft2(fromNumber2(s))
  ];
}
function validate13(signature, options = {}) {
  try {
    assert7(signature, options);
    return true;
  } catch {
    return false;
  }
}
function vToYParity(v) {
  if (v === 0 || v === 27)
    return 0;
  if (v === 1 || v === 28)
    return 1;
  if (v >= 35)
    return v % 2 === 0 ? 1 : 0;
  throw new InvalidVError({ value: v });
}
function yParityToV(yParity) {
  if (yParity === 0)
    return 27;
  if (yParity === 1)
    return 28;
  throw new InvalidYParityError({ value: yParity });
}
var InvalidSerializedSizeError2 = class extends BaseError2 {
  constructor({ signature }) {
    super(`Value \`${signature}\` is an invalid signature size.`, {
      metaMessages: [
        "Expected: 64 bytes or 65 bytes.",
        `Received ${size3(from2(signature))} bytes.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidSerializedSizeError"
    });
  }
};
var MissingPropertiesError = class extends BaseError2 {
  constructor({ signature }) {
    super(`Signature \`${stringify2(signature)}\` is missing either an \`r\`, \`s\`, or \`yParity\` property.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.MissingPropertiesError"
    });
  }
};
var InvalidRError = class extends BaseError2 {
  constructor({ value: value10 }) {
    super(`Value \`${value10}\` is an invalid r value. r must be a positive integer less than 2^256.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidRError"
    });
  }
};
var InvalidSError = class extends BaseError2 {
  constructor({ value: value10 }) {
    super(`Value \`${value10}\` is an invalid s value. s must be a positive integer less than 2^256.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidSError"
    });
  }
};
var InvalidYParityError = class extends BaseError2 {
  constructor({ value: value10 }) {
    super(`Value \`${value10}\` is an invalid y-parity value. Y-parity must be 0 or 1.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidYParityError"
    });
  }
};
var InvalidVError = class extends BaseError2 {
  constructor({ value: value10 }) {
    super(`Value \`${value10}\` is an invalid v value. v must be 27, 28 or >=35.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidVError"
    });
  }
};

// node_modules/viem/_esm/account-abstraction/constants/abis.js
var entryPoint06Abi = [
  {
    inputs: [
      { name: "preOpGas", type: "uint256" },
      { name: "paid", type: "uint256" },
      { name: "validAfter", type: "uint48" },
      { name: "validUntil", type: "uint48" },
      { name: "targetSuccess", type: "bool" },
      { name: "targetResult", type: "bytes" }
    ],
    name: "ExecutionResult",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          { name: "preOpGas", type: "uint256" },
          { name: "prefund", type: "uint256" },
          { name: "sigFailed", type: "bool" },
          { name: "validAfter", type: "uint48" },
          { name: "validUntil", type: "uint48" },
          { name: "paymasterContext", type: "bytes" }
        ],
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "paymasterInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResult",
    type: "error"
  },
  {
    inputs: [
      {
        components: [
          { name: "preOpGas", type: "uint256" },
          { name: "prefund", type: "uint256" },
          { name: "sigFailed", type: "bool" },
          { name: "validAfter", type: "uint48" },
          { name: "validUntil", type: "uint48" },
          { name: "paymasterContext", type: "bytes" }
        ],
        name: "returnInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "senderInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "factoryInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "stake", type: "uint256" },
          { name: "unstakeDelaySec", type: "uint256" }
        ],
        name: "paymasterInfo",
        type: "tuple"
      },
      {
        components: [
          { name: "aggregator", type: "address" },
          {
            components: [
              { name: "stake", type: "uint256" },
              {
                name: "unstakeDelaySec",
                type: "uint256"
              }
            ],
            name: "stakeInfo",
            type: "tuple"
          }
        ],
        name: "aggregatorInfo",
        type: "tuple"
      }
    ],
    name: "ValidationResultWithAggregation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      { indexed: false, name: "success", type: "bool" },
      {
        indexed: false,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [],
    name: "SIG_VALIDATION_FAILED",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "initCode", type: "bytes" },
      { name: "sender", type: "address" },
      { name: "paymasterAndData", type: "bytes" }
    ],
    name: "_validateSenderAndPaymaster",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint112" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint112" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "op",
        type: "tuple"
      },
      { name: "target", type: "address" },
      { name: "targetCallData", type: "bytes" }
    ],
    name: "simulateHandleOp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          { name: "callGasLimit", type: "uint256" },
          {
            name: "verificationGasLimit",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "maxFeePerGas", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            type: "uint256"
          },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "simulateValidation",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];
var entryPoint07Abi = [
  {
    inputs: [
      { name: "success", type: "bool" },
      { name: "ret", type: "bytes" }
    ],
    name: "DelegateAndRevert",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" }
    ],
    name: "FailedOp",
    type: "error"
  },
  {
    inputs: [
      { name: "opIndex", type: "uint256" },
      { name: "reason", type: "string" },
      { name: "inner", type: "bytes" }
    ],
    name: "FailedOpWithRevert",
    type: "error"
  },
  {
    inputs: [{ name: "returnData", type: "bytes" }],
    name: "PostOpReverted",
    type: "error"
  },
  { inputs: [], name: "ReentrancyGuardReentrantCall", type: "error" },
  {
    inputs: [{ name: "sender", type: "address" }],
    name: "SenderAddressResult",
    type: "error"
  },
  {
    inputs: [{ name: "aggregator", type: "address" }],
    name: "SignatureValidationFailed",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "factory",
        type: "address"
      },
      {
        indexed: false,
        name: "paymaster",
        type: "address"
      }
    ],
    name: "AccountDeployed",
    type: "event"
  },
  { anonymous: false, inputs: [], name: "BeforeExecution", type: "event" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalDeposit",
        type: "uint256"
      }
    ],
    name: "Deposited",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "PostOpRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "aggregator",
        type: "address"
      }
    ],
    name: "SignatureAggregatorChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "totalStaked",
        type: "uint256"
      },
      {
        indexed: false,
        name: "unstakeDelaySec",
        type: "uint256"
      }
    ],
    name: "StakeLocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawTime",
        type: "uint256"
      }
    ],
    name: "StakeUnlocked",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "StakeWithdrawn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: true,
        name: "paymaster",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      { indexed: false, name: "success", type: "bool" },
      {
        indexed: false,
        name: "actualGasCost",
        type: "uint256"
      },
      {
        indexed: false,
        name: "actualGasUsed",
        type: "uint256"
      }
    ],
    name: "UserOperationEvent",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      }
    ],
    name: "UserOperationPrefundTooLow",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "userOpHash",
        type: "bytes32"
      },
      {
        indexed: true,
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        name: "nonce",
        type: "uint256"
      },
      {
        indexed: false,
        name: "revertReason",
        type: "bytes"
      }
    ],
    name: "UserOperationRevertReason",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "account",
        type: "address"
      },
      {
        indexed: false,
        name: "withdrawAddress",
        type: "address"
      },
      {
        indexed: false,
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Withdrawn",
    type: "event"
  },
  {
    inputs: [{ name: "unstakeDelaySec", type: "uint32" }],
    name: "addStake",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "target", type: "address" },
      { name: "data", type: "bytes" }
    ],
    name: "delegateAndRevert",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "depositTo",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [{ name: "", type: "address" }],
    name: "deposits",
    outputs: [
      { name: "deposit", type: "uint256" },
      { name: "staked", type: "bool" },
      { name: "stake", type: "uint112" },
      { name: "unstakeDelaySec", type: "uint32" },
      { name: "withdrawTime", type: "uint48" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "account", type: "address" }],
    name: "getDepositInfo",
    outputs: [
      {
        components: [
          { name: "deposit", type: "uint256" },
          { name: "staked", type: "bool" },
          { name: "stake", type: "uint112" },
          { name: "unstakeDelaySec", type: "uint32" },
          { name: "withdrawTime", type: "uint48" }
        ],
        name: "info",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { name: "sender", type: "address" },
      { name: "key", type: "uint192" }
    ],
    name: "getNonce",
    outputs: [{ name: "nonce", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "initCode", type: "bytes" }],
    name: "getSenderAddress",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "userOp",
        type: "tuple"
      }
    ],
    name: "getUserOpHash",
    outputs: [{ name: "", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              { name: "initCode", type: "bytes" },
              { name: "callData", type: "bytes" },
              {
                name: "accountGasLimits",
                type: "bytes32"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "gasFees", type: "bytes32" },
              {
                name: "paymasterAndData",
                type: "bytes"
              },
              { name: "signature", type: "bytes" }
            ],
            name: "userOps",
            type: "tuple[]"
          },
          {
            name: "aggregator",
            type: "address"
          },
          { name: "signature", type: "bytes" }
        ],
        name: "opsPerAggregator",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleAggregatedOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { name: "sender", type: "address" },
          { name: "nonce", type: "uint256" },
          { name: "initCode", type: "bytes" },
          { name: "callData", type: "bytes" },
          {
            name: "accountGasLimits",
            type: "bytes32"
          },
          {
            name: "preVerificationGas",
            type: "uint256"
          },
          { name: "gasFees", type: "bytes32" },
          { name: "paymasterAndData", type: "bytes" },
          { name: "signature", type: "bytes" }
        ],
        name: "ops",
        type: "tuple[]"
      },
      { name: "beneficiary", type: "address" }
    ],
    name: "handleOps",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "key", type: "uint192" }],
    name: "incrementNonce",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "callData", type: "bytes" },
      {
        components: [
          {
            components: [
              { name: "sender", type: "address" },
              { name: "nonce", type: "uint256" },
              {
                name: "verificationGasLimit",
                type: "uint256"
              },
              {
                name: "callGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterVerificationGasLimit",
                type: "uint256"
              },
              {
                name: "paymasterPostOpGasLimit",
                type: "uint256"
              },
              {
                name: "preVerificationGas",
                type: "uint256"
              },
              { name: "paymaster", type: "address" },
              {
                name: "maxFeePerGas",
                type: "uint256"
              },
              {
                name: "maxPriorityFeePerGas",
                type: "uint256"
              }
            ],
            name: "mUserOp",
            type: "tuple"
          },
          { name: "userOpHash", type: "bytes32" },
          { name: "prefund", type: "uint256" },
          { name: "contextOffset", type: "uint256" },
          { name: "preOpGas", type: "uint256" }
        ],
        name: "opInfo",
        type: "tuple"
      },
      { name: "context", type: "bytes" }
    ],
    name: "innerHandleOp",
    outputs: [{ name: "actualGasCost", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "", type: "address" },
      { name: "", type: "uint192" }
    ],
    name: "nonceSequenceNumber",
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "unlockStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      }
    ],
    name: "withdrawStake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        name: "withdrawAddress",
        type: "address"
      },
      { name: "withdrawAmount", type: "uint256" }
    ],
    name: "withdrawTo",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

// node_modules/viem/_esm/account-abstraction/utils/userOperation/getInitCode.js
function getInitCode(userOperation) {
  const { authorization, factory, factoryData } = userOperation;
  if (factory === "0x7702" || factory === "0x7702000000000000000000000000000000000000") {
    if (!authorization)
      return "0x7702000000000000000000000000000000000000";
    const delegation = authorization.address;
    return concat([delegation, factoryData ?? "0x"]);
  }
  if (!factory)
    return "0x";
  return concat([factory, factoryData ?? "0x"]);
}

// node_modules/viem/_esm/account-abstraction/utils/userOperation/toPackedUserOperation.js
function toPackedUserOperation(userOperation) {
  const { callGasLimit, callData, maxPriorityFeePerGas, maxFeePerGas, paymaster, paymasterData, paymasterPostOpGasLimit, paymasterVerificationGasLimit, sender, signature = "0x", verificationGasLimit } = userOperation;
  const accountGasLimits = concat([
    pad(numberToHex(verificationGasLimit || 0n), { size: 16 }),
    pad(numberToHex(callGasLimit || 0n), { size: 16 })
  ]);
  const initCode = getInitCode(userOperation);
  const gasFees = concat([
    pad(numberToHex(maxPriorityFeePerGas || 0n), { size: 16 }),
    pad(numberToHex(maxFeePerGas || 0n), { size: 16 })
  ]);
  const nonce = userOperation.nonce ?? 0n;
  const paymasterAndData = paymaster ? concat([
    paymaster,
    pad(numberToHex(paymasterVerificationGasLimit || 0n), {
      size: 16
    }),
    pad(numberToHex(paymasterPostOpGasLimit || 0n), {
      size: 16
    }),
    paymasterData || "0x"
  ]) : "0x";
  const preVerificationGas = userOperation.preVerificationGas ?? 0n;
  return {
    accountGasLimits,
    callData,
    initCode,
    gasFees,
    nonce,
    paymasterAndData,
    preVerificationGas,
    sender,
    signature
  };
}

// node_modules/viem/_esm/account-abstraction/utils/userOperation/getUserOperationTypedData.js
var types2 = {
  PackedUserOperation: [
    { type: "address", name: "sender" },
    { type: "uint256", name: "nonce" },
    { type: "bytes", name: "initCode" },
    { type: "bytes", name: "callData" },
    { type: "bytes32", name: "accountGasLimits" },
    { type: "uint256", name: "preVerificationGas" },
    { type: "bytes32", name: "gasFees" },
    { type: "bytes", name: "paymasterAndData" }
  ]
};
function getUserOperationTypedData(parameters) {
  const { chainId, entryPointAddress, userOperation } = parameters;
  const packedUserOp = toPackedUserOperation(userOperation);
  return {
    types: types2,
    primaryType: "PackedUserOperation",
    domain: {
      name: "ERC4337",
      version: "1",
      chainId,
      verifyingContract: entryPointAddress
    },
    message: packedUserOp
  };
}

// node_modules/viem/_esm/account-abstraction/utils/userOperation/getUserOperationHash.js
function getUserOperationHash(parameters) {
  const { chainId, entryPointAddress, entryPointVersion } = parameters;
  const userOperation = parameters.userOperation;
  const { authorization, callData = "0x", callGasLimit, maxFeePerGas, maxPriorityFeePerGas, nonce, paymasterAndData = "0x", preVerificationGas, sender, verificationGasLimit } = userOperation;
  if (entryPointVersion === "0.8")
    return hashTypedData(getUserOperationTypedData({
      chainId,
      entryPointAddress,
      userOperation
    }));
  const packedUserOp = (() => {
    var _a106, _b32;
    if (entryPointVersion === "0.6") {
      const factory = (_a106 = userOperation.initCode) == null ? void 0 : _a106.slice(0, 42);
      const factoryData = (_b32 = userOperation.initCode) == null ? void 0 : _b32.slice(42);
      const initCode = getInitCode({
        authorization,
        factory,
        factoryData
      });
      return encodeAbiParameters([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "uint256" },
        { type: "bytes32" }
      ], [
        sender,
        nonce,
        keccak256(initCode),
        keccak256(callData),
        callGasLimit,
        verificationGasLimit,
        preVerificationGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        keccak256(paymasterAndData)
      ]);
    }
    if (entryPointVersion === "0.7") {
      const packedUserOp2 = toPackedUserOperation(userOperation);
      return encodeAbiParameters([
        { type: "address" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "bytes32" },
        { type: "uint256" },
        { type: "bytes32" },
        { type: "bytes32" }
      ], [
        packedUserOp2.sender,
        packedUserOp2.nonce,
        keccak256(packedUserOp2.initCode),
        keccak256(packedUserOp2.callData),
        packedUserOp2.accountGasLimits,
        packedUserOp2.preVerificationGas,
        packedUserOp2.gasFees,
        keccak256(packedUserOp2.paymasterAndData)
      ]);
    }
    throw new Error(`entryPointVersion "${entryPointVersion}" not supported.`);
  })();
  return keccak256(encodeAbiParameters([{ type: "bytes32" }, { type: "address" }, { type: "uint256" }], [keccak256(packedUserOp), entryPointAddress, BigInt(chainId)]));
}

// node_modules/viem/_esm/account-abstraction/accounts/toSmartAccount.js
async function toSmartAccount(implementation) {
  const { extend: extend5, nonceKeyManager = createNonceManager({
    source: {
      get() {
        return Date.now();
      },
      set() {
      }
    }
  }), ...rest } = implementation;
  let deployed = false;
  const address = await implementation.getAddress();
  return {
    ...extend5,
    ...rest,
    address,
    async getFactoryArgs() {
      if ("isDeployed" in this && await this.isDeployed())
        return { factory: void 0, factoryData: void 0 };
      return implementation.getFactoryArgs();
    },
    async getNonce(parameters) {
      const key = (parameters == null ? void 0 : parameters.key) ?? BigInt(await nonceKeyManager.consume({
        address,
        chainId: implementation.client.chain.id,
        client: implementation.client
      }));
      if (implementation.getNonce)
        return await implementation.getNonce({ ...parameters, key });
      const nonce = await readContract(implementation.client, {
        abi: parseAbi([
          "function getNonce(address, uint192) pure returns (uint256)"
        ]),
        address: implementation.entryPoint.address,
        functionName: "getNonce",
        args: [address, key]
      });
      return nonce;
    },
    async isDeployed() {
      if (deployed)
        return true;
      const code = await getAction(implementation.client, getCode, "getCode")({
        address
      });
      deployed = Boolean(code);
      return deployed;
    },
    ...implementation.sign ? {
      async sign(parameters) {
        const [{ factory, factoryData }, signature] = await Promise.all([
          this.getFactoryArgs(),
          implementation.sign(parameters)
        ]);
        if (factory && factoryData)
          return serializeErc6492Signature({
            address: factory,
            data: factoryData,
            signature
          });
        return signature;
      }
    } : {},
    async signMessage(parameters) {
      const [{ factory, factoryData }, signature] = await Promise.all([
        this.getFactoryArgs(),
        implementation.signMessage(parameters)
      ]);
      if (factory && factoryData && factory !== "0x7702")
        return serializeErc6492Signature({
          address: factory,
          data: factoryData,
          signature
        });
      return signature;
    },
    async signTypedData(parameters) {
      const [{ factory, factoryData }, signature] = await Promise.all([
        this.getFactoryArgs(),
        implementation.signTypedData(parameters)
      ]);
      if (factory && factoryData && factory !== "0x7702")
        return serializeErc6492Signature({
          address: factory,
          data: factoryData,
          signature
        });
      return signature;
    },
    type: "smart"
  };
}

// node_modules/viem/_esm/account-abstraction/errors/bundler.js
var AccountNotDeployedError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Smart Account is not deployed.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- No `factory`/`factoryData` or `initCode` properties are provided for Smart Account deployment.",
        "- An incorrect `sender` address is provided."
      ],
      name: "AccountNotDeployedError"
    });
  }
};
Object.defineProperty(AccountNotDeployedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa20/
});
var ExecutionRevertedError2 = class extends BaseError {
  constructor({ cause: cause3, data, message } = {}) {
    var _a106;
    const reason = (_a106 = message == null ? void 0 : message.replace("execution reverted: ", "")) == null ? void 0 : _a106.replace("execution reverted", "");
    super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
      cause: cause3,
      name: "ExecutionRevertedError"
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.data = data;
  }
};
Object.defineProperty(ExecutionRevertedError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32521
});
Object.defineProperty(ExecutionRevertedError2, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /execution reverted/
});
var FailedToSendToBeneficiaryError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Failed to send funds to beneficiary.", {
      cause: cause3,
      name: "FailedToSendToBeneficiaryError"
    });
  }
};
Object.defineProperty(FailedToSendToBeneficiaryError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa91/
});
var GasValuesOverflowError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Gas value overflowed.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- one of the gas values exceeded 2**120 (uint120)"
      ].filter(Boolean),
      name: "GasValuesOverflowError"
    });
  }
};
Object.defineProperty(GasValuesOverflowError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa94/
});
var HandleOpsOutOfGasError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("The `handleOps` function was called by the Bundler with a gas limit too low.", {
      cause: cause3,
      name: "HandleOpsOutOfGasError"
    });
  }
};
Object.defineProperty(HandleOpsOutOfGasError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa95/
});
var InitCodeFailedError = class extends BaseError {
  constructor({ cause: cause3, factory, factoryData, initCode }) {
    super("Failed to simulate deployment for Smart Account.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- Invalid `factory`/`factoryData` or `initCode` properties are present",
        "- Smart Account deployment execution ran out of gas (low `verificationGasLimit` value)",
        "- Smart Account deployment execution reverted with an error\n",
        factory && `factory: ${factory}`,
        factoryData && `factoryData: ${factoryData}`,
        initCode && `initCode: ${initCode}`
      ].filter(Boolean),
      name: "InitCodeFailedError"
    });
  }
};
Object.defineProperty(InitCodeFailedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa13/
});
var InitCodeMustCreateSenderError = class extends BaseError {
  constructor({ cause: cause3, factory, factoryData, initCode }) {
    super("Smart Account initialization implementation did not create an account.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- `factory`/`factoryData` or `initCode` properties are invalid",
        "- Smart Account initialization implementation is incorrect\n",
        factory && `factory: ${factory}`,
        factoryData && `factoryData: ${factoryData}`,
        initCode && `initCode: ${initCode}`
      ].filter(Boolean),
      name: "InitCodeMustCreateSenderError"
    });
  }
};
Object.defineProperty(InitCodeMustCreateSenderError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa15/
});
var InitCodeMustReturnSenderError = class extends BaseError {
  constructor({ cause: cause3, factory, factoryData, initCode, sender }) {
    super("Smart Account initialization implementation does not return the expected sender.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "Smart Account initialization implementation does not return a sender address\n",
        factory && `factory: ${factory}`,
        factoryData && `factoryData: ${factoryData}`,
        initCode && `initCode: ${initCode}`,
        sender && `sender: ${sender}`
      ].filter(Boolean),
      name: "InitCodeMustReturnSenderError"
    });
  }
};
Object.defineProperty(InitCodeMustReturnSenderError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa14/
});
var InsufficientPrefundError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Smart Account does not have sufficient funds to execute the User Operation.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the Smart Account does not have sufficient funds to cover the required prefund, or",
        "- a Paymaster was not provided"
      ].filter(Boolean),
      name: "InsufficientPrefundError"
    });
  }
};
Object.defineProperty(InsufficientPrefundError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa21/
});
var InternalCallOnlyError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Bundler attempted to call an invalid function on the EntryPoint.", {
      cause: cause3,
      name: "InternalCallOnlyError"
    });
  }
};
Object.defineProperty(InternalCallOnlyError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa92/
});
var InvalidAggregatorError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Bundler used an invalid aggregator for handling aggregated User Operations.", {
      cause: cause3,
      name: "InvalidAggregatorError"
    });
  }
};
Object.defineProperty(InvalidAggregatorError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa96/
});
var InvalidAccountNonceError = class extends BaseError {
  constructor({ cause: cause3, nonce }) {
    super("Invalid Smart Account nonce used for User Operation.", {
      cause: cause3,
      metaMessages: [nonce && `nonce: ${nonce}`].filter(Boolean),
      name: "InvalidAccountNonceError"
    });
  }
};
Object.defineProperty(InvalidAccountNonceError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa25/
});
var InvalidBeneficiaryError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Bundler has not set a beneficiary address.", {
      cause: cause3,
      name: "InvalidBeneficiaryError"
    });
  }
};
Object.defineProperty(InvalidBeneficiaryError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa90/
});
var InvalidFieldsError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Invalid fields set on User Operation.", {
      cause: cause3,
      name: "InvalidFieldsError"
    });
  }
};
Object.defineProperty(InvalidFieldsError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InvalidPaymasterAndDataError = class extends BaseError {
  constructor({ cause: cause3, paymasterAndData }) {
    super("Paymaster properties provided are invalid.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the `paymasterAndData` property is of an incorrect length\n",
        paymasterAndData && `paymasterAndData: ${paymasterAndData}`
      ].filter(Boolean),
      name: "InvalidPaymasterAndDataError"
    });
  }
};
Object.defineProperty(InvalidPaymasterAndDataError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa93/
});
var PaymasterDepositTooLowError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Paymaster deposit for the User Operation is too low.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the Paymaster has deposited less than the expected amount via the `deposit` function"
      ].filter(Boolean),
      name: "PaymasterDepositTooLowError"
    });
  }
};
Object.defineProperty(PaymasterDepositTooLowError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32508
});
Object.defineProperty(PaymasterDepositTooLowError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa31/
});
var PaymasterFunctionRevertedError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("The `validatePaymasterUserOp` function on the Paymaster reverted.", {
      cause: cause3,
      name: "PaymasterFunctionRevertedError"
    });
  }
};
Object.defineProperty(PaymasterFunctionRevertedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa33/
});
var PaymasterNotDeployedError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("The Paymaster contract has not been deployed.", {
      cause: cause3,
      name: "PaymasterNotDeployedError"
    });
  }
};
Object.defineProperty(PaymasterNotDeployedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa30/
});
var PaymasterRateLimitError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause: cause3,
      name: "PaymasterRateLimitError"
    });
  }
};
Object.defineProperty(PaymasterRateLimitError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32504
});
var PaymasterStakeTooLowError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("UserOperation rejected because paymaster (or signature aggregator) is throttled/banned.", {
      cause: cause3,
      name: "PaymasterStakeTooLowError"
    });
  }
};
Object.defineProperty(PaymasterStakeTooLowError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32505
});
var PaymasterPostOpFunctionRevertedError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Paymaster `postOp` function reverted.", {
      cause: cause3,
      name: "PaymasterPostOpFunctionRevertedError"
    });
  }
};
Object.defineProperty(PaymasterPostOpFunctionRevertedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa50/
});
var SenderAlreadyConstructedError = class extends BaseError {
  constructor({ cause: cause3, factory, factoryData, initCode }) {
    super("Smart Account has already been deployed.", {
      cause: cause3,
      metaMessages: [
        "Remove the following properties and try again:",
        factory && "`factory`",
        factoryData && "`factoryData`",
        initCode && "`initCode`"
      ].filter(Boolean),
      name: "SenderAlreadyConstructedError"
    });
  }
};
Object.defineProperty(SenderAlreadyConstructedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa10/
});
var SignatureCheckFailedError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("UserOperation rejected because account signature check failed (or paymaster signature, if the paymaster uses its data as signature).", {
      cause: cause3,
      name: "SignatureCheckFailedError"
    });
  }
};
Object.defineProperty(SignatureCheckFailedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32507
});
var SmartAccountFunctionRevertedError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("The `validateUserOp` function on the Smart Account reverted.", {
      cause: cause3,
      name: "SmartAccountFunctionRevertedError"
    });
  }
};
Object.defineProperty(SmartAccountFunctionRevertedError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa23/
});
var UnsupportedSignatureAggregatorError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("UserOperation rejected because account specified unsupported signature aggregator.", {
      cause: cause3,
      name: "UnsupportedSignatureAggregatorError"
    });
  }
};
Object.defineProperty(UnsupportedSignatureAggregatorError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32506
});
var UserOperationExpiredError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("User Operation expired.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validateUserOp` on the Smart Account are not satisfied"
      ].filter(Boolean),
      name: "UserOperationExpiredError"
    });
  }
};
Object.defineProperty(UserOperationExpiredError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa22/
});
var UserOperationPaymasterExpiredError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Paymaster for User Operation expired.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the `validAfter` or `validUntil` values returned from `validatePaymasterUserOp` on the Paymaster are not satisfied"
      ].filter(Boolean),
      name: "UserOperationPaymasterExpiredError"
    });
  }
};
Object.defineProperty(UserOperationPaymasterExpiredError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa32/
});
var UserOperationSignatureError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Signature provided for the User Operation is invalid.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Smart Account"
      ].filter(Boolean),
      name: "UserOperationSignatureError"
    });
  }
};
Object.defineProperty(UserOperationSignatureError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa24/
});
var UserOperationPaymasterSignatureError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("Signature provided for the User Operation is invalid.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the `signature` for the User Operation is incorrectly computed, and unable to be verified by the Paymaster"
      ].filter(Boolean),
      name: "UserOperationPaymasterSignatureError"
    });
  }
};
Object.defineProperty(UserOperationPaymasterSignatureError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa34/
});
var UserOperationRejectedByEntryPointError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("User Operation rejected by EntryPoint's `simulateValidation` during account creation or validation.", {
      cause: cause3,
      name: "UserOperationRejectedByEntryPointError"
    });
  }
};
Object.defineProperty(UserOperationRejectedByEntryPointError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32500
});
var UserOperationRejectedByPaymasterError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("User Operation rejected by Paymaster's `validatePaymasterUserOp`.", {
      cause: cause3,
      name: "UserOperationRejectedByPaymasterError"
    });
  }
};
Object.defineProperty(UserOperationRejectedByPaymasterError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32501
});
var UserOperationRejectedByOpCodeError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("User Operation rejected with op code validation error.", {
      cause: cause3,
      name: "UserOperationRejectedByOpCodeError"
    });
  }
};
Object.defineProperty(UserOperationRejectedByOpCodeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32502
});
var UserOperationOutOfTimeRangeError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("UserOperation out of time-range: either wallet or paymaster returned a time-range, and it is already expired (or will expire soon).", {
      cause: cause3,
      name: "UserOperationOutOfTimeRangeError"
    });
  }
};
Object.defineProperty(UserOperationOutOfTimeRangeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32503
});
var UnknownBundlerError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super(`An error occurred while executing user operation: ${cause3 == null ? void 0 : cause3.shortMessage}`, {
      cause: cause3,
      name: "UnknownBundlerError"
    });
  }
};
var VerificationGasLimitExceededError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("User Operation verification gas limit exceeded.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the gas used for verification exceeded the `verificationGasLimit`"
      ].filter(Boolean),
      name: "VerificationGasLimitExceededError"
    });
  }
};
Object.defineProperty(VerificationGasLimitExceededError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa40/
});
var VerificationGasLimitTooLowError = class extends BaseError {
  constructor({ cause: cause3 }) {
    super("User Operation verification gas limit is too low.", {
      cause: cause3,
      metaMessages: [
        "This could arise when:",
        "- the `verificationGasLimit` is too low to verify the User Operation"
      ].filter(Boolean),
      name: "VerificationGasLimitTooLowError"
    });
  }
};
Object.defineProperty(VerificationGasLimitTooLowError, "message", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /aa41/
});

// node_modules/viem/_esm/account-abstraction/errors/userOperation.js
var UserOperationExecutionError = class extends BaseError {
  constructor(cause3, { callData, callGasLimit, docsPath: docsPath3, factory, factoryData, initCode, maxFeePerGas, maxPriorityFeePerGas, nonce, paymaster, paymasterAndData, paymasterData, paymasterPostOpGasLimit, paymasterVerificationGasLimit, preVerificationGas, sender, signature, verificationGasLimit }) {
    const prettyArgs = prettyPrint({
      callData,
      callGasLimit,
      factory,
      factoryData,
      initCode,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce,
      paymaster,
      paymasterAndData,
      paymasterData,
      paymasterPostOpGasLimit,
      paymasterVerificationGasLimit,
      preVerificationGas,
      sender,
      signature,
      verificationGasLimit
    });
    super(cause3.shortMessage, {
      cause: cause3,
      docsPath: docsPath3,
      metaMessages: [
        ...cause3.metaMessages ? [...cause3.metaMessages, " "] : [],
        "Request Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "UserOperationExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause3;
  }
};
var UserOperationReceiptNotFoundError = class extends BaseError {
  constructor({ hash: hash11 }) {
    super(`User Operation receipt with hash "${hash11}" could not be found. The User Operation may not have been processed yet.`, { name: "UserOperationReceiptNotFoundError" });
  }
};
var UserOperationNotFoundError = class extends BaseError {
  constructor({ hash: hash11 }) {
    super(`User Operation with hash "${hash11}" could not be found.`, {
      name: "UserOperationNotFoundError"
    });
  }
};
var WaitForUserOperationReceiptTimeoutError = class extends BaseError {
  constructor({ hash: hash11 }) {
    super(`Timed out while waiting for User Operation with hash "${hash11}" to be confirmed.`, { name: "WaitForUserOperationReceiptTimeoutError" });
  }
};

// node_modules/viem/_esm/account-abstraction/utils/errors/getBundlerError.js
var bundlerErrors = [
  ExecutionRevertedError2,
  InvalidFieldsError,
  PaymasterDepositTooLowError,
  PaymasterRateLimitError,
  PaymasterStakeTooLowError,
  SignatureCheckFailedError,
  UnsupportedSignatureAggregatorError,
  UserOperationOutOfTimeRangeError,
  UserOperationRejectedByEntryPointError,
  UserOperationRejectedByPaymasterError,
  UserOperationRejectedByOpCodeError
];
function getBundlerError(err2, args2) {
  const message = (err2.details || "").toLowerCase();
  if (AccountNotDeployedError.message.test(message))
    return new AccountNotDeployedError({
      cause: err2
    });
  if (FailedToSendToBeneficiaryError.message.test(message))
    return new FailedToSendToBeneficiaryError({
      cause: err2
    });
  if (GasValuesOverflowError.message.test(message))
    return new GasValuesOverflowError({
      cause: err2
    });
  if (HandleOpsOutOfGasError.message.test(message))
    return new HandleOpsOutOfGasError({
      cause: err2
    });
  if (InitCodeFailedError.message.test(message))
    return new InitCodeFailedError({
      cause: err2,
      factory: args2.factory,
      factoryData: args2.factoryData,
      initCode: args2.initCode
    });
  if (InitCodeMustCreateSenderError.message.test(message))
    return new InitCodeMustCreateSenderError({
      cause: err2,
      factory: args2.factory,
      factoryData: args2.factoryData,
      initCode: args2.initCode
    });
  if (InitCodeMustReturnSenderError.message.test(message))
    return new InitCodeMustReturnSenderError({
      cause: err2,
      factory: args2.factory,
      factoryData: args2.factoryData,
      initCode: args2.initCode,
      sender: args2.sender
    });
  if (InsufficientPrefundError.message.test(message))
    return new InsufficientPrefundError({
      cause: err2
    });
  if (InternalCallOnlyError.message.test(message))
    return new InternalCallOnlyError({
      cause: err2
    });
  if (InvalidAccountNonceError.message.test(message))
    return new InvalidAccountNonceError({
      cause: err2,
      nonce: args2.nonce
    });
  if (InvalidAggregatorError.message.test(message))
    return new InvalidAggregatorError({
      cause: err2
    });
  if (InvalidBeneficiaryError.message.test(message))
    return new InvalidBeneficiaryError({
      cause: err2
    });
  if (InvalidPaymasterAndDataError.message.test(message))
    return new InvalidPaymasterAndDataError({
      cause: err2
    });
  if (PaymasterDepositTooLowError.message.test(message))
    return new PaymasterDepositTooLowError({
      cause: err2
    });
  if (PaymasterFunctionRevertedError.message.test(message))
    return new PaymasterFunctionRevertedError({
      cause: err2
    });
  if (PaymasterNotDeployedError.message.test(message))
    return new PaymasterNotDeployedError({
      cause: err2
    });
  if (PaymasterPostOpFunctionRevertedError.message.test(message))
    return new PaymasterPostOpFunctionRevertedError({
      cause: err2
    });
  if (SmartAccountFunctionRevertedError.message.test(message))
    return new SmartAccountFunctionRevertedError({
      cause: err2
    });
  if (SenderAlreadyConstructedError.message.test(message))
    return new SenderAlreadyConstructedError({
      cause: err2,
      factory: args2.factory,
      factoryData: args2.factoryData,
      initCode: args2.initCode
    });
  if (UserOperationExpiredError.message.test(message))
    return new UserOperationExpiredError({
      cause: err2
    });
  if (UserOperationPaymasterExpiredError.message.test(message))
    return new UserOperationPaymasterExpiredError({
      cause: err2
    });
  if (UserOperationPaymasterSignatureError.message.test(message))
    return new UserOperationPaymasterSignatureError({
      cause: err2
    });
  if (UserOperationSignatureError.message.test(message))
    return new UserOperationSignatureError({
      cause: err2
    });
  if (VerificationGasLimitExceededError.message.test(message))
    return new VerificationGasLimitExceededError({
      cause: err2
    });
  if (VerificationGasLimitTooLowError.message.test(message))
    return new VerificationGasLimitTooLowError({
      cause: err2
    });
  const error4 = err2.walk((e) => bundlerErrors.some((error5) => error5.code === e.code));
  if (error4) {
    if (error4.code === ExecutionRevertedError2.code)
      return new ExecutionRevertedError2({
        cause: err2,
        data: error4.data,
        message: error4.details
      });
    if (error4.code === InvalidFieldsError.code)
      return new InvalidFieldsError({
        cause: err2
      });
    if (error4.code === PaymasterDepositTooLowError.code)
      return new PaymasterDepositTooLowError({
        cause: err2
      });
    if (error4.code === PaymasterRateLimitError.code)
      return new PaymasterRateLimitError({
        cause: err2
      });
    if (error4.code === PaymasterStakeTooLowError.code)
      return new PaymasterStakeTooLowError({
        cause: err2
      });
    if (error4.code === SignatureCheckFailedError.code)
      return new SignatureCheckFailedError({
        cause: err2
      });
    if (error4.code === UnsupportedSignatureAggregatorError.code)
      return new UnsupportedSignatureAggregatorError({
        cause: err2
      });
    if (error4.code === UserOperationOutOfTimeRangeError.code)
      return new UserOperationOutOfTimeRangeError({
        cause: err2
      });
    if (error4.code === UserOperationRejectedByEntryPointError.code)
      return new UserOperationRejectedByEntryPointError({
        cause: err2
      });
    if (error4.code === UserOperationRejectedByPaymasterError.code)
      return new UserOperationRejectedByPaymasterError({
        cause: err2
      });
    if (error4.code === UserOperationRejectedByOpCodeError.code)
      return new UserOperationRejectedByOpCodeError({
        cause: err2
      });
  }
  return new UnknownBundlerError({
    cause: err2
  });
}

// node_modules/viem/_esm/account-abstraction/utils/errors/getUserOperationError.js
function getUserOperationError(err2, { calls, docsPath: docsPath3, ...args2 }) {
  const cause3 = (() => {
    const cause4 = getBundlerError(err2, args2);
    if (calls && cause4 instanceof ExecutionRevertedError2) {
      const revertData = getRevertData(cause4);
      const contractCalls = calls == null ? void 0 : calls.filter((call2) => call2.abi);
      if (revertData && contractCalls.length > 0)
        return getContractError2({ calls: contractCalls, revertData });
    }
    return cause4;
  })();
  return new UserOperationExecutionError(cause3, {
    docsPath: docsPath3,
    ...args2
  });
}
function getRevertData(error4) {
  let revertData;
  error4.walk((e) => {
    var _a106, _b32, _c7, _d4;
    const error5 = e;
    if (typeof error5.data === "string" || typeof ((_a106 = error5.data) == null ? void 0 : _a106.revertData) === "string" || !(error5 instanceof BaseError) && typeof error5.message === "string") {
      const match43 = (_d4 = (_c7 = ((_b32 = error5.data) == null ? void 0 : _b32.revertData) || error5.data || error5.message).match) == null ? void 0 : _d4.call(_c7, /(0x[A-Za-z0-9]*)/);
      if (match43) {
        revertData = match43[1];
        return true;
      }
    }
    return false;
  });
  return revertData;
}
function getContractError2(parameters) {
  const { calls, revertData } = parameters;
  const { abi: abi11, functionName, args: args2, to: to3 } = (() => {
    const contractCalls = calls == null ? void 0 : calls.filter((call2) => Boolean(call2.abi));
    if (contractCalls.length === 1)
      return contractCalls[0];
    const compatContractCalls = contractCalls.filter((call2) => {
      try {
        return Boolean(decodeErrorResult({
          abi: call2.abi,
          data: revertData
        }));
      } catch {
        return false;
      }
    });
    if (compatContractCalls.length === 1)
      return compatContractCalls[0];
    return {
      abi: [],
      functionName: contractCalls.reduce((acc, call2) => `${acc ? `${acc} | ` : ""}${call2.functionName}`, ""),
      args: void 0,
      to: void 0
    };
  })();
  const cause3 = (() => {
    if (revertData === "0x")
      return new ContractFunctionZeroDataError({ functionName });
    return new ContractFunctionRevertedError({
      abi: abi11,
      data: revertData,
      functionName
    });
  })();
  return new ContractFunctionExecutionError(cause3, {
    abi: abi11,
    args: args2,
    contractAddress: to3,
    functionName
  });
}

// node_modules/viem/_esm/account-abstraction/utils/formatters/userOperationGas.js
function formatUserOperationGas(parameters) {
  const gas = {};
  if (parameters.callGasLimit)
    gas.callGasLimit = BigInt(parameters.callGasLimit);
  if (parameters.preVerificationGas)
    gas.preVerificationGas = BigInt(parameters.preVerificationGas);
  if (parameters.verificationGasLimit)
    gas.verificationGasLimit = BigInt(parameters.verificationGasLimit);
  if (parameters.paymasterPostOpGasLimit)
    gas.paymasterPostOpGasLimit = BigInt(parameters.paymasterPostOpGasLimit);
  if (parameters.paymasterVerificationGasLimit)
    gas.paymasterVerificationGasLimit = BigInt(parameters.paymasterVerificationGasLimit);
  return gas;
}

// node_modules/viem/_esm/account-abstraction/utils/formatters/userOperationRequest.js
function formatUserOperationRequest(request2) {
  const rpcRequest = {};
  if (typeof request2.callData !== "undefined")
    rpcRequest.callData = request2.callData;
  if (typeof request2.callGasLimit !== "undefined")
    rpcRequest.callGasLimit = numberToHex(request2.callGasLimit);
  if (typeof request2.factory !== "undefined")
    rpcRequest.factory = request2.factory;
  if (typeof request2.factoryData !== "undefined")
    rpcRequest.factoryData = request2.factoryData;
  if (typeof request2.initCode !== "undefined")
    rpcRequest.initCode = request2.initCode;
  if (typeof request2.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request2.maxFeePerGas);
  if (typeof request2.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request2.maxPriorityFeePerGas);
  if (typeof request2.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request2.nonce);
  if (typeof request2.paymaster !== "undefined")
    rpcRequest.paymaster = request2.paymaster;
  if (typeof request2.paymasterAndData !== "undefined")
    rpcRequest.paymasterAndData = request2.paymasterAndData || "0x";
  if (typeof request2.paymasterData !== "undefined")
    rpcRequest.paymasterData = request2.paymasterData;
  if (typeof request2.paymasterPostOpGasLimit !== "undefined")
    rpcRequest.paymasterPostOpGasLimit = numberToHex(request2.paymasterPostOpGasLimit);
  if (typeof request2.paymasterVerificationGasLimit !== "undefined")
    rpcRequest.paymasterVerificationGasLimit = numberToHex(request2.paymasterVerificationGasLimit);
  if (typeof request2.preVerificationGas !== "undefined")
    rpcRequest.preVerificationGas = numberToHex(request2.preVerificationGas);
  if (typeof request2.sender !== "undefined")
    rpcRequest.sender = request2.sender;
  if (typeof request2.signature !== "undefined")
    rpcRequest.signature = request2.signature;
  if (typeof request2.verificationGasLimit !== "undefined")
    rpcRequest.verificationGasLimit = numberToHex(request2.verificationGasLimit);
  if (typeof request2.authorization !== "undefined")
    rpcRequest.eip7702Auth = formatAuthorization(request2.authorization);
  return rpcRequest;
}
function formatAuthorization(authorization) {
  return {
    address: authorization.address,
    chainId: numberToHex(authorization.chainId),
    nonce: numberToHex(authorization.nonce),
    r: authorization.r ? numberToHex(BigInt(authorization.r), { size: 32 }) : pad("0x", { size: 32 }),
    s: authorization.s ? numberToHex(BigInt(authorization.s), { size: 32 }) : pad("0x", { size: 32 }),
    yParity: authorization.yParity ? numberToHex(authorization.yParity, { size: 1 }) : pad("0x", { size: 32 })
  };
}

// node_modules/viem/_esm/account-abstraction/actions/paymaster/getPaymasterData.js
async function getPaymasterData(client, parameters) {
  const { chainId, entryPointAddress, context: context15, ...userOperation } = parameters;
  const request2 = formatUserOperationRequest(userOperation);
  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } = await client.request({
    method: "pm_getPaymasterData",
    params: [
      {
        ...request2,
        callGasLimit: request2.callGasLimit ?? "0x0",
        verificationGasLimit: request2.verificationGasLimit ?? "0x0",
        preVerificationGas: request2.preVerificationGas ?? "0x0"
      },
      entryPointAddress,
      numberToHex(chainId),
      context15
    ]
  });
  return {
    ...rest,
    ...paymasterPostOpGasLimit && {
      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit)
    },
    ...paymasterVerificationGasLimit && {
      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit)
    }
  };
}

// node_modules/viem/_esm/account-abstraction/actions/paymaster/getPaymasterStubData.js
async function getPaymasterStubData(client, parameters) {
  const { chainId, entryPointAddress, context: context15, ...userOperation } = parameters;
  const request2 = formatUserOperationRequest(userOperation);
  const { paymasterPostOpGasLimit, paymasterVerificationGasLimit, ...rest } = await client.request({
    method: "pm_getPaymasterStubData",
    params: [
      {
        ...request2,
        callGasLimit: request2.callGasLimit ?? "0x0",
        verificationGasLimit: request2.verificationGasLimit ?? "0x0",
        preVerificationGas: request2.preVerificationGas ?? "0x0"
      },
      entryPointAddress,
      numberToHex(chainId),
      context15
    ]
  });
  return {
    ...rest,
    ...paymasterPostOpGasLimit && {
      paymasterPostOpGasLimit: hexToBigInt(paymasterPostOpGasLimit)
    },
    ...paymasterVerificationGasLimit && {
      paymasterVerificationGasLimit: hexToBigInt(paymasterVerificationGasLimit)
    }
  };
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/prepareUserOperation.js
var defaultParameters2 = [
  "factory",
  "fees",
  "gas",
  "paymaster",
  "nonce",
  "signature",
  "authorization"
];
async function prepareUserOperation(client, parameters_) {
  var _a106;
  const parameters = parameters_;
  const { account: account_ = client.account, parameters: properties = defaultParameters2, stateOverride } = parameters;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  const bundlerClient = client;
  const paymaster = parameters.paymaster ?? (bundlerClient == null ? void 0 : bundlerClient.paymaster);
  const paymasterAddress = typeof paymaster === "string" ? paymaster : void 0;
  const { getPaymasterStubData: getPaymasterStubData2, getPaymasterData: getPaymasterData2 } = (() => {
    if (paymaster === true)
      return {
        getPaymasterStubData: (parameters2) => getAction(bundlerClient, getPaymasterStubData, "getPaymasterStubData")(parameters2),
        getPaymasterData: (parameters2) => getAction(bundlerClient, getPaymasterData, "getPaymasterData")(parameters2)
      };
    if (typeof paymaster === "object") {
      const { getPaymasterStubData: getPaymasterStubData3, getPaymasterData: getPaymasterData3 } = paymaster;
      return {
        getPaymasterStubData: getPaymasterData3 && getPaymasterStubData3 ? getPaymasterStubData3 : getPaymasterData3,
        getPaymasterData: getPaymasterData3 && getPaymasterStubData3 ? getPaymasterData3 : void 0
      };
    }
    return {
      getPaymasterStubData: void 0,
      getPaymasterData: void 0
    };
  })();
  const paymasterContext = parameters.paymasterContext ? parameters.paymasterContext : bundlerClient == null ? void 0 : bundlerClient.paymasterContext;
  let request2 = {
    ...parameters,
    paymaster: paymasterAddress,
    sender: account.address
  };
  const [callData, factory, fees, nonce, authorization] = await Promise.all([
    (async () => {
      if (parameters.calls)
        return account.encodeCalls(parameters.calls.map((call_) => {
          const call2 = call_;
          if (call2.abi)
            return {
              data: encodeFunctionData(call2),
              to: call2.to,
              value: call2.value
            };
          return call2;
        }));
      return parameters.callData;
    })(),
    (async () => {
      if (!properties.includes("factory"))
        return void 0;
      if (parameters.initCode)
        return { initCode: parameters.initCode };
      if (parameters.factory && parameters.factoryData) {
        return {
          factory: parameters.factory,
          factoryData: parameters.factoryData
        };
      }
      const { factory: factory2, factoryData } = await account.getFactoryArgs();
      if (account.entryPoint.version === "0.6")
        return {
          initCode: factory2 && factoryData ? concat([factory2, factoryData]) : void 0
        };
      return {
        factory: factory2,
        factoryData
      };
    })(),
    (async () => {
      var _a107;
      if (!properties.includes("fees"))
        return void 0;
      if (typeof parameters.maxFeePerGas === "bigint" && typeof parameters.maxPriorityFeePerGas === "bigint")
        return request2;
      if ((_a107 = bundlerClient == null ? void 0 : bundlerClient.userOperation) == null ? void 0 : _a107.estimateFeesPerGas) {
        const fees2 = await bundlerClient.userOperation.estimateFeesPerGas({
          account,
          bundlerClient,
          userOperation: request2
        });
        return {
          ...request2,
          ...fees2
        };
      }
      try {
        const client_ = bundlerClient.client ?? client;
        const fees2 = await getAction(client_, estimateFeesPerGas, "estimateFeesPerGas")({
          chain: client_.chain,
          type: "eip1559"
        });
        return {
          maxFeePerGas: typeof parameters.maxFeePerGas === "bigint" ? parameters.maxFeePerGas : BigInt(
            // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
            2n * fees2.maxFeePerGas
          ),
          maxPriorityFeePerGas: typeof parameters.maxPriorityFeePerGas === "bigint" ? parameters.maxPriorityFeePerGas : BigInt(
            // Bundlers unfortunately have strict rules on fee prechecks  we will need to set a generous buffer.
            2n * fees2.maxPriorityFeePerGas
          )
        };
      } catch {
        return void 0;
      }
    })(),
    (async () => {
      if (!properties.includes("nonce"))
        return void 0;
      if (typeof parameters.nonce === "bigint")
        return parameters.nonce;
      return account.getNonce();
    })(),
    (async () => {
      if (!properties.includes("authorization"))
        return void 0;
      if (typeof parameters.authorization === "object")
        return parameters.authorization;
      if (account.authorization && !await account.isDeployed()) {
        const authorization2 = await prepareAuthorization(account.client, account.authorization);
        return {
          ...authorization2,
          r: "0xfffffffffffffffffffffffffffffff000000000000000000000000000000000",
          s: "0x7aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
          yParity: 1
        };
      }
      return void 0;
    })()
  ]);
  if (typeof callData !== "undefined")
    request2.callData = callData;
  if (typeof factory !== "undefined")
    request2 = { ...request2, ...factory };
  if (typeof fees !== "undefined")
    request2 = { ...request2, ...fees };
  if (typeof nonce !== "undefined")
    request2.nonce = nonce;
  if (typeof authorization !== "undefined")
    request2.authorization = authorization;
  if (properties.includes("signature")) {
    if (typeof parameters.signature !== "undefined")
      request2.signature = parameters.signature;
    else
      request2.signature = await account.getStubSignature(request2);
  }
  if (account.entryPoint.version === "0.6" && !request2.initCode)
    request2.initCode = "0x";
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (client.chain)
      return client.chain.id;
    const chainId_ = await getAction(client, getChainId, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  let isPaymasterPopulated = false;
  if (properties.includes("paymaster") && getPaymasterStubData2 && !paymasterAddress && !parameters.paymasterAndData) {
    const { isFinal = false, sponsor, ...paymasterArgs } = await getPaymasterStubData2({
      chainId: await getChainId2(),
      entryPointAddress: account.entryPoint.address,
      context: paymasterContext,
      ...request2
    });
    isPaymasterPopulated = isFinal;
    request2 = {
      ...request2,
      ...paymasterArgs
    };
  }
  if (account.entryPoint.version === "0.6" && !request2.paymasterAndData)
    request2.paymasterAndData = "0x";
  if (properties.includes("gas")) {
    if ((_a106 = account.userOperation) == null ? void 0 : _a106.estimateGas) {
      const gas = await account.userOperation.estimateGas(request2);
      request2 = {
        ...request2,
        ...gas
      };
    }
    if (typeof request2.callGasLimit === "undefined" || typeof request2.preVerificationGas === "undefined" || typeof request2.verificationGasLimit === "undefined" || request2.paymaster && typeof request2.paymasterPostOpGasLimit === "undefined" || request2.paymaster && typeof request2.paymasterVerificationGasLimit === "undefined") {
      const gas = await getAction(bundlerClient, estimateUserOperationGas, "estimateUserOperationGas")({
        account,
        // Some Bundlers fail if nullish gas values are provided for gas estimation :') 
        // so we will need to set a default zeroish value.
        callGasLimit: 0n,
        preVerificationGas: 0n,
        verificationGasLimit: 0n,
        stateOverride,
        ...request2.paymaster ? {
          paymasterPostOpGasLimit: 0n,
          paymasterVerificationGasLimit: 0n
        } : {},
        ...request2
      });
      request2 = {
        ...request2,
        callGasLimit: request2.callGasLimit ?? gas.callGasLimit,
        preVerificationGas: request2.preVerificationGas ?? gas.preVerificationGas,
        verificationGasLimit: request2.verificationGasLimit ?? gas.verificationGasLimit,
        paymasterPostOpGasLimit: request2.paymasterPostOpGasLimit ?? gas.paymasterPostOpGasLimit,
        paymasterVerificationGasLimit: request2.paymasterVerificationGasLimit ?? gas.paymasterVerificationGasLimit
      };
    }
  }
  if (properties.includes("paymaster") && getPaymasterData2 && !paymasterAddress && !parameters.paymasterAndData && !isPaymasterPopulated) {
    const paymaster2 = await getPaymasterData2({
      chainId: await getChainId2(),
      entryPointAddress: account.entryPoint.address,
      context: paymasterContext,
      ...request2
    });
    request2 = {
      ...request2,
      ...paymaster2
    };
  }
  delete request2.calls;
  delete request2.parameters;
  delete request2.paymasterContext;
  if (typeof request2.paymaster !== "string")
    delete request2.paymaster;
  return request2;
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/estimateUserOperationGas.js
async function estimateUserOperationGas(client, parameters) {
  var _a106;
  const { account: account_ = client.account, entryPointAddress, stateOverride } = parameters;
  if (!account_ && !parameters.sender)
    throw new AccountNotFoundError();
  const account = account_ ? parseAccount(account_) : void 0;
  const rpcStateOverride = serializeStateOverride(stateOverride);
  const request2 = account ? await getAction(client, prepareUserOperation, "prepareUserOperation")({
    ...parameters,
    parameters: [
      "authorization",
      "factory",
      "nonce",
      "paymaster",
      "signature"
    ]
  }) : parameters;
  try {
    const params = [
      formatUserOperationRequest(request2),
      entryPointAddress ?? ((_a106 = account == null ? void 0 : account.entryPoint) == null ? void 0 : _a106.address)
    ];
    const result = await client.request({
      method: "eth_estimateUserOperationGas",
      params: rpcStateOverride ? [...params, rpcStateOverride] : [...params]
    });
    return formatUserOperationGas(result);
  } catch (error4) {
    const calls = parameters.calls;
    throw getUserOperationError(error4, {
      ...request2,
      ...calls ? { calls } : {}
    });
  }
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/getSupportedEntryPoints.js
function getSupportedEntryPoints(client) {
  return client.request({ method: "eth_supportedEntryPoints" });
}

// node_modules/viem/_esm/account-abstraction/utils/formatters/userOperation.js
function formatUserOperation(parameters) {
  const userOperation = { ...parameters };
  if (parameters.callGasLimit)
    userOperation.callGasLimit = BigInt(parameters.callGasLimit);
  if (parameters.maxFeePerGas)
    userOperation.maxFeePerGas = BigInt(parameters.maxFeePerGas);
  if (parameters.maxPriorityFeePerGas)
    userOperation.maxPriorityFeePerGas = BigInt(parameters.maxPriorityFeePerGas);
  if (parameters.nonce)
    userOperation.nonce = BigInt(parameters.nonce);
  if (parameters.paymasterPostOpGasLimit)
    userOperation.paymasterPostOpGasLimit = BigInt(parameters.paymasterPostOpGasLimit);
  if (parameters.paymasterVerificationGasLimit)
    userOperation.paymasterVerificationGasLimit = BigInt(parameters.paymasterVerificationGasLimit);
  if (parameters.preVerificationGas)
    userOperation.preVerificationGas = BigInt(parameters.preVerificationGas);
  if (parameters.verificationGasLimit)
    userOperation.verificationGasLimit = BigInt(parameters.verificationGasLimit);
  return userOperation;
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/getUserOperation.js
async function getUserOperation(client, { hash: hash11 }) {
  const result = await client.request({
    method: "eth_getUserOperationByHash",
    params: [hash11]
  }, { dedupe: true });
  if (!result)
    throw new UserOperationNotFoundError({ hash: hash11 });
  const { blockHash, blockNumber, entryPoint, transactionHash, userOperation } = result;
  return {
    blockHash,
    blockNumber: BigInt(blockNumber),
    entryPoint,
    transactionHash,
    userOperation: formatUserOperation(userOperation)
  };
}

// node_modules/viem/_esm/account-abstraction/utils/formatters/userOperationReceipt.js
function formatUserOperationReceipt(parameters) {
  const receipt = { ...parameters };
  if (parameters.actualGasCost)
    receipt.actualGasCost = BigInt(parameters.actualGasCost);
  if (parameters.actualGasUsed)
    receipt.actualGasUsed = BigInt(parameters.actualGasUsed);
  if (parameters.logs)
    receipt.logs = parameters.logs.map((log5) => formatLog(log5));
  if (parameters.receipt)
    receipt.receipt = formatTransactionReceipt(receipt.receipt);
  return receipt;
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/getUserOperationReceipt.js
async function getUserOperationReceipt(client, { hash: hash11 }) {
  const receipt = await client.request({
    method: "eth_getUserOperationReceipt",
    params: [hash11]
  }, { dedupe: true });
  if (!receipt)
    throw new UserOperationReceiptNotFoundError({ hash: hash11 });
  return formatUserOperationReceipt(receipt);
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/sendUserOperation.js
async function sendUserOperation(client, parameters) {
  var _a106, _b32;
  const { account: account_ = client.account, entryPointAddress } = parameters;
  if (!account_ && !parameters.sender)
    throw new AccountNotFoundError();
  const account = account_ ? parseAccount(account_) : void 0;
  const request2 = account ? await getAction(client, prepareUserOperation, "prepareUserOperation")(parameters) : parameters;
  const signature = parameters.signature || await ((_a106 = account == null ? void 0 : account.signUserOperation) == null ? void 0 : _a106.call(account, request2));
  const rpcParameters = formatUserOperationRequest({
    ...request2,
    signature
  });
  try {
    return await client.request({
      method: "eth_sendUserOperation",
      params: [
        rpcParameters,
        entryPointAddress ?? ((_b32 = account == null ? void 0 : account.entryPoint) == null ? void 0 : _b32.address)
      ]
    }, { retryCount: 0 });
  } catch (error4) {
    const calls = parameters.calls;
    throw getUserOperationError(error4, {
      ...request2,
      ...calls ? { calls } : {},
      signature
    });
  }
}

// node_modules/viem/_esm/account-abstraction/actions/bundler/waitForUserOperationReceipt.js
function waitForUserOperationReceipt(client, parameters) {
  const { hash: hash11, pollingInterval = client.pollingInterval, retryCount, timeout: timeout6 = 12e4 } = parameters;
  let count9 = 0;
  const observerId = stringify([
    "waitForUserOperationReceipt",
    client.uid,
    hash11
  ]);
  return new Promise((resolve, reject3) => {
    const unobserve = observe(observerId, { resolve, reject: reject3 }, (emit2) => {
      const done17 = (fn2) => {
        unpoll();
        fn2();
        unobserve();
      };
      const unpoll = poll13(async () => {
        if (retryCount && count9 >= retryCount)
          done17(() => emit2.reject(new WaitForUserOperationReceiptTimeoutError({ hash: hash11 })));
        try {
          const receipt = await getAction(client, getUserOperationReceipt, "getUserOperationReceipt")({ hash: hash11 });
          done17(() => emit2.resolve(receipt));
        } catch (err2) {
          const error4 = err2;
          if (error4.name !== "UserOperationReceiptNotFoundError")
            done17(() => emit2.reject(error4));
        }
        count9++;
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      if (timeout6)
        setTimeout(() => done17(() => emit2.reject(new WaitForUserOperationReceiptTimeoutError({ hash: hash11 }))), timeout6);
      return unpoll;
    });
  });
}

// node_modules/viem/_esm/account-abstraction/clients/decorators/bundler.js
function bundlerActions(client) {
  return {
    estimateUserOperationGas: (parameters) => estimateUserOperationGas(client, parameters),
    getChainId: () => getChainId(client),
    getSupportedEntryPoints: () => getSupportedEntryPoints(client),
    getUserOperation: (parameters) => getUserOperation(client, parameters),
    getUserOperationReceipt: (parameters) => getUserOperationReceipt(client, parameters),
    prepareUserOperation: (parameters) => prepareUserOperation(client, parameters),
    sendUserOperation: (parameters) => sendUserOperation(client, parameters),
    waitForUserOperationReceipt: (parameters) => waitForUserOperationReceipt(client, parameters)
  };
}

// node_modules/viem/_esm/account-abstraction/clients/decorators/paymaster.js
function paymasterActions(client) {
  return {
    getPaymasterData: (parameters) => getPaymasterData(client, parameters),
    getPaymasterStubData: (parameters) => getPaymasterStubData(client, parameters)
  };
}

// node_modules/viem/_esm/account-abstraction/constants/address.js
var entryPoint07Address2 = "0x0000000071727De22E5E9d8BAf0edAc6f37da032";

// node_modules/permissionless/_esm/actions/smartAccount/sendTransaction.js
async function sendTransaction2(client, args2) {
  let userOpHash;
  if ("to" in args2) {
    const { account: account_ = client.account, data, maxFeePerGas, maxPriorityFeePerGas, to: to3, value: value10, nonce } = args2;
    if (!account_) {
      throw new AccountNotFoundError2({
        docsPath: "/docs/actions/wallet/sendTransaction"
      });
    }
    const account = parseAccount(account_);
    if (!to3)
      throw new Error("Missing to address");
    userOpHash = await getAction(client, sendUserOperation, "sendUserOperation")({
      ...args2,
      calls: [
        {
          to: to3,
          value: value10 || BigInt(0),
          data: data || "0x"
        }
      ],
      account,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce: nonce ? BigInt(nonce) : void 0
    });
  } else {
    userOpHash = await getAction(client, sendUserOperation, "sendUserOperation")({ ...args2 });
  }
  const userOperationReceipt = await getAction(client, waitForUserOperationReceipt, "waitForUserOperationReceipt")({
    hash: userOpHash
  });
  return userOperationReceipt == null ? void 0 : userOperationReceipt.receipt.transactionHash;
}

// node_modules/permissionless/_esm/actions/smartAccount/signMessage.js
async function signMessage4(client, { account: account_ = client.account, message }) {
  if (!account_)
    throw new AccountNotFoundError2({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const account = parseAccount(account_);
  return account.signMessage({ message });
}

// node_modules/permissionless/_esm/actions/smartAccount/signTypedData.js
async function signTypedData4(client, { account: account_ = client.account, domain: domain2, message, primaryType, types: types_ }) {
  if (!account_) {
    throw new AccountNotFoundError2({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  }
  const account = parseAccount(account_);
  const types3 = {
    EIP712Domain: getTypesForEIP712Domain({ domain: domain2 }),
    ...types_
  };
  validateTypedData({
    domain: domain2,
    message,
    primaryType,
    types: types3
  });
  return account.signTypedData({
    domain: domain2,
    primaryType,
    types: types3,
    message
  });
}

// node_modules/permissionless/_esm/actions/smartAccount/writeContract.js
async function writeContract2(client, { abi: abi11, address, args: args2, dataSuffix, functionName, ...request2 }) {
  const data = encodeFunctionData({
    abi: abi11,
    args: args2,
    functionName
  });
  const hash11 = await getAction(client, sendTransaction2, "sendTransaction")({
    data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
    to: address,
    ...request2
  });
  return hash11;
}

// node_modules/permissionless/_esm/clients/decorators/smartAccount.js
function smartAccountActions(client) {
  return {
    sendTransaction: (args2) => sendTransaction2(client, args2),
    signMessage: (args2) => signMessage4(client, args2),
    signTypedData: (args2) => signTypedData4(client, args2),
    writeContract: (args2) => writeContract2(client, args2)
  };
}

// node_modules/permissionless/_esm/clients/createSmartAccountClient.js
function createSmartAccountClient(parameters) {
  var _a106;
  const { client: client_, key = "bundler", name = "Bundler Client", paymaster, paymasterContext, bundlerTransport, userOperation } = parameters;
  const client = Object.assign(createClient({
    ...parameters,
    chain: parameters.chain ?? (client_ == null ? void 0 : client_.chain),
    transport: bundlerTransport,
    key,
    name,
    type: "bundlerClient"
    // TODO: is this okay?
  }), { client: client_, paymaster, paymasterContext, userOperation });
  if ((_a106 = parameters.userOperation) == null ? void 0 : _a106.prepareUserOperation) {
    const customPrepareUserOp = parameters.userOperation.prepareUserOperation;
    return client.extend(bundlerActions).extend((client2) => ({
      prepareUserOperation: (args2) => {
        return customPrepareUserOp(client2, args2);
      }
    })).extend(bundlerActions).extend((client2) => ({
      prepareUserOperation: (args2) => {
        return customPrepareUserOp(client2, args2);
      }
    })).extend(smartAccountActions);
  }
  return client.extend(bundlerActions).extend(smartAccountActions);
}

// node_modules/permissionless/_esm/actions/public/getAccountNonce.js
var getAccountNonce = async (client, args2) => {
  const { address, entryPointAddress, key = BigInt(0) } = args2;
  return await getAction(client, readContract, "readContract")({
    address: entryPointAddress,
    abi: [
      {
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "key",
            type: "uint192"
          }
        ],
        name: "getNonce",
        outputs: [
          {
            name: "nonce",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ],
    functionName: "getNonce",
    args: [address, key]
  });
};

// node_modules/permissionless/_esm/accounts/light/toLightSmartAccount.js
var SignatureType;
(function(SignatureType2) {
  SignatureType2["EOA"] = "0x00";
})(SignatureType || (SignatureType = {}));

// node_modules/permissionless/_esm/accounts/etherspot/constants.js
var VALIDATOR_MODE;
(function(VALIDATOR_MODE3) {
  VALIDATOR_MODE3["DEFAULT"] = "0x00";
  VALIDATOR_MODE3["ENABLE"] = "0x01";
})(VALIDATOR_MODE || (VALIDATOR_MODE = {}));

// node_modules/permissionless/_esm/accounts/safe/signUserOperation.js
async function signUserOperation(parameters) {
  const { chainId, entryPoint, validAfter = 0, validUntil = 0, safe4337ModuleAddress: _safe4337ModuleAddress, version, owners, signatures: existingSignatures, account, ...userOperation } = parameters;
  const { safe4337ModuleAddress } = getDefaultAddresses(version, entryPoint.version, {
    safe4337ModuleAddress: _safe4337ModuleAddress
  });
  const message = {
    safe: userOperation.sender,
    callData: userOperation.callData,
    nonce: userOperation.nonce,
    initCode: userOperation.initCode ?? "0x",
    maxFeePerGas: userOperation.maxFeePerGas,
    maxPriorityFeePerGas: userOperation.maxPriorityFeePerGas,
    preVerificationGas: userOperation.preVerificationGas,
    verificationGasLimit: userOperation.verificationGasLimit,
    callGasLimit: userOperation.callGasLimit,
    paymasterAndData: userOperation.paymasterAndData ?? "0x",
    validAfter,
    validUntil,
    entryPoint: entryPoint.address
  };
  if ("initCode" in userOperation) {
    message.paymasterAndData = userOperation.paymasterAndData ?? "0x";
  }
  if ("factory" in userOperation) {
    if (userOperation.factory && userOperation.factoryData) {
      message.initCode = concatHex([
        userOperation.factory,
        userOperation.factoryData
      ]);
    }
    if (!userOperation.sender) {
      throw new Error("Sender is required");
    }
    message.paymasterAndData = getPaymasterAndData({
      ...userOperation,
      sender: userOperation.sender
    });
  }
  const localOwners = [
    await toOwner({
      owner: account
    })
  ];
  let unPackedSignatures = [];
  if (existingSignatures) {
    const decoded = decodeAbiParameters([
      {
        components: [
          { type: "address", name: "signer" },
          { type: "bytes", name: "data" }
        ],
        name: "signatures",
        type: "tuple[]"
      }
    ], existingSignatures);
    unPackedSignatures = decoded[0];
  }
  const signatures2 = [
    ...unPackedSignatures,
    ...await Promise.all(localOwners.map(async (localOwner) => ({
      signer: localOwner.address,
      data: await localOwner.signTypedData({
        domain: {
          chainId,
          verifyingContract: safe4337ModuleAddress
        },
        types: entryPoint.version === "0.6" ? EIP712_SAFE_OPERATION_TYPE_V06 : EIP712_SAFE_OPERATION_TYPE_V07,
        primaryType: "SafeOp",
        message
      })
    })))
  ];
  if (signatures2.length !== owners.length) {
    return encodeAbiParameters([
      {
        components: [
          { type: "address", name: "signer" },
          { type: "bytes", name: "data" }
        ],
        name: "signatures",
        type: "tuple[]"
      }
    ], [signatures2]);
  }
  signatures2.sort((left3, right3) => left3.signer.toLowerCase().localeCompare(right3.signer.toLowerCase()));
  const signatureBytes = concat(signatures2.map((sig) => sig.data));
  return encodePacked(["uint48", "uint48", "bytes"], [validAfter, validUntil, signatureBytes]);
}

// node_modules/permissionless/_esm/accounts/safe/toSafeSmartAccount.js
var multiSendAbi = [
  {
    inputs: [
      {
        internalType: "bytes",
        name: "transactions",
        type: "bytes"
      }
    ],
    name: "multiSend",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  }
];
var initSafe7579Abi = [
  {
    type: "function",
    name: "initSafe7579",
    inputs: [
      {
        name: "safe7579",
        type: "address",
        internalType: "address"
      },
      {
        name: "executors",
        type: "tuple[]",
        internalType: "struct ModuleInit[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "initData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "fallbacks",
        type: "tuple[]",
        internalType: "struct ModuleInit[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "initData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "hooks",
        type: "tuple[]",
        internalType: "struct ModuleInit[]",
        components: [
          {
            name: "module",
            type: "address",
            internalType: "address"
          },
          {
            name: "initData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      },
      {
        name: "attesters",
        type: "address[]",
        internalType: "address[]"
      },
      {
        name: "threshold",
        type: "uint8",
        internalType: "uint8"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  }
];
var preValidationSetupAbi = [
  {
    type: "function",
    name: "preValidationSetup",
    inputs: [
      {
        name: "initHash",
        type: "bytes32",
        internalType: "bytes32"
      },
      {
        name: "to",
        type: "address",
        internalType: "address"
      },
      {
        name: "preInit",
        type: "bytes",
        internalType: "bytes"
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  }
];
var enableModulesAbi = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "modules",
        type: "address[]"
      }
    ],
    name: "enableModules",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var setupAbi = [
  {
    inputs: [
      {
        internalType: "address[]",
        name: "_owners",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "_threshold",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "fallbackHandler",
        type: "address"
      },
      {
        internalType: "address",
        name: "paymentToken",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "payment",
        type: "uint256"
      },
      {
        internalType: "address payable",
        name: "paymentReceiver",
        type: "address"
      }
    ],
    name: "setup",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var createProxyWithNonceAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_singleton",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "initializer",
        type: "bytes"
      },
      {
        internalType: "uint256",
        name: "saltNonce",
        type: "uint256"
      }
    ],
    name: "createProxyWithNonce",
    outputs: [
      {
        internalType: "contract SafeProxy",
        name: "proxy",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var setupSafeAbi = [
  {
    type: "function",
    name: "setupSafe",
    inputs: [
      {
        name: "initData",
        type: "tuple",
        internalType: "struct Safe7579Launchpad.InitData",
        components: [
          {
            name: "singleton",
            type: "address",
            internalType: "address"
          },
          {
            name: "owners",
            type: "address[]",
            internalType: "address[]"
          },
          {
            name: "threshold",
            type: "uint256",
            internalType: "uint256"
          },
          {
            name: "setupTo",
            type: "address",
            internalType: "address"
          },
          {
            name: "setupData",
            type: "bytes",
            internalType: "bytes"
          },
          {
            name: "safe7579",
            type: "address",
            internalType: "contract ISafe7579"
          },
          {
            name: "validators",
            type: "tuple[]",
            internalType: "struct ModuleInit[]",
            components: [
              {
                name: "module",
                type: "address",
                internalType: "address"
              },
              {
                name: "initData",
                type: "bytes",
                internalType: "bytes"
              }
            ]
          },
          {
            name: "callData",
            type: "bytes",
            internalType: "bytes"
          }
        ]
      }
    ],
    outputs: [],
    stateMutability: "nonpayable"
  }
];
var executeUserOpWithErrorStringAbi = [
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "uint8",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "executeUserOpWithErrorString",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];
var EIP712_SAFE_OPERATION_TYPE_V06 = {
  SafeOp: [
    { type: "address", name: "safe" },
    { type: "uint256", name: "nonce" },
    { type: "bytes", name: "initCode" },
    { type: "bytes", name: "callData" },
    { type: "uint256", name: "callGasLimit" },
    { type: "uint256", name: "verificationGasLimit" },
    { type: "uint256", name: "preVerificationGas" },
    { type: "uint256", name: "maxFeePerGas" },
    { type: "uint256", name: "maxPriorityFeePerGas" },
    { type: "bytes", name: "paymasterAndData" },
    { type: "uint48", name: "validAfter" },
    { type: "uint48", name: "validUntil" },
    { type: "address", name: "entryPoint" }
  ]
};
var EIP712_SAFE_OPERATION_TYPE_V07 = {
  SafeOp: [
    { type: "address", name: "safe" },
    { type: "uint256", name: "nonce" },
    { type: "bytes", name: "initCode" },
    { type: "bytes", name: "callData" },
    { type: "uint128", name: "verificationGasLimit" },
    { type: "uint128", name: "callGasLimit" },
    { type: "uint256", name: "preVerificationGas" },
    { type: "uint128", name: "maxPriorityFeePerGas" },
    { type: "uint128", name: "maxFeePerGas" },
    { type: "bytes", name: "paymasterAndData" },
    { type: "uint48", name: "validAfter" },
    { type: "uint48", name: "validUntil" },
    { type: "address", name: "entryPoint" }
  ]
};
var SAFE_VERSION_TO_ADDRESSES_MAP = {
  "1.4.1": {
    "0.6": {
      SAFE_MODULE_SETUP_ADDRESS: "0x8EcD4ec46D4D2a6B64fE960B3D64e8B94B2234eb",
      SAFE_4337_MODULE_ADDRESS: "0xa581c4A4DB7175302464fF3C06380BC3270b4037",
      SAFE_PROXY_FACTORY_ADDRESS: "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
      SAFE_SINGLETON_ADDRESS: "0x41675C099F32341bf84BFc5382aF534df5C7461a",
      MULTI_SEND_ADDRESS: "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
      MULTI_SEND_CALL_ONLY_ADDRESS: "0x9641d764fc13c8B624c04430C7356C1C7C8102e2"
    },
    "0.7": {
      SAFE_MODULE_SETUP_ADDRESS: "0x2dd68b007B46fBe91B9A7c3EDa5A7a1063cB5b47",
      SAFE_4337_MODULE_ADDRESS: "0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226",
      SAFE_PROXY_FACTORY_ADDRESS: "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
      SAFE_SINGLETON_ADDRESS: "0x41675C099F32341bf84BFc5382aF534df5C7461a",
      MULTI_SEND_ADDRESS: "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
      MULTI_SEND_CALL_ONLY_ADDRESS: "0x9641d764fc13c8B624c04430C7356C1C7C8102e2"
    }
  }
};
var adjustVInSignature = (signingMethod, signature) => {
  const ETHEREUM_V_VALUES = [0, 1, 27, 28];
  const MIN_VALID_V_VALUE_FOR_SAFE_ECDSA = 27;
  let signatureV = Number.parseInt(signature.slice(-2), 16);
  if (!ETHEREUM_V_VALUES.includes(signatureV)) {
    throw new Error("Invalid signature");
  }
  if (signingMethod === "eth_sign") {
    if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
      signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;
    }
    signatureV += 4;
  }
  if (signingMethod === "eth_signTypedData") {
    if (signatureV < MIN_VALID_V_VALUE_FOR_SAFE_ECDSA) {
      signatureV += MIN_VALID_V_VALUE_FOR_SAFE_ECDSA;
    }
  }
  return signature.slice(0, -2) + signatureV.toString(16);
};
var generateSafeMessageMessage = (message) => {
  const signableMessage = message;
  if (typeof signableMessage === "string" || signableMessage.raw) {
    return hashMessage(signableMessage);
  }
  return hashTypedData(message);
};
var encodeInternalTransaction = (tx) => {
  const encoded = encodePacked(
    // uint8 = 1 byte for operation
    // address = 20 bytes for to address
    // uint256 = 32 bytes for value
    // uint256 = 32 bytes for data length
    // bytes = dynamic length for data
    ["uint8", "address", "uint256", "uint256", "bytes"],
    [
      tx.operation,
      tx.to,
      tx.value,
      BigInt(tx.data.slice(2).length / 2),
      tx.data
    ]
  );
  return encoded.slice(2);
};
var encodeMultiSend = (txs) => {
  const data = `0x${txs.map((tx) => encodeInternalTransaction(tx)).join("")}`;
  return encodeFunctionData({
    abi: multiSendAbi,
    functionName: "multiSend",
    args: [data]
  });
};
var get7579LaunchPadInitData = ({ safe4337ModuleAddress, safeSingletonAddress, erc7579LaunchpadAddress, owners, validators, executors, fallbacks, hooks, attesters, threshold, attestersThreshold }) => {
  const initData = {
    singleton: safeSingletonAddress,
    owners,
    threshold,
    setupTo: erc7579LaunchpadAddress,
    setupData: encodeFunctionData({
      abi: initSafe7579Abi,
      functionName: "initSafe7579",
      args: [
        safe4337ModuleAddress,
        // SAFE_7579_ADDRESS,
        executors.map((executor) => ({
          module: executor.address,
          initData: executor.context
        })),
        fallbacks.map((fallback3) => ({
          module: fallback3.address,
          initData: fallback3.context
        })),
        hooks.map((hook) => ({
          module: hook.address,
          initData: hook.context
        })),
        attesters.sort((left3, right3) => left3.toLowerCase().localeCompare(right3.toLowerCase())),
        attestersThreshold
      ]
    }),
    safe7579: safe4337ModuleAddress,
    validators
  };
  return initData;
};
var getInitializerCode = async ({ owners, threshold, safeModuleSetupAddress, safe4337ModuleAddress, multiSendAddress, safeSingletonAddress, erc7579LaunchpadAddress, setupTransactions = [], safeModules = [], validators = [], executors = [], fallbacks = [], hooks = [], attesters = [], attestersThreshold = 0, paymentToken = zeroAddress, payment = BigInt(0), paymentReceiver = zeroAddress }) => {
  if (erc7579LaunchpadAddress) {
    const initData = get7579LaunchPadInitData({
      safe4337ModuleAddress,
      safeSingletonAddress,
      erc7579LaunchpadAddress,
      owners,
      validators,
      executors,
      fallbacks,
      threshold,
      hooks,
      attesters,
      attestersThreshold
    });
    const initHash = keccak256(encodeAbiParameters([
      {
        internalType: "address",
        name: "singleton",
        type: "address"
      },
      {
        internalType: "address[]",
        name: "owners",
        type: "address[]"
      },
      {
        internalType: "uint256",
        name: "threshold",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "setupTo",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "setupData",
        type: "bytes"
      },
      {
        internalType: "contract ISafe7579",
        name: "safe7579",
        type: "address"
      },
      {
        internalType: "struct ModuleInit[]",
        name: "validators",
        type: "tuple[]",
        components: [
          {
            internalType: "address",
            name: "module",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "initData",
            type: "bytes"
          }
        ]
      }
    ], [
      initData.singleton,
      initData.owners,
      initData.threshold,
      initData.setupTo,
      initData.setupData,
      initData.safe7579,
      initData.validators.map((validator) => ({
        module: validator.address,
        initData: validator.context
      }))
    ]));
    return encodeFunctionData({
      abi: preValidationSetupAbi,
      functionName: "preValidationSetup",
      args: [initHash, zeroAddress, "0x"]
    });
  }
  const multiSendCallData = encodeMultiSend([
    {
      to: safeModuleSetupAddress,
      data: encodeFunctionData({
        abi: enableModulesAbi,
        functionName: "enableModules",
        args: [[safe4337ModuleAddress, ...safeModules]]
      }),
      value: BigInt(0),
      operation: 1
    },
    ...setupTransactions.map((tx) => ({ ...tx, operation: 0 }))
  ]);
  return encodeFunctionData({
    abi: setupAbi,
    functionName: "setup",
    args: [
      owners,
      threshold,
      multiSendAddress,
      multiSendCallData,
      safe4337ModuleAddress,
      paymentToken,
      payment,
      paymentReceiver
    ]
  });
};
function getPaymasterAndData(unpackedUserOperation) {
  return unpackedUserOperation.paymaster ? concat([
    unpackedUserOperation.paymaster,
    pad(toHex(unpackedUserOperation.paymasterVerificationGasLimit || BigInt(0)), {
      size: 16
    }),
    pad(toHex(unpackedUserOperation.paymasterPostOpGasLimit || BigInt(0)), {
      size: 16
    }),
    unpackedUserOperation.paymasterData || "0x"
  ]) : "0x";
}
var getAccountInitCode = async ({ owners, threshold, safeModuleSetupAddress, safe4337ModuleAddress, safeSingletonAddress, erc7579LaunchpadAddress, multiSendAddress, paymentToken, payment, paymentReceiver, saltNonce = BigInt(0), setupTransactions = [], safeModules = [], validators = [], executors = [], fallbacks = [], hooks = [], attesters = [], attestersThreshold = 0 }) => {
  const initializer = await getInitializerCode({
    owners,
    threshold,
    safeModuleSetupAddress,
    safe4337ModuleAddress,
    multiSendAddress,
    setupTransactions,
    safeSingletonAddress,
    safeModules,
    erc7579LaunchpadAddress,
    validators,
    executors,
    fallbacks,
    hooks,
    attesters,
    attestersThreshold,
    paymentToken,
    payment,
    paymentReceiver
  });
  const initCodeCallData = encodeFunctionData({
    abi: createProxyWithNonceAbi,
    functionName: "createProxyWithNonce",
    args: [
      erc7579LaunchpadAddress ?? safeSingletonAddress,
      initializer,
      saltNonce
    ]
  });
  return initCodeCallData;
};
var getDefaultAddresses = (safeVersion, entryPointVersion, { addModuleLibAddress: _addModuleLibAddress, safeModuleSetupAddress: _safeModuleSetupAddress, safe4337ModuleAddress: _safe4337ModuleAddress, safeProxyFactoryAddress: _safeProxyFactoryAddress, safeSingletonAddress: _safeSingletonAddress, multiSendAddress: _multiSendAddress, multiSendCallOnlyAddress: _multiSendCallOnlyAddress }) => {
  const safeModuleSetupAddress = _safeModuleSetupAddress ?? _addModuleLibAddress ?? SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion].SAFE_MODULE_SETUP_ADDRESS;
  const safe4337ModuleAddress = _safe4337ModuleAddress ?? SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion].SAFE_4337_MODULE_ADDRESS;
  const safeProxyFactoryAddress = _safeProxyFactoryAddress ?? SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion].SAFE_PROXY_FACTORY_ADDRESS;
  const safeSingletonAddress = _safeSingletonAddress ?? SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion].SAFE_SINGLETON_ADDRESS;
  const multiSendAddress = _multiSendAddress ?? SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion].MULTI_SEND_ADDRESS;
  const multiSendCallOnlyAddress = _multiSendCallOnlyAddress ?? SAFE_VERSION_TO_ADDRESSES_MAP[safeVersion][entryPointVersion].MULTI_SEND_CALL_ONLY_ADDRESS;
  return {
    safeModuleSetupAddress,
    safe4337ModuleAddress,
    safeProxyFactoryAddress,
    safeSingletonAddress,
    multiSendAddress,
    multiSendCallOnlyAddress
  };
};
function isErc7579Args(args2) {
  return args2.erc7579LaunchpadAddress !== void 0;
}
var proxyCreationCodeAbi = [
  {
    inputs: [],
    name: "proxyCreationCode",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "pure",
    type: "function"
  }
];
var getAccountAddress = async ({ client, owners, threshold, safeModuleSetupAddress, safe4337ModuleAddress, safeProxyFactoryAddress, safeSingletonAddress, multiSendAddress, erc7579LaunchpadAddress, paymentToken, payment, paymentReceiver, setupTransactions = [], safeModules = [], saltNonce = BigInt(0), validators = [], executors = [], fallbacks = [], hooks = [], attesters = [], attestersThreshold = 0 }) => {
  const proxyCreationCode = await readContract(client, {
    abi: proxyCreationCodeAbi,
    address: safeProxyFactoryAddress,
    functionName: "proxyCreationCode"
  });
  const initializer = await getInitializerCode({
    owners,
    threshold,
    safeModuleSetupAddress,
    safe4337ModuleAddress,
    multiSendAddress,
    setupTransactions,
    safeSingletonAddress,
    safeModules,
    erc7579LaunchpadAddress,
    validators,
    executors,
    fallbacks,
    hooks,
    attesters,
    attestersThreshold,
    paymentToken,
    payment,
    paymentReceiver
  });
  const deploymentCode = encodePacked(["bytes", "uint256"], [
    proxyCreationCode,
    hexToBigInt(erc7579LaunchpadAddress ?? safeSingletonAddress)
  ]);
  const salt = keccak256(encodePacked(["bytes32", "uint256"], [keccak256(encodePacked(["bytes"], [initializer])), saltNonce]));
  return getContractAddress({
    from: safeProxyFactoryAddress,
    salt,
    bytecode: deploymentCode,
    opcode: "CREATE2"
  });
};
async function toSafeSmartAccount(parameters) {
  var _a106, _b32, _c7;
  const { client, owners: _owners, address, threshold = BigInt(_owners.length), version, safe4337ModuleAddress: _safe4337ModuleAddress, safeProxyFactoryAddress: _safeProxyFactoryAddress, safeSingletonAddress: _safeSingletonAddress, erc7579LaunchpadAddress, saltNonce = BigInt(0), validUntil = 0, validAfter = 0, nonceKey, paymentToken, payment, paymentReceiver, onchainIdentifier } = parameters;
  const owners = await Promise.all(_owners.map(async (owner) => {
    if ("account" in owner) {
      return owner.account;
    }
    if ("request" in owner) {
      return toOwner({
        owner
      });
    }
    return owner;
  }));
  const localOwners = await Promise.all(_owners.filter((owner) => {
    if ("type" in owner && owner.type === "local") {
      return true;
    }
    if ("request" in owner) {
      return true;
    }
    if ("account" in owner) {
      return true;
    }
    return false;
  }).map((owner) => toOwner({
    owner
  })));
  const entryPoint = {
    address: ((_a106 = parameters.entryPoint) == null ? void 0 : _a106.address) ?? entryPoint07Address2,
    abi: (((_b32 = parameters.entryPoint) == null ? void 0 : _b32.version) ?? "0.7") === "0.6" ? entryPoint06Abi : entryPoint07Abi,
    version: ((_c7 = parameters.entryPoint) == null ? void 0 : _c7.version) ?? "0.7"
  };
  let _safeModuleSetupAddress = void 0;
  let _multiSendAddress = void 0;
  let _multiSendCallOnlyAddress = void 0;
  let safeModules = void 0;
  let setupTransactions = [];
  let validators = [];
  let executors = [];
  let fallbacks = [];
  let hooks = [];
  let attesters = [];
  let attestersThreshold = 0;
  if (!isErc7579Args(parameters)) {
    _safeModuleSetupAddress = parameters.safeModuleSetupAddress;
    _multiSendAddress = parameters.multiSendAddress;
    _multiSendCallOnlyAddress = parameters.multiSendCallOnlyAddress;
    safeModules = parameters.safeModules;
    setupTransactions = parameters.setupTransactions ?? [];
  }
  if (isErc7579Args(parameters)) {
    validators = parameters.validators ?? [];
    executors = parameters.executors ?? [];
    fallbacks = parameters.fallbacks ?? [];
    hooks = parameters.hooks ?? [];
    attesters = parameters.attesters ?? [];
    attestersThreshold = parameters.attestersThreshold ?? 0;
  }
  const { safeModuleSetupAddress, safe4337ModuleAddress, safeProxyFactoryAddress, safeSingletonAddress, multiSendAddress, multiSendCallOnlyAddress } = getDefaultAddresses(version, entryPoint.version, {
    safeModuleSetupAddress: _safeModuleSetupAddress,
    safe4337ModuleAddress: _safe4337ModuleAddress,
    safeProxyFactoryAddress: _safeProxyFactoryAddress,
    safeSingletonAddress: _safeSingletonAddress,
    multiSendAddress: _multiSendAddress,
    multiSendCallOnlyAddress: _multiSendCallOnlyAddress
  });
  let accountAddress = address;
  let chainId;
  const getMemoizedChainId = async () => {
    if (chainId)
      return chainId;
    chainId = client.chain ? client.chain.id : await getAction(client, getChainId, "getChainId")({});
    return chainId;
  };
  const getFactoryArgs = async () => {
    return {
      factory: safeProxyFactoryAddress,
      factoryData: await getAccountInitCode({
        owners: owners.map((owner) => owner.address),
        threshold,
        safeModuleSetupAddress,
        safe4337ModuleAddress,
        safeSingletonAddress,
        multiSendAddress,
        erc7579LaunchpadAddress,
        saltNonce,
        setupTransactions,
        safeModules,
        validators,
        executors,
        fallbacks,
        hooks,
        attesters,
        attestersThreshold,
        paymentToken,
        payment,
        paymentReceiver
      })
    };
  };
  return toSmartAccount({
    client,
    entryPoint,
    getFactoryArgs,
    async getAddress() {
      if (accountAddress)
        return accountAddress;
      accountAddress = await getAccountAddress({
        client,
        owners: owners.map((owner) => owner.address),
        threshold,
        safeModuleSetupAddress,
        safe4337ModuleAddress,
        safeProxyFactoryAddress,
        safeSingletonAddress,
        multiSendAddress,
        erc7579LaunchpadAddress,
        saltNonce,
        setupTransactions,
        safeModules,
        validators,
        executors,
        fallbacks,
        hooks,
        attesters,
        attestersThreshold,
        paymentToken,
        payment,
        paymentReceiver
      });
      return accountAddress;
    },
    async encodeCalls(calls) {
      const hasMultipleCalls = calls.length > 1;
      if (erc7579LaunchpadAddress) {
        const safeDeployed = await isSmartAccountDeployed(client, await this.getAddress());
        if (!safeDeployed) {
          const initData = get7579LaunchPadInitData({
            safe4337ModuleAddress,
            safeSingletonAddress,
            erc7579LaunchpadAddress,
            owners: owners.map((owner) => owner.address),
            threshold,
            validators,
            executors,
            fallbacks,
            hooks,
            attesters,
            attestersThreshold
          });
          return encodeFunctionData({
            abi: setupSafeAbi,
            functionName: "setupSafe",
            args: [
              {
                ...initData,
                validators: initData.validators.map((validator) => ({
                  module: validator.address,
                  initData: validator.context
                })),
                callData: encode7579Calls({
                  mode: {
                    type: hasMultipleCalls ? "batchcall" : "call",
                    revertOnError: false,
                    selector: "0x",
                    context: "0x"
                  },
                  callData: calls
                })
              }
            ]
          });
        }
        return encode7579Calls({
          mode: {
            type: hasMultipleCalls ? "batchcall" : "call",
            revertOnError: false,
            selector: "0x",
            context: "0x"
          },
          callData: calls
        });
      }
      let to3;
      let value10;
      let data;
      let operationType = 0;
      if (hasMultipleCalls) {
        to3 = multiSendCallOnlyAddress;
        value10 = BigInt(0);
        data = encodeMultiSend(calls.map((tx) => ({
          to: tx.to,
          value: tx.value ?? 0n,
          data: tx.data ?? "0x",
          operation: 0
        })));
        operationType = 1;
      } else {
        const call2 = calls.length === 0 ? void 0 : calls[0];
        if (!call2) {
          throw new Error("No calls to encode");
        }
        to3 = call2.to;
        data = call2.data ?? "0x";
        value10 = call2.value ?? 0n;
      }
      const calldata = encodeFunctionData({
        abi: executeUserOpWithErrorStringAbi,
        functionName: "executeUserOpWithErrorString",
        args: [to3, value10, data, operationType]
      });
      if (onchainIdentifier) {
        return concat([calldata, onchainIdentifier]);
      }
      return calldata;
    },
    async decodeCalls(callData) {
      try {
        const decoded2 = decodeFunctionData({
          abi: setupSafeAbi,
          data: callData
        });
        return decode7579Calls(decoded2.args[0].callData).callData;
      } catch (_) {
      }
      try {
        return decode7579Calls(callData).callData;
      } catch (_) {
      }
      const decoded = decodeFunctionData({
        abi: executeUserOpWithErrorStringAbi,
        data: callData
      });
      const to3 = decoded.args[0];
      const value10 = decoded.args[1];
      const data = decoded.args[2];
      if (to3 === multiSendCallOnlyAddress) {
        const decodedMultiSend = decodeFunctionData({
          abi: multiSendAbi,
          data
        });
        const dataToDecode = decodedMultiSend.args[0];
        const transactions = [];
        let position = 0;
        const dataLength = size(dataToDecode);
        while (position < dataLength) {
          position += 1;
          const to4 = getAddress(slice(dataToDecode, position, position + 20));
          position += 20;
          const value11 = BigInt(slice(dataToDecode, position, position + 32));
          position += 32;
          const dataLength2 = Number(BigInt(slice(dataToDecode, position, position + 32)) * BigInt(2));
          position += 32;
          const data2 = slice(dataToDecode, position, position + dataLength2);
          position += dataLength2;
          transactions.push({ to: to4, value: value11, data: data2 });
        }
        return transactions;
      }
      return [{ to: to3, value: value10, data }];
    },
    async getNonce(args2) {
      return getAccountNonce(client, {
        address: await this.getAddress(),
        entryPointAddress: entryPoint.address,
        key: nonceKey ?? (args2 == null ? void 0 : args2.key)
      });
    },
    async getStubSignature() {
      return encodePacked(["uint48", "uint48", "bytes"], [
        0,
        0,
        `0x${owners.map((_) => "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff").join("")}`
      ]);
    },
    async sign({ hash: hash11 }) {
      return this.signMessage({ message: hash11 });
    },
    async signMessage({ message }) {
      if (localOwners.length !== owners.length) {
        throw new Error("Owners length mismatch, currently not supported");
      }
      const messageHash = hashTypedData({
        domain: {
          chainId: await getMemoizedChainId(),
          verifyingContract: await this.getAddress()
        },
        types: {
          SafeMessage: [{ name: "message", type: "bytes" }]
        },
        primaryType: "SafeMessage",
        message: {
          message: generateSafeMessageMessage(message)
        }
      });
      const signatures2 = await Promise.all(localOwners.map(async (localOwner) => ({
        signer: localOwner.address,
        data: adjustVInSignature("eth_sign", await localOwner.signMessage({
          message: {
            raw: toBytes(messageHash)
          }
        }))
      })));
      signatures2.sort((left3, right3) => left3.signer.toLowerCase().localeCompare(right3.signer.toLowerCase()));
      const signatureBytes = concat(signatures2.map((sig) => sig.data));
      return erc7579LaunchpadAddress ? concat([zeroAddress, signatureBytes]) : signatureBytes;
    },
    async signTypedData(typedData) {
      if (localOwners.length !== owners.length) {
        throw new Error("Owners length mismatch, currently not supported");
      }
      const signatures2 = await Promise.all(localOwners.map(async (localOwner) => ({
        signer: localOwner.address,
        data: adjustVInSignature("eth_signTypedData", await localOwner.signTypedData({
          domain: {
            chainId: await getMemoizedChainId(),
            verifyingContract: await this.getAddress()
          },
          types: {
            SafeMessage: [
              { name: "message", type: "bytes" }
            ]
          },
          primaryType: "SafeMessage",
          message: {
            message: generateSafeMessageMessage(typedData)
          }
        }))
      })));
      signatures2.sort((left3, right3) => left3.signer.toLowerCase().localeCompare(right3.signer.toLowerCase()));
      const signatureBytes = concat(signatures2.map((sig) => sig.data));
      return erc7579LaunchpadAddress ? concat([zeroAddress, signatureBytes]) : signatureBytes;
    },
    async signUserOperation(parameters2) {
      const { chainId: chainId2 = await getMemoizedChainId(), ...userOperation } = parameters2;
      if (localOwners.length !== owners.length) {
        throw new Error("Owners length mismatch use SafeSmartAccount.signUserOperation from `permissionless/accounts/safe`");
      }
      let signatures2 = void 0;
      for (const owner of localOwners) {
        signatures2 = await signUserOperation({
          ...userOperation,
          version,
          entryPoint,
          owners: localOwners,
          account: owner,
          chainId: await getMemoizedChainId(),
          signatures: signatures2,
          validAfter,
          validUntil,
          safe4337ModuleAddress
        });
      }
      if (!signatures2) {
        throw new Error("No signatures found");
      }
      return signatures2;
    }
  });
}

// node_modules/ox/_esm/core/Abi.js
var Abi_exports = {};
__export(Abi_exports, {
  format: () => format12,
  from: () => from10
});

// node_modules/ox/_esm/core/internal/abi.js
function isSignatures(value10) {
  for (const item of value10) {
    if (typeof item !== "string")
      return false;
  }
  return true;
}

// node_modules/ox/_esm/core/Abi.js
function format12(abi11) {
  return formatAbi(abi11);
}
function from10(abi11) {
  if (isSignatures(abi11))
    return parseAbi(abi11);
  return abi11;
}

// node_modules/ox/_esm/core/AbiError.js
var AbiError_exports = {};
__export(AbiError_exports, {
  decode: () => decode9,
  encode: () => encode11,
  format: () => format13,
  from: () => from11,
  fromAbi: () => fromAbi4,
  getSelector: () => getSelector3,
  panicReasons: () => panicReasons2,
  solidityError: () => solidityError,
  solidityErrorSelector: () => solidityErrorSelector,
  solidityPanic: () => solidityPanic,
  solidityPanicSelector: () => solidityPanicSelector
});
function decode9(abiError, data, options = {}) {
  if (size3(data) < 4)
    throw new InvalidSelectorSizeError({ data });
  if (abiError.inputs.length === 0)
    return void 0;
  const values15 = decode7(abiError.inputs, slice3(data, 4), options);
  if (values15 && Object.keys(values15).length === 1) {
    if (Array.isArray(values15))
      return values15[0];
    return Object.values(values15)[0];
  }
  return values15;
}
function encode11(abiError, ...args2) {
  const selector = getSelector3(abiError);
  const data = args2.length > 0 ? encode8(abiError.inputs, args2[0]) : void 0;
  return data ? concat3(selector, data) : selector;
}
function format13(abiError) {
  return formatAbiItem(abiError);
}
function from11(abiError, options = {}) {
  return from5(abiError, options);
}
function fromAbi4(abi11, name, options) {
  if (name === "Error")
    return solidityError;
  if (name === "Panic")
    return solidityPanic;
  if (validate2(name, { strict: false })) {
    const selector = slice3(name, 0, 4);
    if (selector === solidityErrorSelector)
      return solidityError;
    if (selector === solidityPanicSelector)
      return solidityPanic;
  }
  const item = fromAbi(abi11, name, options);
  if (item.type !== "error")
    throw new NotFoundError({ name, type: "error" });
  return item;
}
function getSelector3(abiItem) {
  return getSelector(abiItem);
}
var panicReasons2 = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
var solidityError = from11({
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
});
var solidityErrorSelector = "0x08c379a0";
var solidityPanic = from11({
  inputs: [
    {
      name: "reason",
      type: "uint8"
    }
  ],
  name: "Panic",
  type: "error"
});
var solidityPanicSelector = "0x4e487b71";

// node_modules/ox/_esm/core/AbiEvent.js
var AbiEvent_exports = {};
__export(AbiEvent_exports, {
  ArgsMismatchError: () => ArgsMismatchError,
  DataMismatchError: () => DataMismatchError,
  FilterTypeNotSupportedError: () => FilterTypeNotSupportedError2,
  InputNotFoundError: () => InputNotFoundError,
  SelectorTopicMismatchError: () => SelectorTopicMismatchError,
  TopicsMismatchError: () => TopicsMismatchError,
  assertArgs: () => assertArgs,
  decode: () => decode10,
  encode: () => encode12,
  format: () => format14,
  from: () => from12,
  fromAbi: () => fromAbi5,
  getSelector: () => getSelector4
});
function assertArgs(abiEvent, args2, matchArgs) {
  if (!args2 || !matchArgs)
    throw new ArgsMismatchError({
      abiEvent,
      expected: args2,
      given: matchArgs
    });
  function isEqual4(input, value10, arg) {
    if (input.type === "address")
      return isEqual3(value10, arg);
    if (input.type === "string")
      return keccak2562(fromString(value10)) === arg;
    if (input.type === "bytes")
      return keccak2562(value10) === arg;
    return value10 === arg;
  }
  if (Array.isArray(args2) && Array.isArray(matchArgs)) {
    for (const [index3, value10] of matchArgs.entries()) {
      if (value10 === null || value10 === void 0)
        continue;
      const input = abiEvent.inputs[index3];
      if (!input)
        throw new InputNotFoundError({
          abiEvent,
          name: `${index3}`
        });
      const value_ = Array.isArray(value10) ? value10 : [value10];
      let equal = false;
      for (const value11 of value_) {
        if (isEqual4(input, value11, args2[index3]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args2,
          given: matchArgs
        });
    }
  }
  if (typeof args2 === "object" && !Array.isArray(args2) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    for (const [key, value10] of Object.entries(matchArgs)) {
      if (value10 === null || value10 === void 0)
        continue;
      const input = abiEvent.inputs.find((input2) => input2.name === key);
      if (!input)
        throw new InputNotFoundError({ abiEvent, name: key });
      const value_ = Array.isArray(value10) ? value10 : [value10];
      let equal = false;
      for (const value11 of value_) {
        if (isEqual4(input, value11, args2[key]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args2,
          given: matchArgs
        });
    }
}
function decode10(abiEvent, log5) {
  const { data, topics } = log5;
  const [selector_, ...argTopics] = topics;
  const selector = getSelector4(abiEvent);
  if (selector_ !== selector)
    throw new SelectorTopicMismatchError({
      abiEvent,
      actual: selector_,
      expected: selector
    });
  const { inputs } = abiEvent;
  const isUnnamed = inputs == null ? void 0 : inputs.every((x) => !("name" in x && x.name));
  let args2 = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
  for (let i = 0; i < indexedInputs.length; i++) {
    const param = indexedInputs[i];
    const topic = argTopics[i];
    if (!topic)
      throw new TopicsMismatchError({
        abiEvent,
        param
      });
    args2[isUnnamed ? i : param.name || i] = (() => {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return topic;
      const decoded = decode7([param], topic) || [];
      return decoded[0];
    })();
  }
  const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decode7(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args2 = [...args2, ...decodedData];
          else {
            for (let i = 0; i < nonIndexedInputs.length; i++) {
              const index3 = inputs.indexOf(nonIndexedInputs[i]);
              args2[nonIndexedInputs[i].name || index3] = decodedData[i];
            }
          }
        }
      } catch (err2) {
        if (err2 instanceof DataSizeTooSmallError || err2 instanceof PositionOutOfBoundsError2)
          throw new DataMismatchError({
            abiEvent,
            data,
            parameters: nonIndexedInputs,
            size: size3(data)
          });
        throw err2;
      }
    } else {
      throw new DataMismatchError({
        abiEvent,
        data: "0x",
        parameters: nonIndexedInputs,
        size: 0
      });
    }
  }
  return Object.values(args2).length > 0 ? args2 : void 0;
}
function encode12(abiEvent, ...[args2]) {
  let topics = [];
  if (args2 && abiEvent.inputs) {
    const indexedInputs = abiEvent.inputs.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args2) ? args2 : Object.values(args2).length > 0 ? (indexedInputs == null ? void 0 : indexedInputs.map((x, i) => args2[x.name ?? i])) ?? [] : [];
    if (args_.length > 0) {
      const encode16 = (param, value10) => {
        if (param.type === "string")
          return keccak2562(fromString2(value10));
        if (param.type === "bytes")
          return keccak2562(value10);
        if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
          throw new FilterTypeNotSupportedError2(param.type);
        return encode8([param], [value10]);
      };
      topics = (indexedInputs == null ? void 0 : indexedInputs.map((param, i) => {
        if (Array.isArray(args_[i]))
          return args_[i].map((_, j) => encode16(param, args_[i][j]));
        return typeof args_[i] !== "undefined" && args_[i] !== null ? encode16(param, args_[i]) : null;
      })) ?? [];
    }
  }
  const selector = (() => {
    if (abiEvent.hash)
      return abiEvent.hash;
    return getSelector4(abiEvent);
  })();
  return { topics: [selector, ...topics] };
}
function format14(abiEvent) {
  return formatAbiItem(abiEvent);
}
function from12(abiEvent, options = {}) {
  return from5(abiEvent, options);
}
function fromAbi5(abi11, name, options) {
  const item = fromAbi(abi11, name, options);
  if (item.type !== "event")
    throw new NotFoundError({ name, type: "event" });
  return item;
}
function getSelector4(abiItem) {
  return getSignatureHash(abiItem);
}
var ArgsMismatchError = class extends BaseError2 {
  constructor({ abiEvent, expected, given }) {
    super("Given arguments do not match the expected arguments.", {
      metaMessages: [
        `Event: ${format14(abiEvent)}`,
        `Expected Arguments: ${!expected ? "None" : ""}`,
        expected ? prettyPrint2(expected) : void 0,
        `Given Arguments: ${!given ? "None" : ""}`,
        given ? prettyPrint2(given) : void 0
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.ArgsMismatchError"
    });
  }
};
var InputNotFoundError = class extends BaseError2 {
  constructor({ abiEvent, name }) {
    super(`Parameter "${name}" not found on \`${format14(abiEvent)}\`.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.InputNotFoundError"
    });
  }
};
var DataMismatchError = class extends BaseError2 {
  constructor({ abiEvent, data, parameters, size: size45 }) {
    super([
      `Data size of ${size45} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Non-indexed Parameters: (${format9(parameters)})`,
        `Data:   ${data} (${size45} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.DataMismatchError"
    });
    Object.defineProperty(this, "abiEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parameters", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiEvent = abiEvent;
    this.data = data;
    this.parameters = parameters;
    this.size = size45;
  }
};
var TopicsMismatchError = class extends BaseError2 {
  constructor({ abiEvent, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} for "${format14(abiEvent)}".`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.TopicsMismatchError"
    });
    Object.defineProperty(this, "abiEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiEvent = abiEvent;
  }
};
var SelectorTopicMismatchError = class extends BaseError2 {
  constructor({ abiEvent, actual, expected }) {
    super(`topics[0]="${actual}" does not match the expected topics[0]="${expected}".`, {
      metaMessages: [`Event: ${format14(abiEvent)}`, `Selector: ${expected}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.SelectorTopicMismatchError"
    });
  }
};
var FilterTypeNotSupportedError2 = class extends BaseError2 {
  constructor(type8) {
    super(`Filter type "${type8}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.FilterTypeNotSupportedError"
    });
  }
};

// node_modules/ox/_esm/core/AccessList.js
var AccessList_exports = {};
__export(AccessList_exports, {
  InvalidStorageKeySizeError: () => InvalidStorageKeySizeError2,
  fromTupleList: () => fromTupleList,
  toTupleList: () => toTupleList
});
function fromTupleList(accessList) {
  const list = [];
  for (let i = 0; i < accessList.length; i++) {
    const [address, storageKeys] = accessList[i];
    if (address)
      assert5(address, { strict: false });
    list.push({
      address,
      storageKeys: storageKeys.map((key) => validate10(key) ? key : trimLeft2(key))
    });
  }
  return list;
}
function toTupleList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const tuple7 = [];
  for (const { address, storageKeys } of accessList) {
    for (let j = 0; j < storageKeys.length; j++)
      if (size3(storageKeys[j]) !== 32)
        throw new InvalidStorageKeySizeError2({
          storageKey: storageKeys[j]
        });
    if (address)
      assert5(address, { strict: false });
    tuple7.push([address, storageKeys]);
  }
  return tuple7;
}
var InvalidStorageKeySizeError2 = class extends BaseError2 {
  constructor({ storageKey }) {
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${size3(storageKey)} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccessList.InvalidStorageKeySizeError"
    });
  }
};

// node_modules/ox/_esm/core/AccountProof.js
var AccountProof_exports = {};

// node_modules/ox/_esm/core/AesGcm.js
var AesGcm_exports = {};
__export(AesGcm_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  getKey: () => getKey,
  ivLength: () => ivLength,
  randomSalt: () => randomSalt
});
var ivLength = 16;
async function decrypt(value10, key, options = {}) {
  const { as: as18 = typeof value10 === "string" ? "Hex" : "Bytes" } = options;
  const encrypted = from(value10);
  const iv = encrypted.slice(0, ivLength);
  const data = encrypted.slice(ivLength);
  const decrypted = await globalThis.crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, key, from(data));
  const result = new Uint8Array(decrypted);
  if (as18 === "Bytes")
    return result;
  return from2(result);
}
async function encrypt(value10, key, options = {}) {
  const { as: as18 = typeof value10 === "string" ? "Hex" : "Bytes" } = options;
  const iv = random(ivLength);
  const encrypted = await globalThis.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, key, from(value10));
  const result = concat2(iv, new Uint8Array(encrypted));
  if (as18 === "Bytes")
    return result;
  return from2(result);
}
async function getKey(options) {
  const { iterations = 9e5, password, salt = randomSalt(32) } = options;
  const baseKey = await globalThis.crypto.subtle.importKey("raw", fromString(password), { name: "PBKDF2" }, false, ["deriveBits", "deriveKey"]);
  const key = await globalThis.crypto.subtle.deriveKey({
    name: "PBKDF2",
    salt,
    iterations,
    hash: "SHA-256"
  }, baseKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
  return key;
}
function randomSalt(size45 = 32) {
  return random(size45);
}

// node_modules/ox/_esm/core/Authorization.js
var Authorization_exports = {};
__export(Authorization_exports, {
  from: () => from14,
  fromRpc: () => fromRpc3,
  fromRpcList: () => fromRpcList,
  fromTuple: () => fromTuple2,
  fromTupleList: () => fromTupleList2,
  getSignPayload: () => getSignPayload2,
  hash: () => hash4,
  toRpc: () => toRpc4,
  toRpcList: () => toRpcList,
  toTuple: () => toTuple2,
  toTupleList: () => toTupleList2
});

// node_modules/ox/_esm/core/Rlp.js
var Rlp_exports = {};
__export(Rlp_exports, {
  decodeRlpCursor: () => decodeRlpCursor,
  from: () => from13,
  fromBytes: () => fromBytes7,
  fromHex: () => fromHex6,
  readLength: () => readLength,
  readList: () => readList,
  to: () => to,
  toBytes: () => toBytes8,
  toHex: () => toHex6
});
function toBytes8(value10) {
  return to(value10, "Bytes");
}
function toHex6(value10) {
  return to(value10, "Hex");
}
function to(value10, to3) {
  const to_ = to3 ?? (typeof value10 === "string" ? "Hex" : "Bytes");
  const bytes = (() => {
    if (typeof value10 === "string") {
      if (value10.length > 3 && value10.length % 2 !== 0)
        throw new InvalidLengthError(value10);
      return fromHex(value10);
    }
    return value10;
  })();
  const cursor = create(bytes, {
    recursiveReadLimit: Number.POSITIVE_INFINITY
  });
  const result = decodeRlpCursor(cursor, to_);
  return result;
}
function decodeRlpCursor(cursor, to3 = "Hex") {
  if (cursor.bytes.length === 0)
    return to3 === "Hex" ? fromBytes(cursor.bytes) : cursor.bytes;
  const prefix = cursor.readByte();
  if (prefix < 128)
    cursor.decrementPosition(1);
  if (prefix < 192) {
    const length7 = readLength(cursor, prefix, 128);
    const bytes = cursor.readBytes(length7);
    return to3 === "Hex" ? fromBytes(bytes) : bytes;
  }
  const length6 = readLength(cursor, prefix, 192);
  return readList(cursor, length6, to3);
}
function readLength(cursor, prefix, offset) {
  if (offset === 128 && prefix < 128)
    return 1;
  if (prefix <= offset + 55)
    return prefix - offset;
  if (prefix === offset + 55 + 1)
    return cursor.readUint8();
  if (prefix === offset + 55 + 2)
    return cursor.readUint16();
  if (prefix === offset + 55 + 3)
    return cursor.readUint24();
  if (prefix === offset + 55 + 4)
    return cursor.readUint32();
  throw new BaseError2("Invalid RLP prefix");
}
function readList(cursor, length6, to3) {
  const position = cursor.position;
  const value10 = [];
  while (cursor.position - position < length6)
    value10.push(decodeRlpCursor(cursor, to3));
  return value10;
}
function from13(value10, options) {
  const { as: as18 } = options;
  const encodable = getEncodable2(value10);
  const cursor = create(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (as18 === "Hex")
    return fromBytes(cursor.bytes);
  return cursor.bytes;
}
function fromBytes7(bytes, options = {}) {
  const { as: as18 = "Bytes" } = options;
  return from13(bytes, { as: as18 });
}
function fromHex6(hex2, options = {}) {
  const { as: as18 = "Hex" } = options;
  return from13(hex2, { as: as18 });
}
function getEncodable2(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList2(bytes.map((x) => getEncodable2(x)));
  return getEncodableBytes2(bytes);
}
function getEncodableList2(list) {
  const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
  const sizeOfBodyLength = getSizeOfLength2(bodyLength);
  const length6 = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length: length6,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode: encode16 } of list) {
        encode16(cursor);
      }
    }
  };
}
function getEncodableBytes2(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? fromHex(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength2(bytes.length);
  const length6 = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length: length6,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength2(length6) {
  if (length6 < 2 ** 8)
    return 1;
  if (length6 < 2 ** 16)
    return 2;
  if (length6 < 2 ** 24)
    return 3;
  if (length6 < 2 ** 32)
    return 4;
  throw new BaseError2("Length is too large.");
}

// node_modules/ox/_esm/core/Authorization.js
function from14(authorization, options = {}) {
  if (typeof authorization.chainId === "string")
    return fromRpc3(authorization);
  return { ...authorization, ...options.signature };
}
function fromRpc3(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = extract2(authorization);
  return {
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    ...signature
  };
}
function fromRpcList(authorizationList) {
  return authorizationList.map(fromRpc3);
}
function fromTuple2(tuple7) {
  const [chainId, address, nonce, yParity, r, s] = tuple7;
  const signature = yParity && r && s ? fromTuple([yParity, r, s]) : void 0;
  return from14({
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    ...signature
  });
}
function fromTupleList2(tupleList) {
  const list = [];
  for (const tuple7 of tupleList)
    list.push(fromTuple2(tuple7));
  return list;
}
function getSignPayload2(authorization) {
  return hash4(authorization);
}
function hash4(authorization) {
  return keccak2562(concat3("0x05", fromHex6(toTuple2(authorization))));
}
function toRpc4(authorization) {
  const { address, chainId, nonce, ...signature } = authorization;
  return {
    address,
    chainId: fromNumber2(chainId),
    nonce: fromNumber2(nonce),
    ...toRpc3(signature)
  };
}
function toRpcList(authorizationList) {
  return authorizationList.map(toRpc4);
}
function toTuple2(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = extract2(authorization);
  return [
    chainId ? fromNumber2(chainId) : "0x",
    address,
    nonce ? fromNumber2(nonce) : "0x",
    ...signature ? toTuple(signature) : []
  ];
}
function toTupleList2(list) {
  if (!list || list.length === 0)
    return [];
  const tupleList = [];
  for (const authorization of list)
    tupleList.push(toTuple2(authorization));
  return tupleList;
}

// node_modules/ox/_esm/core/Base58.js
var Base58_exports = {};
__export(Base58_exports, {
  fromBytes: () => fromBytes8,
  fromHex: () => fromHex7,
  fromString: () => fromString8,
  toBytes: () => toBytes9,
  toHex: () => toHex7,
  toString: () => toString5
});

// node_modules/ox/_esm/core/internal/base58.js
var integerToAlphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var alphabetToInteger = (
  /* __PURE__ */
  Object.freeze({
    1: 0n,
    2: 1n,
    3: 2n,
    4: 3n,
    5: 4n,
    6: 5n,
    7: 6n,
    8: 7n,
    9: 8n,
    A: 9n,
    B: 10n,
    C: 11n,
    D: 12n,
    E: 13n,
    F: 14n,
    G: 15n,
    H: 16n,
    J: 17n,
    K: 18n,
    L: 19n,
    M: 20n,
    N: 21n,
    P: 22n,
    Q: 23n,
    R: 24n,
    S: 25n,
    T: 26n,
    U: 27n,
    V: 28n,
    W: 29n,
    X: 30n,
    Y: 31n,
    Z: 32n,
    a: 33n,
    b: 34n,
    c: 35n,
    d: 36n,
    e: 37n,
    f: 38n,
    g: 39n,
    h: 40n,
    i: 41n,
    j: 42n,
    k: 43n,
    m: 44n,
    n: 45n,
    o: 46n,
    p: 47n,
    q: 48n,
    r: 49n,
    s: 50n,
    t: 51n,
    u: 52n,
    v: 53n,
    w: 54n,
    x: 55n,
    y: 56n,
    z: 57n
  })
);
function from15(value10) {
  let bytes = from(value10);
  let integer4 = (() => {
    let hex2 = value10;
    if (value10 instanceof Uint8Array)
      hex2 = fromBytes(bytes);
    return BigInt(hex2);
  })();
  let result = "";
  while (integer4 > 0n) {
    const remainder3 = Number(integer4 % 58n);
    integer4 = integer4 / 58n;
    result = integerToAlphabet[remainder3] + result;
  }
  while (bytes.length > 1 && bytes[0] === 0) {
    result = "1" + result;
    bytes = bytes.slice(1);
  }
  return result;
}

// node_modules/ox/_esm/core/Base58.js
function fromBytes8(value10) {
  return from15(value10);
}
function fromHex7(value10) {
  return from15(value10);
}
function fromString8(value10) {
  return from15(fromString(value10));
}
function toBytes9(value10) {
  return fromHex(toHex7(value10));
}
function toHex7(value10) {
  let integer4 = BigInt(0);
  let pad4 = 0;
  let checkPad = true;
  for (let i = 0; i < value10.length; i++) {
    const char2 = value10[i];
    if (checkPad && char2 === "1")
      pad4++;
    else
      checkPad = false;
    if (typeof alphabetToInteger[char2] !== "bigint")
      throw new Error("invalid base58 character: " + char2);
    integer4 = integer4 * 58n;
    integer4 = integer4 + alphabetToInteger[char2];
  }
  if (!pad4)
    return `0x${integer4.toString(16)}`;
  return `0x${"0".repeat(pad4 * 2)}${integer4.toString(16)}`;
}
function toString5(value10) {
  return toString2(toHex7(value10));
}

// node_modules/ox/_esm/core/BinaryStateTree.js
var BinaryStateTree_exports = {};
__export(BinaryStateTree_exports, {
  create: () => create2,
  insert: () => insert5,
  merkelize: () => merkelize
});

// node_modules/@noble/hashes/esm/_blake.js
var BSIGMA = Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
function G1s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 16);
  c = c + d | 0;
  b = rotr(b ^ c, 12);
  return { a, b, c, d };
}
function G2s(a, b, c, d, x) {
  a = a + b + x | 0;
  d = rotr(d ^ a, 8);
  c = c + d | 0;
  b = rotr(b ^ c, 7);
  return { a, b, c, d };
}

// node_modules/@noble/hashes/esm/blake2.js
var B2B_IV = Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = new Uint32Array(32);
function G1b(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function G2b(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
  let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
  let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
  let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
  let ll = add3L(Al, Bl, Xl);
  Ah = add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
  BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
  BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
  BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
  BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
  anumber(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key, salt, personalization } = opts;
  if (key !== void 0 && (key.length < 1 || key.length > keyLen))
    throw new Error("key length must be undefined or 1.." + keyLen);
  if (salt !== void 0 && salt.length !== saltLen)
    throw new Error("salt must be undefined or " + saltLen);
  if (personalization !== void 0 && personalization.length !== persLen)
    throw new Error("personalization must be undefined or " + persLen);
}
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen) {
    super();
    this.finished = false;
    this.destroyed = false;
    this.length = 0;
    this.pos = 0;
    anumber(blockLen);
    anumber(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u32(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes2(data);
    abytes(data);
    const { blockLen, buffer: buffer7, buffer32 } = this;
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take16 = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take16 === blockLen && !(dataOffset % 4) && pos + take16 < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer7.set(data.subarray(pos, pos + take16), this.pos);
      this.pos += take16;
      this.length += take16;
      pos += take16;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u32(out);
    this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
  }
  digest() {
    const { buffer: buffer7, outputLen } = this;
    this.digestInto(buffer7);
    const res = buffer7.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to3) {
    const { buffer: buffer7, length: length6, finished, destroyed, outputLen, pos } = this;
    to3 || (to3 = new this.constructor({ dkLen: outputLen }));
    to3.set(...this.get());
    to3.buffer.set(buffer7);
    to3.destroyed = destroyed;
    to3.finished = finished;
    to3.length = length6;
    to3.pos = pos;
    to3.outputLen = outputLen;
    return to3;
  }
  clone() {
    return this._cloneInto();
  }
};
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
    super(128, olen);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    checkBlake2Opts(olen, opts, 64, 16, 16);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes2(key);
      keyLength = key.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes2(salt);
      const slt = u32(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      personalization = toBytes2(personalization);
      const pers = u32(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BBUF[i] = v);
    BBUF.set(B2B_IV, 16);
    let { h: h2, l } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l;
    BBUF[25] = B2B_IV[9] ^ h2;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j = 0;
    const s = BSIGMA;
    for (let i = 0; i < 12; i++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = createOptHasher((opts) => new BLAKE2b(opts));
function compress2(s, offset, msg, rounds, v0, v1, v2, v32, v42, v52, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
  let j = 0;
  for (let i = 0; i < rounds; i++) {
    ({ a: v0, b: v42, c: v8, d: v12 } = G1s(v0, v42, v8, v12, msg[offset + s[j++]]));
    ({ a: v0, b: v42, c: v8, d: v12 } = G2s(v0, v42, v8, v12, msg[offset + s[j++]]));
    ({ a: v1, b: v52, c: v9, d: v13 } = G1s(v1, v52, v9, v13, msg[offset + s[j++]]));
    ({ a: v1, b: v52, c: v9, d: v13 } = G2s(v1, v52, v9, v13, msg[offset + s[j++]]));
    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));
    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));
    ({ a: v32, b: v7, c: v11, d: v15 } = G1s(v32, v7, v11, v15, msg[offset + s[j++]]));
    ({ a: v32, b: v7, c: v11, d: v15 } = G2s(v32, v7, v11, v15, msg[offset + s[j++]]));
    ({ a: v0, b: v52, c: v10, d: v15 } = G1s(v0, v52, v10, v15, msg[offset + s[j++]]));
    ({ a: v0, b: v52, c: v10, d: v15 } = G2s(v0, v52, v10, v15, msg[offset + s[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));
    ({ a: v32, b: v42, c: v9, d: v14 } = G1s(v32, v42, v9, v14, msg[offset + s[j++]]));
    ({ a: v32, b: v42, c: v9, d: v14 } = G2s(v32, v42, v9, v14, msg[offset + s[j++]]));
  }
  return { v0, v1, v2, v3: v32, v4: v42, v5: v52, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };
}
var B2S_IV = SHA256_IV;
var BLAKE2s = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 32 : opts.dkLen;
    super(64, olen);
    this.v0 = B2S_IV[0] | 0;
    this.v1 = B2S_IV[1] | 0;
    this.v2 = B2S_IV[2] | 0;
    this.v3 = B2S_IV[3] | 0;
    this.v4 = B2S_IV[4] | 0;
    this.v5 = B2S_IV[5] | 0;
    this.v6 = B2S_IV[6] | 0;
    this.v7 = B2S_IV[7] | 0;
    checkBlake2Opts(olen, opts, 32, 8, 8);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes2(key);
      keyLength = key.length;
    }
    this.v0 ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes2(salt);
      const slt = u32(salt);
      this.v4 ^= swap8IfBE(slt[0]);
      this.v5 ^= swap8IfBE(slt[1]);
    }
    if (personalization !== void 0) {
      personalization = toBytes2(personalization);
      const pers = u32(personalization);
      this.v6 ^= swap8IfBE(pers[0]);
      this.v7 ^= swap8IfBE(pers[1]);
    }
    if (key !== void 0) {
      abytes(key);
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  get() {
    const { v0, v1, v2, v3: v32, v4: v42, v5: v52, v6, v7 } = this;
    return [v0, v1, v2, v32, v42, v52, v6, v7];
  }
  // prettier-ignore
  set(v0, v1, v2, v32, v42, v52, v6, v7) {
    this.v0 = v0 | 0;
    this.v1 = v1 | 0;
    this.v2 = v2 | 0;
    this.v3 = v32 | 0;
    this.v4 = v42 | 0;
    this.v5 = v52 | 0;
    this.v6 = v6 | 0;
    this.v7 = v7 | 0;
  }
  compress(msg, offset, isLast) {
    const { h: h2, l } = fromBig(BigInt(this.length));
    const { v0, v1, v2, v3: v32, v4: v42, v5: v52, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress2(BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h2 ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);
    this.v0 ^= v0 ^ v8;
    this.v1 ^= v1 ^ v9;
    this.v2 ^= v2 ^ v10;
    this.v3 ^= v32 ^ v11;
    this.v4 ^= v42 ^ v12;
    this.v5 ^= v52 ^ v13;
    this.v6 ^= v6 ^ v14;
    this.v7 ^= v7 ^ v15;
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2s = createOptHasher((opts) => new BLAKE2s(opts));

// node_modules/@noble/hashes/esm/blake3.js
var B3_Flags = {
  CHUNK_START: 1,
  CHUNK_END: 2,
  PARENT: 4,
  ROOT: 8,
  KEYED_HASH: 16,
  DERIVE_KEY_CONTEXT: 32,
  DERIVE_KEY_MATERIAL: 64
};
var B3_IV = SHA256_IV.slice();
var B3_SIGMA = (() => {
  const Id2 = Array.from({ length: 16 }, (_, i) => i);
  const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);
  const res = [];
  for (let i = 0, v = Id2; i < 7; i++, v = permute(v))
    res.push(...v);
  return Uint8Array.from(res);
})();
var BLAKE3 = class _BLAKE3 extends BLAKE2 {
  constructor(opts = {}, flags = 0) {
    super(64, opts.dkLen === void 0 ? 32 : opts.dkLen);
    this.chunkPos = 0;
    this.chunksDone = 0;
    this.flags = 0 | 0;
    this.stack = [];
    this.posOut = 0;
    this.bufferOut32 = new Uint32Array(16);
    this.chunkOut = 0;
    this.enableXOF = true;
    const { key, context: context15 } = opts;
    const hasContext = context15 !== void 0;
    if (key !== void 0) {
      if (hasContext)
        throw new Error('Only "key" or "context" can be specified at same time');
      const k = toBytes2(key).slice();
      abytes(k, 32);
      this.IV = u32(k);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.KEYED_HASH;
    } else if (hasContext) {
      const ctx = toBytes2(context15);
      const contextKey = new _BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
      this.IV = u32(contextKey);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
    } else {
      this.IV = B3_IV.slice();
      this.flags = flags;
    }
    this.state = this.IV.slice();
    this.bufferOut = u8(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(counter12, flags, buf, bufPos = 0) {
    const { state: s, pos } = this;
    const { h: h2, l } = fromBig(BigInt(counter12), true);
    const { v0, v1, v2, v3: v32, v4: v42, v5: v52, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress2(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h2, l, pos, flags);
    s[0] = v0 ^ v8;
    s[1] = v1 ^ v9;
    s[2] = v2 ^ v10;
    s[3] = v32 ^ v11;
    s[4] = v42 ^ v12;
    s[5] = v52 ^ v13;
    s[6] = v6 ^ v14;
    s[7] = v7 ^ v15;
  }
  compress(buf, bufPos = 0, isLast = false) {
    let flags = this.flags;
    if (!this.chunkPos)
      flags |= B3_Flags.CHUNK_START;
    if (this.chunkPos === 15 || isLast)
      flags |= B3_Flags.CHUNK_END;
    if (!isLast)
      this.pos = this.blockLen;
    this.b2Compress(this.chunksDone, flags, buf, bufPos);
    this.chunkPos += 1;
    if (this.chunkPos === 16 || isLast) {
      let chunk7 = this.state;
      this.state = this.IV.slice();
      for (let last8, chunks3 = this.chunksDone + 1; isLast || !(chunks3 & 1); chunks3 >>= 1) {
        if (!(last8 = this.stack.pop()))
          break;
        this.buffer32.set(last8, 0);
        this.buffer32.set(chunk7, 8);
        this.pos = this.blockLen;
        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
        chunk7 = this.state;
        this.state = this.IV.slice();
      }
      this.chunksDone++;
      this.chunkPos = 0;
      this.stack.push(chunk7);
    }
    this.pos = 0;
  }
  _cloneInto(to3) {
    to3 = super._cloneInto(to3);
    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
    to3.state.set(state.slice());
    to3.stack = stack.map((i) => Uint32Array.from(i));
    to3.IV.set(IV);
    to3.flags = flags;
    to3.chunkPos = chunkPos;
    to3.chunksDone = chunksDone;
    to3.posOut = posOut;
    to3.chunkOut = chunkOut;
    to3.enableXOF = this.enableXOF;
    to3.bufferOut32.set(this.bufferOut32);
    return to3;
  }
  destroy() {
    this.destroyed = true;
    clean(this.state, this.buffer32, this.IV, this.bufferOut32);
    clean(...this.stack);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;
    const { h: h2, l } = fromBig(BigInt(this.chunkOut++));
    swap32IfBE(buffer32);
    const { v0, v1, v2, v3: v32, v4: v42, v5: v52, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress2(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h2, pos, flags);
    out32[0] = v0 ^ v8;
    out32[1] = v1 ^ v9;
    out32[2] = v2 ^ v10;
    out32[3] = v32 ^ v11;
    out32[4] = v42 ^ v12;
    out32[5] = v52 ^ v13;
    out32[6] = v6 ^ v14;
    out32[7] = v7 ^ v15;
    out32[8] = s[0] ^ v8;
    out32[9] = s[1] ^ v9;
    out32[10] = s[2] ^ v10;
    out32[11] = s[3] ^ v11;
    out32[12] = s[4] ^ v12;
    out32[13] = s[5] ^ v13;
    out32[14] = s[6] ^ v14;
    out32[15] = s[7] ^ v15;
    swap32IfBE(buffer32);
    swap32IfBE(out32);
    this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    clean(this.buffer.subarray(this.pos));
    let flags = this.flags | B3_Flags.ROOT;
    if (this.stack.length) {
      flags |= B3_Flags.PARENT;
      swap32IfBE(this.buffer32);
      this.compress(this.buffer32, 0, true);
      swap32IfBE(this.buffer32);
      this.chunksDone = 0;
      this.pos = this.blockLen;
    } else {
      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
    }
    this.flags = flags;
    this.b2CompressOut();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const { blockLen, bufferOut } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.b2CompressOut();
      const take16 = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take16), pos);
      this.posOut += take16;
      pos += take16;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.enableXOF = false;
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
};
var blake3 = createXOFer((opts) => new BLAKE3(opts));

// node_modules/ox/_esm/core/BinaryStateTree.js
function create2() {
  return {
    root: emptyNode()
  };
}
function insert5(tree, key, value10) {
  const stem = slice2(key, 0, 31);
  const subIndex = slice2(key, 31)[0];
  if (tree.root.type === "empty") {
    tree.root = stemNode(stem);
    tree.root.values[subIndex] = value10;
    return;
  }
  function inner(node_, stem2, subIndex2, value11, depth) {
    let node = node_;
    if (node.type === "empty") {
      node = stemNode(stem2);
      node.values[subIndex2] = value11;
      return node;
    }
    const stemBits = bytesToBits(stem2);
    if (node.type === "stem") {
      if (isEqual(node.stem, stem2)) {
        node.values[subIndex2] = value11;
        return node;
      }
      const existingStemBits = bytesToBits(node.stem);
      return splitLeaf(node, stemBits, existingStemBits, subIndex2, value11, depth);
    }
    if (node.type === "internal") {
      const bit = stemBits[depth];
      if (bit === 0) {
        node.left = inner(node.left, stem2, subIndex2, value11, depth + 1);
      } else {
        node.right = inner(node.right, stem2, subIndex2, value11, depth + 1);
      }
      return node;
    }
    return emptyNode();
  }
  tree.root = inner(tree.root, stem, subIndex, value10, 0);
}
function merkelize(tree) {
  function inner(node) {
    if (node.type === "empty")
      return new Uint8Array(32).fill(0);
    if (node.type === "internal") {
      const hash_left = inner(node.left);
      const hash_right = inner(node.right);
      return hash5(concat2(hash_left, hash_right));
    }
    let level = node.values.map(hash5);
    while (level.length > 1) {
      const level_ = [];
      for (let i = 0; i < level.length; i += 2)
        level_.push(hash5(concat2(level[i], level[i + 1])));
      level = level_;
    }
    return hash5(concat2(node.stem, new Uint8Array(1).fill(0), level[0]));
  }
  return inner(tree.root);
}
function splitLeaf(leaf, stemBits, existingStemBits, subIndex, value10, depth) {
  if (stemBits[depth] === existingStemBits[depth]) {
    const internal2 = internalNode();
    const bit2 = stemBits[depth];
    if (bit2 === 0) {
      internal2.left = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value10, depth + 1);
    } else {
      internal2.right = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value10, depth + 1);
    }
    return internal2;
  }
  const internal = internalNode();
  const bit = stemBits[depth];
  const stem = bitsToBytes(stemBits);
  if (bit === 0) {
    internal.left = stemNode(stem);
    internal.left.values[subIndex] = value10;
    internal.right = leaf;
  } else {
    internal.right = stemNode(stem);
    internal.right.values[subIndex] = value10;
    internal.left = leaf;
  }
  return internal;
}
function emptyNode() {
  return {
    type: "empty"
  };
}
function internalNode() {
  return {
    left: emptyNode(),
    right: emptyNode(),
    type: "internal"
  };
}
function stemNode(stem) {
  return {
    stem,
    values: Array.from({ length: 256 }, () => void 0),
    type: "stem"
  };
}
function bytesToBits(bytes) {
  const bits2 = [];
  for (const byte of bytes)
    for (let i = 0; i < 8; i++)
      bits2.push(byte >> 7 - i & 1);
  return bits2;
}
function bitsToBytes(bits2) {
  const byte_data = new Uint8Array(bits2.length / 8);
  for (let i = 0; i < bits2.length; i += 8) {
    let byte = 0;
    for (let j = 0; j < 8; j++)
      byte |= bits2[i + j] << 7 - j;
    byte_data[i / 8] = byte;
  }
  return byte_data;
}
function hash5(bytes) {
  if (!bytes)
    return new Uint8Array(32).fill(0);
  if (!bytes.some((byte) => byte !== 0))
    return new Uint8Array(32).fill(0);
  return blake3(bytes);
}

// node_modules/ox/_esm/core/Blobs.js
var Blobs_exports = {};
__export(Blobs_exports, {
  BlobSizeTooLargeError: () => BlobSizeTooLargeError2,
  EmptyBlobError: () => EmptyBlobError2,
  EmptyBlobVersionedHashesError: () => EmptyBlobVersionedHashesError,
  InvalidVersionedHashSizeError: () => InvalidVersionedHashSizeError2,
  InvalidVersionedHashVersionError: () => InvalidVersionedHashVersionError2,
  bytesPerBlob: () => bytesPerBlob2,
  bytesPerFieldElement: () => bytesPerFieldElement2,
  commitmentToVersionedHash: () => commitmentToVersionedHash2,
  commitmentsToVersionedHashes: () => commitmentsToVersionedHashes2,
  fieldElementsPerBlob: () => fieldElementsPerBlob2,
  from: () => from17,
  maxBytesPerTransaction: () => maxBytesPerTransaction2,
  sidecarsToVersionedHashes: () => sidecarsToVersionedHashes2,
  to: () => to2,
  toBytes: () => toBytes10,
  toCommitments: () => toCommitments,
  toHex: () => toHex8,
  toProofs: () => toProofs,
  toSidecars: () => toSidecars,
  toVersionedHashes: () => toVersionedHashes
});

// node_modules/ox/_esm/core/Kzg.js
var Kzg_exports = {};
__export(Kzg_exports, {
  from: () => from16,
  versionedHashVersion: () => versionedHashVersion
});
var versionedHashVersion = 1;
function from16(value10) {
  const { blobToKzgCommitment, computeBlobKzgProof } = value10;
  return {
    blobToKzgCommitment,
    computeBlobKzgProof
  };
}

// node_modules/ox/_esm/core/Blobs.js
var blobsPerTransaction2 = 6;
var bytesPerFieldElement2 = 32;
var fieldElementsPerBlob2 = 4096;
var bytesPerBlob2 = bytesPerFieldElement2 * fieldElementsPerBlob2;
var maxBytesPerTransaction2 = bytesPerBlob2 * blobsPerTransaction2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob2 * blobsPerTransaction2;
function commitmentsToVersionedHashes2(commitments, options = {}) {
  const { version } = options;
  const as18 = options.as ?? (typeof commitments[0] === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash2(commitment, {
      as: as18,
      version
    }));
  }
  return hashes;
}
function commitmentToVersionedHash2(commitment, options = {}) {
  const { version = 1 } = options;
  const as18 = options.as ?? (typeof commitment === "string" ? "Hex" : "Bytes");
  const versionedHash = sha2564(commitment, { as: "Bytes" });
  versionedHash.set([version], 0);
  return as18 === "Bytes" ? versionedHash : fromBytes(versionedHash);
}
function from17(data, options = {}) {
  const as18 = options.as ?? (typeof data === "string" ? "Hex" : "Bytes");
  const data_ = typeof data === "string" ? fromHex(data) : data;
  const size_ = size2(data_);
  if (!size_)
    throw new EmptyBlobError2();
  if (size_ > maxBytesPerTransaction2)
    throw new BlobSizeTooLargeError2({
      maxSize: maxBytesPerTransaction2,
      size: size_
    });
  const blobs = [];
  let active2 = true;
  let position = 0;
  while (active2) {
    const blob = create(new Uint8Array(bytesPerBlob2));
    let size45 = 0;
    while (size45 < fieldElementsPerBlob2) {
      const bytes = data_.slice(position, position + (bytesPerFieldElement2 - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active2 = false;
        break;
      }
      size45++;
      position += 31;
    }
    blobs.push(blob);
  }
  return as18 === "Bytes" ? blobs.map((x) => x.bytes) : blobs.map((x) => fromBytes(x.bytes));
}
function sidecarsToVersionedHashes2(sidecars, options = {}) {
  const { version } = options;
  const as18 = options.as ?? (typeof sidecars[0].blob === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const { commitment } of sidecars) {
    hashes.push(commitmentToVersionedHash2(commitment, {
      as: as18,
      version
    }));
  }
  return hashes;
}
function to2(blobs, to3) {
  const to_ = to3 ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x) => fromHex(x)) : blobs;
  const length6 = blobs_.reduce((length7, blob) => length7 + blob.length, 0);
  const data = create(new Uint8Array(length6));
  let active2 = true;
  for (const blob of blobs_) {
    const cursor = create(blob);
    while (active2 && cursor.position < blob.length) {
      cursor.incrementPosition(1);
      let consume = 31;
      if (blob.length - cursor.position < 31)
        consume = blob.length - cursor.position;
      for (const _ in Array.from({ length: consume })) {
        const byte = cursor.readByte();
        const isTerminator = byte === 128 && !cursor.inspectBytes(cursor.remaining).includes(128);
        if (isTerminator) {
          active2 = false;
          break;
        }
        data.pushByte(byte);
      }
    }
  }
  const trimmedData = data.bytes.slice(0, data.position);
  return to_ === "Hex" ? fromBytes(trimmedData) : trimmedData;
}
function toHex8(blobs) {
  return to2(blobs, "Hex");
}
function toBytes10(blobs) {
  return to2(blobs, "Bytes");
}
function toCommitments(blobs, options) {
  const { kzg } = options;
  const as18 = options.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x) => fromHex(x)) : blobs;
  const commitments = [];
  for (const blob of blobs_)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return as18 === "Bytes" ? commitments : commitments.map((x) => fromBytes(x));
}
function toProofs(blobs, options) {
  const { kzg } = options;
  const as18 = options.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x) => fromHex(x)) : blobs;
  const commitments = typeof options.commitments[0] === "string" ? options.commitments.map((x) => fromHex(x)) : options.commitments;
  const proofs = [];
  for (let i = 0; i < blobs_.length; i++) {
    const blob = blobs_[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return as18 === "Bytes" ? proofs : proofs.map((x) => fromBytes(x));
}
function toSidecars(blobs, options) {
  const { kzg } = options;
  const commitments = options.commitments ?? toCommitments(blobs, { kzg });
  const proofs = options.proofs ?? toProofs(blobs, { commitments, kzg });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}
function toVersionedHashes(blobs, options) {
  const commitments = toCommitments(blobs, options);
  return commitmentsToVersionedHashes2(commitments, options);
}
var BlobSizeTooLargeError2 = class extends BaseError2 {
  constructor({ maxSize, size: size45 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size45} bytes`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError2 = class extends BaseError2 {
  constructor() {
    super("Blob data must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.EmptyBlobError"
    });
  }
};
var EmptyBlobVersionedHashesError = class extends BaseError2 {
  constructor() {
    super("Blob versioned hashes must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.EmptyBlobVersionedHashesError"
    });
  }
};
var InvalidVersionedHashSizeError2 = class extends BaseError2 {
  constructor({ hash: hash11, size: size45 }) {
    super(`Versioned hash "${hash11}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size45}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.InvalidVersionedHashSizeError"
    });
  }
};
var InvalidVersionedHashVersionError2 = class extends BaseError2 {
  constructor({ hash: hash11, version }) {
    super(`Versioned hash "${hash11}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersion}`,
        `Received: ${version}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.InvalidVersionedHashVersionError"
    });
  }
};

// node_modules/ox/_esm/core/Block.js
var Block_exports = {};
__export(Block_exports, {
  fromRpc: () => fromRpc5,
  toRpc: () => toRpc6
});

// node_modules/ox/_esm/core/Transaction.js
var Transaction_exports = {};
__export(Transaction_exports, {
  fromRpc: () => fromRpc4,
  fromRpcType: () => fromRpcType,
  toRpc: () => toRpc5,
  toRpcType: () => toRpcType
});
var toRpcType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
var fromRpcType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function fromRpc4(transaction, _options = {}) {
  if (!transaction)
    return null;
  const signature = extract2(transaction);
  const transaction_ = {
    ...transaction,
    ...signature
  };
  transaction_.blockNumber = transaction.blockNumber ? BigInt(transaction.blockNumber) : null;
  transaction_.data = transaction.input;
  transaction_.gas = BigInt(transaction.gas ?? 0n);
  transaction_.nonce = BigInt(transaction.nonce ?? 0n);
  transaction_.transactionIndex = transaction.transactionIndex ? Number(transaction.transactionIndex) : null;
  transaction_.value = BigInt(transaction.value ?? 0n);
  if (transaction.authorizationList)
    transaction_.authorizationList = fromRpcList(transaction.authorizationList);
  if (transaction.chainId)
    transaction_.chainId = Number(transaction.chainId);
  if (transaction.gasPrice)
    transaction_.gasPrice = BigInt(transaction.gasPrice);
  if (transaction.maxFeePerBlobGas)
    transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);
  if (transaction.maxFeePerGas)
    transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);
  if (transaction.maxPriorityFeePerGas)
    transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);
  if (transaction.type)
    transaction_.type = fromRpcType[transaction.type] ?? transaction.type;
  if (signature)
    transaction_.v = yParityToV(signature.yParity);
  return transaction_;
}
function toRpc5(transaction, _options) {
  const rpc2 = {};
  rpc2.blockHash = transaction.blockHash;
  rpc2.blockNumber = typeof transaction.blockNumber === "bigint" ? fromNumber2(transaction.blockNumber) : null;
  rpc2.from = transaction.from;
  rpc2.gas = fromNumber2(transaction.gas ?? 0n);
  rpc2.hash = transaction.hash;
  rpc2.input = transaction.input;
  rpc2.nonce = fromNumber2(transaction.nonce ?? 0n);
  rpc2.to = transaction.to;
  rpc2.transactionIndex = transaction.transactionIndex ? fromNumber2(transaction.transactionIndex) : null;
  rpc2.type = toRpcType[transaction.type] ?? transaction.type;
  rpc2.value = fromNumber2(transaction.value ?? 0n);
  if (transaction.accessList)
    rpc2.accessList = transaction.accessList;
  if (transaction.authorizationList)
    rpc2.authorizationList = toRpcList(transaction.authorizationList);
  if (transaction.blobVersionedHashes)
    rpc2.blobVersionedHashes = transaction.blobVersionedHashes;
  if (transaction.chainId)
    rpc2.chainId = fromNumber2(transaction.chainId);
  if (typeof transaction.gasPrice === "bigint")
    rpc2.gasPrice = fromNumber2(transaction.gasPrice);
  if (typeof transaction.maxFeePerBlobGas === "bigint")
    rpc2.maxFeePerBlobGas = fromNumber2(transaction.maxFeePerBlobGas);
  if (typeof transaction.maxFeePerGas === "bigint")
    rpc2.maxFeePerGas = fromNumber2(transaction.maxFeePerGas);
  if (typeof transaction.maxPriorityFeePerGas === "bigint")
    rpc2.maxPriorityFeePerGas = fromNumber2(transaction.maxPriorityFeePerGas);
  if (typeof transaction.r === "bigint")
    rpc2.r = fromNumber2(transaction.r, { size: 32 });
  if (typeof transaction.s === "bigint")
    rpc2.s = fromNumber2(transaction.s, { size: 32 });
  if (typeof transaction.v === "number")
    rpc2.v = fromNumber2(transaction.v, { size: 1 });
  if (typeof transaction.yParity === "number")
    rpc2.yParity = transaction.yParity === 0 ? "0x0" : "0x1";
  return rpc2;
}

// node_modules/ox/_esm/core/Block.js
function toRpc6(block, _options = {}) {
  var _a106;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return toRpc5(transaction);
  });
  return {
    baseFeePerGas: typeof block.baseFeePerGas === "bigint" ? fromNumber2(block.baseFeePerGas) : void 0,
    blobGasUsed: typeof block.blobGasUsed === "bigint" ? fromNumber2(block.blobGasUsed) : void 0,
    excessBlobGas: typeof block.excessBlobGas === "bigint" ? fromNumber2(block.excessBlobGas) : void 0,
    extraData: block.extraData,
    difficulty: typeof block.difficulty === "bigint" ? fromNumber2(block.difficulty) : void 0,
    gasLimit: fromNumber2(block.gasLimit),
    gasUsed: fromNumber2(block.gasUsed),
    hash: block.hash,
    logsBloom: block.logsBloom,
    miner: block.miner,
    mixHash: block.mixHash,
    nonce: block.nonce,
    number: typeof block.number === "bigint" ? fromNumber2(block.number) : null,
    parentBeaconBlockRoot: block.parentBeaconBlockRoot,
    parentHash: block.parentHash,
    receiptsRoot: block.receiptsRoot,
    sealFields: block.sealFields,
    sha3Uncles: block.sha3Uncles,
    size: fromNumber2(block.size),
    stateRoot: block.stateRoot,
    timestamp: fromNumber2(block.timestamp),
    totalDifficulty: typeof block.totalDifficulty === "bigint" ? fromNumber2(block.totalDifficulty) : void 0,
    transactions,
    transactionsRoot: block.transactionsRoot,
    uncles: block.uncles,
    withdrawals: (_a106 = block.withdrawals) == null ? void 0 : _a106.map(toRpc),
    withdrawalsRoot: block.withdrawalsRoot
  };
}
function fromRpc5(block, _options = {}) {
  var _a106;
  if (!block)
    return null;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return fromRpc4(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : void 0,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: BigInt(block.gasLimit ?? 0n),
    gasUsed: BigInt(block.gasUsed ?? 0n),
    number: block.number ? BigInt(block.number) : null,
    size: BigInt(block.size ?? 0n),
    stateRoot: block.stateRoot,
    timestamp: BigInt(block.timestamp ?? 0n),
    totalDifficulty: BigInt(block.totalDifficulty ?? 0n),
    transactions,
    withdrawals: (_a106 = block.withdrawals) == null ? void 0 : _a106.map(fromRpc)
  };
}

// node_modules/ox/_esm/core/Bloom.js
var Bloom_exports = {};
__export(Bloom_exports, {
  contains: () => contains9,
  validate: () => validate14
});
function contains9(bloom, input) {
  const filter26 = fromHex(bloom);
  const hash11 = keccak2562(input, { as: "Bytes" });
  for (const i of [0, 2, 4]) {
    const bit = hash11[i + 1] + (hash11[i] << 8) & 2047;
    if ((filter26[256 - 1 - Math.floor(bit / 8)] & 1 << bit % 8) === 0)
      return false;
  }
  return true;
}
function validate14(value10) {
  return validate2(value10) && size3(value10) === 256;
}

// node_modules/ox/_esm/core/Bls.js
var Bls_exports = {};
__export(Bls_exports, {
  aggregate: () => aggregate3,
  getPublicKey: () => getPublicKey2,
  noble: () => noble2,
  randomPrivateKey: () => randomPrivateKey2,
  sign: () => sign7,
  verify: () => verify3
});

// node_modules/@noble/curves/esm/abstract/bls.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
function NAfDecomposition(a) {
  const res = [];
  for (; a > _1n; a >>= _1n) {
    if ((a & _1n) === _0n)
      res.unshift(0);
    else if ((a & _3n) === _3n) {
      res.unshift(-1);
      a += _1n;
    } else
      res.unshift(1);
  }
  return res;
}
function bls(CURVE) {
  const { Fp: Fp3, Fr, Fp2: Fp22, Fp6: Fp62, Fp12: Fp122 } = CURVE.fields;
  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;
  const TWIST = CURVE.params.twistType;
  const G1_ = weierstrassPoints(CURVE.G1);
  const G1 = Object.assign(G1_, createHasher2(G1_.Point, CURVE.G1.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G1.htfDefaults
  }));
  const G2_ = weierstrassPoints(CURVE.G2);
  const G2 = Object.assign(G2_, createHasher2(G2_.Point, CURVE.G2.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G2.htfDefaults
  }));
  let lineFunction;
  if (TWIST === "multiplicative") {
    lineFunction = (c0, c1, c2, f2, Px, Py) => Fp122.mul014(f2, c0, Fp22.mul(c1, Px), Fp22.mul(c2, Py));
  } else if (TWIST === "divisive") {
    lineFunction = (c0, c1, c2, f2, Px, Py) => Fp122.mul034(f2, Fp22.mul(c2, Py), Fp22.mul(c1, Px), c0);
  } else
    throw new Error("bls: unknown twist type");
  const Fp2div2 = Fp22.div(Fp22.ONE, Fp22.mul(Fp22.ONE, _2n));
  function pointDouble(ell, Rx, Ry, Rz) {
    const t0 = Fp22.sqr(Ry);
    const t1 = Fp22.sqr(Rz);
    const t2 = Fp22.mulByB(Fp22.mul(t1, _3n));
    const t3 = Fp22.mul(t2, _3n);
    const t4 = Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(Ry, Rz)), t1), t0);
    const c0 = Fp22.sub(t2, t0);
    const c1 = Fp22.mul(Fp22.sqr(Rx), _3n);
    const c2 = Fp22.neg(t4);
    ell.push([c0, c1, c2]);
    Rx = Fp22.mul(Fp22.mul(Fp22.mul(Fp22.sub(t0, t3), Rx), Ry), Fp2div2);
    Ry = Fp22.sub(Fp22.sqr(Fp22.mul(Fp22.add(t0, t3), Fp2div2)), Fp22.mul(Fp22.sqr(t2), _3n));
    Rz = Fp22.mul(t0, t4);
    return { Rx, Ry, Rz };
  }
  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {
    const t0 = Fp22.sub(Ry, Fp22.mul(Qy, Rz));
    const t1 = Fp22.sub(Rx, Fp22.mul(Qx, Rz));
    const c0 = Fp22.sub(Fp22.mul(t0, Qx), Fp22.mul(t1, Qy));
    const c1 = Fp22.neg(t0);
    const c2 = t1;
    ell.push([c0, c1, c2]);
    const t2 = Fp22.sqr(t1);
    const t3 = Fp22.mul(t2, t1);
    const t4 = Fp22.mul(t2, Rx);
    const t5 = Fp22.add(Fp22.sub(t3, Fp22.mul(t4, _2n)), Fp22.mul(Fp22.sqr(t0), Rz));
    Rx = Fp22.mul(t1, t5);
    Ry = Fp22.sub(Fp22.mul(Fp22.sub(t4, t5), t0), Fp22.mul(t3, Ry));
    Rz = Fp22.mul(Rz, t3);
    return { Rx, Ry, Rz };
  }
  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);
  const calcPairingPrecomputes = memoized((point) => {
    const p = point;
    const { x, y } = p.toAffine();
    const Qx = x, Qy = y, negQy = Fp22.neg(y);
    let Rx = Qx, Ry = Qy, Rz = Fp22.ONE;
    const ell = [];
    for (const bit of ATE_NAF) {
      const cur = [];
      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));
      if (bit)
        ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));
      ell.push(cur);
    }
    if (CURVE.postPrecompute) {
      const last8 = ell[ell.length - 1];
      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last8));
    }
    return ell;
  });
  function millerLoopBatch(pairs, withFinalExponent = false) {
    let f12 = Fp122.ONE;
    if (pairs.length) {
      const ellLen = pairs[0][0].length;
      for (let i = 0; i < ellLen; i++) {
        f12 = Fp122.sqr(f12);
        for (const [ell, Px, Py] of pairs) {
          for (const [c0, c1, c2] of ell[i])
            f12 = lineFunction(c0, c1, c2, f12, Px, Py);
        }
      }
    }
    if (BLS_X_IS_NEGATIVE)
      f12 = Fp122.conjugate(f12);
    return withFinalExponent ? Fp122.finalExponentiate(f12) : f12;
  }
  function pairingBatch(pairs, withFinalExponent = true) {
    const res = [];
    normalizeZ(G1.Point, "pz", pairs.map(({ g1 }) => g1));
    normalizeZ(G2.Point, "pz", pairs.map(({ g2 }) => g2));
    for (const { g1, g2 } of pairs) {
      if (g1.is0() || g2.is0())
        throw new Error("pairing is not available for ZERO point");
      g1.assertValidity();
      g2.assertValidity();
      const Qa = g1.toAffine();
      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);
    }
    return millerLoopBatch(res, withFinalExponent);
  }
  function pairing(Q, P, withFinalExponent = true) {
    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);
  }
  const rand = CURVE.randomBytes || randomBytes;
  const utils2 = {
    randomPrivateKey: () => {
      const length6 = getMinHashLength(Fr.ORDER);
      return mapHashToField(rand(length6), Fr.ORDER);
    },
    calcPairingPrecomputes
  };
  function aNonEmpty(arr) {
    if (!Array.isArray(arr) || arr.length === 0)
      throw new Error("expected non-empty array");
  }
  function normP1(point) {
    return point instanceof G1.Point ? point : G1.Point.fromHex(point);
  }
  function normP2(point) {
    return point instanceof G2.Point ? point : Signature.fromHex(point);
  }
  function createBls(PubCurve, SigCurve) {
    function normPub(point) {
      return point instanceof PubCurve.Point ? point : PubCurve.Point.fromHex(point);
    }
    function normSig(point) {
      return point instanceof SigCurve.Point ? point : SigCurve.Point.fromHex(point);
    }
    function amsg(m) {
      if (!(m instanceof SigCurve.Point))
        throw new Error(`expected valid message hashed to ${isLongSigs ? "G2" : "G1"} curve`);
      return m;
    }
    const isLongSigs = SigCurve.Point.Fp.BYTES > PubCurve.Point.Fp.BYTES;
    return {
      // P = pk x G
      getPublicKey(privateKey) {
        return PubCurve.Point.fromPrivateKey(privateKey);
      },
      // S = pk x H(m)
      sign(message, privateKey, unusedArg) {
        if (unusedArg != null)
          throw new Error("sign() expects 2 arguments");
        amsg(message).assertValidity();
        return message.multiply(PubCurve.normPrivateKeyToScalar(privateKey));
      },
      // Checks if pairing of public key & hash is equal to pairing of generator & signature.
      // e(P, H(m)) == e(G, S)
      // e(S, G) == e(H(m), P)
      verify(signature, message, publicKey, unusedArg) {
        if (unusedArg != null)
          throw new Error("verify() expects 3 arguments");
        signature = normSig(signature);
        publicKey = normPub(publicKey);
        const P = publicKey.negate();
        const G = PubCurve.Point.BASE;
        const Hm = amsg(message);
        const S = signature;
        const exp_ = isLongSigs ? [
          { g1: P, g2: Hm },
          { g1: G, g2: S }
        ] : [
          { g1: Hm, g2: P },
          { g1: S, g2: G }
        ];
        const exp = pairingBatch(exp_);
        return Fp122.eql(exp, Fp122.ONE);
      },
      // Adds a bunch of public key points together.
      // pk1 + pk2 + pk3 = pkA
      aggregatePublicKeys(publicKeys) {
        aNonEmpty(publicKeys);
        publicKeys = publicKeys.map((pub) => normPub(pub));
        const agg = publicKeys.reduce((sum7, p) => sum7.add(p), PubCurve.Point.ZERO);
        agg.assertValidity();
        return agg;
      },
      // Adds a bunch of signature points together.
      // pk1 + pk2 + pk3 = pkA
      aggregateSignatures(signatures2) {
        aNonEmpty(signatures2);
        signatures2 = signatures2.map((sig) => normSig(sig));
        const agg = signatures2.reduce((sum7, s) => sum7.add(s), SigCurve.Point.ZERO);
        agg.assertValidity();
        return agg;
      },
      hash(messageBytes, DST) {
        abytes(messageBytes);
        const opts = DST ? { DST } : void 0;
        return SigCurve.hashToCurve(messageBytes, opts);
      },
      // @ts-ignore
      Signature: isLongSigs ? CURVE.G2.Signature : CURVE.G1.ShortSignature
    };
  }
  const longSignatures = createBls(G1, G2);
  const shortSignatures = createBls(G2, G1);
  const { ShortSignature } = CURVE.G1;
  const { Signature } = CURVE.G2;
  function normP1Hash(point, htfOpts) {
    return point instanceof G1.Point ? point : shortSignatures.hash(ensureBytes("point", point), htfOpts == null ? void 0 : htfOpts.DST);
  }
  function normP2Hash(point, htfOpts) {
    return point instanceof G2.Point ? point : longSignatures.hash(ensureBytes("point", point), htfOpts == null ? void 0 : htfOpts.DST);
  }
  function getPublicKey4(privateKey) {
    return longSignatures.getPublicKey(privateKey).toBytes(true);
  }
  function getPublicKeyForShortSignatures(privateKey) {
    return shortSignatures.getPublicKey(privateKey).toBytes(true);
  }
  function sign10(message, privateKey, htfOpts) {
    const Hm = normP2Hash(message, htfOpts);
    const S = longSignatures.sign(Hm, privateKey);
    return message instanceof G2.Point ? S : Signature.toBytes(S);
  }
  function signShortSignature(message, privateKey, htfOpts) {
    const Hm = normP1Hash(message, htfOpts);
    const S = shortSignatures.sign(Hm, privateKey);
    return message instanceof G1.Point ? S : ShortSignature.toBytes(S);
  }
  function verify6(signature, message, publicKey, htfOpts) {
    const Hm = normP2Hash(message, htfOpts);
    return longSignatures.verify(signature, Hm, publicKey);
  }
  function verifyShortSignature(signature, message, publicKey, htfOpts) {
    const Hm = normP1Hash(message, htfOpts);
    return shortSignatures.verify(signature, Hm, publicKey);
  }
  function aggregatePublicKeys(publicKeys) {
    const agg = longSignatures.aggregatePublicKeys(publicKeys);
    return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);
  }
  function aggregateSignatures(signatures2) {
    const agg = longSignatures.aggregateSignatures(signatures2);
    return signatures2[0] instanceof G2.Point ? agg : Signature.toBytes(agg);
  }
  function aggregateShortSignatures(signatures2) {
    const agg = shortSignatures.aggregateSignatures(signatures2);
    return signatures2[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);
  }
  function verifyBatch(signature, messages, publicKeys, htfOpts) {
    aNonEmpty(messages);
    if (publicKeys.length !== messages.length)
      throw new Error("amount of public keys and messages should be equal");
    const sig = normP2(signature);
    const nMessages = messages.map((i) => normP2Hash(i, htfOpts));
    const nPublicKeys = publicKeys.map(normP1);
    const messagePubKeyMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < nPublicKeys.length; i++) {
      const pub = nPublicKeys[i];
      const msg = nMessages[i];
      let keys15 = messagePubKeyMap.get(msg);
      if (keys15 === void 0) {
        keys15 = [];
        messagePubKeyMap.set(msg, keys15);
      }
      keys15.push(pub);
    }
    const paired = [];
    try {
      for (const [msg, keys15] of messagePubKeyMap) {
        const groupPublicKey = keys15.reduce((acc, msg2) => acc.add(msg2));
        paired.push({ g1: groupPublicKey, g2: msg });
      }
      paired.push({ g1: G1.Point.BASE.negate(), g2: sig });
      return Fp122.eql(pairingBatch(paired), Fp122.ONE);
    } catch {
      return false;
    }
  }
  G1.Point.BASE.precompute(4);
  return {
    longSignatures,
    shortSignatures,
    millerLoopBatch,
    pairing,
    pairingBatch,
    // TODO!!!
    verifyBatch,
    curves: {
      G1: G1_.Point,
      G2: G2_.Point
    },
    fields: {
      Fr,
      Fp: Fp3,
      Fp2: Fp22,
      Fp6: Fp62,
      Fp12: Fp122
    },
    params: {
      ateLoopSize: CURVE.params.ateLoopSize,
      twistType: CURVE.params.twistType,
      // deprecated
      r: CURVE.params.r,
      G1b: CURVE.G1.b,
      G2b: CURVE.G2.b
    },
    utils: utils2,
    // deprecated
    getPublicKey: getPublicKey4,
    getPublicKeyForShortSignatures,
    sign: sign10,
    signShortSignature,
    verify: verify6,
    verifyShortSignature,
    aggregatePublicKeys,
    aggregateSignatures,
    aggregateShortSignatures,
    G1,
    G2,
    Signature,
    ShortSignature
  };
}

// node_modules/@noble/curves/esm/abstract/tower.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
function calcFrobeniusCoefficients(Fp3, nonResidue, modulus, degree, num = 1, divisor) {
  const _divisor = BigInt(divisor === void 0 ? degree : divisor);
  const towerModulus = modulus ** BigInt(degree);
  const res = [];
  for (let i = 0; i < num; i++) {
    const a = BigInt(i + 1);
    const powers2 = [];
    for (let j = 0, qPower = _1n2; j < degree; j++) {
      const power = (a * qPower - a) / _divisor % towerModulus;
      powers2.push(Fp3.pow(nonResidue, power));
      qPower *= modulus;
    }
    res.push(powers2);
  }
  return res;
}
function psiFrobenius(Fp3, Fp22, base) {
  const PSI_X = Fp22.pow(base, (Fp3.ORDER - _1n2) / _3n2);
  const PSI_Y = Fp22.pow(base, (Fp3.ORDER - _1n2) / _2n2);
  function psi(x, y) {
    const x2 = Fp22.mul(Fp22.frobeniusMap(x, 1), PSI_X);
    const y2 = Fp22.mul(Fp22.frobeniusMap(y, 1), PSI_Y);
    return [x2, y2];
  }
  const PSI2_X = Fp22.pow(base, (Fp3.ORDER ** _2n2 - _1n2) / _3n2);
  const PSI2_Y = Fp22.pow(base, (Fp3.ORDER ** _2n2 - _1n2) / _2n2);
  if (!Fp22.eql(PSI2_Y, Fp22.neg(Fp22.ONE)))
    throw new Error("psiFrobenius: PSI2_Y!==-1");
  function psi2(x, y) {
    return [Fp22.mul(x, PSI2_X), Fp22.neg(y)];
  }
  const mapAffine = (fn2) => (c, P) => {
    const affine = P.toAffine();
    const p = fn2(affine.x, affine.y);
    return c.fromAffine({ x: p[0], y: p[1] });
  };
  const G2psi3 = mapAffine(psi);
  const G2psi22 = mapAffine(psi2);
  return { psi, psi2, G2psi: G2psi3, G2psi2: G2psi22, PSI_X, PSI_Y, PSI2_X, PSI2_Y };
}
function tower12(opts) {
  const { ORDER } = opts;
  const Fp3 = Field(ORDER);
  const FpNONRESIDUE = Fp3.create(opts.NONRESIDUE || BigInt(-1));
  const Fpdiv2 = Fp3.div(Fp3.ONE, _2n2);
  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp3, FpNONRESIDUE, Fp3.ORDER, 2)[0];
  const Fp2Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp3.add(c0, r0),
    c1: Fp3.add(c1, r1)
  });
  const Fp2Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp3.sub(c0, r0),
    c1: Fp3.sub(c1, r1)
  });
  const Fp2Multiply = ({ c0, c1 }, rhs) => {
    if (typeof rhs === "bigint")
      return { c0: Fp3.mul(c0, rhs), c1: Fp3.mul(c1, rhs) };
    const { c0: r0, c1: r1 } = rhs;
    let t1 = Fp3.mul(c0, r0);
    let t2 = Fp3.mul(c1, r1);
    const o0 = Fp3.sub(t1, t2);
    const o1 = Fp3.sub(Fp3.mul(Fp3.add(c0, c1), Fp3.add(r0, r1)), Fp3.add(t1, t2));
    return { c0: o0, c1: o1 };
  };
  const Fp2Square = ({ c0, c1 }) => {
    const a = Fp3.add(c0, c1);
    const b = Fp3.sub(c0, c1);
    const c = Fp3.add(c0, c0);
    return { c0: Fp3.mul(a, b), c1: Fp3.mul(c, c1) };
  };
  const Fp2fromBigTuple = (tuple7) => {
    if (tuple7.length !== 2)
      throw new Error("invalid tuple");
    const fps = tuple7.map((n) => Fp3.create(n));
    return { c0: fps[0], c1: fps[1] };
  };
  function isValidC(num, ORDER2) {
    return typeof num === "bigint" && _0n2 <= num && num < ORDER2;
  }
  const FP2_ORDER = ORDER * ORDER;
  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);
  const Fp22 = {
    ORDER: FP2_ORDER,
    isLE: Fp3.isLE,
    NONRESIDUE: Fp2Nonresidue,
    BITS: bitLen(FP2_ORDER),
    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),
    MASK: bitMask(bitLen(FP2_ORDER)),
    ZERO: { c0: Fp3.ZERO, c1: Fp3.ZERO },
    ONE: { c0: Fp3.ONE, c1: Fp3.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1 }) => isValidC(c0, FP2_ORDER) && isValidC(c1, FP2_ORDER),
    is0: ({ c0, c1 }) => Fp3.is0(c0) && Fp3.is0(c1),
    isValidNot0: (num) => !Fp22.is0(num) && Fp22.isValid(num),
    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp3.eql(c0, r0) && Fp3.eql(c1, r1),
    neg: ({ c0, c1 }) => ({ c0: Fp3.neg(c0), c1: Fp3.neg(c1) }),
    pow: (num, power) => FpPow(Fp22, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp22, nums),
    // Normalized
    add: Fp2Add,
    sub: Fp2Subtract,
    mul: Fp2Multiply,
    sqr: Fp2Square,
    // NonNormalized stuff
    addN: Fp2Add,
    subN: Fp2Subtract,
    mulN: Fp2Multiply,
    sqrN: Fp2Square,
    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
    div: (lhs, rhs) => Fp22.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp22.inv(rhs)),
    inv: ({ c0: a, c1: b }) => {
      const factor = Fp3.inv(Fp3.create(a * a + b * b));
      return { c0: Fp3.mul(factor, Fp3.create(a)), c1: Fp3.mul(factor, Fp3.create(-b)) };
    },
    sqrt: (num) => {
      if (opts.Fp2sqrt)
        return opts.Fp2sqrt(num);
      const { c0, c1 } = num;
      if (Fp3.is0(c1)) {
        if (FpLegendre(Fp3, c0) === 1)
          return Fp22.create({ c0: Fp3.sqrt(c0), c1: Fp3.ZERO });
        else
          return Fp22.create({ c0: Fp3.ZERO, c1: Fp3.sqrt(Fp3.div(c0, FpNONRESIDUE)) });
      }
      const a = Fp3.sqrt(Fp3.sub(Fp3.sqr(c0), Fp3.mul(Fp3.sqr(c1), FpNONRESIDUE)));
      let d = Fp3.mul(Fp3.add(a, c0), Fpdiv2);
      const legendre = FpLegendre(Fp3, d);
      if (legendre === -1)
        d = Fp3.sub(d, a);
      const a0 = Fp3.sqrt(d);
      const candidateSqrt = Fp22.create({ c0: a0, c1: Fp3.div(Fp3.mul(c1, Fpdiv2), a0) });
      if (!Fp22.eql(Fp22.sqr(candidateSqrt), num))
        throw new Error("Cannot find square root");
      const x1 = candidateSqrt;
      const x2 = Fp22.neg(x1);
      const { re: re1, im: im1 } = Fp22.reim(x1);
      const { re: re2, im: im2 } = Fp22.reim(x2);
      if (im1 > im2 || im1 === im2 && re1 > re2)
        return x1;
      return x2;
    },
    // Same as sgn0_m_eq_2 in RFC 9380
    isOdd: (x) => {
      const { re: x0, im: x1 } = Fp22.reim(x);
      const sign_0 = x0 % _2n2;
      const zero_0 = x0 === _0n2;
      const sign_1 = x1 % _2n2;
      return BigInt(sign_0 || zero_0 && sign_1) == _1n2;
    },
    // Bytes util
    fromBytes(b) {
      if (b.length !== Fp22.BYTES)
        throw new Error("fromBytes invalid length=" + b.length);
      return { c0: Fp3.fromBytes(b.subarray(0, Fp3.BYTES)), c1: Fp3.fromBytes(b.subarray(Fp3.BYTES)) };
    },
    toBytes: ({ c0, c1 }) => concatBytes(Fp3.toBytes(c0), Fp3.toBytes(c1)),
    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({
      c0: Fp3.cmov(c0, r0, c),
      c1: Fp3.cmov(c1, r1, c)
    }),
    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),
    // multiply by u + 1
    mulByNonresidue: ({ c0, c1 }) => Fp22.mul({ c0, c1 }, Fp2Nonresidue),
    mulByB: opts.Fp2mulByB,
    fromBigTuple: Fp2fromBigTuple,
    frobeniusMap: ({ c0, c1 }, power) => ({
      c0,
      c1: Fp3.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])
    })
  };
  const Fp6Add = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({
    c0: Fp22.add(c0, r0),
    c1: Fp22.add(c1, r1),
    c2: Fp22.add(c2, r2)
  });
  const Fp6Subtract = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({
    c0: Fp22.sub(c0, r0),
    c1: Fp22.sub(c1, r1),
    c2: Fp22.sub(c2, r2)
  });
  const Fp6Multiply = ({ c0, c1, c2 }, rhs) => {
    if (typeof rhs === "bigint") {
      return {
        c0: Fp22.mul(c0, rhs),
        c1: Fp22.mul(c1, rhs),
        c2: Fp22.mul(c2, rhs)
      };
    }
    const { c0: r0, c1: r1, c2: r2 } = rhs;
    const t0 = Fp22.mul(c0, r0);
    const t1 = Fp22.mul(c1, r1);
    const t2 = Fp22.mul(c2, r2);
    return {
      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
      c0: Fp22.add(t0, Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c2), Fp22.add(r1, r2)), Fp22.add(t1, t2)))),
      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
      c1: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c1), Fp22.add(r0, r1)), Fp22.add(t0, t1)), Fp22.mulByNonresidue(t2)),
      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
      c2: Fp22.sub(Fp22.add(t1, Fp22.mul(Fp22.add(c0, c2), Fp22.add(r0, r2))), Fp22.add(t0, t2))
    };
  };
  const Fp6Square = ({ c0, c1, c2 }) => {
    let t0 = Fp22.sqr(c0);
    let t1 = Fp22.mul(Fp22.mul(c0, c1), _2n2);
    let t3 = Fp22.mul(Fp22.mul(c1, c2), _2n2);
    let t4 = Fp22.sqr(c2);
    return {
      c0: Fp22.add(Fp22.mulByNonresidue(t3), t0),
      // T3 * (u + 1) + T0
      c1: Fp22.add(Fp22.mulByNonresidue(t4), t1),
      // T4 * (u + 1) + T1
      // T1 + (c0 - c1 + c2) + T3 - T0 - T4
      c2: Fp22.sub(Fp22.sub(Fp22.add(Fp22.add(t1, Fp22.sqr(Fp22.add(Fp22.sub(c0, c1), c2))), t3), t0), t4)
    };
  };
  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(Fp22, Fp2Nonresidue, Fp3.ORDER, 6, 2, 3);
  const Fp62 = {
    ORDER: Fp22.ORDER,
    // TODO: unused, but need to verify
    isLE: Fp22.isLE,
    BITS: 3 * Fp22.BITS,
    BYTES: 3 * Fp22.BYTES,
    MASK: bitMask(3 * Fp22.BITS),
    ZERO: { c0: Fp22.ZERO, c1: Fp22.ZERO, c2: Fp22.ZERO },
    ONE: { c0: Fp22.ONE, c1: Fp22.ZERO, c2: Fp22.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1, c2 }) => Fp22.isValid(c0) && Fp22.isValid(c1) && Fp22.isValid(c2),
    is0: ({ c0, c1, c2 }) => Fp22.is0(c0) && Fp22.is0(c1) && Fp22.is0(c2),
    isValidNot0: (num) => !Fp62.is0(num) && Fp62.isValid(num),
    neg: ({ c0, c1, c2 }) => ({ c0: Fp22.neg(c0), c1: Fp22.neg(c1), c2: Fp22.neg(c2) }),
    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => Fp22.eql(c0, r0) && Fp22.eql(c1, r1) && Fp22.eql(c2, r2),
    sqrt: notImplemented,
    // Do we need division by bigint at all? Should be done via order:
    div: (lhs, rhs) => Fp62.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp62.inv(rhs)),
    pow: (num, power) => FpPow(Fp62, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp62, nums),
    // Normalized
    add: Fp6Add,
    sub: Fp6Subtract,
    mul: Fp6Multiply,
    sqr: Fp6Square,
    // NonNormalized stuff
    addN: Fp6Add,
    subN: Fp6Subtract,
    mulN: Fp6Multiply,
    sqrN: Fp6Square,
    inv: ({ c0, c1, c2 }) => {
      let t0 = Fp22.sub(Fp22.sqr(c0), Fp22.mulByNonresidue(Fp22.mul(c2, c1)));
      let t1 = Fp22.sub(Fp22.mulByNonresidue(Fp22.sqr(c2)), Fp22.mul(c0, c1));
      let t2 = Fp22.sub(Fp22.sqr(c1), Fp22.mul(c0, c2));
      let t4 = Fp22.inv(Fp22.add(Fp22.mulByNonresidue(Fp22.add(Fp22.mul(c2, t1), Fp22.mul(c1, t2))), Fp22.mul(c0, t0)));
      return { c0: Fp22.mul(t4, t0), c1: Fp22.mul(t4, t1), c2: Fp22.mul(t4, t2) };
    },
    // Bytes utils
    fromBytes: (b) => {
      if (b.length !== Fp62.BYTES)
        throw new Error("fromBytes invalid length=" + b.length);
      return {
        c0: Fp22.fromBytes(b.subarray(0, Fp22.BYTES)),
        c1: Fp22.fromBytes(b.subarray(Fp22.BYTES, 2 * Fp22.BYTES)),
        c2: Fp22.fromBytes(b.subarray(2 * Fp22.BYTES))
      };
    },
    toBytes: ({ c0, c1, c2 }) => concatBytes(Fp22.toBytes(c0), Fp22.toBytes(c1), Fp22.toBytes(c2)),
    cmov: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) => ({
      c0: Fp22.cmov(c0, r0, c),
      c1: Fp22.cmov(c1, r1, c),
      c2: Fp22.cmov(c2, r2, c)
    }),
    fromBigSix: (t) => {
      if (!Array.isArray(t) || t.length !== 6)
        throw new Error("invalid Fp6 usage");
      return {
        c0: Fp22.fromBigTuple(t.slice(0, 2)),
        c1: Fp22.fromBigTuple(t.slice(2, 4)),
        c2: Fp22.fromBigTuple(t.slice(4, 6))
      };
    },
    frobeniusMap: ({ c0, c1, c2 }, power) => ({
      c0: Fp22.frobeniusMap(c0, power),
      c1: Fp22.mul(Fp22.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),
      c2: Fp22.mul(Fp22.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])
    }),
    mulByFp2: ({ c0, c1, c2 }, rhs) => ({
      c0: Fp22.mul(c0, rhs),
      c1: Fp22.mul(c1, rhs),
      c2: Fp22.mul(c2, rhs)
    }),
    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp22.mulByNonresidue(c2), c1: c0, c2: c1 }),
    // Sparse multiplication
    mul1: ({ c0, c1, c2 }, b1) => ({
      c0: Fp22.mulByNonresidue(Fp22.mul(c2, b1)),
      c1: Fp22.mul(c0, b1),
      c2: Fp22.mul(c1, b1)
    }),
    // Sparse multiplication
    mul01({ c0, c1, c2 }, b0, b1) {
      let t0 = Fp22.mul(c0, b0);
      let t1 = Fp22.mul(c1, b1);
      return {
        // ((c1 + c2) * b1 - T1) * (u + 1) + T0
        c0: Fp22.add(Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c2), b1), t1)), t0),
        // (b0 + b1) * (c0 + c1) - T0 - T1
        c1: Fp22.sub(Fp22.sub(Fp22.mul(Fp22.add(b0, b1), Fp22.add(c0, c1)), t0), t1),
        // (c0 + c2) * b0 - T0 + T1
        c2: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c2), b0), t0), t1)
      };
    }
  };
  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp22, Fp2Nonresidue, Fp3.ORDER, 12, 1, 6)[0];
  const Fp12Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp62.add(c0, r0),
    c1: Fp62.add(c1, r1)
  });
  const Fp12Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp62.sub(c0, r0),
    c1: Fp62.sub(c1, r1)
  });
  const Fp12Multiply = ({ c0, c1 }, rhs) => {
    if (typeof rhs === "bigint")
      return { c0: Fp62.mul(c0, rhs), c1: Fp62.mul(c1, rhs) };
    let { c0: r0, c1: r1 } = rhs;
    let t1 = Fp62.mul(c0, r0);
    let t2 = Fp62.mul(c1, r1);
    return {
      c0: Fp62.add(t1, Fp62.mulByNonresidue(t2)),
      // T1 + T2 * v
      // (c0 + c1) * (r0 + r1) - (T1 + T2)
      c1: Fp62.sub(Fp62.mul(Fp62.add(c0, c1), Fp62.add(r0, r1)), Fp62.add(t1, t2))
    };
  };
  const Fp12Square = ({ c0, c1 }) => {
    let ab = Fp62.mul(c0, c1);
    return {
      // (c1 * v + c0) * (c0 + c1) - AB - AB * v
      c0: Fp62.sub(Fp62.sub(Fp62.mul(Fp62.add(Fp62.mulByNonresidue(c1), c0), Fp62.add(c0, c1)), ab), Fp62.mulByNonresidue(ab)),
      c1: Fp62.add(ab, ab)
    };
  };
  function Fp4Square2(a, b) {
    const a2 = Fp22.sqr(a);
    const b22 = Fp22.sqr(b);
    return {
      first: Fp22.add(Fp22.mulByNonresidue(b22), a2),
      // b * Nonresidue + a
      second: Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(a, b)), a2), b22)
      // (a + b) - a - b
    };
  }
  const Fp122 = {
    ORDER: Fp22.ORDER,
    // TODO: unused, but need to verify
    isLE: Fp62.isLE,
    BITS: 2 * Fp62.BITS,
    BYTES: 2 * Fp62.BYTES,
    MASK: bitMask(2 * Fp62.BITS),
    ZERO: { c0: Fp62.ZERO, c1: Fp62.ZERO },
    ONE: { c0: Fp62.ONE, c1: Fp62.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1 }) => Fp62.isValid(c0) && Fp62.isValid(c1),
    is0: ({ c0, c1 }) => Fp62.is0(c0) && Fp62.is0(c1),
    isValidNot0: (num) => !Fp122.is0(num) && Fp122.isValid(num),
    neg: ({ c0, c1 }) => ({ c0: Fp62.neg(c0), c1: Fp62.neg(c1) }),
    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp62.eql(c0, r0) && Fp62.eql(c1, r1),
    sqrt: notImplemented,
    inv: ({ c0, c1 }) => {
      let t = Fp62.inv(Fp62.sub(Fp62.sqr(c0), Fp62.mulByNonresidue(Fp62.sqr(c1))));
      return { c0: Fp62.mul(c0, t), c1: Fp62.neg(Fp62.mul(c1, t)) };
    },
    div: (lhs, rhs) => Fp122.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp122.inv(rhs)),
    pow: (num, power) => FpPow(Fp122, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp122, nums),
    // Normalized
    add: Fp12Add,
    sub: Fp12Subtract,
    mul: Fp12Multiply,
    sqr: Fp12Square,
    // NonNormalized stuff
    addN: Fp12Add,
    subN: Fp12Subtract,
    mulN: Fp12Multiply,
    sqrN: Fp12Square,
    // Bytes utils
    fromBytes: (b) => {
      if (b.length !== Fp122.BYTES)
        throw new Error("fromBytes invalid length=" + b.length);
      return {
        c0: Fp62.fromBytes(b.subarray(0, Fp62.BYTES)),
        c1: Fp62.fromBytes(b.subarray(Fp62.BYTES))
      };
    },
    toBytes: ({ c0, c1 }) => concatBytes(Fp62.toBytes(c0), Fp62.toBytes(c1)),
    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({
      c0: Fp62.cmov(c0, r0, c),
      c1: Fp62.cmov(c1, r1, c)
    }),
    // Utils
    // toString() {
    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');
    // },
    // fromTuple(c: [Fp6, Fp6]) {
    //   return new Fp12(...c);
    // }
    fromBigTwelve: (t) => ({
      c0: Fp62.fromBigSix(t.slice(0, 6)),
      c1: Fp62.fromBigSix(t.slice(6, 12))
    }),
    // Raises to q**i -th power
    frobeniusMap(lhs, power) {
      const { c0, c1, c2 } = Fp62.frobeniusMap(lhs.c1, power);
      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];
      return {
        c0: Fp62.frobeniusMap(lhs.c0, power),
        c1: Fp62.create({
          c0: Fp22.mul(c0, coeff),
          c1: Fp22.mul(c1, coeff),
          c2: Fp22.mul(c2, coeff)
        })
      };
    },
    mulByFp2: ({ c0, c1 }, rhs) => ({
      c0: Fp62.mulByFp2(c0, rhs),
      c1: Fp62.mulByFp2(c1, rhs)
    }),
    conjugate: ({ c0, c1 }) => ({ c0, c1: Fp62.neg(c1) }),
    // Sparse multiplication
    mul014: ({ c0, c1 }, o0, o1, o4) => {
      let t0 = Fp62.mul01(c0, o0, o1);
      let t1 = Fp62.mul1(c1, o4);
      return {
        c0: Fp62.add(Fp62.mulByNonresidue(t1), t0),
        // T1 * v + T0
        // (c1 + c0) * [o0, o1+o4] - T0 - T1
        c1: Fp62.sub(Fp62.sub(Fp62.mul01(Fp62.add(c1, c0), o0, Fp22.add(o1, o4)), t0), t1)
      };
    },
    mul034: ({ c0, c1 }, o0, o3, o4) => {
      const a = Fp62.create({
        c0: Fp22.mul(c0.c0, o0),
        c1: Fp22.mul(c0.c1, o0),
        c2: Fp22.mul(c0.c2, o0)
      });
      const b = Fp62.mul01(c1, o3, o4);
      const e = Fp62.mul01(Fp62.add(c0, c1), Fp22.add(o0, o3), o4);
      return {
        c0: Fp62.add(Fp62.mulByNonresidue(b), a),
        c1: Fp62.sub(e, Fp62.add(a, b))
      };
    },
    // A cyclotomic group is a subgroup of Fp^n defined by
    //   G(p) = {  Fp : ^(p) = 1}
    // The result of any pairing is in a cyclotomic subgroup
    // https://eprint.iacr.org/2009/565.pdf
    _cyclotomicSquare: opts.Fp12cyclotomicSquare,
    _cyclotomicExp: opts.Fp12cyclotomicExp,
    // https://eprint.iacr.org/2010/354.pdf
    // https://eprint.iacr.org/2009/565.pdf
    finalExponentiate: opts.Fp12finalExponentiate
  };
  return { Fp: Fp3, Fp2: Fp22, Fp6: Fp62, Fp12: Fp122, Fp4Square: Fp4Square2 };
}

// node_modules/@noble/curves/esm/bls12-381.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n3 = BigInt(3);
var _4n = BigInt(4);
var BLS_X = BigInt("0xd201000000010000");
var BLS_X_LEN = bitLen(BLS_X);
var bls12_381_CURVE_G1 = {
  p: BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),
  n: BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"),
  h: BigInt("0x396c8c005555e1568c00aaab0000aaab"),
  a: _0n3,
  b: _4n,
  Gx: BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),
  Gy: BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1")
};
var bls12_381_Fr = Field(bls12_381_CURVE_G1.n);
var { Fp, Fp2, Fp6, Fp4Square, Fp12 } = tower12({
  // Order of Fp
  ORDER: bls12_381_CURVE_G1.p,
  // Finite extension field over irreducible polynominal.
  // Fp(u) / (u - ) where  = -1
  FP2_NONRESIDUE: [_1n3, _1n3],
  Fp2mulByB: ({ c0, c1 }) => {
    const t0 = Fp.mul(c0, _4n);
    const t1 = Fp.mul(c1, _4n);
    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };
  },
  // Fp12
  // A cyclotomic group is a subgroup of Fp^n defined by
  //   G(p) = {  Fp : ^(p) = 1}
  // The result of any pairing is in a cyclotomic subgroup
  // https://eprint.iacr.org/2009/565.pdf
  Fp12cyclotomicSquare: ({ c0, c1 }) => {
    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;
    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;
    const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);
    const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);
    const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);
    const t9 = Fp2.mulByNonresidue(t8);
    return {
      c0: Fp6.create({
        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n3), t3),
        // 2 * (T3 - c0c0)  + T3
        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n3), t5),
        // 2 * (T5 - c0c1)  + T5
        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n3), t7)
      }),
      // 2 * (T7 - c0c2)  + T7
      c1: Fp6.create({
        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n3), t9),
        // 2 * (T9 + c1c0) + T9
        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n3), t4),
        // 2 * (T4 + c1c1) + T4
        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n3), t6)
      })
    };
  },
  Fp12cyclotomicExp(num, n) {
    let z = Fp12.ONE;
    for (let i = BLS_X_LEN - 1; i >= 0; i--) {
      z = Fp12._cyclotomicSquare(z);
      if (bitGet(n, i))
        z = Fp12.mul(z, num);
    }
    return z;
  },
  // https://eprint.iacr.org/2010/354.pdf
  // https://eprint.iacr.org/2009/565.pdf
  Fp12finalExponentiate: (num) => {
    const x = BLS_X;
    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);
    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);
    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));
    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);
    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));
    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));
    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));
    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));
    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);
    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);
    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);
    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);
    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
  }
});
var { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE));
var htfDefaults = Object.freeze({
  DST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  encodeDST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  p: Fp.ORDER,
  m: 2,
  k: 128,
  expand: "xmd",
  hash: sha256
});
var bls12_381_CURVE_G2 = {
  p: Fp2.ORDER,
  n: bls12_381_CURVE_G1.n,
  h: BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),
  a: Fp2.ZERO,
  b: Fp2.fromBigTuple([_4n, _4n]),
  Gx: Fp2.fromBigTuple([
    BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),
    BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")
  ]),
  Gy: Fp2.fromBigTuple([
    BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),
    BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")
  ])
};
var COMPZERO = setMask(Fp.toBytes(_0n3), { infinity: true, compressed: true });
function parseMask(bytes) {
  bytes = bytes.slice();
  const mask = bytes[0] & 224;
  const compressed = !!(mask >> 7 & 1);
  const infinity2 = !!(mask >> 6 & 1);
  const sort4 = !!(mask >> 5 & 1);
  bytes[0] &= 31;
  return { compressed, infinity: infinity2, sort: sort4, value: bytes };
}
function setMask(bytes, mask) {
  if (bytes[0] & 224)
    throw new Error("setMask: non-empty mask");
  if (mask.compressed)
    bytes[0] |= 128;
  if (mask.infinity)
    bytes[0] |= 64;
  if (mask.sort)
    bytes[0] |= 32;
  return bytes;
}
function pointG1ToBytes(_c7, point, isComp) {
  const { BYTES: L, ORDER: P } = Fp;
  const is0 = point.is0();
  const { x, y } = point.toAffine();
  if (isComp) {
    if (is0)
      return COMPZERO.slice();
    const sort4 = Boolean(y * _2n3 / P);
    return setMask(numberToBytesBE(x, L), { compressed: true, sort: sort4 });
  } else {
    if (is0) {
      return concatBytes(Uint8Array.of(64), new Uint8Array(2 * L - 1));
    } else {
      return concatBytes(numberToBytesBE(x, L), numberToBytesBE(y, L));
    }
  }
}
function signatureG1ToBytes(point) {
  point.assertValidity();
  const { BYTES: L, ORDER: P } = Fp;
  const { x, y } = point.toAffine();
  if (point.is0())
    return COMPZERO.slice();
  const sort4 = Boolean(y * _2n3 / P);
  return setMask(numberToBytesBE(x, L), { compressed: true, sort: sort4 });
}
function pointG1FromBytes(bytes) {
  const { compressed, infinity: infinity2, sort: sort4, value: value10 } = parseMask(bytes);
  const { BYTES: L, ORDER: P } = Fp;
  if (value10.length === 48 && compressed) {
    const compressedValue = bytesToNumberBE(value10);
    const x = Fp.create(compressedValue & Fp.MASK);
    if (infinity2) {
      if (x !== _0n3)
        throw new Error("invalid G1 point: non-empty, at infinity, with compression");
      return { x: _0n3, y: _0n3 };
    }
    const right3 = Fp.add(Fp.pow(x, _3n3), Fp.create(bls12_381_CURVE_G1.b));
    let y = Fp.sqrt(right3);
    if (!y)
      throw new Error("invalid G1 point: compressed point");
    if (y * _2n3 / P !== BigInt(sort4))
      y = Fp.neg(y);
    return { x: Fp.create(x), y: Fp.create(y) };
  } else if (value10.length === 96 && !compressed) {
    const x = bytesToNumberBE(value10.subarray(0, L));
    const y = bytesToNumberBE(value10.subarray(L));
    if (infinity2) {
      if (x !== _0n3 || y !== _0n3)
        throw new Error("G1: non-empty point at infinity");
      return bls12_381.G1.Point.ZERO.toAffine();
    }
    return { x: Fp.create(x), y: Fp.create(y) };
  } else {
    throw new Error("invalid G1 point: expected 48/96 bytes");
  }
}
function signatureG1FromBytes(hex2) {
  const { infinity: infinity2, sort: sort4, value: value10 } = parseMask(ensureBytes("signatureHex", hex2, 48));
  const P = Fp.ORDER;
  const Point2 = bls12_381.G1.Point;
  const compressedValue = bytesToNumberBE(value10);
  if (infinity2)
    return Point2.ZERO;
  const x = Fp.create(compressedValue & Fp.MASK);
  const right3 = Fp.add(Fp.pow(x, _3n3), Fp.create(bls12_381_CURVE_G1.b));
  let y = Fp.sqrt(right3);
  if (!y)
    throw new Error("invalid G1 point: compressed");
  const aflag = BigInt(sort4);
  if (y * _2n3 / P !== aflag)
    y = Fp.neg(y);
  const point = Point2.fromAffine({ x, y });
  point.assertValidity();
  return point;
}
function pointG2ToBytes(_c7, point, isComp) {
  const { BYTES: L, ORDER: P } = Fp;
  const is0 = point.is0();
  const { x, y } = point.toAffine();
  if (isComp) {
    if (is0)
      return concatBytes(COMPZERO, numberToBytesBE(_0n3, L));
    const flag = Boolean(y.c1 === _0n3 ? y.c0 * _2n3 / P : y.c1 * _2n3 / P);
    return concatBytes(setMask(numberToBytesBE(x.c1, L), { compressed: true, sort: flag }), numberToBytesBE(x.c0, L));
  } else {
    if (is0)
      return concatBytes(Uint8Array.of(64), new Uint8Array(4 * L - 1));
    const { re: x0, im: x1 } = Fp2.reim(x);
    const { re: y0, im: y1 } = Fp2.reim(y);
    return concatBytes(numberToBytesBE(x1, L), numberToBytesBE(x0, L), numberToBytesBE(y1, L), numberToBytesBE(y0, L));
  }
}
function signatureG2ToBytes(point) {
  point.assertValidity();
  const { BYTES: L } = Fp;
  if (point.is0())
    return concatBytes(COMPZERO, numberToBytesBE(_0n3, L));
  const { x, y } = point.toAffine();
  const { re: x0, im: x1 } = Fp2.reim(x);
  const { re: y0, im: y1 } = Fp2.reim(y);
  const tmp = y1 > _0n3 ? y1 * _2n3 : y0 * _2n3;
  const sort4 = Boolean(tmp / Fp.ORDER & _1n3);
  const z2 = x0;
  return concatBytes(setMask(numberToBytesBE(x1, L), { sort: sort4, compressed: true }), numberToBytesBE(z2, L));
}
function pointG2FromBytes(bytes) {
  const { BYTES: L, ORDER: P } = Fp;
  const { compressed, infinity: infinity2, sort: sort4, value: value10 } = parseMask(bytes);
  if (!compressed && !infinity2 && sort4 || // 00100000
  !compressed && infinity2 && sort4 || // 01100000
  sort4 && infinity2 && compressed) {
    throw new Error("invalid encoding flag: " + (bytes[0] & 224));
  }
  const slc2 = (b, from29, to3) => bytesToNumberBE(b.slice(from29, to3));
  if (value10.length === 96 && compressed) {
    if (infinity2) {
      if (value10.reduce((p, c) => p !== 0 ? c + 1 : c, 0) > 0) {
        throw new Error("invalid G2 point: compressed");
      }
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    }
    const x_1 = slc2(value10, 0, L);
    const x_0 = slc2(value10, L, 2 * L);
    const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });
    const right3 = Fp2.add(Fp2.pow(x, _3n3), bls12_381_CURVE_G2.b);
    let y = Fp2.sqrt(right3);
    const Y_bit = y.c1 === _0n3 ? y.c0 * _2n3 / P : y.c1 * _2n3 / P ? _1n3 : _0n3;
    y = sort4 && Y_bit > 0 ? y : Fp2.neg(y);
    return { x, y };
  } else if (value10.length === 192 && !compressed) {
    if (infinity2) {
      if (value10.reduce((p, c) => p !== 0 ? c + 1 : c, 0) > 0) {
        throw new Error("invalid G2 point: uncompressed");
      }
      return { x: Fp2.ZERO, y: Fp2.ZERO };
    }
    const x1 = slc2(value10, 0 * L, 1 * L);
    const x0 = slc2(value10, 1 * L, 2 * L);
    const y1 = slc2(value10, 2 * L, 3 * L);
    const y0 = slc2(value10, 3 * L, 4 * L);
    return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };
  } else {
    throw new Error("invalid G2 point: expected 96/192 bytes");
  }
}
function signatureG2FromBytes(hex2) {
  const { ORDER: P } = Fp;
  const { infinity: infinity2, sort: sort4, value: value10 } = parseMask(ensureBytes("signatureHex", hex2));
  const Point2 = bls12_381.G2.Point;
  const half = value10.length / 2;
  if (half !== 48 && half !== 96)
    throw new Error("invalid compressed signature length, expected 96/192 bytes");
  const z1 = bytesToNumberBE(value10.slice(0, half));
  const z2 = bytesToNumberBE(value10.slice(half));
  if (infinity2)
    return Point2.ZERO;
  const x1 = Fp.create(z1 & Fp.MASK);
  const x2 = Fp.create(z2);
  const x = Fp2.create({ c0: x2, c1: x1 });
  const y2 = Fp2.add(Fp2.pow(x, _3n3), bls12_381_CURVE_G2.b);
  let y = Fp2.sqrt(y2);
  if (!y)
    throw new Error("Failed to find a square root");
  const { re: y0, im: y1 } = Fp2.reim(y);
  const aflag1 = BigInt(sort4);
  const isGreater = y1 > _0n3 && y1 * _2n3 / P !== aflag1;
  const is0 = y1 === _0n3 && y0 * _2n3 / P !== aflag1;
  if (isGreater || is0)
    y = Fp2.neg(y);
  const point = Point2.fromAffine({ x, y });
  point.assertValidity();
  return point;
}
var bls12_381 = bls({
  // Fields
  fields: {
    Fp,
    Fp2,
    Fp6,
    Fp12,
    Fr: bls12_381_Fr
  },
  // G1: y = x + 4
  G1: {
    ...bls12_381_CURVE_G1,
    Fp,
    htfDefaults: { ...htfDefaults, m: 1, DST: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    isTorsionFree: (c, point) => {
      const beta = BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe");
      const phi = new c(Fp.mul(point.px, beta), point.py, point.pz);
      const xP = point.multiplyUnsafe(BLS_X).negate();
      const u2P = xP.multiplyUnsafe(BLS_X);
      return u2P.equals(phi);
    },
    // Clear cofactor of G1
    // https://eprint.iacr.org/2019/403
    clearCofactor: (_c7, point) => {
      return point.multiplyUnsafe(BLS_X).add(point);
    },
    mapToCurve: mapToG1,
    fromBytes: pointG1FromBytes,
    toBytes: pointG1ToBytes,
    ShortSignature: {
      fromBytes(bytes) {
        abytes(bytes);
        return signatureG1FromBytes(bytes);
      },
      fromHex(hex2) {
        return signatureG1FromBytes(hex2);
      },
      toBytes(point) {
        return signatureG1ToBytes(point);
      },
      toRawBytes(point) {
        return signatureG1ToBytes(point);
      },
      toHex(point) {
        return bytesToHex2(signatureG1ToBytes(point));
      }
    }
  },
  G2: {
    ...bls12_381_CURVE_G2,
    Fp: Fp2,
    // https://datatracker.ietf.org/doc/html/rfc9380#name-clearing-the-cofactor
    // https://datatracker.ietf.org/doc/html/rfc9380#name-cofactor-clearing-for-bls12
    hEff: BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),
    htfDefaults: { ...htfDefaults },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    mapToCurve: mapToG2,
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    // Older version: https://eprint.iacr.org/2019/814.pdf
    isTorsionFree: (c, P) => {
      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P));
    },
    // Maps the point into the prime-order subgroup G2.
    // clear_cofactor_bls12381_g2 from RFC 9380.
    // https://eprint.iacr.org/2017/419.pdf
    // prettier-ignore
    clearCofactor: (c, P) => {
      const x = BLS_X;
      let t1 = P.multiplyUnsafe(x).negate();
      let t2 = G2psi(c, P);
      let t3 = P.double();
      t3 = G2psi2(c, t3);
      t3 = t3.subtract(t2);
      t2 = t1.add(t2);
      t2 = t2.multiplyUnsafe(x).negate();
      t3 = t3.add(t2);
      t3 = t3.subtract(t1);
      const Q = t3.subtract(P);
      return Q;
    },
    fromBytes: pointG2FromBytes,
    toBytes: pointG2ToBytes,
    Signature: {
      fromBytes(bytes) {
        abytes(bytes);
        return signatureG2FromBytes(bytes);
      },
      fromHex(hex2) {
        return signatureG2FromBytes(hex2);
      },
      toBytes(point) {
        return signatureG2ToBytes(point);
      },
      toRawBytes(point) {
        return signatureG2ToBytes(point);
      },
      toHex(point) {
        return bytesToHex2(signatureG2ToBytes(point));
      }
    }
  },
  params: {
    ateLoopSize: BLS_X,
    // The BLS parameter x for BLS12-381
    r: bls12_381_CURVE_G1.n,
    // order; z  z + 1; CURVE.n from other curves
    xNegative: true,
    twistType: "multiplicative"
  },
  htfDefaults,
  hash: sha256
});
var isogenyMapG2 = isogenyMap(Fp2, [
  // xNum
  [
    [
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"
    ],
    [
      "0x0",
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"
    ],
    [
      "0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1",
      "0x0"
    ]
  ],
  // xDen
  [
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"
    ],
    [
      "0xc",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ],
  // yNum
  [
    [
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706",
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"
    ],
    [
      "0x0",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"
    ],
    [
      "0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10",
      "0x0"
    ]
  ],
  // yDen
  [
    [
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"
    ],
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"
    ],
    [
      "0x12",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ]
].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));
var isogenyMapG1 = isogenyMap(Fp, [
  // xNum
  [
    "0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7",
    "0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb",
    "0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0",
    "0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861",
    "0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9",
    "0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983",
    "0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84",
    "0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e",
    "0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317",
    "0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e",
    "0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b",
    "0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"
  ],
  // xDen
  [
    "0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c",
    "0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff",
    "0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19",
    "0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8",
    "0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e",
    "0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5",
    "0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a",
    "0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e",
    "0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641",
    "0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33",
    "0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696",
    "0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6",
    "0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb",
    "0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb",
    "0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0",
    "0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2",
    "0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29",
    "0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587",
    "0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30",
    "0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132",
    "0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e",
    "0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8",
    "0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133",
    "0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b",
    "0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"
  ],
  // yDen
  [
    "0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1",
    "0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d",
    "0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2",
    "0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416",
    "0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d",
    "0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac",
    "0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c",
    "0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9",
    "0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a",
    "0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55",
    "0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8",
    "0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092",
    "0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc",
    "0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7",
    "0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i) => i.map((j) => BigInt(j))));
var G1_SWU = mapToCurveSimpleSWU(Fp, {
  A: Fp.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),
  B: Fp.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),
  Z: Fp.create(BigInt(11))
});
var G2_SWU = mapToCurveSimpleSWU(Fp2, {
  A: Fp2.create({ c0: Fp.create(_0n3), c1: Fp.create(BigInt(240)) }),
  // A' = 240 * I
  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }),
  // B' = 1012 * (1 + I)
  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) })
  // Z: -(2 + I)
});
function mapToG1(scalars) {
  const { x, y } = G1_SWU(Fp.create(scalars[0]));
  return isogenyMapG1(x, y);
}
function mapToG2(scalars) {
  const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));
  return isogenyMapG2(x, y);
}

// node_modules/ox/_esm/core/Bls.js
var noble2 = bls12_381;
function aggregate3(points) {
  var _a106;
  const group5 = typeof ((_a106 = points[0]) == null ? void 0 : _a106.x) === "bigint" ? bls12_381.G1 : bls12_381.G2;
  const point = points.reduce((acc, point2) => acc.add(new group5.ProjectivePoint(point2.x, point2.y, point2.z)), group5.ProjectivePoint.ZERO);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
function getPublicKey2(options) {
  const { privateKey, size: size45 = "short-key:long-sig" } = options;
  const group5 = size45 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const { px, py, pz } = group5.ProjectivePoint.fromPrivateKey(from2(privateKey).slice(2));
  return { x: px, y: py, z: pz };
}
function randomPrivateKey2(options = {}) {
  const { as: as18 = "Hex" } = options;
  const bytes = bls12_381.utils.randomPrivateKey();
  if (as18 === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function sign7(options) {
  const { payload, privateKey, suite, size: size45 = "short-key:long-sig" } = options;
  const payloadGroup = size45 === "short-key:long-sig" ? bls12_381.G2 : bls12_381.G1;
  const payloadPoint = payloadGroup.hashToCurve(from(payload), suite ? { DST: fromString(suite) } : void 0);
  const privateKeyGroup = size45 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const signature = payloadPoint.multiply(privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)));
  return {
    x: signature.px,
    y: signature.py,
    z: signature.pz
  };
}
function verify3(options) {
  const { payload, suite } = options;
  const publicKey = options.publicKey;
  const signature = options.signature;
  const isShortSig = typeof signature.x === "bigint";
  const group5 = isShortSig ? bls12_381.G1 : bls12_381.G2;
  const payloadPoint = group5.hashToCurve(from(payload), suite ? { DST: fromString(suite) } : void 0);
  const shortSigPairing = () => bls12_381.pairingBatch([
    {
      g1: payloadPoint,
      g2: new bls12_381.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z)
    },
    {
      g1: new bls12_381.G1.ProjectivePoint(signature.x, signature.y, signature.z),
      g2: bls12_381.G2.ProjectivePoint.BASE.negate()
    }
  ]);
  const longSigPairing = () => bls12_381.pairingBatch([
    {
      g1: new bls12_381.G1.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z).negate(),
      g2: payloadPoint
    },
    {
      g1: bls12_381.G1.ProjectivePoint.BASE,
      g2: new bls12_381.G2.ProjectivePoint(signature.x, signature.y, signature.z)
    }
  ]);
  return bls12_381.fields.Fp12.eql(isShortSig ? shortSigPairing() : longSigPairing(), bls12_381.fields.Fp12.ONE);
}

// node_modules/ox/_esm/core/BlsPoint.js
var BlsPoint_exports = {};
__export(BlsPoint_exports, {
  fromBytes: () => fromBytes9,
  fromHex: () => fromHex8,
  toBytes: () => toBytes11,
  toHex: () => toHex9
});
function toBytes11(point) {
  const group5 = typeof point.z === "bigint" ? bls12_381.G1 : bls12_381.G2;
  return new group5.ProjectivePoint(point.x, point.y, point.z).toRawBytes();
}
function toHex9(point) {
  return fromBytes(toBytes11(point));
}
function fromBytes9(bytes) {
  const group5 = bytes.length === 48 ? bls12_381.G1 : bls12_381.G2;
  const point = group5.ProjectivePoint.fromHex(bytes);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
function fromHex8(hex2, group5) {
  return fromBytes9(toBytes3(hex2), group5);
}

// node_modules/ox/_esm/core/ContractAddress.js
var ContractAddress_exports = {};
__export(ContractAddress_exports, {
  from: () => from18,
  fromCreate: () => fromCreate,
  fromCreate2: () => fromCreate2
});
function from18(options) {
  if (options.salt)
    return fromCreate2(options);
  return fromCreate(options);
}
function fromCreate(options) {
  const from29 = fromHex(from4(options.from));
  let nonce = fromNumber(options.nonce);
  if (nonce[0] === 0)
    nonce = new Uint8Array([]);
  return from4(`0x${keccak2562(fromBytes7([from29, nonce], { as: "Hex" })).slice(26)}`);
}
function fromCreate2(options) {
  const from29 = fromHex(from4(options.from));
  const salt = padLeft(validate(options.salt) ? options.salt : fromHex(options.salt), 32);
  const bytecodeHash = (() => {
    if ("bytecodeHash" in options) {
      if (validate(options.bytecodeHash))
        return options.bytecodeHash;
      return fromHex(options.bytecodeHash);
    }
    return keccak2562(options.bytecode, { as: "Bytes" });
  })();
  return from4(slice3(keccak2562(concat2(fromHex("0xff"), from29, salt, bytecodeHash), { as: "Hex" }), 12));
}

// node_modules/ox/_esm/core/Ens.js
var Ens_exports = {};
__export(Ens_exports, {
  labelhash: () => labelhash2,
  namehash: () => namehash2,
  normalize: () => normalize5
});

// node_modules/@adraffy/ens-normalize/dist/index.mjs
var COMPRESSED$1 = "AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28";
var FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
function decode_arithmetic(bytes) {
  let pos = 0;
  function u162() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u162();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1; i < symbol_count; i++) {
    acc.push(total += u162());
  }
  let skip = u162();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N = 31;
  const FULL = 2 ** N;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK3 = FULL - 1;
  let register = 0;
  for (let i = 0; i < N; i++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range6 = FULL;
  while (true) {
    let value10 = Math.floor(((register - low + 1) * total - 1) / range6);
    let start5 = 0;
    let end7 = symbol_count;
    while (end7 - start5 > 1) {
      let mid = start5 + end7 >>> 1;
      if (value10 < acc[mid]) {
        end7 = mid;
      } else {
        start5 = mid;
      }
    }
    if (start5 == 0) break;
    symbols.push(start5);
    let a = low + Math.floor(range6 * acc[start5] / total);
    let b = low + Math.floor(range6 * acc[start5 + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK3 | read_bit();
      a = a << 1 & MASK3;
      b = b << 1 & MASK3 | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK3 >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range6 = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}
function read_payload(v) {
  let pos = 0;
  return () => v[pos++];
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}
function unsafe_atob(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n = s.length;
  let ret = new Uint8Array(6 * n >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n, next6) {
  let v = Array(n);
  for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next6());
  return v;
}
function read_sorted(next6, prev = 0) {
  let ret = [];
  while (true) {
    let x = next6();
    let n = next6();
    if (!n) break;
    prev += x;
    for (let i = 0; i < n; i++) {
      ret.push(prev + i);
    }
    prev += n + 1;
  }
  return ret;
}
function read_sorted_arrays(next6) {
  return read_array_while(() => {
    let v = read_sorted(next6);
    if (v.length) return v;
  });
}
function read_mapped(next6) {
  let ret = [];
  while (true) {
    let w = next6();
    if (w == 0) break;
    ret.push(read_linear_table(w, next6));
  }
  while (true) {
    let w = next6() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next6));
  }
  return ret.flat();
}
function read_array_while(next6) {
  let v = [];
  while (true) {
    let x = next6(v.length);
    if (!x) break;
    v.push(x);
  }
  return v;
}
function read_transposed(n, w, next6) {
  let m = Array(n).fill().map(() => []);
  for (let i = 0; i < w; i++) {
    read_deltas(n, next6).forEach((x, j) => m[j].push(x));
  }
  return m;
}
function read_linear_table(w, next6) {
  let dx = 1 + next6();
  let dy = next6();
  let vN = read_array_while(next6);
  let m = read_transposed(vN.length, 1 + w, next6);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
}
function read_replacement_table(w, next6) {
  let n = 1 + next6();
  let m = read_transposed(n, 1 + w, next6);
  return m.map((v) => [v[0], v.slice(1)]);
}
function read_trie(next6) {
  let ret = [];
  let sorted = read_sorted(next6);
  expand2(decode11([]), []);
  return ret;
  function decode11(Q) {
    let S = next6();
    let B = read_array_while(() => {
      let cps = read_sorted(next6).map((i) => sorted[i]);
      if (cps.length) return decode11(cps);
    });
    return { S, B, Q };
  }
  function expand2({ S, B }, cps, saved) {
    if (S & 4 && saved === cps[cps.length - 1]) return;
    if (S & 2) saved = cps[cps.length - 1];
    if (S & 1) ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand2(br, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s) {
  let cps = [];
  for (let pos = 0, len = s.length; pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk7 = 4096;
  let len = cps.length;
  if (len < chunk7) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0; i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk7)));
  }
  return buf.join("");
}
function compare_arrays(a, b) {
  let n = a.length;
  let c = n - b.length;
  for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
  return c;
}
var COMPRESSED = "AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA";
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
function init$1() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a, bucket);
      }
      bucket.set(b, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b) {
  if (a >= L0 && a < L1 && b >= V0 && b < V1) {
    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
    return a + (b - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add14(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add14(L0 + l_index);
        add14(V0 + v_index);
        if (t_index > 0) add14(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add14(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1; i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x) => Array.from(x);
function group_has_cp(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
}
var Emoji = class extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
};
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;
function init2() {
  if (MAPPED) return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set26, v) => v.forEach((x) => set26.add(x));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks3 = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set26 = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i) => set_add_many(set26, chunks3[i]));
    set_add_many(set26, read_sorted_array());
    return set26;
  };
  GROUPS = read_array_while((i) => {
    let N = read_array_while(r).map((x) => x + 96);
    if (N.length) {
      let R = i >= unrestricted;
      N[0] -= 32;
      N = str_from_cps(N);
      if (R) N = `Restricted[${N}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a - b);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union17 = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union17.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P) add_to_union(cp);
    for (let cp of g.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next6 = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next6);
      } else {
        prev = next6;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s) {
  return `"${s}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n = cps.length;
  let last8 = -1;
  for (let i = 1; i < n; i++) {
    cp = cps[i];
    let match43 = FENCED.get(cp);
    if (match43) {
      if (last8 == i) throw error_placement(`${prev} + ${match43}`);
      last8 = i + 1;
      prev = match43;
    }
  }
  if (last8 == n) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max14 = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max14) {
    max14 >>= 1;
    cps = [...cps.slice(0, max14), 8230, ...cps.slice(-max14)];
  }
  let prev = 0;
  let n = cps.length;
  for (let i = 0; i < n; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n)));
  return buf.join("");
}
function is_combining_mark(cp, only_nsm) {
  init2();
  return only_nsm ? NSM.has(cp) : CM.has(cp);
}
function should_escape(cp) {
  init2();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten21(split7(name, nfc, filter_fe0f));
}
function split7(name, nf, ef) {
  if (!name) return [];
  init2();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info3 = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info3.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type8;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info3.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info3.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type8 = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type8 = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i = 1; i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type8 = g.N;
        }
      }
      info3.type = type8;
    } catch (err2) {
      info3.error = err2;
    }
    return info3;
  });
}
function check_whole(group5, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set26 = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set26.has(g)) : Array_from(set26);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group5.N}/${g.N}`);
      }
    }
  }
}
function determine_group(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1) break;
  }
  return groups;
}
function flatten21(split8) {
  return split8.map(({ input, error: error4, output }) => {
    if (error4) {
      let msg = error4.message;
      throw new Error(split8.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length; i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i; k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten) eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}

// node_modules/ox/_esm/core/internal/ens.js
function unwrapLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash11 = `0x${label.slice(1, 65)}`;
  if (!validate2(hash11, { strict: true }))
    return null;
  return hash11;
}

// node_modules/ox/_esm/core/Ens.js
function labelhash2(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return fromBytes(result);
  return unwrapLabelhash(label) || keccak2562(fromString2(label));
}
function namehash2(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return fromBytes(result);
  const labels = name.split(".");
  for (let i = labels.length - 1; i >= 0; i -= 1) {
    const hashFromEncodedLabel = unwrapLabelhash(labels[i]);
    const hashed = hashFromEncodedLabel ? fromHex(hashFromEncodedLabel) : keccak2562(fromString(labels[i]), { as: "Bytes" });
    result = keccak2562(concat2(result, hashed), { as: "Bytes" });
  }
  return fromBytes(result);
}
function normalize5(name) {
  return ens_normalize(name);
}

// node_modules/ox/_esm/core/Filter.js
var Filter_exports = {};
__export(Filter_exports, {
  fromRpc: () => fromRpc6,
  toRpc: () => toRpc7
});
function fromRpc6(filter26) {
  const { fromBlock, toBlock } = filter26;
  return {
    ...filter26,
    ...fromBlock && {
      fromBlock: validate2(fromBlock, { strict: false }) ? BigInt(fromBlock) : fromBlock
    },
    ...toBlock && {
      toBlock: validate2(toBlock, { strict: false }) ? BigInt(toBlock) : toBlock
    }
  };
}
function toRpc7(filter26) {
  const { address, topics, fromBlock, toBlock } = filter26;
  return {
    ...address && { address },
    ...topics && { topics },
    ...typeof fromBlock !== "undefined" ? {
      fromBlock: typeof fromBlock === "bigint" ? fromNumber2(fromBlock) : fromBlock
    } : {},
    ...typeof toBlock !== "undefined" ? {
      toBlock: typeof toBlock === "bigint" ? fromNumber2(toBlock) : toBlock
    } : {}
  };
}

// node_modules/ox/_esm/core/HdKey.js
var HdKey_exports = {};
__export(HdKey_exports, {
  fromExtendedKey: () => fromExtendedKey,
  fromJson: () => fromJson3,
  fromSeed: () => fromSeed,
  path: () => path
});

// node_modules/ox/_esm/core/Secp256k1.js
var Secp256k1_exports = {};
__export(Secp256k1_exports, {
  getPublicKey: () => getPublicKey3,
  noble: () => noble3,
  randomPrivateKey: () => randomPrivateKey3,
  recoverAddress: () => recoverAddress2,
  recoverPublicKey: () => recoverPublicKey3,
  sign: () => sign8,
  verify: () => verify4
});
var noble3 = secp256k1;
function getPublicKey3(options) {
  const { privateKey } = options;
  const point = secp256k1.ProjectivePoint.fromPrivateKey(from2(privateKey).slice(2));
  return from3(point);
}
function randomPrivateKey3(options = {}) {
  const { as: as18 = "Hex" } = options;
  const bytes = secp256k1.utils.randomPrivateKey();
  if (as18 === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function recoverAddress2(options) {
  return fromPublicKey(recoverPublicKey3(options));
}
function recoverPublicKey3(options) {
  const { payload, signature } = options;
  const { r, s, yParity } = signature;
  const signature_ = new secp256k1.Signature(BigInt(r), BigInt(s)).addRecoveryBit(yParity);
  const point = signature_.recoverPublicKey(from2(payload).substring(2));
  return from3(point);
}
function sign8(options) {
  const { extraEntropy: extraEntropy3 = extraEntropy2, hash: hash11, payload, privateKey } = options;
  const { r, s, recovery } = secp256k1.sign(from(payload), from(privateKey), {
    extraEntropy: typeof extraEntropy3 === "boolean" ? extraEntropy3 : from2(extraEntropy3).slice(2),
    lowS: true,
    ...hash11 ? { prehash: true } : {}
  });
  return {
    r,
    s,
    yParity: recovery
  };
}
function verify4(options) {
  const { address, hash: hash11, payload, publicKey, signature } = options;
  if (address)
    return isEqual3(address, recoverAddress2({ payload, signature }));
  return secp256k1.verify(signature, from(payload), toBytes5(publicKey), ...hash11 ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/internal/hdKey.js
function fromScure(key) {
  return {
    derive: (path2) => fromScure(key.derive(path2)),
    depth: key.depth,
    identifier: fromBytes(key.identifier),
    index: key.index,
    privateKey: fromBytes(key.privateKey),
    privateExtendedKey: key.privateExtendedKey,
    publicKey: getPublicKey3({ privateKey: key.privateKey }),
    publicExtendedKey: key.publicExtendedKey,
    versions: key.versions
  };
}

// node_modules/ox/_esm/core/HdKey.js
function fromExtendedKey(extendedKey) {
  const key = HDKey.fromExtendedKey(extendedKey);
  return fromScure(key);
}
function fromJson3(json3) {
  return fromScure(HDKey.fromJSON(json3));
}
function fromSeed(seed, options = {}) {
  const { versions } = options;
  const key = HDKey.fromMasterSeed(from(seed), versions);
  return fromScure(key);
}
function path(options = {}) {
  const { account = 0, change = 0, index: index3 = 0 } = options;
  return `m/44'/60'/${account}'/${change}/${index3}`;
}

// node_modules/ox/_esm/core/Fee.js
var Fee_exports = {};

// node_modules/ox/_esm/core/Keystore.js
var Keystore_exports = {};
__export(Keystore_exports, {
  decrypt: () => decrypt3,
  encrypt: () => encrypt3,
  pbkdf2: () => pbkdf22,
  pbkdf2Async: () => pbkdf2Async2,
  scrypt: () => scrypt2,
  scryptAsync: () => scryptAsync2,
  toKey: () => toKey,
  toKeyAsync: () => toKeyAsync
});

// node_modules/@noble/ciphers/esm/utils.js
function isBytes3(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function anumber3(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes3(b, ...lengths) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes3(out);
  const min11 = instance.outputLen;
  if (out.length < min11) {
    throw new Error("digestInto() expects output buffer of length at least " + min11);
  }
}
function u83(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u324(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean2(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin2 = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex4(bytes) {
  abytes3(bytes);
  if (hasHexBuiltin2)
    return bytes.toHex();
  let hex2 = "";
  for (let i = 0; i < bytes.length; i++) {
    hex2 += hexes[bytes[i]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch3) {
  if (ch3 >= asciis._0 && ch3 <= asciis._9)
    return ch3 - asciis._0;
  if (ch3 >= asciis.A && ch3 <= asciis.F)
    return ch3 - (asciis.A - 10);
  if (ch3 >= asciis.a && ch3 <= asciis.f)
    return ch3 - (asciis.a - 10);
  return;
}
function hexToBytes4(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  if (hasHexBuiltin2)
    return Uint8Array.fromHex(hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array8 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n2 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char2 = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi);
    }
    array8[ai] = n1 * 16 + n2;
  }
  return array8;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes12(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  else if (isBytes3(data))
    data = copyBytes(data);
  else
    throw new Error("Uint8Array expected, got " + typeof data);
  return data;
}
function overlapBytes(a, b) {
  return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
  a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
  b.byteOffset < a.byteOffset + a.byteLength;
}
function complexOverlapBytes(input, output) {
  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
    throw new Error("complex overlap of input and output is not supported");
}
function concatBytes3(...arrays) {
  let sum7 = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes3(a);
    sum7 += a.length;
  }
  const res = new Uint8Array(sum7);
  for (let i = 0, pad4 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad4);
    pad4 += a.length;
  }
  return res;
}
function checkOpts2(defaults, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff13 = 0;
  for (let i = 0; i < a.length; i++)
    diff13 |= a[i] ^ b[i];
  return diff13 === 0;
}
var wrapCipher = (params, constructor) => {
  function wrappedCipher(key, ...args2) {
    abytes3(key);
    if (!isLE)
      throw new Error("Non little-endian hardware is not yet supported");
    if (params.nonceLength !== void 0) {
      const nonce = args2[0];
      if (!nonce)
        throw new Error("nonce / iv required");
      if (params.varSizeNonce)
        abytes3(nonce);
      else
        abytes3(nonce, params.nonceLength);
    }
    const tagl = params.tagLength;
    if (tagl && args2[1] !== void 0) {
      abytes3(args2[1]);
    }
    const cipher = constructor(key, ...args2);
    const checkOutput = (fnLength, output) => {
      if (output !== void 0) {
        if (fnLength !== 2)
          throw new Error("cipher output not supported");
        abytes3(output);
      }
    };
    let called = false;
    const wrCipher = {
      encrypt(data, output) {
        if (called)
          throw new Error("cannot encrypt() twice with same key + nonce");
        called = true;
        abytes3(data);
        checkOutput(cipher.encrypt.length, output);
        return cipher.encrypt(data, output);
      },
      decrypt(data, output) {
        abytes3(data);
        if (tagl && data.length < tagl)
          throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
        checkOutput(cipher.decrypt.length, output);
        return cipher.decrypt(data, output);
      }
    };
    return wrCipher;
  }
  Object.assign(wrappedCipher, params);
  return wrappedCipher;
};
function getOutput(expectedLength, out, onlyAligned = true) {
  if (out === void 0)
    return new Uint8Array(expectedLength);
  if (out.length !== expectedLength)
    throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
  if (onlyAligned && !isAligned32(out))
    throw new Error("invalid output, must be aligned");
  return out;
}
function setBigUint64(view, byteOffset, value10, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value10, isLE2);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value10 >> _32n & _u32_max);
  const wl = Number(value10 & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function u64Lengths(dataLength, aadLength, isLE2) {
  abool(isLE2);
  const num = new Uint8Array(16);
  const view = createView2(num);
  setBigUint64(view, 0, BigInt(aadLength), isLE2);
  setBigUint64(view, 8, BigInt(dataLength), isLE2);
  return num;
}
function isAligned32(bytes) {
  return bytes.byteOffset % 4 === 0;
}
function copyBytes(bytes) {
  return Uint8Array.from(bytes);
}

// node_modules/@noble/ciphers/esm/_polyval.js
var BLOCK_SIZE = 16;
var ZEROS16 = new Uint8Array(16);
var ZEROS32 = u324(ZEROS16);
var POLY = 225;
var mul2 = (s0, s1, s2, s3) => {
  const hiBit = s3 & 1;
  return {
    s3: s2 << 31 | s3 >>> 1,
    s2: s1 << 31 | s2 >>> 1,
    s1: s0 << 31 | s1 >>> 1,
    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
    // reduce % poly
  };
};
var swapLE = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
function _toGHASHKey(k) {
  k.reverse();
  const hiBit = k[15] & 1;
  let carry = 0;
  for (let i = 0; i < k.length; i++) {
    const t = k[i];
    k[i] = t >>> 1 | carry;
    carry = (t & 1) << 7;
  }
  k[0] ^= -hiBit & 225;
  return k;
}
var estimateWindow = (bytes) => {
  if (bytes > 64 * 1024)
    return 8;
  if (bytes > 1024)
    return 4;
  return 2;
};
var GHASH = class {
  // We select bits per window adaptively based on expectedLength
  constructor(key, expectedLength) {
    this.blockLen = BLOCK_SIZE;
    this.outputLen = BLOCK_SIZE;
    this.s0 = 0;
    this.s1 = 0;
    this.s2 = 0;
    this.s3 = 0;
    this.finished = false;
    key = toBytes12(key);
    abytes3(key, 16);
    const kView = createView2(key);
    let k0 = kView.getUint32(0, false);
    let k1 = kView.getUint32(4, false);
    let k2 = kView.getUint32(8, false);
    let k3 = kView.getUint32(12, false);
    const doubles = [];
    for (let i = 0; i < 128; i++) {
      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });
      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
    }
    const W = estimateWindow(expectedLength || 1024);
    if (![1, 2, 4, 8].includes(W))
      throw new Error("ghash: invalid window size, expected 2, 4 or 8");
    this.W = W;
    const bits2 = 128;
    const windows = bits2 / W;
    const windowSize = this.windowSize = 2 ** W;
    const items = [];
    for (let w = 0; w < windows; w++) {
      for (let byte = 0; byte < windowSize; byte++) {
        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
        for (let j = 0; j < W; j++) {
          const bit = byte >>> W - j - 1 & 1;
          if (!bit)
            continue;
          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];
          s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
        }
        items.push({ s0, s1, s2, s3 });
      }
    }
    this.t = items;
  }
  _updateBlock(s0, s1, s2, s3) {
    s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
    const { W, t, windowSize } = this;
    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
    const mask = (1 << W) - 1;
    let w = 0;
    for (const num of [s0, s1, s2, s3]) {
      for (let bytePos = 0; bytePos < 4; bytePos++) {
        const byte = num >>> 8 * bytePos & 255;
        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {
          const bit = byte >>> W * bitPos & mask;
          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
          o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
          w += 1;
        }
      }
    }
    this.s0 = o0;
    this.s1 = o1;
    this.s2 = o2;
    this.s3 = o3;
  }
  update(data) {
    aexists2(this);
    data = toBytes12(data);
    abytes3(data);
    const b32 = u324(data);
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    const left3 = data.length % BLOCK_SIZE;
    for (let i = 0; i < blocks; i++) {
      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);
    }
    if (left3) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
      clean2(ZEROS32);
    }
    return this;
  }
  destroy() {
    const { t } = this;
    for (const elm of t) {
      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
    }
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u324(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out;
  }
  digest() {
    const res = new Uint8Array(BLOCK_SIZE);
    this.digestInto(res);
    this.destroy();
    return res;
  }
};
var Polyval = class extends GHASH {
  constructor(key, expectedLength) {
    key = toBytes12(key);
    abytes3(key);
    const ghKey = _toGHASHKey(copyBytes(key));
    super(ghKey, expectedLength);
    clean2(ghKey);
  }
  update(data) {
    data = toBytes12(data);
    aexists2(this);
    const b32 = u324(data);
    const left3 = data.length % BLOCK_SIZE;
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    for (let i = 0; i < blocks; i++) {
      this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));
    }
    if (left3) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
      clean2(ZEROS32);
    }
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u324(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out.reverse();
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes12(msg)).digest();
  const tmp = hashCons(new Uint8Array(16), 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
  return hashC;
}
var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

// node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE2 = 16;
var BLOCK_SIZE32 = 4;
var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
var POLY2 = 283;
function mul22(n) {
  return n << 1 ^ POLY2 & -(n >> 7);
}
function mul(a, b) {
  let res = 0;
  for (; b > 0; b >>= 1) {
    res ^= a & -(b & 1);
    a = mul22(a);
  }
  return res;
}
var sbox = (() => {
  const t = new Uint8Array(256);
  for (let i = 0, x = 1; i < 256; i++, x ^= mul22(x))
    t[i] = x;
  const box = new Uint8Array(256);
  box[0] = 99;
  for (let i = 0; i < 255; i++) {
    let x = t[255 - i];
    x |= x << 8;
    box[t[i]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
  }
  clean2(t);
  return box;
})();
var invSbox = sbox.map((_, j) => sbox.indexOf(j));
var rotr32_8 = (n) => n << 24 | n >>> 8;
var rotl32_8 = (n) => n << 8 | n >>> 24;
var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function genTtable(sbox2, fn2) {
  if (sbox2.length !== 256)
    throw new Error("Wrong sbox length");
  const T02 = new Uint32Array(256).map((_, j) => fn2(sbox2[j]));
  const T12 = T02.map(rotl32_8);
  const T2 = T12.map(rotl32_8);
  const T3 = T2.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox22 = new Uint16Array(256 * 256);
  for (let i = 0; i < 256; i++) {
    for (let j = 0; j < 256; j++) {
      const idx = i * 256 + j;
      T01[idx] = T02[i] ^ T12[j];
      T23[idx] = T2[i] ^ T3[j];
      sbox22[idx] = sbox2[i] << 8 | sbox2[j];
    }
  }
  return { sbox: sbox2, sbox2: sbox22, T0: T02, T1: T12, T2, T3, T01, T23 };
}
var tableEncoding = genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
var tableDecoding = genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
var xPowers = (() => {
  const p = new Uint8Array(16);
  for (let i = 0, x = 1; i < 16; i++, x = mul22(x))
    p[i] = x;
  return p;
})();
function expandKeyLE(key) {
  abytes3(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error("aes: invalid key size, should be 16, 24 or 32, got " + len);
  const { sbox2 } = tableEncoding;
  const toClean = [];
  if (!isAligned32(key))
    toClean.push(key = copyBytes(key));
  const k32 = u324(key);
  const Nk = k32.length;
  const subByte = (n) => applySbox(sbox2, n, n, n, n);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i = Nk; i < xk.length; i++) {
    let t = xk[i - 1];
    if (i % Nk === 0)
      t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];
    else if (Nk > 6 && i % Nk === 4)
      t = subByte(t);
    xk[i] = xk[i - Nk] ^ t;
  }
  clean2(...toClean);
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = tableEncoding;
  const { T0: T02, T1: T12, T2, T3 } = tableDecoding;
  for (let i = 0; i < Nk; i += 4) {
    for (let j = 0; j < 4; j++)
      xk[i + j] = encKey[Nk - i - 4 + j];
  }
  clean2(encKey);
  for (let i = 4; i < Nk - 4; i++) {
    const x = xk[i];
    const w = applySbox(sbox2, x, x, x, x);
    xk[i] = T02[w & 255] ^ T12[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s2, s3) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s2, s3) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
}
function encrypt2(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableEncoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i = 0; i < rounds; i++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function decrypt2(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableDecoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i = 0; i < rounds; i++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function ctrCounter(xk, nonce, src, dst) {
  abytes3(nonce, BLOCK_SIZE2);
  abytes3(src);
  const srcLen = src.length;
  dst = getOutput(srcLen, dst);
  complexOverlapBytes(src, dst);
  const ctr2 = nonce;
  const c32 = u324(ctr2);
  let { s0, s1, s2, s3 } = encrypt2(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u324(src);
  const dst32 = u324(dst);
  for (let i = 0; i + 4 <= src32.length; i += 4) {
    dst32[i + 0] = src32[i + 0] ^ s0;
    dst32[i + 1] = src32[i + 1] ^ s1;
    dst32[i + 2] = src32[i + 2] ^ s2;
    dst32[i + 3] = src32[i + 3] ^ s3;
    let carry = 1;
    for (let i2 = ctr2.length - 1; i2 >= 0; i2--) {
      carry = carry + (ctr2[i2] & 255) | 0;
      ctr2[i2] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2, s3 } = encrypt2(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start5 = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start5 < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u83(b32);
    for (let i = start5, pos = 0; i < srcLen; i++, pos++)
      dst[i] = src[i] ^ buf[pos];
    clean2(b32);
  }
  return dst;
}
function ctr32(xk, isLE2, nonce, src, dst) {
  abytes3(nonce, BLOCK_SIZE2);
  abytes3(src);
  dst = getOutput(src.length, dst);
  const ctr2 = nonce;
  const c32 = u324(ctr2);
  const view = createView2(ctr2);
  const src32 = u324(src);
  const dst32 = u324(dst);
  const ctrPos = isLE2 ? 0 : 12;
  const srcLen = src.length;
  let ctrNum = view.getUint32(ctrPos, isLE2);
  let { s0, s1, s2, s3 } = encrypt2(xk, c32[0], c32[1], c32[2], c32[3]);
  for (let i = 0; i + 4 <= src32.length; i += 4) {
    dst32[i + 0] = src32[i + 0] ^ s0;
    dst32[i + 1] = src32[i + 1] ^ s1;
    dst32[i + 2] = src32[i + 2] ^ s2;
    dst32[i + 3] = src32[i + 3] ^ s3;
    ctrNum = ctrNum + 1 >>> 0;
    view.setUint32(ctrPos, ctrNum, isLE2);
    ({ s0, s1, s2, s3 } = encrypt2(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start5 = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start5 < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u83(b32);
    for (let i = start5, pos = 0; i < srcLen; i++, pos++)
      dst[i] = src[i] ^ buf[pos];
    clean2(b32);
  }
  return dst;
}
var ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function aesctr(key, nonce) {
  function processCtr(buf, dst) {
    abytes3(buf);
    if (dst !== void 0) {
      abytes3(dst);
      if (!isAligned32(dst))
        throw new Error("unaligned destination");
    }
    const xk = expandKeyLE(key);
    const n = copyBytes(nonce);
    const toClean = [xk, n];
    if (!isAligned32(buf))
      toClean.push(buf = copyBytes(buf));
    const out = ctrCounter(xk, n, buf, dst);
    clean2(...toClean);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  abytes3(data);
  if (data.length % BLOCK_SIZE2 !== 0) {
    throw new Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size " + BLOCK_SIZE2);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  abytes3(plaintext);
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE2;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  if (!isAligned32(plaintext))
    plaintext = copyBytes(plaintext);
  const b = u324(plaintext);
  if (pcks5) {
    let left3 = BLOCK_SIZE2 - remaining;
    if (!left3)
      left3 = BLOCK_SIZE2;
    outLen = outLen + left3;
  }
  dst = getOutput(outLen, dst);
  complexOverlapBytes(plaintext, dst);
  const o = u324(dst);
  return { b, o, out: dst };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error("aes/pcks5: empty ciphertext not allowed");
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error("aes/pcks5: wrong padding");
  const out = data.subarray(0, -lastByte);
  for (let i = 0; i < lastByte; i++)
    if (data[len - i - 1] !== lastByte)
      throw new Error("aes/pcks5: wrong padding");
  return out;
}
function padPCKS(left3) {
  const tmp = new Uint8Array(16);
  const tmp32 = u324(tmp);
  tmp.set(left3);
  const paddingByte = BLOCK_SIZE2 - left3.length;
  for (let i = BLOCK_SIZE2 - paddingByte; i < BLOCK_SIZE2; i++)
    tmp[i] = paddingByte;
  return tmp32;
}
var ecb = wrapCipher({ blockSize: 16 }, function aesecb(key, opts = {}) {
  const pcks5 = !opts.disablePadding;
  return {
    encrypt(plaintext, dst) {
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const xk = expandKeyLE(key);
      let i = 0;
      for (; i + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = encrypt2(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i * 4));
        const { s0, s1, s2, s3 } = encrypt2(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      clean2(xk);
      return _out;
    },
    decrypt(ciphertext, dst) {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      dst = getOutput(ciphertext.length, dst);
      const toClean = [xk];
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      complexOverlapBytes(ciphertext, dst);
      const b = u324(ciphertext);
      const o = u324(dst);
      for (let i = 0; i + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = decrypt2(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      clean2(...toClean);
      return validatePCKS(dst, pcks5);
    }
  };
});
var cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescbc(key, iv, opts = {}) {
  const pcks5 = !opts.disablePadding;
  return {
    encrypt(plaintext, dst) {
      const xk = expandKeyLE(key);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      let _iv = iv;
      const toClean = [xk];
      if (!isAligned32(_iv))
        toClean.push(_iv = copyBytes(_iv));
      const n32 = u324(_iv);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      let i = 0;
      for (; i + 4 <= b.length; ) {
        s0 ^= b[i + 0], s1 ^= b[i + 1], s2 ^= b[i + 2], s3 ^= b[i + 3];
        ({ s0, s1, s2, s3 } = encrypt2(xk, s0, s1, s2, s3));
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
        ({ s0, s1, s2, s3 } = encrypt2(xk, s0, s1, s2, s3));
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      clean2(...toClean);
      return _out;
    },
    decrypt(ciphertext, dst) {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      let _iv = iv;
      const toClean = [xk];
      if (!isAligned32(_iv))
        toClean.push(_iv = copyBytes(_iv));
      const n32 = u324(_iv);
      dst = getOutput(ciphertext.length, dst);
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      complexOverlapBytes(ciphertext, dst);
      const b = u324(ciphertext);
      const o = u324(dst);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      for (let i = 0; i + 4 <= b.length; ) {
        const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
        s0 = b[i + 0], s1 = b[i + 1], s2 = b[i + 2], s3 = b[i + 3];
        const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt2(xk, s0, s1, s2, s3);
        o[i++] = o0 ^ ps0, o[i++] = o1 ^ ps1, o[i++] = o2 ^ ps2, o[i++] = o3 ^ ps3;
      }
      clean2(...toClean);
      return validatePCKS(dst, pcks5);
    }
  };
});
var cfb = wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescfb(key, iv) {
  function processCfb(src, isEncrypt, dst) {
    abytes3(src);
    const srcLen = src.length;
    dst = getOutput(srcLen, dst);
    if (overlapBytes(src, dst))
      throw new Error("overlapping src and dst not supported.");
    const xk = expandKeyLE(key);
    let _iv = iv;
    const toClean = [xk];
    if (!isAligned32(_iv))
      toClean.push(_iv = copyBytes(_iv));
    if (!isAligned32(src))
      toClean.push(src = copyBytes(src));
    const src32 = u324(src);
    const dst32 = u324(dst);
    const next32 = isEncrypt ? dst32 : src32;
    const n32 = u324(_iv);
    let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
    for (let i = 0; i + 4 <= src32.length; ) {
      const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt2(xk, s0, s1, s2, s3);
      dst32[i + 0] = src32[i + 0] ^ e0;
      dst32[i + 1] = src32[i + 1] ^ e1;
      dst32[i + 2] = src32[i + 2] ^ e2;
      dst32[i + 3] = src32[i + 3] ^ e3;
      s0 = next32[i++], s1 = next32[i++], s2 = next32[i++], s3 = next32[i++];
    }
    const start5 = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
    if (start5 < srcLen) {
      ({ s0, s1, s2, s3 } = encrypt2(xk, s0, s1, s2, s3));
      const buf = u83(new Uint32Array([s0, s1, s2, s3]));
      for (let i = start5, pos = 0; i < srcLen; i++, pos++)
        dst[i] = src[i] ^ buf[pos];
      clean2(buf);
    }
    clean2(...toClean);
    return dst;
  }
  return {
    encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),
    decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst)
  };
});
function computeTag(fn2, isLE2, key, data, AAD) {
  const aadLength = AAD ? AAD.length : 0;
  const h2 = fn2.create(key, data.length + aadLength);
  if (AAD)
    h2.update(AAD);
  const num = u64Lengths(8 * data.length, 8 * aadLength, isLE2);
  h2.update(data);
  h2.update(num);
  const res = h2.digest();
  clean2(num);
  return res;
}
var gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aesgcm(key, nonce, AAD) {
  if (nonce.length < 8)
    throw new Error("aes/gcm: invalid nonce length");
  const tagLength = 16;
  function _computeTag(authKey, tagMask, data) {
    const tag5 = computeTag(ghash, false, authKey, data, AAD);
    for (let i = 0; i < tagMask.length; i++)
      tag5[i] ^= tagMask[i];
    return tag5;
  }
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const authKey = EMPTY_BLOCK.slice();
    const counter12 = EMPTY_BLOCK.slice();
    ctr32(xk, false, counter12, counter12, authKey);
    if (nonce.length === 12) {
      counter12.set(nonce);
    } else {
      const nonceLen = EMPTY_BLOCK.slice();
      const view = createView2(nonceLen);
      setBigUint64(view, 8, BigInt(nonce.length * 8), false);
      const g = ghash.create(authKey).update(nonce).update(nonceLen);
      g.digestInto(counter12);
      g.destroy();
    }
    const tagMask = ctr32(xk, false, counter12, EMPTY_BLOCK);
    return { xk, authKey, counter: counter12, tagMask };
  }
  return {
    encrypt(plaintext) {
      const { xk, authKey, counter: counter12, tagMask } = deriveKeys();
      const out = new Uint8Array(plaintext.length + tagLength);
      const toClean = [xk, authKey, counter12, tagMask];
      if (!isAligned32(plaintext))
        toClean.push(plaintext = copyBytes(plaintext));
      ctr32(xk, false, counter12, plaintext, out.subarray(0, plaintext.length));
      const tag5 = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
      toClean.push(tag5);
      out.set(tag5, plaintext.length);
      clean2(...toClean);
      return out;
    },
    decrypt(ciphertext) {
      const { xk, authKey, counter: counter12, tagMask } = deriveKeys();
      const toClean = [xk, authKey, tagMask, counter12];
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag5 = _computeTag(authKey, tagMask, data);
      toClean.push(tag5);
      if (!equalBytes(tag5, passedTag))
        throw new Error("aes/gcm: invalid ghash tag");
      const out = ctr32(xk, false, counter12, data);
      clean2(...toClean);
      return out;
    }
  };
});
var limit = (name, min11, max14) => (value10) => {
  if (!Number.isSafeInteger(value10) || min11 > value10 || value10 > max14) {
    const minmax = "[" + min11 + ".." + max14 + "]";
    throw new Error("" + name + ": expected value in range " + minmax + ", got " + value10);
  }
};
var gcmsiv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aessiv(key, nonce, AAD) {
  const tagLength = 16;
  const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
  const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
  const NONCE_LIMIT = limit("nonce", 12, 12);
  const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
  abytes3(key, 16, 24, 32);
  NONCE_LIMIT(nonce.length);
  if (AAD !== void 0)
    AAD_LIMIT(AAD.length);
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const encKey = new Uint8Array(key.length);
    const authKey = new Uint8Array(16);
    const toClean = [xk, encKey];
    let _nonce = nonce;
    if (!isAligned32(_nonce))
      toClean.push(_nonce = copyBytes(_nonce));
    const n32 = u324(_nonce);
    let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];
    let counter12 = 0;
    for (const derivedKey of [authKey, encKey].map(u324)) {
      const d32 = u324(derivedKey);
      for (let i = 0; i < d32.length; i += 2) {
        const { s0: o0, s1: o1 } = encrypt2(xk, s0, s1, s2, s3);
        d32[i + 0] = o0;
        d32[i + 1] = o1;
        s0 = ++counter12;
      }
    }
    const res = { authKey, encKey: expandKeyLE(encKey) };
    clean2(...toClean);
    return res;
  }
  function _computeTag(encKey, authKey, data) {
    const tag5 = computeTag(polyval, true, authKey, data, AAD);
    for (let i = 0; i < 12; i++)
      tag5[i] ^= nonce[i];
    tag5[15] &= 127;
    const t32 = u324(tag5);
    let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];
    ({ s0, s1, s2, s3 } = encrypt2(encKey, s0, s1, s2, s3));
    t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;
    return tag5;
  }
  function processSiv(encKey, tag5, input) {
    let block = copyBytes(tag5);
    block[15] |= 128;
    const res = ctr32(encKey, true, block, input);
    clean2(block);
    return res;
  }
  return {
    encrypt(plaintext) {
      PLAIN_LIMIT(plaintext.length);
      const { encKey, authKey } = deriveKeys();
      const tag5 = _computeTag(encKey, authKey, plaintext);
      const toClean = [encKey, authKey, tag5];
      if (!isAligned32(plaintext))
        toClean.push(plaintext = copyBytes(plaintext));
      const out = new Uint8Array(plaintext.length + tagLength);
      out.set(tag5, plaintext.length);
      out.set(processSiv(encKey, tag5, plaintext));
      clean2(...toClean);
      return out;
    },
    decrypt(ciphertext) {
      CIPHER_LIMIT(ciphertext.length);
      const tag5 = ciphertext.subarray(-tagLength);
      const { encKey, authKey } = deriveKeys();
      const toClean = [encKey, authKey];
      if (!isAligned32(ciphertext))
        toClean.push(ciphertext = copyBytes(ciphertext));
      const plaintext = processSiv(encKey, tag5, ciphertext.subarray(0, -tagLength));
      const expectedTag = _computeTag(encKey, authKey, plaintext);
      toClean.push(expectedTag);
      if (!equalBytes(tag5, expectedTag)) {
        clean2(...toClean);
        throw new Error("invalid polyval tag");
      }
      clean2(...toClean);
      return plaintext;
    }
  };
});
function isBytes32(a) {
  return a instanceof Uint32Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint32Array";
}
function encryptBlock(xk, block) {
  abytes3(block, 16);
  if (!isBytes32(xk))
    throw new Error("_encryptBlock accepts result of expandKeyLE");
  const b32 = u324(block);
  let { s0, s1, s2, s3 } = encrypt2(xk, b32[0], b32[1], b32[2], b32[3]);
  b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;
  return block;
}
function decryptBlock(xk, block) {
  abytes3(block, 16);
  if (!isBytes32(xk))
    throw new Error("_decryptBlock accepts result of expandKeyLE");
  const b32 = u324(block);
  let { s0, s1, s2, s3 } = decrypt2(xk, b32[0], b32[1], b32[2], b32[3]);
  b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;
  return block;
}
var AESW = {
  /*
  High-level pseudocode:
  ```
  A: u64 = IV
  out = []
  for (let i=0, ctr = 0; i<6; i++) {
    for (const chunk of chunks(plaintext, 8)) {
      A ^= swapEndianess(ctr++)
      [A, res] = chunks(encrypt(A || chunk), 8);
      out ||= res
    }
  }
  out = A || out
  ```
  Decrypt is the same, but reversed.
  */
  encrypt(kek, out) {
    if (out.length >= 2 ** 32)
      throw new Error("plaintext should be less than 4gb");
    const xk = expandKeyLE(kek);
    if (out.length === 16)
      encryptBlock(xk, out);
    else {
      const o32 = u324(out);
      let a0 = o32[0], a1 = o32[1];
      for (let j = 0, ctr2 = 1; j < 6; j++) {
        for (let pos = 2; pos < o32.length; pos += 2, ctr2++) {
          const { s0, s1, s2, s3 } = encrypt2(xk, a0, a1, o32[pos], o32[pos + 1]);
          a0 = s0, a1 = s1 ^ byteSwap(ctr2), o32[pos] = s2, o32[pos + 1] = s3;
        }
      }
      o32[0] = a0, o32[1] = a1;
    }
    xk.fill(0);
  },
  decrypt(kek, out) {
    if (out.length - 8 >= 2 ** 32)
      throw new Error("ciphertext should be less than 4gb");
    const xk = expandKeyDecLE(kek);
    const chunks3 = out.length / 8 - 1;
    if (chunks3 === 1)
      decryptBlock(xk, out);
    else {
      const o32 = u324(out);
      let a0 = o32[0], a1 = o32[1];
      for (let j = 0, ctr2 = chunks3 * 6; j < 6; j++) {
        for (let pos = chunks3 * 2; pos >= 1; pos -= 2, ctr2--) {
          a1 ^= byteSwap(ctr2);
          const { s0, s1, s2, s3 } = decrypt2(xk, a0, a1, o32[pos], o32[pos + 1]);
          a0 = s0, a1 = s1, o32[pos] = s2, o32[pos + 1] = s3;
        }
      }
      o32[0] = a0, o32[1] = a1;
    }
    xk.fill(0);
  }
};
var AESKW_IV = new Uint8Array(8).fill(166);
var aeskw = wrapCipher({ blockSize: 8 }, (kek) => ({
  encrypt(plaintext) {
    if (!plaintext.length || plaintext.length % 8 !== 0)
      throw new Error("invalid plaintext length");
    if (plaintext.length === 8)
      throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
    const out = concatBytes3(AESKW_IV, plaintext);
    AESW.encrypt(kek, out);
    return out;
  },
  decrypt(ciphertext) {
    if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)
      throw new Error("invalid ciphertext length");
    const out = copyBytes(ciphertext);
    AESW.decrypt(kek, out);
    if (!equalBytes(out.subarray(0, 8), AESKW_IV))
      throw new Error("integrity check failed");
    out.subarray(0, 8).fill(0);
    return out.subarray(8);
  }
}));
var AESKWP_IV = 2790873510;
var aeskwp = wrapCipher({ blockSize: 8 }, (kek) => ({
  encrypt(plaintext) {
    if (!plaintext.length)
      throw new Error("invalid plaintext length");
    const padded = Math.ceil(plaintext.length / 8) * 8;
    const out = new Uint8Array(8 + padded);
    out.set(plaintext, 8);
    const out32 = u324(out);
    out32[0] = AESKWP_IV;
    out32[1] = byteSwap(plaintext.length);
    AESW.encrypt(kek, out);
    return out;
  },
  decrypt(ciphertext) {
    if (ciphertext.length < 16)
      throw new Error("invalid ciphertext length");
    const out = copyBytes(ciphertext);
    const o32 = u324(out);
    AESW.decrypt(kek, out);
    const len = byteSwap(o32[1]) >>> 0;
    const padded = Math.ceil(len / 8) * 8;
    if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)
      throw new Error("integrity check failed");
    for (let i = len; i < padded; i++)
      if (out[8 + i] !== 0)
        throw new Error("integrity check failed");
    out.subarray(0, 8).fill(0);
    return out.subarray(8, 8 + len);
  }
}));

// node_modules/@noble/hashes/esm/scrypt.js
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head13 = oi + 0;
  let tail5 = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail5 + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head13 += 16, ii += 16) {
    XorAndSalsa(out, tail5, input, ii, out, head13);
    if (i > 0)
      tail5 += 16;
    XorAndSalsa(out, head13, input, ii += 16, out, tail5);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  anumber(N);
  anumber(r);
  anumber(p);
  anumber(dkLen);
  anumber(asyncTick);
  anumber(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  const pow32 = Math.pow(2, 32);
  if (N <= 1 || (N & N - 1) !== 0 || N > pow32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, and less than 2^32");
  }
  if (p < 0 || p > (pow32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (pow32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error("Scrypt: memused is bigger than maxMem. Expected 128 * r * (N + p) > maxmem of " + maxmem);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  clean(B, V, tmp);
  return res;
}
function scrypt(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  swap32IfBE(B32);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi + i];
    for (let i = 0, pos = 0; i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    for (let i = 0; i < N; i++) {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    }
  }
  swap32IfBE(B32);
  return scryptOutput(password, dkLen, B, V, tmp);
}
async function scryptAsync(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
  swap32IfBE(B32);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi + i];
    let pos = 0;
    await asyncLoop(N - 1, asyncTick, () => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    await asyncLoop(N, asyncTick, () => {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    });
  }
  swap32IfBE(B32);
  return scryptOutput(password, dkLen, B, V, tmp);
}

// node_modules/ox/_esm/core/Keystore.js
function decrypt3(keystore, key, options = {}) {
  const { as: as18 = "Hex" } = options;
  const key_ = from(typeof key === "function" ? key() : key);
  const encKey = slice2(key_, 0, 16);
  const macKey = slice2(key_, 16, 32);
  const ciphertext = from(`0x${keystore.crypto.ciphertext}`);
  const mac = keccak2562(concat2(macKey, ciphertext));
  if (!isEqual(mac, from(`0x${keystore.crypto.mac}`)))
    throw new Error("corrupt keystore");
  const data = ctr(encKey, from(`0x${keystore.crypto.cipherparams.iv}`)).decrypt(ciphertext);
  if (as18 === "Hex")
    return toHex2(data);
  return data;
}
function encrypt3(privateKey, key, options) {
  const { id: id3 = crypto.randomUUID(), kdf, kdfparams, iv } = options;
  const key_ = from(typeof key === "function" ? key() : key);
  const value_ = from(privateKey);
  const encKey = slice2(key_, 0, 16);
  const macKey = slice2(key_, 16, 32);
  const ciphertext = ctr(encKey, iv).encrypt(value_);
  const mac = keccak2562(concat2(macKey, ciphertext));
  return {
    crypto: {
      cipher: "aes-128-ctr",
      ciphertext: toHex2(ciphertext).slice(2),
      cipherparams: { iv: toHex2(iv).slice(2) },
      kdf,
      kdfparams,
      mac: toHex2(mac).slice(2)
    },
    id: id3,
    version: 3
  };
}
function pbkdf22(options) {
  const { iv, iterations = 262144, password } = options;
  const salt = options.salt ? from(options.salt) : random(32);
  const key = toHex2(pbkdf2(sha256, password, salt, { c: iterations, dkLen: 32 }));
  return defineKey(() => key, {
    iv,
    kdfparams: {
      c: iterations,
      dklen: 32,
      prf: "hmac-sha256",
      salt: toHex2(salt).slice(2)
    },
    kdf: "pbkdf2"
  });
}
async function pbkdf2Async2(options) {
  const { iv, iterations = 262144, password } = options;
  const salt = options.salt ? from(options.salt) : random(32);
  const key = toHex2(await pbkdf2Async(sha256, password, salt, {
    c: iterations,
    dkLen: 32
  }));
  return defineKey(() => key, {
    iv,
    kdfparams: {
      c: iterations,
      dklen: 32,
      prf: "hmac-sha256",
      salt: toHex2(salt).slice(2)
    },
    kdf: "pbkdf2"
  });
}
function scrypt2(options) {
  const { iv, n = 262144, password, p = 8, r = 1 } = options;
  const salt = options.salt ? from(options.salt) : random(32);
  const key = toHex2(scrypt(password, salt, { N: n, dkLen: 32, r, p }));
  return defineKey(() => key, {
    iv,
    kdfparams: {
      dklen: 32,
      n,
      p,
      r,
      salt: toHex2(salt).slice(2)
    },
    kdf: "scrypt"
  });
}
async function scryptAsync2(options) {
  const { iv, n = 262144, password } = options;
  const p = 8;
  const r = 1;
  const salt = options.salt ? from(options.salt) : random(32);
  const key = toHex2(await scryptAsync(password, salt, { N: n, dkLen: 32, r, p }));
  return defineKey(() => key, {
    iv,
    kdfparams: {
      dklen: 32,
      n,
      p,
      r,
      salt: toHex2(salt).slice(2)
    },
    kdf: "scrypt"
  });
}
function toKey(keystore, options) {
  const { crypto: crypto2 } = keystore;
  const { password } = options;
  const { cipherparams, kdf, kdfparams } = crypto2;
  const { iv } = cipherparams;
  const { c, n, p, r, salt } = kdfparams;
  const [key] = (() => {
    switch (kdf) {
      case "scrypt":
        return scrypt2({
          iv: from(`0x${iv}`),
          n,
          p,
          r,
          salt: from(`0x${salt}`),
          password
        });
      case "pbkdf2":
        return pbkdf22({
          iv: from(`0x${iv}`),
          iterations: c,
          password,
          salt: from(`0x${salt}`)
        });
      default:
        throw new Error("unsupported kdf");
    }
  })();
  return key;
}
async function toKeyAsync(keystore, options) {
  const { crypto: crypto2 } = keystore;
  const { password } = options;
  const { cipherparams, kdf, kdfparams } = crypto2;
  const { iv } = cipherparams;
  const { c, n, p, r, salt } = kdfparams;
  const [key] = await (async () => {
    switch (kdf) {
      case "scrypt":
        return await scryptAsync2({
          iv: from(`0x${iv}`),
          n,
          p,
          r,
          salt: from(`0x${salt}`),
          password
        });
      case "pbkdf2":
        return await pbkdf22({
          iv: from(`0x${iv}`),
          iterations: c,
          password,
          salt: from(`0x${salt}`)
        });
      default:
        throw new Error("unsupported kdf");
    }
  })();
  return key;
}
function defineKey(key, options) {
  const iv = options.iv ? from(options.iv) : random(16);
  return [key, { ...options, iv }];
}

// node_modules/ox/_esm/core/Log.js
var Log_exports = {};
__export(Log_exports, {
  fromRpc: () => fromRpc7,
  toRpc: () => toRpc8
});
function fromRpc7(log5, _options = {}) {
  return {
    ...log5,
    blockNumber: log5.blockNumber ? BigInt(log5.blockNumber) : null,
    logIndex: log5.logIndex ? Number(log5.logIndex) : null,
    transactionIndex: log5.transactionIndex ? Number(log5.transactionIndex) : null
  };
}
function toRpc8(log5, _options = {}) {
  return {
    address: log5.address,
    blockHash: log5.blockHash,
    blockNumber: typeof log5.blockNumber === "bigint" ? fromNumber2(log5.blockNumber) : null,
    data: log5.data,
    logIndex: typeof log5.logIndex === "number" ? fromNumber2(log5.logIndex) : null,
    topics: log5.topics,
    transactionHash: log5.transactionHash,
    transactionIndex: typeof log5.transactionIndex === "number" ? fromNumber2(log5.transactionIndex) : null,
    removed: log5.removed
  };
}

// node_modules/ox/_esm/core/Mnemonic.js
var Mnemonic_exports = {};
__export(Mnemonic_exports, {
  czech: () => wordlist,
  english: () => wordlist2,
  french: () => wordlist3,
  italian: () => wordlist4,
  japanese: () => wordlist5,
  korean: () => wordlist6,
  path: () => path,
  portuguese: () => wordlist7,
  random: () => random5,
  simplifiedChinese: () => wordlist8,
  spanish: () => wordlist9,
  toHdKey: () => toHdKey,
  toPrivateKey: () => toPrivateKey,
  toSeed: () => toSeed,
  traditionalChinese: () => wordlist10,
  validate: () => validate15
});
function random5(wordlist11, options = {}) {
  const { strength = 128 } = options;
  return generateMnemonic(wordlist11, strength);
}
function toHdKey(mnemonic, options = {}) {
  const { passphrase } = options;
  const seed = toSeed(mnemonic, { passphrase });
  return fromSeed(seed);
}
function toPrivateKey(mnemonic, options = {}) {
  const { path: path2 = path(), passphrase } = options;
  const hdKey = toHdKey(mnemonic, { passphrase }).derive(path2);
  if (options.as === "Bytes")
    return from(hdKey.privateKey);
  return hdKey.privateKey;
}
function toSeed(mnemonic, options = {}) {
  const { passphrase } = options;
  const seed = mnemonicToSeedSync(mnemonic, passphrase);
  if (options.as === "Hex")
    return toHex2(seed);
  return seed;
}
function validate15(mnemonic, wordlist11) {
  return validateMnemonic(mnemonic, wordlist11);
}

// node_modules/ox/_esm/core/PersonalMessage.js
var PersonalMessage_exports = {};
__export(PersonalMessage_exports, {
  encode: () => encode13,
  getSignPayload: () => getSignPayload3
});
function encode13(data) {
  const message = from2(data);
  return concat3(
    // Personal Sign Format: `0x19  "Ethereum Signed Message:\n"  message.length  message`
    "0x19",
    fromString2("Ethereum Signed Message:\n" + size3(message)),
    message
  );
}
function getSignPayload3(data) {
  return keccak2562(encode13(data));
}

// node_modules/ox/_esm/core/Provider.js
var Provider_exports = {};
__export(Provider_exports, {
  AtomicReadyWalletRejectedUpgradeError: () => AtomicReadyWalletRejectedUpgradeError2,
  AtomicityNotSupportedError: () => AtomicityNotSupportedError2,
  BundleTooLargeError: () => BundleTooLargeError2,
  ChainDisconnectedError: () => ChainDisconnectedError2,
  DisconnectedError: () => DisconnectedError,
  DuplicateIdError: () => DuplicateIdError2,
  IsUndefinedError: () => IsUndefinedError,
  ProviderRpcError: () => ProviderRpcError3,
  SwitchChainError: () => SwitchChainError2,
  UnauthorizedError: () => UnauthorizedError,
  UnknownBundleIdError: () => UnknownBundleIdError2,
  UnsupportedChainIdError: () => UnsupportedChainIdError2,
  UnsupportedMethodError: () => UnsupportedMethodError,
  UnsupportedNonOptionalCapabilityError: () => UnsupportedNonOptionalCapabilityError2,
  UserRejectedRequestError: () => UserRejectedRequestError2,
  createEmitter: () => createEmitter,
  from: () => from20,
  parseError: () => parseError3
});

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/ox/_esm/core/RpcResponse.js
var RpcResponse_exports = {};
__export(RpcResponse_exports, {
  BaseError: () => BaseError3,
  InternalError: () => InternalError,
  InvalidInputError: () => InvalidInputError2,
  InvalidParamsError: () => InvalidParamsError,
  InvalidRequestError: () => InvalidRequestError,
  LimitExceededError: () => LimitExceededError,
  MethodNotFoundError: () => MethodNotFoundError,
  MethodNotSupportedError: () => MethodNotSupportedError,
  ParseError: () => ParseError3,
  ResourceNotFoundError: () => ResourceNotFoundError,
  ResourceUnavailableError: () => ResourceUnavailableError,
  TransactionRejectedError: () => TransactionRejectedError,
  VersionNotSupportedError: () => VersionNotSupportedError,
  from: () => from19,
  parse: () => parse4,
  parseError: () => parseError2
});
function from19(response, options = {}) {
  const { request: request2 } = options;
  return {
    ...response,
    id: response.id ?? (request2 == null ? void 0 : request2.id),
    jsonrpc: response.jsonrpc ?? request2.jsonrpc
  };
}
function parse4(response, options = {}) {
  const { raw = false } = options;
  const response_ = response;
  if (raw)
    return response;
  if (response_.error)
    throw parseError2(response_.error);
  return response_.result;
}
function parseError2(error4) {
  const error_ = error4;
  if (error_ instanceof Error && !("code" in error_))
    return new InternalError({
      cause: error_,
      data: error_,
      message: error_.message
    });
  const { code } = error_;
  if (code === InternalError.code)
    return new InternalError(error_);
  if (code === InvalidInputError2.code)
    return new InvalidInputError2(error_);
  if (code === InvalidParamsError.code)
    return new InvalidParamsError(error_);
  if (code === InvalidRequestError.code)
    return new InvalidRequestError(error_);
  if (code === LimitExceededError.code)
    return new LimitExceededError(error_);
  if (code === MethodNotFoundError.code)
    return new MethodNotFoundError(error_);
  if (code === MethodNotSupportedError.code)
    return new MethodNotSupportedError(error_);
  if (code === ParseError3.code)
    return new ParseError3(error_);
  if (code === ResourceNotFoundError.code)
    return new ResourceNotFoundError(error_);
  if (code === ResourceUnavailableError.code)
    return new ResourceUnavailableError(error_);
  if (code === TransactionRejectedError.code)
    return new TransactionRejectedError(error_);
  if (code === VersionNotSupportedError.code)
    return new VersionNotSupportedError(error_);
  return new InternalError({
    cause: error_ instanceof Error ? error_ : void 0,
    data: error_,
    message: error_.message
  });
}
var BaseError3 = class extends Error {
  constructor(errorObject) {
    const { cause: cause3, code, message, data } = errorObject;
    super(message, { cause: cause3 });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.BaseError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause3;
    this.code = code;
    this.data = data;
  }
};
var InvalidInputError2 = class _InvalidInputError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _InvalidInputError.code,
      data: parameters.data,
      message: parameters.message ?? "Missing or invalid parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidInputError"
    });
  }
};
Object.defineProperty(InvalidInputError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
var ResourceNotFoundError = class _ResourceNotFoundError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _ResourceNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not found."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceNotFoundError"
    });
  }
};
Object.defineProperty(ResourceNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
var ResourceUnavailableError = class _ResourceUnavailableError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _ResourceUnavailableError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not available."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceUnavailableError"
    });
  }
};
Object.defineProperty(ResourceUnavailableError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
var TransactionRejectedError = class _TransactionRejectedError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _TransactionRejectedError.code,
      data: parameters.data,
      message: parameters.message ?? "Transaction creation failed."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.TransactionRejectedError"
    });
  }
};
Object.defineProperty(TransactionRejectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
var MethodNotSupportedError = class _MethodNotSupportedError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "Method is not implemented."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotSupportedError"
    });
  }
};
Object.defineProperty(MethodNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
var LimitExceededError = class _LimitExceededError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _LimitExceededError.code,
      data: parameters.data,
      message: parameters.message ?? "Rate limit exceeded."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.LimitExceededError"
    });
  }
};
Object.defineProperty(LimitExceededError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
var VersionNotSupportedError = class _VersionNotSupportedError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _VersionNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "JSON-RPC version not supported."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.VersionNotSupportedError"
    });
  }
};
Object.defineProperty(VersionNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
var InvalidRequestError = class _InvalidRequestError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _InvalidRequestError.code,
      data: parameters.data,
      message: parameters.message ?? "Input is not a valid JSON-RPC request."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidRequestError"
    });
  }
};
Object.defineProperty(InvalidRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
var MethodNotFoundError = class _MethodNotFoundError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Method does not exist."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotFoundError"
    });
  }
};
Object.defineProperty(MethodNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
var InvalidParamsError = class _InvalidParamsError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _InvalidParamsError.code,
      data: parameters.data,
      message: parameters.message ?? "Invalid method parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidParamsError"
    });
  }
};
Object.defineProperty(InvalidParamsError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InternalError = class _InternalError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      cause: parameters.cause,
      code: _InternalError.code,
      data: parameters.data,
      message: parameters.message ?? "Internal JSON-RPC error."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InternalError"
    });
  }
};
Object.defineProperty(InternalError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
var ParseError3 = class _ParseError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _ParseError.code,
      data: parameters.data,
      message: parameters.message ?? "Failed to parse JSON-RPC response."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ParseError"
    });
  }
};
Object.defineProperty(ParseError3, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});

// node_modules/ox/_esm/core/Provider.js
var ProviderRpcError3 = class extends Error {
  constructor(code, message) {
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = code;
    this.details = message;
  }
};
var UserRejectedRequestError2 = class extends ProviderRpcError3 {
  constructor({ message = "The user rejected the request." } = {}) {
    super(4001, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UserRejectedRequestError"
    });
  }
};
Object.defineProperty(UserRejectedRequestError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
var UnauthorizedError = class extends ProviderRpcError3 {
  constructor({ message = "The requested method and/or account has not been authorized by the user." } = {}) {
    super(4100, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnauthorizedError"
    });
  }
};
Object.defineProperty(UnauthorizedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
var UnsupportedMethodError = class extends ProviderRpcError3 {
  constructor({ message = "The provider does not support the requested method." } = {}) {
    super(4200, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedMethodError"
    });
  }
};
Object.defineProperty(UnsupportedMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
var DisconnectedError = class extends ProviderRpcError3 {
  constructor({ message = "The provider is disconnected from all chains." } = {}) {
    super(4900, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DisconnectedError"
    });
  }
};
Object.defineProperty(DisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
var ChainDisconnectedError2 = class extends ProviderRpcError3 {
  constructor({ message = "The provider is not connected to the requested chain." } = {}) {
    super(4901, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.ChainDisconnectedError"
    });
  }
};
Object.defineProperty(ChainDisconnectedError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
var SwitchChainError2 = class extends ProviderRpcError3 {
  constructor({ message = "An error occurred when attempting to switch chain." } = {}) {
    super(4902, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.SwitchChainError"
    });
  }
};
Object.defineProperty(SwitchChainError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
var UnsupportedNonOptionalCapabilityError2 = class extends ProviderRpcError3 {
  constructor({ message = "This Wallet does not support a capability that was not marked as optional." } = {}) {
    super(5700, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedNonOptionalCapabilityError"
    });
  }
};
Object.defineProperty(UnsupportedNonOptionalCapabilityError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5700
});
var UnsupportedChainIdError2 = class extends ProviderRpcError3 {
  constructor({ message = "This Wallet does not support the requested chain ID." } = {}) {
    super(5710, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5710
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedChainIdError"
    });
  }
};
Object.defineProperty(UnsupportedChainIdError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5710
});
var DuplicateIdError2 = class extends ProviderRpcError3 {
  constructor({ message = "There is already a bundle submitted with this ID." } = {}) {
    super(5720, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5720
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DuplicateIdError"
    });
  }
};
Object.defineProperty(DuplicateIdError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5720
});
var UnknownBundleIdError2 = class extends ProviderRpcError3 {
  constructor({ message = "This bundle id is unknown / has not been submitted." } = {}) {
    super(5730, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5730
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnknownBundleIdError"
    });
  }
};
Object.defineProperty(UnknownBundleIdError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5730
});
var BundleTooLargeError2 = class extends ProviderRpcError3 {
  constructor({ message = "The call bundle is too large for the Wallet to process." } = {}) {
    super(5740, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5740
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.BundleTooLargeError"
    });
  }
};
Object.defineProperty(BundleTooLargeError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5740
});
var AtomicReadyWalletRejectedUpgradeError2 = class extends ProviderRpcError3 {
  constructor({ message = "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade." } = {}) {
    super(5750, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5750
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.AtomicReadyWalletRejectedUpgradeError"
    });
  }
};
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5750
});
var AtomicityNotSupportedError2 = class extends ProviderRpcError3 {
  constructor({ message = "The wallet does not support atomic execution but the request requires it." } = {}) {
    super(5760, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5760
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.AtomicityNotSupportedError"
    });
  }
};
Object.defineProperty(AtomicityNotSupportedError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5760
});
function createEmitter() {
  const emitter = new import_index.default();
  return {
    get eventNames() {
      return emitter.eventNames.bind(emitter);
    },
    get listenerCount() {
      return emitter.listenerCount.bind(emitter);
    },
    get listeners() {
      return emitter.listeners.bind(emitter);
    },
    addListener: emitter.addListener.bind(emitter),
    emit: emitter.emit.bind(emitter),
    off: emitter.off.bind(emitter),
    on: emitter.on.bind(emitter),
    once: emitter.once.bind(emitter),
    removeAllListeners: emitter.removeAllListeners.bind(emitter),
    removeListener: emitter.removeListener.bind(emitter)
  };
}
function from20(provider, options = {}) {
  var _a106, _b32;
  const { includeEvents = true } = options;
  if (!provider)
    throw new IsUndefinedError();
  return {
    ...includeEvents ? {
      on: (_a106 = provider.on) == null ? void 0 : _a106.bind(provider),
      removeListener: (_b32 = provider.removeListener) == null ? void 0 : _b32.bind(provider)
    } : {},
    async request(args2) {
      try {
        const result = await provider.request(args2);
        if (result && typeof result === "object" && "jsonrpc" in result)
          return parse4(result);
        return result;
      } catch (error4) {
        throw parseError3(error4);
      }
    }
  };
}
function parseError3(error4) {
  const error_ = parseError2(error4);
  if (error_ instanceof InternalError) {
    if (!error_.data)
      return error_;
    const { code } = error_.data;
    if (code === DisconnectedError.code)
      return new DisconnectedError(error_);
    if (code === ChainDisconnectedError2.code)
      return new ChainDisconnectedError2(error_);
    if (code === UserRejectedRequestError2.code)
      return new UserRejectedRequestError2(error_);
    if (code === UnauthorizedError.code)
      return new UnauthorizedError(error_);
    if (code === UnsupportedMethodError.code)
      return new UnsupportedMethodError(error_);
    if (code === SwitchChainError2.code)
      return new SwitchChainError2(error_);
    if (code === AtomicReadyWalletRejectedUpgradeError2.code)
      return new AtomicReadyWalletRejectedUpgradeError2(error_);
    if (code === AtomicityNotSupportedError2.code)
      return new AtomicityNotSupportedError2(error_);
    if (code === BundleTooLargeError2.code)
      return new BundleTooLargeError2(error_);
    if (code === UnknownBundleIdError2.code)
      return new UnknownBundleIdError2(error_);
    if (code === DuplicateIdError2.code)
      return new DuplicateIdError2(error_);
    if (code === UnsupportedChainIdError2.code)
      return new UnsupportedChainIdError2(error_);
    if (code === UnsupportedNonOptionalCapabilityError2.code)
      return new UnsupportedNonOptionalCapabilityError2(error_);
  }
  return error_;
}
var IsUndefinedError = class extends BaseError2 {
  constructor() {
    super("`provider` is undefined.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.IsUndefinedError"
    });
  }
};

// node_modules/ox/_esm/core/RpcSchema.js
var RpcSchema_exports = {};
__export(RpcSchema_exports, {
  from: () => from21
});
function from21() {
  return null;
}

// node_modules/ox/_esm/core/RpcRequest.js
var RpcRequest_exports = {};
__export(RpcRequest_exports, {
  createStore: () => createStore,
  from: () => from22
});
function createStore(options = {}) {
  let id3 = options.id ?? 0;
  return {
    prepare(options2) {
      return from22({
        id: id3++,
        ...options2
      });
    },
    get id() {
      return id3;
    }
  };
}
function from22(options) {
  return {
    ...options,
    jsonrpc: "2.0"
  };
}

// node_modules/ox/_esm/core/RpcTransport.js
var RpcTransport_exports = {};
__export(RpcTransport_exports, {
  HttpError: () => HttpError,
  MalformedResponseError: () => MalformedResponseError,
  fromHttp: () => fromHttp
});

// node_modules/ox/_esm/core/internal/promise.js
function withTimeout2(fn2, options) {
  const { errorInstance = new TimeoutError2(), timeout: timeout6, signal } = options;
  return new Promise((resolve, reject3) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout6 > 0)
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject3(errorInstance);
            }
          }, timeout6);
        resolve(await fn2({ signal: controller.signal }));
      } catch (err2) {
        if ((err2 == null ? void 0 : err2.name) === "AbortError")
          reject3(errorInstance);
        reject3(err2);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
var TimeoutError2 = class extends BaseError2 {
  constructor() {
    super("Operation timed out.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Promise.TimeoutError"
    });
  }
};

// node_modules/ox/_esm/core/internal/rpcTransport.js
function create3(transport, options_root) {
  const requestStore = createStore();
  return {
    request: async ({ method, params }, options = {}) => {
      const body = requestStore.prepare({ method, params });
      const data = await transport.request(body, options);
      return parse4(data, {
        raw: options.raw ?? (options_root == null ? void 0 : options_root.raw)
      });
    }
  };
}

// node_modules/ox/_esm/core/RpcTransport.js
function fromHttp(url3, options = {}) {
  return create3({
    async request(body_, options_) {
      const { fetchFn = options.fetchFn ?? fetch, fetchOptions: fetchOptions_ = options.fetchOptions, timeout: timeout6 = options.timeout ?? 1e4 } = options_;
      const body = JSON.stringify(body_);
      const fetchOptions = typeof fetchOptions_ === "function" ? await fetchOptions_(body_) : fetchOptions_;
      const response = await withTimeout2(({ signal }) => {
        const init3 = {
          ...fetchOptions,
          body,
          headers: {
            "Content-Type": "application/json",
            ...fetchOptions == null ? void 0 : fetchOptions.headers
          },
          method: (fetchOptions == null ? void 0 : fetchOptions.method) ?? "POST",
          signal: (fetchOptions == null ? void 0 : fetchOptions.signal) ?? (timeout6 > 0 ? signal : null)
        };
        const request2 = new Request(url3, init3);
        return fetchFn(request2);
      }, {
        timeout: timeout6,
        signal: true
      });
      const data = await (async () => {
        var _a106;
        if ((_a106 = response.headers.get("Content-Type")) == null ? void 0 : _a106.startsWith("application/json"))
          return response.json();
        return response.text().then((data2) => {
          try {
            return JSON.parse(data2 || "{}");
          } catch (err2) {
            if (response.ok)
              throw new MalformedResponseError({
                response: data2
              });
            return { error: data2 };
          }
        });
      })();
      if (!response.ok)
        throw new HttpError({
          body,
          details: JSON.stringify(data.error) ?? response.statusText,
          response,
          url: url3
        });
      return data;
    }
  }, { raw: options.raw });
}
var HttpError = class extends BaseError2 {
  constructor({ body, details, response, url: url3 }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        `Status: ${response.status}`,
        `URL: ${getUrl(url3)}`,
        body ? `Body: ${JSON.stringify(body)}` : void 0
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcTransport.HttpError"
    });
  }
};
var MalformedResponseError = class extends BaseError2 {
  constructor({ response }) {
    super("HTTP Response could not be parsed as JSON.", {
      metaMessages: [`Response: ${response}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcTransport.MalformedResponseError"
    });
  }
};

// node_modules/ox/_esm/core/Siwe.js
var Siwe_exports = {};
__export(Siwe_exports, {
  InvalidMessageFieldError: () => InvalidMessageFieldError,
  createMessage: () => createMessage,
  domainRegex: () => domainRegex,
  generateNonce: () => generateNonce,
  ipRegex: () => ipRegex,
  isUri: () => isUri,
  localhostRegex: () => localhostRegex,
  nonceRegex: () => nonceRegex,
  parseMessage: () => parseMessage,
  prefixRegex: () => prefixRegex2,
  schemeRegex: () => schemeRegex,
  suffixRegex: () => suffixRegex2,
  validateMessage: () => validateMessage
});

// node_modules/ox/_esm/core/internal/uid.js
var size44 = 256;
var index2 = size44;
var buffer6;
function uid2(length6 = 11) {
  if (!buffer6 || index2 + length6 > size44 * 2) {
    buffer6 = "";
    index2 = 0;
    for (let i = 0; i < size44; i++) {
      buffer6 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer6.substring(index2, index2++ + length6);
}

// node_modules/ox/_esm/core/Siwe.js
var domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;
var ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;
var localhostRegex = /^localhost(:[0-9]{1,5})?$/;
var nonceRegex = /^[a-zA-Z0-9]{8,}$/;
var schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;
var prefixRegex2 = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex2 = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function createMessage(value10) {
  const { chainId, domain: domain2, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version } = value10;
  {
    if (chainId !== Math.floor(chainId))
      throw new InvalidMessageFieldError({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${chainId}`
        ]
      });
    if (!(domainRegex.test(domain2) || ipRegex.test(domain2) || localhostRegex.test(domain2)))
      throw new InvalidMessageFieldError({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${domain2}`
        ]
      });
    if (!nonceRegex.test(nonce))
      throw new InvalidMessageFieldError({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${nonce}`
        ]
      });
    if (!isUri(uri))
      throw new InvalidMessageFieldError({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${uri}`
        ]
      });
    if (version !== "1")
      throw new InvalidMessageFieldError({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${version}`
        ]
      });
    if (scheme && !schemeRegex.test(scheme))
      throw new InvalidMessageFieldError({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${scheme}`
        ]
      });
    const statement2 = value10.statement;
    if (statement2 == null ? void 0 : statement2.includes("\n"))
      throw new InvalidMessageFieldError({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${statement2}`
        ]
      });
  }
  const address = from4(value10.address, { checksum: true });
  const origin = (() => {
    if (scheme)
      return `${scheme}://${domain2}`;
    return domain2;
  })();
  const statement = (() => {
    if (!value10.statement)
      return "";
    return `${value10.statement}
`;
  })();
  const prefix = `${origin} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version}
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!isUri(resource))
        throw new InvalidMessageFieldError({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${resource}`
          ]
        });
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix}
${suffix}`;
}
function generateNonce() {
  return uid2(96);
}
function isUri(value10) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value10))
    return false;
  if (/%[^0-9a-f]/i.test(value10))
    return false;
  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value10))
    return false;
  const splitted = splitUri(value10);
  const scheme = splitted[1];
  const authority = splitted[2];
  const path2 = splitted[3];
  const query = splitted[4];
  const fragment = splitted[5];
  if (!((scheme == null ? void 0 : scheme.length) && path2 && path2.length >= 0))
    return false;
  if (authority == null ? void 0 : authority.length) {
    if (!(path2.length === 0 || /^\//.test(path2)))
      return false;
  } else {
    if (/^\/\//.test(path2))
      return false;
  }
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))
    return false;
  let out = "";
  out += `${scheme}:`;
  if (authority == null ? void 0 : authority.length)
    out += `//${authority}`;
  out += path2;
  if (query == null ? void 0 : query.length)
    out += `?${query}`;
  if (fragment == null ? void 0 : fragment.length)
    out += `#${fragment}`;
  return out;
}
function splitUri(value10) {
  return value10.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function parseMessage(message) {
  var _a106, _b32, _c7;
  const { scheme, statement, ...prefix } = ((_a106 = message.match(prefixRegex2)) == null ? void 0 : _a106.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b32 = message.match(suffixRegex2)) == null ? void 0 : _b32.groups) ?? {};
  const resources = (_c7 = message.split("Resources:")[1]) == null ? void 0 : _c7.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
function validateMessage(value10) {
  const { address, domain: domain2, message, nonce, scheme, time: time3 = /* @__PURE__ */ new Date() } = value10;
  if (domain2 && message.domain !== domain2)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time3 >= message.expirationTime)
    return false;
  if (message.notBefore && time3 < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isEqual3(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}
var InvalidMessageFieldError = class extends BaseError2 {
  constructor(parameters) {
    const { field, metaMessages } = parameters;
    super(`Invalid Sign-In with Ethereum message field "${field}".`, {
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Siwe.InvalidMessageFieldError"
    });
  }
};

// node_modules/ox/_esm/core/StateOverrides.js
var StateOverrides_exports = {};
__export(StateOverrides_exports, {
  fromRpc: () => fromRpc8,
  toRpc: () => toRpc9
});
function fromRpc8(rpcStateOverrides) {
  const stateOverrides = {};
  for (const [address, accountOverridesRpc] of Object.entries(rpcStateOverrides)) {
    const accountOverrides = {};
    if (accountOverridesRpc.balance)
      accountOverrides.balance = BigInt(accountOverridesRpc.balance);
    if (accountOverridesRpc.code)
      accountOverrides.code = accountOverridesRpc.code;
    if (accountOverridesRpc.movePrecompileToAddress)
      accountOverrides.movePrecompileToAddress = accountOverridesRpc.movePrecompileToAddress;
    if (accountOverridesRpc.nonce)
      accountOverrides.nonce = BigInt(accountOverridesRpc.nonce);
    if (accountOverridesRpc.state)
      accountOverrides.state = accountOverridesRpc.state;
    if (accountOverridesRpc.stateDiff)
      accountOverrides.stateDiff = accountOverridesRpc.stateDiff;
    stateOverrides[address] = accountOverrides;
  }
  return stateOverrides;
}
function toRpc9(stateOverrides) {
  const rpcStateOverrides = {};
  for (const [address, accountOverrides] of Object.entries(stateOverrides)) {
    const accountOverridesRpc = {};
    if (typeof accountOverrides.balance === "bigint")
      accountOverridesRpc.balance = fromNumber2(accountOverrides.balance);
    if (accountOverrides.code)
      accountOverridesRpc.code = accountOverrides.code;
    if (accountOverrides.movePrecompileToAddress)
      accountOverridesRpc.movePrecompileToAddress = accountOverrides.movePrecompileToAddress;
    if (typeof accountOverrides.nonce === "bigint")
      accountOverridesRpc.nonce = fromNumber2(accountOverrides.nonce);
    if (accountOverrides.state)
      accountOverridesRpc.state = accountOverrides.state;
    if (accountOverrides.stateDiff)
      accountOverridesRpc.stateDiff = accountOverrides.stateDiff;
    rpcStateOverrides[address] = accountOverridesRpc;
  }
  return rpcStateOverrides;
}

// node_modules/ox/_esm/core/TransactionEnvelope.js
var TransactionEnvelope_exports = {};
__export(TransactionEnvelope_exports, {
  FeeCapTooHighError: () => FeeCapTooHighError2,
  GasPriceTooHighError: () => GasPriceTooHighError,
  InvalidChainIdError: () => InvalidChainIdError2,
  InvalidSerializedError: () => InvalidSerializedError,
  TipAboveFeeCapError: () => TipAboveFeeCapError2
});

// node_modules/ox/_esm/core/Value.js
var Value_exports = {};
__export(Value_exports, {
  InvalidDecimalNumberError: () => InvalidDecimalNumberError2,
  exponents: () => exponents,
  format: () => format15,
  formatEther: () => formatEther2,
  formatGwei: () => formatGwei2,
  from: () => from23,
  fromEther: () => fromEther,
  fromGwei: () => fromGwei
});
var exponents = {
  wei: 0,
  gwei: 9,
  szabo: 12,
  finney: 15,
  ether: 18
};
function format15(value10, decimals = 0) {
  let display = value10.toString();
  const negative2 = display.startsWith("-");
  if (negative2)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer4, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative2 ? "-" : ""}${integer4 || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatEther2(wei, unit = "wei") {
  return format15(wei, exponents.ether - exponents[unit]);
}
function formatGwei2(wei, unit = "wei") {
  return format15(wei, exponents.gwei - exponents[unit]);
}
function from23(value10, decimals = 0) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value10))
    throw new InvalidDecimalNumberError2({ value: value10 });
  let [integer4 = "", fraction = "0"] = value10.split(".");
  const negative2 = integer4.startsWith("-");
  if (negative2)
    integer4 = integer4.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer4 = `${BigInt(integer4) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left3, unit, right3] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right3}`));
    if (rounded > 9)
      fraction = `${BigInt(left3) + BigInt(1)}0`.padStart(left3.length + 1, "0");
    else
      fraction = `${left3}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer4 = `${BigInt(integer4) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative2 ? "-" : ""}${integer4}${fraction}`);
}
function fromEther(ether, unit = "wei") {
  return from23(ether, exponents.ether - exponents[unit]);
}
function fromGwei(gwei, unit = "wei") {
  return from23(gwei, exponents.gwei - exponents[unit]);
}
var InvalidDecimalNumberError2 = class extends BaseError2 {
  constructor({ value: value10 }) {
    super(`Value \`${value10}\` is not a valid decimal number.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Value.InvalidDecimalNumberError"
    });
  }
};

// node_modules/ox/_esm/core/TransactionEnvelope.js
var FeeCapTooHighError2 = class extends BaseError2 {
  constructor({ feeCap } = {}) {
    super(`The fee cap (\`maxFeePerGas\`/\`maxPriorityFeePerGas\`${feeCap ? ` = ${formatGwei2(feeCap)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.FeeCapTooHighError"
    });
  }
};
var GasPriceTooHighError = class extends BaseError2 {
  constructor({ gasPrice } = {}) {
    super(`The gas price (\`gasPrice\`${gasPrice ? ` = ${formatGwei2(gasPrice)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.GasPriceTooHighError"
    });
  }
};
var InvalidChainIdError2 = class extends BaseError2 {
  constructor({ chainId }) {
    super(typeof chainId !== "undefined" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidChainIdError"
    });
  }
};
var InvalidSerializedError = class extends BaseError2 {
  constructor({ attributes, serialized, type: type8 }) {
    const missing = Object.entries(attributes).map(([key, value10]) => typeof value10 === "undefined" ? key : void 0).filter(Boolean);
    super(`Invalid serialized transaction of type "${type8}" was provided.`, {
      metaMessages: [
        `Serialized Transaction: "${serialized}"`,
        missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidSerializedError"
    });
  }
};
var TipAboveFeeCapError2 = class extends BaseError2 {
  constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei2(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei2(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.TipAboveFeeCapError"
    });
  }
};

// node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js
var TransactionEnvelopeLegacy_exports = {};
__export(TransactionEnvelopeLegacy_exports, {
  assert: () => assert8,
  deserialize: () => deserialize2,
  from: () => from24,
  getSignPayload: () => getSignPayload4,
  hash: () => hash6,
  serialize: () => serialize2,
  toRpc: () => toRpc10,
  type: () => type3,
  validate: () => validate16
});
var type3 = "legacy";
function assert8(envelope) {
  const { chainId, gasPrice, to: to3 } = envelope;
  if (to3)
    assert5(to3, { strict: false });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
function deserialize2(serialized) {
  const tuple7 = toHex6(serialized);
  const [nonce, gasPrice, gas, to3, value10, data, chainIdOrV_, r, s] = tuple7;
  if (!(tuple7.length === 6 || tuple7.length === 9))
    throw new InvalidSerializedError({
      attributes: {
        nonce,
        gasPrice,
        gas,
        to: to3,
        value: value10,
        data,
        ...tuple7.length > 6 ? {
          v: chainIdOrV_,
          r,
          s
        } : {}
      },
      serialized,
      type: type3
    });
  const transaction = {
    type: type3
  };
  if (validate2(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value10) && value10 !== "0x")
    transaction.value = BigInt(value10);
  if (validate2(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (tuple7.length === 6)
    return transaction;
  const chainIdOrV = validate2(chainIdOrV_) && chainIdOrV_ !== "0x" ? Number(chainIdOrV_) : 0;
  if (s === "0x" && r === "0x") {
    if (chainIdOrV > 0)
      transaction.chainId = Number(chainIdOrV);
    return transaction;
  }
  const v = chainIdOrV;
  const chainId = Math.floor((v - 35) / 2);
  if (chainId > 0)
    transaction.chainId = chainId;
  else if (v !== 27 && v !== 28)
    throw new InvalidVError({ value: v });
  transaction.yParity = vToYParity(v);
  transaction.v = v;
  transaction.s = s === "0x" ? 0n : BigInt(s);
  transaction.r = r === "0x" ? 0n : BigInt(r);
  assert8(transaction);
  return transaction;
}
function from24(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize2(envelope) : envelope;
  assert8(envelope_);
  const signature_ = (() => {
    if (!signature)
      return {};
    const s = from9(signature);
    s.v = yParityToV(s.yParity);
    return s;
  })();
  return {
    ...envelope_,
    ...signature_,
    type: "legacy"
  };
}
function getSignPayload4(envelope) {
  return hash6(envelope, { presign: true });
}
function hash6(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize2({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize2(envelope, options = {}) {
  const { chainId = 0, gas, data, input, nonce, to: to3, value: value10, gasPrice } = envelope;
  assert8(envelope);
  let serialized = [
    nonce ? fromNumber2(nonce) : "0x",
    gasPrice ? fromNumber2(gasPrice) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to3 ?? "0x",
    value10 ? fromNumber2(value10) : "0x",
    data ?? input ?? "0x"
  ];
  const signature = (() => {
    if (options.signature)
      return {
        r: options.signature.r,
        s: options.signature.s,
        v: yParityToV(options.signature.yParity)
      };
    if (typeof envelope.r === "undefined" || typeof envelope.s === "undefined")
      return void 0;
    return {
      r: envelope.r,
      s: envelope.s,
      v: envelope.v
    };
  })();
  if (signature) {
    const v = (() => {
      if (signature.v >= 35) {
        const inferredChainId = Math.floor((signature.v - 35) / 2);
        if (inferredChainId > 0)
          return signature.v;
        return 27 + (signature.v === 35 ? 0 : 1);
      }
      if (chainId > 0)
        return chainId * 2 + 35 + signature.v - 27;
      const v2 = 27 + (signature.v === 27 ? 0 : 1);
      if (signature.v !== v2)
        throw new InvalidVError({ value: signature.v });
      return v2;
    })();
    serialized = [
      ...serialized,
      fromNumber2(v),
      signature.r === 0n ? "0x" : trimLeft2(fromNumber2(signature.r)),
      signature.s === 0n ? "0x" : trimLeft2(fromNumber2(signature.s))
    ];
  } else if (chainId > 0)
    serialized = [...serialized, fromNumber2(chainId), "0x", "0x"];
  return fromHex6(serialized);
}
function toRpc10(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: typeof envelope.chainId === "number" ? fromNumber2(envelope.chainId) : void 0,
    data: envelope.data ?? envelope.input,
    type: "0x0",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber2(envelope.gasPrice) } : {},
    ...signature ? {
      ...toRpc3(signature),
      v: signature.yParity === 0 ? "0x1b" : "0x1c"
    } : {}
  };
}
function validate16(envelope) {
  try {
    assert8(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js
var TransactionEnvelopeEip1559_exports = {};
__export(TransactionEnvelopeEip1559_exports, {
  assert: () => assert9,
  deserialize: () => deserialize3,
  from: () => from25,
  getSignPayload: () => getSignPayload5,
  hash: () => hash7,
  serialize: () => serialize3,
  serializedType: () => serializedType,
  toRpc: () => toRpc11,
  type: () => type4,
  validate: () => validate17
});
var serializedType = "0x02";
var type4 = "eip1559";
function assert9(envelope) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to: to3 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (to3)
    assert5(to3, { strict: false });
  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)
    throw new FeeCapTooHighError2({ feeCap: maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError2({
      maxFeePerGas,
      maxPriorityFeePerGas
    });
}
function deserialize3(serialized) {
  const transactionArray = toHex6(slice3(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to3, value10, data, accessList, yParity, r, s] = transactionArray;
  if (!(transactionArray.length === 9 || transactionArray.length === 12))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to3,
        value: value10,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r,
          s
        } : {}
      },
      serialized,
      type: type4
    });
  let transaction = {
    chainId: Number(chainId),
    type: type4
  };
  if (validate2(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value10) && value10 !== "0x")
    transaction.value = BigInt(value10);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  const signature = r && s && yParity ? fromTuple([yParity, r, s]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert9(transaction);
  return transaction;
}
function from25(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize3(envelope) : envelope;
  assert9(envelope_);
  return {
    ...envelope_,
    ...signature ? from9(signature) : {},
    type: "eip1559"
  };
}
function getSignPayload5(envelope) {
  return hash7(envelope, { presign: true });
}
function hash7(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize3({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize3(envelope, options = {}) {
  const { chainId, gas, nonce, to: to3, value: value10, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert9(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to3 ?? "0x",
    value10 ? fromNumber2(value10) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat3(serializedType, fromHex6(serialized));
}
function toRpc11(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    type: "0x2",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber2(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? {
      maxPriorityFeePerGas: fromNumber2(envelope.maxPriorityFeePerGas)
    } : {},
    ...signature ? toRpc3(signature) : {}
  };
}
function validate17(envelope) {
  try {
    assert9(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js
var TransactionEnvelopeEip2930_exports = {};
__export(TransactionEnvelopeEip2930_exports, {
  assert: () => assert10,
  deserialize: () => deserialize4,
  from: () => from26,
  getSignPayload: () => getSignPayload6,
  hash: () => hash8,
  serialize: () => serialize4,
  serializedType: () => serializedType2,
  toRpc: () => toRpc12,
  type: () => type5,
  validate: () => validate18
});
var serializedType2 = "0x01";
var type5 = "eip2930";
function assert10(envelope) {
  const { chainId, gasPrice, to: to3 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (to3)
    assert5(to3, { strict: false });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
function deserialize4(serialized) {
  const transactionArray = toHex6(slice3(serialized, 1));
  const [chainId, nonce, gasPrice, gas, to3, value10, data, accessList, yParity, r, s] = transactionArray;
  if (!(transactionArray.length === 8 || transactionArray.length === 11))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        gasPrice,
        gas,
        to: to3,
        value: value10,
        data,
        accessList,
        ...transactionArray.length > 8 ? {
          yParity,
          r,
          s
        } : {}
      },
      serialized,
      type: type5
    });
  let transaction = {
    chainId: Number(chainId),
    type: type5
  };
  if (validate2(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value10) && value10 !== "0x")
    transaction.value = BigInt(value10);
  if (validate2(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  const signature = r && s && yParity ? fromTuple([yParity, r, s]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert10(transaction);
  return transaction;
}
function from26(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize4(envelope) : envelope;
  assert10(envelope_);
  return {
    ...envelope_,
    ...signature ? from9(signature) : {},
    type: "eip2930"
  };
}
function getSignPayload6(envelope) {
  return hash8(envelope, { presign: true });
}
function hash8(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize4({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize4(envelope, options = {}) {
  const { chainId, gas, data, input, nonce, to: to3, value: value10, accessList, gasPrice } = envelope;
  assert10(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    gasPrice ? fromNumber2(gasPrice) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to3 ?? "0x",
    value10 ? fromNumber2(value10) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat3("0x01", fromHex6(serialized));
}
function toRpc12(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber2(envelope.gasPrice) } : {},
    type: "0x1",
    ...signature ? toRpc3(signature) : {}
  };
}
function validate18(envelope) {
  try {
    assert10(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js
var TransactionEnvelopeEip4844_exports = {};
__export(TransactionEnvelopeEip4844_exports, {
  assert: () => assert11,
  deserialize: () => deserialize5,
  from: () => from27,
  getSignPayload: () => getSignPayload7,
  hash: () => hash9,
  serialize: () => serialize5,
  serializedType: () => serializedType3,
  toRpc: () => toRpc13,
  type: () => type6,
  validate: () => validate19
});
var serializedType3 = "0x03";
var type6 = "eip4844";
function assert11(envelope) {
  const { blobVersionedHashes } = envelope;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobVersionedHashesError();
    for (const hash11 of blobVersionedHashes) {
      const size45 = size3(hash11);
      const version = toNumber2(slice3(hash11, 0, 1));
      if (size45 !== 32)
        throw new InvalidVersionedHashSizeError2({ hash: hash11, size: size45 });
      if (version !== versionedHashVersion)
        throw new InvalidVersionedHashVersionError2({
          hash: hash11,
          version
        });
    }
  }
  assert9(envelope);
}
function deserialize5(serialized) {
  const transactionOrWrapperArray = toHex6(slice3(serialized, 1));
  const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
  const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;
  const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to3, value10, data, accessList, maxFeePerBlobGas, blobVersionedHashes, yParity, r, s] = transactionArray;
  const [blobs, commitments, proofs] = wrapperArray;
  if (!(transactionArray.length === 11 || transactionArray.length === 14))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to3,
        value: value10,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r,
          s
        } : {}
      },
      serialized,
      type: type6
    });
  let transaction = {
    blobVersionedHashes,
    chainId: Number(chainId),
    type: type6
  };
  if (validate2(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value10) && value10 !== "0x")
    transaction.value = BigInt(value10);
  if (validate2(maxFeePerBlobGas) && maxFeePerBlobGas !== "0x")
    transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if ((accessList == null ? void 0 : accessList.length) !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  if (blobs && commitments && proofs)
    transaction.sidecars = toSidecars(blobs, {
      commitments,
      proofs
    });
  const signature = r && s && yParity ? fromTuple([yParity, r, s]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert11(transaction);
  return transaction;
}
function from27(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize5(envelope) : envelope;
  assert11(envelope_);
  return {
    ...envelope_,
    ...signature ? from9(signature) : {},
    type: "eip4844"
  };
}
function getSignPayload7(envelope) {
  return hash9(envelope, { presign: true });
}
function hash9(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize5({
    ...envelope,
    ...presign ? {
      sidecars: void 0,
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize5(envelope, options = {}) {
  const { blobVersionedHashes, chainId, gas, nonce, to: to3, value: value10, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = envelope;
  assert11(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to3 ?? "0x",
    value10 ? fromNumber2(value10) : "0x",
    data ?? "0x",
    accessTupleList,
    maxFeePerBlobGas ? fromNumber2(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...signature ? toTuple(signature) : []
  ];
  const sidecars = options.sidecars || envelope.sidecars;
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i = 0; i < sidecars.length; i++) {
      const { blob, commitment, proof } = sidecars[i];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concat3("0x03", sidecars ? (
    // If sidecars are provided, envelope turns into a "network wrapper":
    fromHex6([serialized, blobs, commitments, proofs])
  ) : (
    // Otherwise, standard envelope is used:
    fromHex6(serialized)
  ));
}
function toRpc13(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.maxFeePerBlobGas === "bigint" ? { maxFeePerBlobGas: fromNumber2(envelope.maxFeePerBlobGas) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber2(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? { maxPriorityFeePerGas: fromNumber2(envelope.maxPriorityFeePerGas) } : {},
    type: "0x3",
    ...signature ? toRpc3(signature) : {}
  };
}
function validate19(envelope) {
  try {
    assert11(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js
var TransactionEnvelopeEip7702_exports = {};
__export(TransactionEnvelopeEip7702_exports, {
  assert: () => assert12,
  deserialize: () => deserialize6,
  from: () => from28,
  getSignPayload: () => getSignPayload8,
  hash: () => hash10,
  serialize: () => serialize6,
  serializedType: () => serializedType4,
  type: () => type7,
  validate: () => validate20
});
var serializedType4 = "0x04";
var type7 = "eip7702";
function assert12(envelope) {
  const { authorizationList } = envelope;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { address, chainId } = authorization;
      if (address)
        assert5(address, { strict: false });
      if (Number(chainId) < 0)
        throw new InvalidChainIdError2({ chainId });
    }
  }
  assert9(envelope);
}
function deserialize6(serialized) {
  const transactionArray = toHex6(slice3(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to3, value10, data, accessList, authorizationList, yParity, r, s] = transactionArray;
  if (!(transactionArray.length === 10 || transactionArray.length === 13))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to3,
        value: value10,
        data,
        accessList,
        authorizationList,
        ...transactionArray.length > 9 ? {
          yParity,
          r,
          s
        } : {}
      },
      serialized,
      type: type7
    });
  let transaction = {
    chainId: Number(chainId),
    type: type7
  };
  if (validate2(to3) && to3 !== "0x")
    transaction.to = to3;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce))
    transaction.nonce = nonce === "0x" ? 0n : BigInt(nonce);
  if (validate2(value10) && value10 !== "0x")
    transaction.value = BigInt(value10);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  if (authorizationList !== "0x")
    transaction.authorizationList = fromTupleList2(authorizationList);
  const signature = r && s && yParity ? fromTuple([yParity, r, s]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert12(transaction);
  return transaction;
}
function from28(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize6(envelope) : envelope;
  assert12(envelope_);
  return {
    ...envelope_,
    ...signature ? from9(signature) : {},
    type: "eip7702"
  };
}
function getSignPayload8(envelope) {
  return hash10(envelope, { presign: true });
}
function hash10(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize6({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0
    } : {}
  }));
}
function serialize6(envelope, options = {}) {
  const { authorizationList, chainId, gas, nonce, to: to3, value: value10, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert12(envelope);
  const accessTupleList = toTupleList(accessList);
  const authorizationTupleList = toTupleList2(authorizationList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to3 ?? "0x",
    value10 ? fromNumber2(value10) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    authorizationTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat3(serializedType4, fromHex6(serialized));
}
function validate20(envelope) {
  try {
    assert12(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionReceipt.js
var TransactionReceipt_exports = {};
__export(TransactionReceipt_exports, {
  fromRpc: () => fromRpc9,
  fromRpcStatus: () => fromRpcStatus,
  fromRpcType: () => fromRpcType2,
  toRpc: () => toRpc14,
  toRpcStatus: () => toRpcStatus,
  toRpcType: () => toRpcType2
});
var fromRpcStatus = {
  "0x0": "reverted",
  "0x1": "success"
};
var toRpcStatus = {
  reverted: "0x0",
  success: "0x1"
};
var fromRpcType2 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
var toRpcType2 = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function fromRpc9(receipt) {
  if (!receipt)
    return null;
  return {
    ...receipt,
    blobGasPrice: receipt.blobGasPrice ? BigInt(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : void 0,
    blockNumber: BigInt(receipt.blockNumber ?? 0n),
    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),
    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),
    gasUsed: BigInt(receipt.gasUsed ?? 0n),
    logs: receipt.logs.map((log5) => fromRpc7(log5, { pending: false })),
    status: fromRpcStatus[receipt.status],
    transactionIndex: Number(receipt.transactionIndex ?? 0),
    type: fromRpcType2[receipt.type] || receipt.type
  };
}
function toRpc14(receipt) {
  return {
    blobGasPrice: receipt.blobGasPrice ? fromNumber2(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? fromNumber2(receipt.blobGasUsed) : void 0,
    blockHash: receipt.blockHash,
    blockNumber: fromNumber2(receipt.blockNumber),
    contractAddress: receipt.contractAddress,
    cumulativeGasUsed: fromNumber2(receipt.cumulativeGasUsed),
    effectiveGasPrice: fromNumber2(receipt.effectiveGasPrice),
    from: receipt.from,
    gasUsed: fromNumber2(receipt.gasUsed),
    logs: receipt.logs.map(toRpc8),
    logsBloom: receipt.logsBloom,
    root: receipt.root,
    status: toRpcStatus[receipt.status],
    to: receipt.to,
    transactionHash: receipt.transactionHash,
    transactionIndex: fromNumber2(receipt.transactionIndex),
    type: toRpcType2[receipt.type] ?? receipt.type
  };
}

// node_modules/ox/_esm/core/TransactionRequest.js
var TransactionRequest_exports = {};
__export(TransactionRequest_exports, {
  toRpc: () => toRpc15
});
function toRpc15(request2) {
  const request_rpc = {};
  if (typeof request2.accessList !== "undefined")
    request_rpc.accessList = request2.accessList;
  if (typeof request2.authorizationList !== "undefined")
    request_rpc.authorizationList = toRpcList(request2.authorizationList);
  if (typeof request2.blobVersionedHashes !== "undefined")
    request_rpc.blobVersionedHashes = request2.blobVersionedHashes;
  if (typeof request2.blobs !== "undefined")
    request_rpc.blobs = request2.blobs;
  if (typeof request2.chainId !== "undefined")
    request_rpc.chainId = fromNumber2(request2.chainId);
  if (typeof request2.data !== "undefined") {
    request_rpc.data = request2.data;
    request_rpc.input = request2.data;
  } else if (typeof request2.input !== "undefined") {
    request_rpc.data = request2.input;
    request_rpc.input = request2.input;
  }
  if (typeof request2.from !== "undefined")
    request_rpc.from = request2.from;
  if (typeof request2.gas !== "undefined")
    request_rpc.gas = fromNumber2(request2.gas);
  if (typeof request2.gasPrice !== "undefined")
    request_rpc.gasPrice = fromNumber2(request2.gasPrice);
  if (typeof request2.maxFeePerBlobGas !== "undefined")
    request_rpc.maxFeePerBlobGas = fromNumber2(request2.maxFeePerBlobGas);
  if (typeof request2.maxFeePerGas !== "undefined")
    request_rpc.maxFeePerGas = fromNumber2(request2.maxFeePerGas);
  if (typeof request2.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber2(request2.maxPriorityFeePerGas);
  if (typeof request2.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber2(request2.maxPriorityFeePerGas);
  if (typeof request2.nonce !== "undefined")
    request_rpc.nonce = fromNumber2(request2.nonce);
  if (typeof request2.to !== "undefined")
    request_rpc.to = request2.to;
  if (typeof request2.type !== "undefined")
    request_rpc.type = request2.type;
  if (typeof request2.value !== "undefined")
    request_rpc.value = fromNumber2(request2.value);
  return request_rpc;
}

// node_modules/ox/_esm/core/TypedData.js
var TypedData_exports = {};
__export(TypedData_exports, {
  BytesSizeMismatchError: () => BytesSizeMismatchError3,
  InvalidDomainError: () => InvalidDomainError2,
  InvalidPrimaryTypeError: () => InvalidPrimaryTypeError2,
  InvalidStructTypeError: () => InvalidStructTypeError2,
  assert: () => assert13,
  domainSeparator: () => domainSeparator2,
  encode: () => encode14,
  encodeData: () => encodeData3,
  encodeField: () => encodeField2,
  encodeType: () => encodeType2,
  extractEip712DomainTypes: () => extractEip712DomainTypes,
  findTypeDependencies: () => findTypeDependencies2,
  getSignPayload: () => getSignPayload9,
  hashDomain: () => hashDomain2,
  hashStruct: () => hashStruct2,
  hashType: () => hashType2,
  serialize: () => serialize7,
  validate: () => validate21
});
function assert13(value10) {
  const { domain: domain2, message, primaryType, types: types3 } = value10;
  const validateData = (struct7, data) => {
    for (const param of struct7) {
      const { name, type: type8 } = param;
      const value11 = data[name];
      const integerMatch = type8.match(integerRegex2);
      if (integerMatch && (typeof value11 === "number" || typeof value11 === "bigint")) {
        const [, base, size_] = integerMatch;
        fromNumber2(value11, {
          signed: base === "int",
          size: Number.parseInt(size_ ?? "") / 8
        });
      }
      if (type8 === "address" && typeof value11 === "string" && !validate12(value11))
        throw new InvalidAddressError2({
          address: value11,
          cause: new InvalidInputError()
        });
      const bytesMatch = type8.match(bytesRegex2);
      if (bytesMatch) {
        const [, size45] = bytesMatch;
        if (size45 && size3(value11) !== Number.parseInt(size45))
          throw new BytesSizeMismatchError3({
            expectedSize: Number.parseInt(size45),
            givenSize: size3(value11)
          });
      }
      const struct8 = types3[type8];
      if (struct8) {
        validateReference2(type8);
        validateData(struct8, value11);
      }
    }
  };
  if (types3.EIP712Domain && domain2) {
    if (typeof domain2 !== "object")
      throw new InvalidDomainError2({ domain: domain2 });
    validateData(types3.EIP712Domain, domain2);
  }
  if (primaryType !== "EIP712Domain") {
    if (types3[primaryType])
      validateData(types3[primaryType], message);
    else
      throw new InvalidPrimaryTypeError2({ primaryType, types: types3 });
  }
}
function domainSeparator2(domain2) {
  return hashDomain2({
    domain: domain2
  });
}
function encode14(value10) {
  const { domain: domain2 = {}, message, primaryType } = value10;
  const types3 = {
    EIP712Domain: extractEip712DomainTypes(domain2),
    ...value10.types
  };
  assert13({
    domain: domain2,
    message,
    primaryType,
    types: types3
  });
  const parts2 = ["0x19", "0x01"];
  if (domain2)
    parts2.push(hashDomain2({
      domain: domain2,
      types: types3
    }));
  if (primaryType !== "EIP712Domain")
    parts2.push(hashStruct2({
      data: message,
      primaryType,
      types: types3
    }));
  return concat3(...parts2);
}
function encodeType2(value10) {
  const { primaryType, types: types3 } = value10;
  let result = "";
  const unsortedDeps = findTypeDependencies2({ primaryType, types: types3 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type8 of deps) {
    result += `${type8}(${(types3[type8] ?? []).map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
  }
  return result;
}
function extractEip712DomainTypes(domain2) {
  return [
    typeof (domain2 == null ? void 0 : domain2.name) === "string" && { name: "name", type: "string" },
    (domain2 == null ? void 0 : domain2.version) && { name: "version", type: "string" },
    typeof (domain2 == null ? void 0 : domain2.chainId) === "number" && {
      name: "chainId",
      type: "uint256"
    },
    (domain2 == null ? void 0 : domain2.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (domain2 == null ? void 0 : domain2.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function getSignPayload9(value10) {
  return keccak2562(encode14(value10));
}
function hashDomain2(value10) {
  const { domain: domain2, types: types3 } = value10;
  return hashStruct2({
    data: domain2,
    primaryType: "EIP712Domain",
    types: {
      ...types3,
      EIP712Domain: (types3 == null ? void 0 : types3.EIP712Domain) || extractEip712DomainTypes(domain2)
    }
  });
}
function hashStruct2(value10) {
  const { data, primaryType, types: types3 } = value10;
  const encoded = encodeData3({
    data,
    primaryType,
    types: types3
  });
  return keccak2562(encoded);
}
function serialize7(value10) {
  const { domain: domain_, message: message_, primaryType, types: types3 } = value10;
  const normalizeData = (struct7, value11) => {
    const data = { ...value11 };
    for (const param of struct7) {
      const { name, type: type8 } = param;
      if (type8 === "address")
        data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain2 = (() => {
    if (!domain_)
      return {};
    const type8 = types3.EIP712Domain ?? extractEip712DomainTypes(domain_);
    return normalizeData(type8, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return void 0;
    if (!types3[primaryType])
      return {};
    return normalizeData(types3[primaryType], message_);
  })();
  return stringify2({ domain: domain2, message, primaryType, types: types3 }, (_, value11) => {
    if (typeof value11 === "bigint")
      return value11.toString();
    return value11;
  });
}
function validate21(value10) {
  try {
    assert13(value10);
    return true;
  } catch {
    return false;
  }
}
var BytesSizeMismatchError3 = class extends BaseError2 {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.BytesSizeMismatchError"
    });
  }
};
var InvalidDomainError2 = class extends BaseError2 {
  constructor({ domain: domain2 }) {
    super(`Invalid domain "${stringify2(domain2)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidDomainError"
    });
  }
};
var InvalidPrimaryTypeError2 = class extends BaseError2 {
  constructor({ primaryType, types: types3 }) {
    super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types3))}\`.`, {
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidPrimaryTypeError"
    });
  }
};
var InvalidStructTypeError2 = class extends BaseError2 {
  constructor({ type: type8 }) {
    super(`Struct type "${type8}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidStructTypeError"
    });
  }
};
function encodeData3(value10) {
  const { data, primaryType, types: types3 } = value10;
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType2({ primaryType, types: types3 })];
  for (const field of types3[primaryType] ?? []) {
    const [type8, value11] = encodeField2({
      types: types3,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type8);
    encodedValues.push(value11);
  }
  return encode8(encodedTypes, encodedValues);
}
function hashType2(value10) {
  const { primaryType, types: types3 } = value10;
  const encodedHashType = fromString2(encodeType2({ primaryType, types: types3 }));
  return keccak2562(encodedHashType);
}
function encodeField2(properties) {
  let { types: types3, name, type: type8, value: value10 } = properties;
  if (types3[type8] !== void 0)
    return [
      { type: "bytes32" },
      keccak2562(encodeData3({ data: value10, primaryType: type8, types: types3 }))
    ];
  if (type8 === "bytes") {
    const prepend8 = value10.length % 2 ? "0" : "";
    value10 = `0x${prepend8 + value10.slice(2)}`;
    return [{ type: "bytes32" }, keccak2562(value10, { as: "Hex" })];
  }
  if (type8 === "string")
    return [
      { type: "bytes32" },
      keccak2562(fromString(value10), { as: "Hex" })
    ];
  if (type8.lastIndexOf("]") === type8.length - 1) {
    const parsedType = type8.slice(0, type8.lastIndexOf("["));
    const typeValuePairs = value10.map((item) => encodeField2({
      name,
      type: parsedType,
      types: types3,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak2562(encode8(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
    ];
  }
  return [{ type: type8 }, value10];
}
function findTypeDependencies2(value10, results = /* @__PURE__ */ new Set()) {
  const { primaryType: primaryType_, types: types3 } = value10;
  const match43 = primaryType_.match(/^\w*/u);
  const primaryType = match43 == null ? void 0 : match43[0];
  if (results.has(primaryType) || types3[primaryType] === void 0)
    return results;
  results.add(primaryType);
  for (const field of types3[primaryType])
    findTypeDependencies2({ primaryType: field.type, types: types3 }, results);
  return results;
}
function validateReference2(type8) {
  if (type8 === "address" || type8 === "bool" || type8 === "string" || type8.startsWith("bytes") || type8.startsWith("uint") || type8.startsWith("int"))
    throw new InvalidStructTypeError2({ type: type8 });
}

// node_modules/ox/_esm/core/ValidatorData.js
var ValidatorData_exports = {};
__export(ValidatorData_exports, {
  encode: () => encode15,
  getSignPayload: () => getSignPayload10
});
function encode15(value10) {
  const { data, validator } = value10;
  return concat3(
    // Validator Data Format: `0x19  0x00  <intended validator address>  <data to sign>`
    "0x19",
    "0x00",
    validator,
    from2(data)
  );
}
function getSignPayload10(value10) {
  return keccak2562(encode15(value10));
}

// node_modules/ox/_esm/core/WebCryptoP256.js
var WebCryptoP256_exports = {};
__export(WebCryptoP256_exports, {
  createKeyPair: () => createKeyPair,
  sign: () => sign9,
  verify: () => verify5
});
async function createKeyPair(options = {}) {
  const { extractable = false } = options;
  const keypair = await globalThis.crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, extractable, ["sign", "verify"]);
  const publicKey_raw = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
  const publicKey = from3(new Uint8Array(publicKey_raw));
  return {
    privateKey: keypair.privateKey,
    publicKey
  };
}
async function sign9(options) {
  const { payload, privateKey } = options;
  const signature = await globalThis.crypto.subtle.sign({
    name: "ECDSA",
    hash: "SHA-256"
  }, privateKey, from(payload));
  const signature_bytes = fromArray(new Uint8Array(signature));
  const r = toBigInt(slice2(signature_bytes, 0, 32));
  let s = toBigInt(slice2(signature_bytes, 32, 64));
  if (s > p2562.CURVE.n / 2n)
    s = p2562.CURVE.n - s;
  return { r, s };
}
async function verify5(options) {
  const { payload, signature } = options;
  const publicKey = await globalThis.crypto.subtle.importKey("raw", toBytes5(options.publicKey), { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
  return await globalThis.crypto.subtle.verify({
    name: "ECDSA",
    hash: "SHA-256"
  }, publicKey, concat2(fromNumber(signature.r), fromNumber(signature.s)), from(payload));
}

// node_modules/permissionless/_esm/accounts/kernel/constants.js
var VALIDATOR_MODE2;
(function(VALIDATOR_MODE3) {
  VALIDATOR_MODE3["DEFAULT"] = "0x00";
  VALIDATOR_MODE3["ENABLE"] = "0x01";
})(VALIDATOR_MODE2 || (VALIDATOR_MODE2 = {}));

// node_modules/permissionless/_esm/actions/pimlico/getTokenQuotes.js
var getTokenQuotes = async (client, args2) => {
  var _a106, _b32;
  const chainId = ((_a106 = args2.chain) == null ? void 0 : _a106.id) ?? ((_b32 = client.chain) == null ? void 0 : _b32.id);
  if (!chainId) {
    throw new ChainNotFoundError();
  }
  const res = await client.request({
    method: "pimlico_getTokenQuotes",
    params: [
      { tokens: args2.tokens },
      args2.entryPointAddress,
      numberToHex(chainId)
    ]
  });
  return res.quotes.map((quote) => ({
    ...quote,
    balanceSlot: quote.balanceSlot ? hexToBigInt(quote.balanceSlot) : void 0,
    allowanceSlot: quote.allowanceSlot ? hexToBigInt(quote.allowanceSlot) : void 0,
    postOpGas: hexToBigInt(quote.postOpGas),
    exchangeRate: hexToBigInt(quote.exchangeRate),
    exchangeRateNativeToUsd: hexToBigInt(quote.exchangeRateNativeToUsd)
  }));
};

// node_modules/permissionless/_esm/actions/pimlico/getUserOperationGasPrice.js
var getUserOperationGasPrice = async (client) => {
  const gasPrice = await client.request({
    method: "pimlico_getUserOperationGasPrice",
    params: []
  });
  return {
    slow: {
      maxFeePerGas: BigInt(gasPrice.slow.maxFeePerGas),
      maxPriorityFeePerGas: BigInt(gasPrice.slow.maxPriorityFeePerGas)
    },
    standard: {
      maxFeePerGas: BigInt(gasPrice.standard.maxFeePerGas),
      maxPriorityFeePerGas: BigInt(gasPrice.standard.maxPriorityFeePerGas)
    },
    fast: {
      maxFeePerGas: BigInt(gasPrice.fast.maxFeePerGas),
      maxPriorityFeePerGas: BigInt(gasPrice.fast.maxPriorityFeePerGas)
    }
  };
};

// node_modules/permissionless/_esm/actions/pimlico/getUserOperationStatus.js
var getUserOperationStatus = async (client, { hash: hash11 }) => {
  return client.request({
    method: "pimlico_getUserOperationStatus",
    params: [hash11]
  });
};

// node_modules/permissionless/_esm/actions/pimlico/sendCompressedUserOperation.js
var sendCompressedUserOperation = async (client, args2) => {
  const { compressedUserOperation, inflatorAddress, entryPointAddress } = args2;
  return client.request({
    method: "pimlico_sendCompressedUserOperation",
    params: [compressedUserOperation, inflatorAddress, entryPointAddress]
  });
};

// node_modules/permissionless/_esm/actions/pimlico/sponsorUserOperation.js
var sponsorUserOperation = async (client, args2) => {
  const { sponsorshipPolicyId, paymasterContext, userOperation, entryPoint } = args2;
  const finalPaymasterContext = sponsorshipPolicyId !== void 0 ? {
    ...paymasterContext ?? {},
    sponsorshipPolicyId
  } : paymasterContext;
  const response = await client.request({
    method: "pm_sponsorUserOperation",
    params: finalPaymasterContext ? [
      deepHexlify(userOperation),
      entryPoint.address,
      finalPaymasterContext
    ] : [deepHexlify(userOperation), entryPoint.address]
  });
  if (entryPoint.version === "0.6") {
    const responseV06 = response;
    return {
      paymasterAndData: responseV06.paymasterAndData,
      preVerificationGas: BigInt(responseV06.preVerificationGas),
      verificationGasLimit: BigInt(responseV06.verificationGasLimit),
      callGasLimit: BigInt(responseV06.callGasLimit)
    };
  }
  const responseV07 = response;
  return {
    callGasLimit: BigInt(responseV07.callGasLimit),
    verificationGasLimit: BigInt(responseV07.verificationGasLimit),
    preVerificationGas: BigInt(responseV07.preVerificationGas),
    paymaster: responseV07.paymaster,
    paymasterVerificationGasLimit: BigInt(responseV07.paymasterVerificationGasLimit),
    paymasterPostOpGasLimit: BigInt(responseV07.paymasterPostOpGasLimit),
    paymasterData: responseV07.paymasterData
  };
};

// node_modules/permissionless/_esm/actions/pimlico/validateSponsorshipPolicies.js
var validateSponsorshipPolicies = async (client, args2) => {
  return await client.request({
    method: "pm_validateSponsorshipPolicies",
    params: [
      deepHexlify(args2.userOperation),
      args2.entryPointAddress,
      args2.sponsorshipPolicyIds
    ]
  });
};

// node_modules/permissionless/_esm/clients/decorators/pimlico.js
var pimlicoActions = ({ entryPoint }) => (client) => ({
  getUserOperationGasPrice: async () => getUserOperationGasPrice(client),
  getUserOperationStatus: async (args2) => getUserOperationStatus(client, args2),
  sendCompressedUserOperation: async (args2) => sendCompressedUserOperation(client, {
    ...args2,
    entryPointAddress: entryPoint.address
  }),
  sponsorUserOperation: async (args2) => sponsorUserOperation(client, {
    ...args2,
    entryPoint
  }),
  validateSponsorshipPolicies: async (args2) => validateSponsorshipPolicies(client, {
    ...args2,
    entryPointAddress: entryPoint.address
  }),
  getTokenQuotes: async (args2) => getTokenQuotes(client, {
    ...args2,
    chain: args2.chain,
    entryPointAddress: entryPoint.address
  })
});

// node_modules/permissionless/_esm/clients/pimlico.js
function createPimlicoClient(parameters) {
  const { key = "public", name = "Pimlico Bundler Client", entryPoint } = parameters;
  return createClient({
    ...parameters,
    key,
    name,
    type: "pimlicoClient"
  }).extend(bundlerActions).extend(paymasterActions).extend(pimlicoActions({
    entryPoint: {
      address: (entryPoint == null ? void 0 : entryPoint.address) ?? entryPoint07Address2,
      version: (entryPoint == null ? void 0 : entryPoint.version) ?? "0.7"
    }
  }));
}

// node_modules/@graphprotocol/grc-20/dist/src/smart-wallet.js
var MAINNET_DEFAULT_RPC_URL = "https://rpc-geo-genesis-h0q2s21xx8.t.conduit.xyz";
var TESTNET_DEFAULT_RPC_URL = "https://rpc-geo-test-zc16z3tcvf.t.conduit.xyz";
var DEFAULT_API_KEY = "pim_KqHm63txxhbCYjdDaWaHqH";
var createChain = (network, rpcUrl) => {
  const chain2 = {
    id: network === "TESTNET" ? Number("19411") : Number("80451"),
    name: "Geo Genesis",
    nativeCurrency: {
      name: "Ethereum",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      default: {
        http: [rpcUrl ?? (network === "TESTNET" ? TESTNET_DEFAULT_RPC_URL : MAINNET_DEFAULT_RPC_URL)]
      },
      public: {
        http: [rpcUrl ?? (network === "TESTNET" ? TESTNET_DEFAULT_RPC_URL : MAINNET_DEFAULT_RPC_URL)]
      }
    }
  };
  return chain2;
};
var getSmartAccountWalletClient = async ({ privateKey, rpcUrl = MAINNET_DEFAULT_RPC_URL }) => {
  const chain2 = createChain("MAINNET", rpcUrl);
  const transport = http(rpcUrl);
  const publicClient = createPublicClient({
    transport,
    chain: chain2
  });
  const safeAccount = await toSafeSmartAccount({
    client: publicClient,
    owners: [privateKeyToAccount(privateKey)],
    entryPoint: {
      // optional, defaults to 0.7
      address: entryPoint07Address2,
      version: "0.7"
    },
    version: "1.4.1"
  });
  const bundlerTransport = http(`https://api.pimlico.io/v2/80451/rpc?apikey=${DEFAULT_API_KEY}`);
  const paymasterClient = createPimlicoClient({
    transport: bundlerTransport,
    chain: chain2,
    entryPoint: {
      address: entryPoint07Address2,
      version: "0.7"
    }
  });
  const smartAccount = createSmartAccountClient({
    chain: chain2,
    account: safeAccount,
    paymaster: paymasterClient,
    bundlerTransport,
    userOperation: {
      estimateFeesPerGas: async () => {
        return (await paymasterClient.getUserOperationGasPrice()).fast;
      }
    }
  });
  return smartAccount;
};
var getWalletClient = async ({ privateKey, rpcUrl = TESTNET_DEFAULT_RPC_URL }) => {
  const chain2 = createChain("TESTNET", rpcUrl);
  const transport = http(rpcUrl);
  const wallet = createWalletClient({
    account: privateKeyToAccount(privateKey),
    chain: chain2,
    transport
  });
  return wallet;
};

// node_modules/@graphprotocol/grc-20/dist/src/core/base58.js
var base58_exports2 = {};
__export(base58_exports2, {
  BASE58_ALLOWED_CHARS: () => BASE58_ALLOWED_CHARS,
  decodeBase58ToUUID: () => decodeBase58ToUUID,
  encodeBase58: () => encodeBase58
});
var BASE58_ALLOWED_CHARS = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function encodeBase58(val) {
  const hex2 = BigInt(`0x${val}`);
  let remainder3 = hex2;
  const result = [];
  while (remainder3 > 0n) {
    const mod2 = remainder3 % 58n;
    const base58CharAtMod = BASE58_ALLOWED_CHARS[Number(mod2)];
    if (base58CharAtMod) {
      result.push(base58CharAtMod);
    }
    remainder3 = remainder3 / 58n;
  }
  return result.reverse().join("");
}
function decodeBase58ToUUID(encoded) {
  let decoded = 0n;
  for (const char2 of encoded) {
    const index3 = BASE58_ALLOWED_CHARS.indexOf(char2);
    if (index3 === -1) {
      throw new Error("Invalid Base58 character");
    }
    decoded = decoded * 58n + BigInt(index3);
  }
  let hexStr = decoded.toString(16);
  hexStr = hexStr.padStart(32, "0");
  return [hexStr.slice(0, 8), hexStr.slice(8, 12), hexStr.slice(12, 16), hexStr.slice(16, 20), hexStr.slice(20)].join("-");
}

export {
  getAction,
  publicKeyToAddress,
  sha2562 as sha256,
  readContract,
  http,
  hashTypedData,
  encodePacked,
  verifyMessage,
  zeroAddress,
  createPublicClient,
  createWalletClient,
  dual,
  hasProperty,
  pipeArguments,
  isLeft2 as isLeft,
  isRight2 as isRight,
  Exit_exports,
  TaggedError2 as TaggedError,
  fail12 as fail,
  succeed13 as succeed,
  Effect_exports,
  decodeUnknownSync,
  decodeSync,
  validateSync,
  encodeSync,
  evolve,
  decodeUnknownEither2 as decodeUnknownEither,
  decodeEither2 as decodeEither,
  isSchema,
  Literal2 as Literal,
  Undefined,
  String$,
  Number$,
  Boolean$,
  Union2 as Union,
  Array$,
  isPropertySignature,
  propertySignature,
  fromKey,
  optional,
  Struct,
  Record,
  partial2 as partial,
  transform3 as transform,
  URL$,
  Uint8Array$,
  Date$,
  Class7 as Class,
  equivalence2 as equivalence,
  Schema_exports,
  abool,
  anumber3 as anumber,
  abytes3 as abytes,
  aexists2 as aexists,
  aoutput2 as aoutput,
  u324 as u32,
  clean2 as clean,
  bytesToHex4 as bytesToHex,
  hexToBytes4 as hexToBytes,
  toBytes12 as toBytes,
  checkOpts2 as checkOpts,
  equalBytes,
  wrapCipher,
  getOutput,
  u64Lengths,
  copyBytes,
  parse_default,
  stringify_default,
  v4_default,
  generatePrivateKey,
  privateKeyToAccount,
  blake2b,
  blake3,
  gcm,
  AccountNotFoundError2 as AccountNotFoundError,
  parseModuleTypeId,
  supportsModule,
  encodeInstallModule,
  supportsExecutionMode,
  getUserOperationHash,
  sendUserOperation,
  entryPoint07Address2 as entryPoint07Address,
  createSmartAccountClient,
  getAccountNonce,
  toSafeSmartAccount,
  import_index,
  createPimlicoClient,
  VoteOption,
  id_exports,
  getProcessGeoProposalArguments,
  getAcceptSubspaceArguments,
  getRemoveSubspaceArguments,
  getAcceptEditorArguments,
  getRemoveEditorArguments,
  getCalldataForSpaceGovernanceType,
  system_exports,
  getChecksumAddress,
  network_exports,
  account_exports,
  content_exports,
  data_exports2 as data_exports,
  text_exports,
  encoding_exports,
  ipfs_exports,
  graph_exports,
  position_exports,
  scheme_exports,
  getSmartAccountWalletClient,
  getWalletClient,
  base58_exports2 as base58_exports
};
/*! Bundled license information:

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/nist.js:
@noble/curves/esm/p256.js:
@noble/curves/esm/abstract/bls.js:
@noble/curves/esm/abstract/tower.js:
@noble/curves/esm/bls12-381.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-CCRHR5FT.js.map
